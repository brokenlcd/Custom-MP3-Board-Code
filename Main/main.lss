
main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00009128  00010000  00010000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ctors        00000000  00019128  00019128  00018ed0  2**0
                  CONTENTS
  2 .dtors        00000000  00019128  00019128  00018ed0  2**0
                  CONTENTS
  3 .data         00000ed0  40000000  00019128  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000009e0  40000ed0  40000ed0  00018ed0  2**2
                  ALLOC
  5 .stack        00000c00  40001900  40001900  00018ed0  2**4
                  CONTENTS
  6 .comment      00000276  00000000  00000000  00019ad0  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000508  00000000  00000000  00019d48  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000ec7  00000000  00000000  0001a250  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00009e3c  00000000  00000000  0001b117  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00002b15  00000000  00000000  00024f53  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00002a50  00000000  00000000  00027a68  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  000013f4  00000000  00000000  0002a4b8  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000024ff  00000000  00000000  0002b8ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000449e  00000000  00000000  0002ddab  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000001e0  00000000  00000000  00032249  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00010000 <__Vectors>:
// Exception Vectors
// Mapped to Address 0.
// Absolute addressing mode must be used.

__Vectors:        LDR     PC,Reset_Addr         
   10000:	e59ff018 	ldr	pc, [pc, #24]	; 10020 <Reset_Addr>
                LDR     PC,Undef_Addr
   10004:	e59ff018 	ldr	pc, [pc, #24]	; 10024 <Undef_Addr>
                LDR     PC,SWI_Addr
   10008:	e59ff018 	ldr	pc, [pc, #24]	; 10028 <SWI_Addr>
                LDR     PC,PAbt_Addr
   1000c:	e59ff018 	ldr	pc, [pc, #24]	; 1002c <PAbt_Addr>
                LDR     PC,DAbt_Addr
   10010:	e59ff018 	ldr	pc, [pc, #24]	; 10030 <DAbt_Addr>
                NOP                            /* Reserved Vector */
   10014:	e1a00000 	nop			(mov r0,r0)
//                LDR     PC,IRQ_Addr
//                LDR     PC,[PC, #-0x0FF0]      /* Vector from VicVectAddr */
                LDR     PC,IRQ_Wrapper_Addr
   10018:	e59ff018 	ldr	pc, [pc, #24]	; 10038 <IRQ_Wrapper_Addr>
                LDR     PC,FIQ_Addr
   1001c:	e59ff018 	ldr	pc, [pc, #24]	; 1003c <FIQ_Addr>

00010020 <Reset_Addr>:
   10020:	00010098 	muleq	r1, r8, r0

00010024 <Undef_Addr>:
   10024:	00010040 	andeq	r0, r1, r0, asr #32

00010028 <SWI_Addr>:
   10028:	00000000 	andeq	r0, r0, r0

0001002c <PAbt_Addr>:
   1002c:	00010044 	andeq	r0, r1, r4, asr #32

00010030 <DAbt_Addr>:
   10030:	00010048 	andeq	r0, r1, r8, asr #32
   10034:	00000000 	andeq	r0, r0, r0

00010038 <IRQ_Wrapper_Addr>:
   10038:	00010050 	andeq	r0, r1, r0, asr r0

0001003c <FIQ_Addr>:
   1003c:	0001004c 	andeq	r0, r1, ip, asr #32

00010040 <Undef_Handler>:

Reset_Addr:       .word     Reset_Handler
Undef_Addr:       .word     Undef_Handler
// SWI_Addr:         .word     SWI_Handler
// SWI_Wrapper_Addr: .word     SWI_Wrapper
SWI_Addr:         .word     0      /* in swi_handler.S */
PAbt_Addr:        .word     PAbt_Handler
DAbt_Addr:        .word     DAbt_Handler
                  .word     0                      /* Reserved Address */
// IRQ_Addr:         .word     __IRQ_Handler
IRQ_Wrapper_Addr: .word    __IRQ_Wrapper
FIQ_Addr:         .word     FIQ_Handler

Undef_Handler:  B       Undef_Handler
   10040:	eafffffe 	b	10040 <Undef_Handler>

00010044 <PAbt_Handler>:
/* SWI_Handler:    B       SWI_Handler */
PAbt_Handler:   B       PAbt_Handler
   10044:	eafffffe 	b	10044 <PAbt_Handler>

00010048 <DAbt_Handler>:
DAbt_Handler:   B       DAbt_Handler
   10048:	eafffffe 	b	10048 <DAbt_Handler>

0001004c <FIQ_Handler>:
/* IRQ_Handler:    B       IRQ_Handler */
FIQ_Handler:    B       FIQ_Handler
   1004c:	eafffffe 	b	1004c <FIQ_Handler>

00010050 <__IRQ_Wrapper>:

.size   __Vectors, . - __Vectors



.arm
.section .init, "ax"

.if (VECTREMAPPED)
/* mthomas: Dummy used during startup - mind the nops since the 
   flash-utility will overwrite the "reserved vector"-address
   with the checksum */
				B Reset_Handler
				NOP
				NOP
				NOP
				NOP
				NOP  /* Reserved Address */
				NOP
				NOP
.endif

.arm
.section .init, "ax"
.global __startup
.func __startup
__startup:

Reset_Handler:  


// Memory Mapping
                .set MEMMAP, 0xE01FC040  /* Memory Mapping Control */

.if (REMAP)
                LDR     R0, =MEMMAP
.if     (EXTMEM_MODE)                
                MOV     R1, #3
.elseif (RAM_MODE) || (VECTREMAPPED)
.print "MEMMAP to 2 on init"
                MOV     R1, #2
.else
                MOV     R1, #1
.endif
                STR     R1, [R0]
.endif

// Setup Stack for each mode
                LDR     R0, =Top_Stack

// Enter Undefined Instruction Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_UND|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #UND_Stack_Size

// Enter Abort Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_ABT|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #ABT_Stack_Size

// Enter FIQ Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_FIQ|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #FIQ_Stack_Size

// Enter IRQ Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_IRQ|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #IRQ_Stack_Size

// Enter Supervisor Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_SVC|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #SVC_Stack_Size

// Enter User Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_SYS /* Interrupts enabled */
//				MSR     CPSR_c, #Mode_USR|I_Bit|F_Bit /* Interrupts disabled */
                MOV     SP, R0


.if (RAM_MODE==0)
/* Relocate .data section (Copy from ROM to RAM) */
                LDR     R1, =_etext 
                LDR     R2, =_data 
                LDR     R3, =_edata 
                CMP     R2, R3
                BEQ     DataIsEmpty
LoopRel:        CMP     R2, R3 
                LDRLO   R0, [R1], #4 
                STRLO   R0, [R2], #4 
                BLO     LoopRel 
DataIsEmpty:
.endif
 
/* Clear .bss section (Zero init) */
                MOV     R0, #0 
                LDR     R1, =__bss_start__ 
                LDR     R2, =__bss_end__ 
                CMP     R1,R2
                BEQ     BSSIsEmpty
LoopZI:         CMP     R1, R2 
                STRLO   R0, [R1], #4 
                BLO     LoopZI 
BSSIsEmpty:


// call C++ constructors of global objects
		LDR 	r0, =__ctors_start__
		LDR 	r1, =__ctors_end__
ctor_loop:
		CMP 	r0, r1
		BEQ 	ctor_end
		LDR 	r2, [r0], #4
		STMFD 	sp!, {r0-r1}
		MOV 	lr, pc
		MOV 	pc, r2
		LDMFD 	sp!, {r0-r1}
		B 		ctor_loop
ctor_end:

// Enter the C code
                //LDR     R0,=INIT
                LDR     R0,=main
                TST     R0,#1             // Bit-0 set: main is Thumb
                LDREQ   LR,=__exit_ARM    // ARM Mode
                LDRNE   LR,=__exit_THUMB  // Thumb Mode
                BX      R0

.size   __startup, . - __startup
.endfunc

.arm
.global __exit_ARM
.func __exit_ARM
__exit_ARM:
                B       __exit_ARM
.size   __exit_ARM, . - __exit_ARM
.endfunc

.thumb
.global __exit_THUMB
.func __exit_THUMB
__exit_THUMB:
                B       __exit_THUMB
.size   __exit_THUMB, . - __exit_THUMB
.endfunc


/* mthomas: the following code is inspired by various examples and
   documents from ARM, Atmel, Anglia Designs and others */


.text
.arm

.if (VECTREMAPPED)
.print "Handlers in section .vectmapped -> .data"
.section .vectmapped, "ax"
.else
.print "Handlers in section .vectorg -> .code/.text"
.section .vectorg, "ax"
.endif

.set VIC_base_addr, 0xFFFFF000
.set VIC_vect_offs, 0x30

        .arm
        .global __IRQ_Wrapper
        .func   __IRQ_Wrapper
__IRQ_Wrapper:
/*- Manage Exception Entry  */
/*- Adjust and save LR_irq in IRQ stack  */
            sub         lr, lr, #4
   10050:	e24ee004 	sub	lr, lr, #4	; 0x4
            stmfd       sp!, {lr}
   10054:	e92d4000 	stmdb	sp!, {lr}

/*- Save SPSR need to be saved for nested interrupt */
            mrs         r14, SPSR
   10058:	e14fe000 	mrs	lr, SPSR
            stmfd       sp!, {r14}
   1005c:	e92d4000 	stmdb	sp!, {lr}

/*- Save and r0 in IRQ stack  */
            stmfd       sp!, {r0}
   10060:	e92d0001 	stmdb	sp!, {r0}

/*- Write in the IVR to support Protect Mode  */
/*- No effect in Normal Mode  */
/*- De-assert the NIRQ and clear the source in Protect Mode */
/* R14 = LR */
            ldr         r14, =VIC_base_addr
   10064:	e59fe028 	ldr	lr, [pc, #40]	; 10094 <.text+0x94>
            ldr         r0 , [r14, #VIC_vect_offs]
   10068:	e59e0030 	ldr	r0, [lr, #48]
            /*str         r14, [r14, #VIC_vect_offs]*/

/*- Enable Interrupt and Switch in Supervisor Mode */
            msr         CPSR_c, #Mode_SVC
   1006c:	e321f013 	msr	CPSR_c, #19	; 0x13

/*- Save scratch/used registers and LR in User Stack */
            /*stmfd       sp!, { r1-r3, r12, r14}*/
            stmfd       sp!, { r1-r12, r14 }
   10070:	e92d5ffe 	stmdb	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

/*- Branch to the routine pointed by the VIC-Vector-Address  */
            mov         r14, pc
   10074:	e1a0e00f 	mov	lr, pc
            bx          r0
   10078:	e12fff10 	bx	r0
/*- Restore scratch/used registers and LR from User Stack*/
            /* ldmia       sp!, { r1-r3, r12, r14} */
            ldmia       sp!, { r1-r12, r14 }
   1007c:	e8bd5ffe 	ldmia	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

/*- Disable Interrupt and switch back in IRQ mode */
            msr         CPSR_c, #I_Bit | Mode_IRQ
   10080:	e321f092 	msr	CPSR_c, #146	; 0x92

#if 0
/* VICVectAddr=0 is already done in the ISRs of the Philips-Examples 
   so commented out here */
/*- Mark the End of Interrupt on the VIC */
            ldr         r14, =VIC_base_addr
            str         r14, [r14, #VIC_vect_offs]
#endif

/*- Restore SPSR_irq and r0 from IRQ stack */
            ldmia       sp!, {r0}
   10084:	e8bd0001 	ldmia	sp!, {r0}

/*- Restore SPSR_irq and r0 from IRQ stack */
            ldmia       sp!, {r14}
   10088:	e8bd4000 	ldmia	sp!, {lr}
            msr         SPSR_cxsf, r14
   1008c:	e16ff00e 	msr	SPSR_fsxc, lr

/*- Restore adjusted  LR_irq from IRQ stack directly in the PC */
            ldmia       sp!, {pc}^
   10090:	e8fd8000 	ldmia	sp!, {pc}^
   10094:	fffff000 	swinv	0x00fff000

00010098 <__startup>:
   10098:	e59f00c8 	ldr	r0, [pc, #200]	; 10168 <.text+0x168>
   1009c:	e321f0db 	msr	CPSR_c, #219	; 0xdb
   100a0:	e1a0d000 	mov	sp, r0
   100a4:	e2400080 	sub	r0, r0, #128	; 0x80
   100a8:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
   100ac:	e1a0d000 	mov	sp, r0
   100b0:	e2400080 	sub	r0, r0, #128	; 0x80
   100b4:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
   100b8:	e1a0d000 	mov	sp, r0
   100bc:	e2400080 	sub	r0, r0, #128	; 0x80
   100c0:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
   100c4:	e1a0d000 	mov	sp, r0
   100c8:	e2400c02 	sub	r0, r0, #512	; 0x200
   100cc:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
   100d0:	e1a0d000 	mov	sp, r0
   100d4:	e2400080 	sub	r0, r0, #128	; 0x80
   100d8:	e321f01f 	msr	CPSR_c, #31	; 0x1f
   100dc:	e1a0d000 	mov	sp, r0
   100e0:	e59f1084 	ldr	r1, [pc, #132]	; 1016c <.text+0x16c>
   100e4:	e59f2084 	ldr	r2, [pc, #132]	; 10170 <.text+0x170>
   100e8:	e59f3084 	ldr	r3, [pc, #132]	; 10174 <.text+0x174>
   100ec:	e1520003 	cmp	r2, r3
   100f0:	0a000003 	beq	10104 <DataIsEmpty>

000100f4 <LoopRel>:
   100f4:	e1520003 	cmp	r2, r3
   100f8:	34910004 	ldrcc	r0, [r1], #4
   100fc:	34820004 	strcc	r0, [r2], #4
   10100:	3afffffb 	bcc	100f4 <LoopRel>

00010104 <DataIsEmpty>:
   10104:	e3a00000 	mov	r0, #0	; 0x0
   10108:	e59f1068 	ldr	r1, [pc, #104]	; 10178 <.text+0x178>
   1010c:	e59f2068 	ldr	r2, [pc, #104]	; 1017c <.text+0x17c>
   10110:	e1510002 	cmp	r1, r2
   10114:	0a000002 	beq	10124 <BSSIsEmpty>

00010118 <LoopZI>:
   10118:	e1510002 	cmp	r1, r2
   1011c:	34810004 	strcc	r0, [r1], #4
   10120:	3afffffc 	bcc	10118 <LoopZI>

00010124 <BSSIsEmpty>:
   10124:	e59f0054 	ldr	r0, [pc, #84]	; 10180 <.text+0x180>
   10128:	e59f1054 	ldr	r1, [pc, #84]	; 10184 <.text+0x184>

0001012c <ctor_loop>:
   1012c:	e1500001 	cmp	r0, r1
   10130:	0a000005 	beq	1014c <ctor_end>
   10134:	e4902004 	ldr	r2, [r0], #4
   10138:	e92d0003 	stmdb	sp!, {r0, r1}
   1013c:	e1a0e00f 	mov	lr, pc
   10140:	e1a0f002 	mov	pc, r2
   10144:	e8bd0003 	ldmia	sp!, {r0, r1}
   10148:	eafffff7 	b	1012c <ctor_loop>

0001014c <ctor_end>:
   1014c:	e59f0034 	ldr	r0, [pc, #52]	; 10188 <.text+0x188>
   10150:	e3100001 	tst	r0, #1	; 0x1
   10154:	059fe030 	ldreq	lr, [pc, #48]	; 1018c <.text+0x18c>
   10158:	159fe030 	ldrne	lr, [pc, #48]	; 10190 <.text+0x190>
   1015c:	e12fff10 	bx	r0

00010160 <__exit_ARM>:
   10160:	eafffffe 	b	10160 <__exit_ARM>

00010164 <__exit_THUMB>:
   10164:	e798      	b	10098 <__startup>
   10166:	0000      	lsl	r0, r0, #0
   10168:	2500      	mov	r5, #0
   1016a:	4000      	and	r0, r0
   1016c:	9128      	str	r1, [sp, #160]
   1016e:	0001      	lsl	r1, r0, #0
   10170:	0000      	lsl	r0, r0, #0
   10172:	4000      	and	r0, r0
   10174:	0ed0      	lsr	r0, r2, #27
   10176:	4000      	and	r0, r0
   10178:	0ed0      	lsr	r0, r2, #27
   1017a:	4000      	and	r0, r0
   1017c:	18b0      	add	r0, r6, r2
   1017e:	4000      	and	r0, r0
   10180:	9128      	str	r1, [sp, #160]
   10182:	0001      	lsl	r1, r0, #0
   10184:	9128      	str	r1, [sp, #160]
   10186:	0001      	lsl	r1, r0, #0
   10188:	13d0      	asr	r0, r2, #15
   1018a:	0001      	lsl	r1, r0, #0
   1018c:	0160      	lsl	r0, r4, #5
   1018e:	0001      	lsl	r1, r0, #0
   10190:	0164      	lsl	r4, r4, #5
   10192:	0001      	lsl	r1, r0, #0

00010194 <delay_ms>:
//The function will cause the firmware to delay for "count" milleseconds.
void delay_ms(int count)
{
    int i;
    count *= 10000;
   10194:	e59f301c 	ldr	r3, [pc, #28]	; 101b8 <.text+0x1b8>
   10198:	e0000093 	mul	r0, r3, r0
   1019c:	e3a03000 	mov	r3, #0	; 0x0
   101a0:	ea000001 	b	101ac <delay_ms+0x18>
    for (i = 0; i < count; i++)
        asm volatile ("nop");
   101a4:	e1a00000 	nop			(mov r0,r0)
   101a8:	e2833001 	add	r3, r3, #1	; 0x1
   101ac:	e1530000 	cmp	r3, r0
   101b0:	bafffffb 	blt	101a4 <delay_ms+0x10>
}
   101b4:	e12fff1e 	bx	lr
   101b8:	00002710 	andeq	r2, r0, r0, lsl r7

000101bc <getNewFiles>:

//Usage: bootUp();
//Inputs: None
//This function initializes the serial port, the SD card, the I/O pins and the interrupts
void bootUp(void)
{
    rprintf_devopen(putc_serial0); //Init rprintf
    delay_ms(10); //Delay for power to stablize

    //Bring up SD and FAT
    if(!sd_raw_init())
    {
        rprintf("SD Init Error\n");
    }
    if(openroot())
    {
        rprintf("SD OpenRoot Error\n");
    }
     
	//Initialize I/O Ports and Peripherals
	//Setup the MP3 I/O Lines
	IODIR0 |= MP3_XCS;
	IODIR0 &= ~MP3_DREQ;
	PINSEL1 |= 0x00000C00;	//Set the MP3_DREQ Pin to be a capture pin
	IODIR1 |= MP3_XDCS | MP3_GPIO0 | MP3_XRES;	
	
	//Setupt the FM Trans. Lines
	IODIR1 |= FM_LA; 												//FM Trans Outputs (Leave SPI pins unconfigured for now)
	IODIR1 |= FM_CS;
	
	//Setup the SD Card I/O Lines
	IODIR0 |= SD_CS;												//SD Card Outputs
	
	//Setup the Accelerometer I/O Lines
	IODIR0 |= (GS1 | GS2);											//Accelerometer Outputs
	PINSEL0 |= (MMA_X_PINSEL | MMA_Y_PINSEL | MMA_Z_PINSEL);		//Make sure that ADC pins have ADC Functions selected
	IOCLR0 = (GS1 | GS2);											//Init. Accel. to 1.5G Mode
	
	//Setup the LCD I/O Lines
	IODIR0 |= (LCD_RES | LCD_CS);									//LCD Outputs
	
	//Setup the LED Lines										
	IODIR0 |= (LED_BLU | LED_RED | LED_GRN);						//Led's
	ledBlueOff();
	ledRedOff();
	ledGrnOff();
	
	//Setup the Buttons
	IODIR1 &= (~SW_UP & ~SW_DWN & ~SW_MID);		//Button Inputs

	IODIR0 &= ~(1<<23);							//Set the Vbus line as an input

    //Setupt the Interrupts
	VPBDIV=1;										// Set PCLK equal to the System Clock	
	VICIntSelect = ~0x30; 							// Timer 0 AND TIMER 1 interrupt is an IRQ interrupt
    VICIntEnable = 0x10; 							// Enable Timer 0 Interrupts (Don't start sending song data with Timer 1)
    VICVectCntl0= 0x25; 							// Use slot 0 for timer 1 interrupt
    VICVectAddr0 = (unsigned int)timer1ISR; 		// Set the address of ISR for slot 1		
    VICVectCntl1 = 0x24; 							// Use slot 1 for timer 0 interrupt
    VICVectAddr1 = (unsigned int)timer0ISR; 		// Set the address of ISR for slot 1
	
	//Configure Timer0
	T0PR = 1500;									//Divide Clock(60MHz) by 1500 for 40kHz PS
	T0TCR |=0X01;									//Enable the clock
	T0CTCR=0;										//Timer Mode
	T0MCR=0x0003;									//Interrupt and Reset Timer on Match
	T0MR0=1000;										//Interrupt on 40Hz
	
	//Configure Timer1
	T1PR = 200;										//Divide Clock by 300 for 40kHz PS
	T1TCR |=0X01;									//Enable the clock
	T1CTCR=0;										//Timer Mode
	T1CCR=0x0A00;									//Capture and interrupt on the rising edge of DREQ
	
	//Setup the SPI Port
    S0SPCCR = 64;              											// SCK = 1 MHz, counter > 8 and even
    S0SPCR  = 0x20;                										// Master, no interrupt enable, 8 bits	
}

//Usage: None (Automatically Called by FW)
//Inputs: None
//This function is a global interrupt called by a match on the Timer 0 match.  This interrupt
//	is responsible for sending music to the MP3 player when it is needed. 
//WARNING: Altering the Timer 0 Prescale register or Timer 0 Match value will put proper MP3 playing at risk.
//			Adding superfluous code to this interrupt section may also contribute to improper MP3 playback.
static void timer1ISR(void)
{
	vs1002Config();												//Enable MP3 Comm. Lines
	while(IOPIN0 & MP3_DREQ){
		vs1002SendMusic(current_song.data, MAXBUFFERSIZE);		//Send the buffered song data
		if(fat16_read_file(current_song.handle, current_song.data, MAXBUFFERSIZE) <= 0)song_is_over=1;	//Buffer more data if available
		else song_is_over=0;									//if there's no more data available, set the flag, else leave it alone
	}	
	vs1002Finish();												//Disable MP3 Comm. Lines
	T1IR = 0xFF; 												//Clear the timer 0 interrupt
	VICVectAddr = 0; 											//Update VIC priorities	
}

//Usage: None (Automatically Called by FW)
//Inputs: None
//This function is a global interrupt called by a match on the Timer 1 match.  The interrupt
// is responsible for determining if a button has been pressed or if the screen has been rotated
// and setting the appropriate global flag if either has occured.
static void timer0ISR(void)
{
	button_pressed=getButton();			//Find out if a button has been pressed, and which one
	cur_position=MMA_get_y();			//Get the current position of the screen
	if((prev_position<700 && cur_position>700)||(prev_position>700 && cur_position<700))update_screen=1; 
	else update_screen=0;				//Determine if the accelerometer has been rotated
	prev_position=cur_position;			//Save the position value for later reference
	T0IR = 0xFF;						//Clear the timer interrupt
	VICVectAddr =0;						//Update the VIC priorities
}

//Usage: button_value=getButton();
//Inputs:  None
//Outputs: None
//Function returns the value of the button that is currently being pressed.
// UP_BUT, DWN_BUT, and MID_BUT values can be viewed in MP3Dev.h
char getButton(void){
	if(!(IOPIN1 & SW_UP)) return UP_BUT;
	else if(!(IOPIN1 & SW_DWN)) return DWN_BUT;
	else if(!(IOPIN1 & SW_MID)) return MID_BUT;
	return NO_BUT;
}


void getNewFiles(DisplayStruct *files, FileStruct *file_list){
   101bc:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	if(files->current_page < files->total_pages){
   101c0:	e5d02006 	ldrb	r2, [r0, #6]
   101c4:	e5d03005 	ldrb	r3, [r0, #5]
   101c8:	e1520003 	cmp	r2, r3
   101cc:	e1a05001 	mov	r5, r1
		for(int i =0; i<NUMROWS; i++){
			for(int j=0; j<MAXFILENAMELEN; j++){
				files->list[i].file_name[j] = file_list[files->current_page*NUMROWS+i].file_name[j];
			}
		}
	}
	else{
		for(int i=0; i<(NUMBEROFFILES-files->total_pages*NUMROWS); i++){
   101d0:	33a0c000 	movcc	ip, #0	; 0x0
   101d4:	33a0e00c 	movcc	lr, #12	; 0xc
   101d8:	259f30c8 	ldrcs	r3, [pc, #200]	; 102a8 <.text+0x2a8>
   101dc:	25934000 	ldrcs	r4, [r3]
   101e0:	23a0e000 	movcs	lr, #0	; 0x0
   101e4:	2a00001d 	bcs	10260 <getNewFiles+0xa4>
   101e8:	e3a01000 	mov	r1, #0	; 0x0
   101ec:	e5d02006 	ldrb	r2, [r0, #6]
   101f0:	e3a0300f 	mov	r3, #15	; 0xf
   101f4:	e023c392 	mla	r3, r2, r3, ip
   101f8:	e0813283 	add	r3, r1, r3, lsl #5
   101fc:	e7d32005 	ldrb	r2, [r3, r5]
   10200:	e0803001 	add	r3, r0, r1
   10204:	e2811001 	add	r1, r1, #1	; 0x1
   10208:	e351001e 	cmp	r1, #30	; 0x1e
   1020c:	e7c3200e 	strb	r2, [r3, lr]
   10210:	1afffff5 	bne	101ec <getNewFiles+0x30>
   10214:	e28cc001 	add	ip, ip, #1	; 0x1
   10218:	e35c000f 	cmp	ip, #15	; 0xf
   1021c:	e28ee020 	add	lr, lr, #32	; 0x20
   10220:	0a00001e 	beq	102a0 <getNewFiles+0xe4>
   10224:	eaffffef 	b	101e8 <getNewFiles+0x2c>
   10228:	e3a0c000 	mov	ip, #0	; 0x0
			for(int j=0; j<MAXFILENAMELEN; j++){
				files->list[i].file_name[j] = file_list[files->current_page*NUMROWS+i].file_name[j];
   1022c:	e5d02006 	ldrb	r2, [r0, #6]
   10230:	e3a0300f 	mov	r3, #15	; 0xf
   10234:	e023e392 	mla	r3, r2, r3, lr
   10238:	e08c3283 	add	r3, ip, r3, lsl #5
   1023c:	e7d31005 	ldrb	r1, [r3, r5]
   10240:	e080200c 	add	r2, r0, ip
   10244:	e1a0328e 	mov	r3, lr, lsl #5
   10248:	e28cc001 	add	ip, ip, #1	; 0x1
   1024c:	e283300c 	add	r3, r3, #12	; 0xc
   10250:	e35c001e 	cmp	ip, #30	; 0x1e
   10254:	e7c21003 	strb	r1, [r2, r3]
   10258:	1afffff3 	bne	1022c <getNewFiles+0x70>
   1025c:	e28ee001 	add	lr, lr, #1	; 0x1
   10260:	e5d03005 	ldrb	r3, [r0, #5]
   10264:	e3a0200f 	mov	r2, #15	; 0xf
   10268:	e0030392 	mul	r3, r2, r3
   1026c:	e0632004 	rsb	r2, r3, r4
   10270:	e15e0002 	cmp	lr, r2
   10274:	baffffeb 	blt	10228 <getNewFiles+0x6c>
   10278:	e1a03282 	mov	r3, r2, lsl #5
   1027c:	e283300c 	add	r3, r3, #12	; 0xc
   10280:	e0800003 	add	r0, r0, r3
   10284:	ea000001 	b	10290 <getNewFiles+0xd4>
			}
		}
		for(int i=(NUMBEROFFILES-files->total_pages*NUMROWS); i<NUMROWS; i++)files->list[i].file_name[0]='\0';
   10288:	e3a03000 	mov	r3, #0	; 0x0
   1028c:	e5403020 	strb	r3, [r0, #-32]
   10290:	e352000e 	cmp	r2, #14	; 0xe
   10294:	e2800020 	add	r0, r0, #32	; 0x20
   10298:	e2822001 	add	r2, r2, #1	; 0x1
   1029c:	dafffff9 	ble	10288 <getNewFiles+0xcc>
	}
}
   102a0:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   102a4:	e12fff1e 	bx	lr
   102a8:	40000ed4 	ldrmid	r0, [r0], -r4

000102ac <fillSettings>:

//Usage: file_is_open = loadSongInfo(&current_song, &file_manager);
//Inputs: SongStruct *song: Pointer to the struct in which the song information will be loaded
//		  DisplayStruct *selected_song: Pointer to the song whose information will be loaded
//The function takes the currently selected file name from the selected_song structure and loads
// the vital file information into the song structure.  The function also opens the song and prepares
// it to be played.  If the function succesfully opens the song, a 1 is returned, else a 0 is returned.
char loadSongInfo(SongStruct *song, DisplayStruct *selected_song){
	//Get the selected songs file name
	for(int i=0; i<MAXFILENAMELEN; i++){
		song->file_name[i] = selected_song->list[selected_song->current_index].file_name[i];
	}
	//Get the selected songs display name
	for(int i=0; i<MAXDISPLEN; i++){
		if((song->file_name[i] == '.') || (i==MAXDISPLEN-1)){
			song->name[i]='\0';
			i=MAXDISPLEN;
		}	
		else song->name[i]=song->file_name[i];
	}
	
	PINSEL0 |= (SCLK_PINSEL | MISO_PINSEL | MOSI_PINSEL);	//Make sure SPI is selected for reading the card
	//Check to see if the selected song is valid
	if(!root_file_exists(song->file_name)){
		PINSEL0 &= 0xFFFFC00F;
		return 0;
	}	
	//Open the selected song
	else{
		song->handle=root_open(song->file_name);
		song->size=fat16_file_size(song->handle);
		fat16_read_file(song->handle, song->data, MAXBUFFERSIZE);
	}
	
	
	PINSEL0 &= 0xFFFFC00F;
	return 1;
}

//Usage: CloseSong(&current_song);
//Inputs: SongStruct *song: Pointer to a song structure to be closed
//Function closes a song that is currently open.
void closeSong(SongStruct *song){
	PINSEL0 |= (SCLK_PINSEL | MISO_PINSEL | MOSI_PINSEL);
	fat16_close_file(song->handle);
	PINSEL0 &= 0xFFFFC00F;
}

//Usage: highlightRow(&current_display, PREVIOUS);
//Inputs: DisplayStruct *current_display: Pointer to the display structure whose current row value should be changed.
//		  char direction: direction value can be PREVIOUS or NEXT.  Value indicates which row should be highlighted
//Depending on "direction" this value highlights a row, and manages the current_row and current_index values.
void highlightRow(DisplayStruct *display, char direction){
	PINSEL0 &= 0xFFFFC00F;		//Hand over SPI lines to LCD talk
	LCDSetRowColor(display->current_row, 0, display->back_color, display->orientation);
	LCDPrintString(display->list[display->current_index].file_name, 0,display->text_color, display->current_row,0,display->orientation);
	if(direction == PREVIOUS){
		display->current_row--;
		display->current_index--;
	}
	else{
		display->current_row++;
		display->current_index++;		
	}
	LCDSetRowColor(display->current_row, 0, display->text_color, display->orientation);
	LCDPrintString(display->list[display->current_index].file_name, 0,display->back_color, display->current_row,0,display->orientation);	
}

//Usage: printMenu(&settings_menu);
//Inputs: DisplayStruct *display: Pointer to the display struct to be displayed on the LCD.
//This function writes the title, along with all of the file names in the display struct to the screen.
void printMenu(DisplayStruct *display){
	PINSEL0 &= 0xFFFFC00F;		//Hand over SPI lines to LCD talk
	if(display->current_page==0)LCDPrintString(display->title,0, display->text_color, 0,0,display->orientation);
	for(int j=0; j<NUMROWS; j++){
		LCDPrintString(display->list[j].file_name,0, display->text_color, j+1,0,display->orientation);
	}
	LCDSetRowColor(display->current_row, 0, display->text_color, display->orientation);
	LCDPrintString(display->list[display->current_index].file_name, 0,display->back_color, display->current_row,0,display->orientation);
}

//Usage: fillSettings(&settings_menu, &settings_values);
//Inputs: DisplayStruct *menu: Struct whose file names should be loaded with the settings menu
//		  SettingsStruct *values: settings struct whose initial values should be set
//This function fills the input display struct with a list of settings, along with a "settings" title.  It
//also loads the default display values along with the default settings values. 
void fillSettings(DisplayStruct *menu){
   102ac:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   102b0:	e59f509c 	ldr	r5, [pc, #156]	; 10354 <.text+0x354>
   102b4:	e59f809c 	ldr	r8, [pc, #156]	; 10358 <.text+0x358>
   102b8:	e59f709c 	ldr	r7, [pc, #156]	; 1035c <.text+0x35c>
   102bc:	e59f609c 	ldr	r6, [pc, #156]	; 10360 <.text+0x360>
   102c0:	e1a04000 	mov	r4, r0
   102c4:	e1a0e000 	mov	lr, r0
	for(int i=0; i<MAXDISPLEN; i++){
		menu->list[0].file_name[i] = volume[i];
   102c8:	e4d52001 	ldrb	r2, [r5], #1
   102cc:	e59f3090 	ldr	r3, [pc, #144]	; 10364 <.text+0x364>
		menu->list[1].file_name[i] = radio_power[i];
   102d0:	e4d81001 	ldrb	r1, [r8], #1
		menu->list[2].file_name[i] = radio_channel_menu[i];
   102d4:	e4d70001 	ldrb	r0, [r7], #1
		menu->title[i] = settings[i];
   102d8:	e4d6c001 	ldrb	ip, [r6], #1
   102dc:	e1550003 	cmp	r5, r3
   102e0:	e5ce200c 	strb	r2, [lr, #12]
   102e4:	e5ce102c 	strb	r1, [lr, #44]
   102e8:	e5ce004c 	strb	r0, [lr, #76]
   102ec:	e5cec1ec 	strb	ip, [lr, #492]
   102f0:	e28ee001 	add	lr, lr, #1	; 0x1
   102f4:	1afffff3 	bne	102c8 <fillSettings+0x1c>
   102f8:	e1a03004 	mov	r3, r4
   102fc:	e3a02003 	mov	r2, #3	; 0x3
	}
	for(int i=3; i<NUMROWS; i++){
   10300:	e2822001 	add	r2, r2, #1	; 0x1
		menu->list[i].file_name[0]='\0';
   10304:	e3a01000 	mov	r1, #0	; 0x0
   10308:	e352000f 	cmp	r2, #15	; 0xf
   1030c:	e5c3106c 	strb	r1, [r3, #108]
   10310:	e2833020 	add	r3, r3, #32	; 0x20
   10314:	1afffff9 	bne	10300 <fillSettings+0x54>
	}
	menu->text_color=white;
   10318:	e59f3048 	ldr	r3, [pc, #72]	; 10368 <.text+0x368>
   1031c:	e5d33000 	ldrb	r3, [r3]
   10320:	e5c43003 	strb	r3, [r4, #3]
	menu->back_color=black;
   10324:	e59f3040 	ldr	r3, [pc, #64]	; 1036c <.text+0x36c>
   10328:	e5d32000 	ldrb	r2, [r3]
	menu->current_row=1;
   1032c:	e3a03001 	mov	r3, #1	; 0x1
	menu->current_column=0;
	menu->current_index=0;
	menu->orientation = ORIENTLEFT;
	menu->current_page=0;
	menu->total_pages = 0;
   10330:	e5c41005 	strb	r1, [r4, #5]
   10334:	e5c42004 	strb	r2, [r4, #4]
   10338:	e5c43002 	strb	r3, [r4, #2]
   1033c:	e5c43000 	strb	r3, [r4]
   10340:	e5c41001 	strb	r1, [r4, #1]
   10344:	e5841008 	str	r1, [r4, #8]
   10348:	e5c41006 	strb	r1, [r4, #6]
}
   1034c:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   10350:	e12fff1e 	bx	lr
   10354:	00018bd4 	ldreqd	r8, [r1], -r4
   10358:	00018bbc 	streqh	r8, [r1], -ip
   1035c:	00018bac 	andeq	r8, r1, ip, lsr #23
   10360:	00018ba0 	andeq	r8, r1, r0, lsr #23
   10364:	00018bea 	andeq	r8, r1, sl, ror #23
   10368:	4000000a 	andmi	r0, r0, sl
   1036c:	40001564 	andmi	r1, r0, r4, ror #10

00010370 <reset>:

//Usage: handleUpButton(current_display, &Files[0]);
//Inputs: 	DisplayStruct *display: Display currently being shown to the user.
//			FileStruct *Files: List of files on the SD card
//Outputs: None
//Description: This function will highlight the previous row on the screen.  If the file menu is being shown,
// and the first file is currently selected, the function will get the previous group of files and display them.
void handleUpButton(DisplayStruct *display, FileStruct *Files){
	if(display->current_row >1){	//See if the currently highlighted row is at the top of the page
		highlightRow(display, PREVIOUS); //If it isn't, then highlight the previous row
	}
	//If the current row is at the top of the page, and there are previous songs, then get them.
	else if((display->current_row == 1) && (display->current_page > 0)){	//If a prev. page exists, load it
		//Load previous 15 songs and reset row, index and offset values
		display->current_page-=1;					//Set the "new" current page to be loaded
		quickClear(display);
		display->current_row=15;					//Start current row at bottom of next screen
		display->current_index=14;					//
		getNewFiles(&file_manager, &Files[0]);		//Load the previous page
		printMenu(display);							//	display previous page
	}
}

//Usage: handleDownButton(current_display, &Files[0]);
//Inputs: 	DisplayStruct *display: Display currently being shown to the user.
//			FileStruct *Files: List of files on the SD card
//Outputs: None
//Description: This function will highlight the next row on the screen.  If the file menu is being shown,
// and the last file is currently selected, the function will get the next group of files and display them.
void handleDownButton(DisplayStruct *display, FileStruct *Files){
	if(display->current_row <15){	//See if the currently highlighted row is at the bottom of the page
		highlightRow(display, NEXT);	//If it's not, then highlight the next row
	}
	//If the current highlighted row is at the bottom, and there're more songs, then get them
	else if((display->current_row == 15) && (display->current_page < display->total_pages)){
		//Load next 15 songs and reset row, index and offset values
		display->current_page+=1;		
		quickClear(display);
		display->current_row=1;
		display->current_index=0;
		getNewFiles(&file_manager, &Files[0]);
		printMenu(display);				
	}
}

//Usage: handleMiddleButton();
//Inputs: None
//Outputs: None
//Description: This function is called when the middle button is pressed.
//  The function performs an action based on the current state of the MP3 player.
//	(1.-If the file menu is displayed, and a song is not being played, the function starts the currently highlighted song.)
//	(2.-If the file menu is displayed and a song IS being played, the fucntion stops the currently playing song)
//	(3.-If the settings menu is displayed, the function opens the selected setting and allows the user to edit the setting.)
void handleMiddleButton(void){
	VICIntEnClr = 0x10;
	delay_ms(250);
	
	//If the File Menu is being displayed, middle button acts like play/stop
	if(current_display == &file_manager){
		if(!file_is_open){				//If a file isn't already playing then this acts like a play button
			file_is_open=loadSongInfo(&current_song, &file_manager);	//Get the current song info.
			if(!file_is_open){			//Make sure this is a valid file
				LCDClear(white);
				LCDPrintString(NotFound, 0, black, 1,0,current_display->orientation);
				delay_ms(1000);
				LCDClear(black);
				printMenu(&file_manager);
			}	
			else{
				vs1002Config();							//Enable the MP3 Comm. Lines
				vs1002SCIWrite(SCI_MODE, SM_SDINEW);	//Make sure the MP3 player is in the right mode.
				vs1002Finish();							//Disable the MP3 Comm. Lines
				ledBlueOn();
				//Send first song data
				vs1002Config();										//Enable MP3 Comm. Lines
				while((IOPIN0 & MP3_DREQ) != 0){
					vs1002SendMusic(current_song.data, MAXBUFFERSIZE);	//Send the buffered song data
					if(fat16_read_file(current_song.handle, current_song.data, MAXBUFFERSIZE) <= 0)song_is_over=1;	//Buffer more data if available
					else song_is_over=0;									//if there's no more data available, set the flag, else leave it alone
				}
				vs1002Finish();
				PINSEL1 |= 0x00000C00;						
				VICIntEnable |= 0x20;		//Enable Timer 1 Interrupts(This is the "Song Sending" interrupt).
				IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);		//Assign LCD pins as Outputs
			}
		}	
		else{							//If a file is already open then this acts like a stop button
			VICIntEnClr = 0x20;											//Disable Time 0 Interrupts(Stop the "Song Sending" interrupt)
			ledBlueOff();
			vs1002Config();												//Enable the MP3 Comm Lines
			vs1002SCIWrite(SCI_MODE, SM_OUTOFWAV);						//Tell the MP3 Player to jump out of WAV decoding
			for(int i=0; i<150; i++)vs1002SCIWrite(SCI_MODE, 0x00);	//Send 150 zeroes to the player to clear it's FIFO.
			vs1002Finish();												//Disable the MP3 Comm. Lines
			IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);			//Assign LCD pins as Outputs
			closeSong(&current_song);									//Close the current song
			file_is_open=0;												//Clear the global flag
			VICIntEnable = 0x10;
		}
	}
	
	//Else we are on the Settings menu, and we need to handle the settins options
	else{
		if(file_is_open)quickClear(current_display);
		else LCDClear(settings_menu.back_color);
		LCDPrintString(current_display->list[current_display->current_index].file_name,0,current_display->text_color,1,0,current_display->orientation);
		VICIntEnable|=0x10;
		if(current_display->current_row==VOLUMEMENU){
			VICIntEnable |= 0x10;
			LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
			LCDPrintString("%d", volume_setting, white, 2, 0, current_display->orientation);
			while(button_pressed < MID_BUT){
				VICIntEnClr = 0x10;				//Stop Interrupts to
				delay_ms(150);					//	debounce the switch					
				if(button_pressed==UP_BUT){
					if(volume_setting < 32){
						volume_setting+=1;
						vs1002Config();				//Enable the MP3 Comm. Lines
						vs1002SetVolume(INCREASE);	//Lower the volume
						vs1002Finish();				//Disable MP3 Comm. Lines
					}	
					LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
					LCDPrintString("%d", volume_setting, current_display->text_color, 2, 0, current_display->orientation);
				}
				else if(button_pressed==DWN_BUT){
					if(volume_setting >= 0){
						volume_setting--;
						vs1002Config();			//Enable the MP3 Comm. Lines
						vs1002SetVolume(DECREASE);	//Lower the volume
						vs1002Finish();			//Disable MP3 Comm. Lines
					}
					LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
					LCDPrintString("%d", volume_setting, white, 2, 0, current_display->orientation);
				}
				VICIntEnable |= 0x10;
			}
		}	
		else if(current_display->current_row==RADIOCMENU){
			LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
			LCDPrintString("%d", radio_channel, white, 2, 0, current_display->orientation);
			button_pressed=NO_BUT;
			VICIntEnable |= 0x10;
			while(button_pressed < MID_BUT){
				VICIntEnClr = 0x10;	//Stop Interrupts to
				delay_ms(100);		//	debounce the switch					
				if(button_pressed==UP_BUT){
					//Increase Radio Channel
					if(radio_channel < 1075)radio_channel+=2;
					LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
					LCDPrintString("%d", radio_channel, white, 2, 0, current_display->orientation);
				}
				else if(button_pressed==DWN_BUT){
					//Decrease Radio Channel
					if(radio_channel > 885)radio_channel-=2;
					LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
					LCDPrintString("%d", radio_channel, white, 2, 0, current_display->orientation);
				}
				ns73SetChannel(radio_channel);
				VICIntEnable |= 0x10;
			}
			IOCLR1 |= FM_CS;				//Select the FM transmitter
			delay_ms(100);
			ns73Config();					//Configigure the FM Trans. I/O
			ns73SetChannel(radio_channel);	//Set the channel	
			IOSET1 |= FM_CS;				//Unselect the FM transmitter
		}
		else if(current_display->current_row==RADIOPMENU){
			LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
			if(radio_enable)LCDPrintString("On", 0, current_display->text_color, 2,0,current_display->orientation);
			else LCDPrintString("Off", 0, current_display->text_color, 2,0,current_display->orientation);
			button_pressed=NO_BUT;
			VICIntEnable |= 0x10;
			while(button_pressed < MID_BUT){
				VICIntEnClr = 0x10;	//Stop Interrupts to
				delay_ms(100);		//	debounce the switch					
				if(button_pressed==UP_BUT){
					//Enable Radio
					radio_enable=ON;
					LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
					LCDPrintString("On", 0, current_display->text_color, 2,0,current_display->orientation);
					
					IOCLR1 |= FM_CS;			//Select the FM transmitter
					delay_ms(100);
					ns73Config();				//Configigure the FM Trans. I/O
					ns73Send(R0, PE | AG);		//Power up the radio	
					IOSET1 |= FM_CS;			//Unselect the FM transmitter

				}
				else if(button_pressed==DWN_BUT){
					//Disable Radio
					radio_enable=OFF;
					LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
					LCDPrintString("Off", 0, current_display->text_color, 2,0,current_display->orientation);

					IOCLR1 |= FM_CS;			//Select the FM transmitter
					delay_ms(100);
					ns73Config();				//Configigure the FM Trans. I/O
					ns73Send(R0, MUTE);		//Power up the radio	
					IOSET1 |= FM_CS;			//Unselect the FM transmitter	

				}
				VICIntEnable |= 0x10;
			}
		}
		if(file_is_open)quickClear(current_display);
		else LCDClear(current_display->back_color);
		printMenu(current_display);
	}
	VICIntEnable |= 0x10;
}


//Usage: quickClear(currentDisplay);
//Inputs: DisplayStruct *display - pointer to the display that contains the current display
//Outputs: None
//Description: Rather than painting every pixel a specific color (like LCDClear does) this routine
//			   will simply color all of the text the same color as the background, giving the illusion
//			   of a clear screen.  Only works with the background color.  Much faster than LCDClear, and is
//			   good to use while an MP3 is playing.
void quickClear(DisplayStruct *display){
	PINSEL0 &= 0xFFFFC00F;		//Hand over SPI lines to LCD talk
	//If we're on the first page of the menu, we also need to clear the title.
	if(display->current_page==0){
		LCDPrintString(display->title,0, display->back_color, 0,0,display->orientation);
		
	}
	LCDSetRowColor(display->current_row, 0, display->back_color, display->orientation);
	for(int j=0; j<NUMROWS; j++){
		LCDPrintString(display->list[j].file_name,0, display->back_color, j+1,0,display->orientation);
		LCDPrintString(newline,0, black, j+1,0,0);
	}
}

void reset(void)
{
    // Intentionally fault Watchdog to trigger a reset condition
    WDMOD |= 3;
   10370:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
   10374:	e5913000 	ldr	r3, [r1]
   10378:	e3833003 	orr	r3, r3, #3	; 0x3
   1037c:	e5813000 	str	r3, [r1]
    WDFEED = 0xAA;
   10380:	e3a0228e 	mov	r2, #-536870904	; 0xe0000008
   10384:	e3a000aa 	mov	r0, #170	; 0xaa
    WDFEED = 0x55;
   10388:	e3a03055 	mov	r3, #85	; 0x55
   1038c:	e5820000 	str	r0, [r2]
   10390:	e5823000 	str	r3, [r2]
    WDFEED = 0xAA;
    WDFEED = 0x00;
   10394:	e3a03000 	mov	r3, #0	; 0x0
   10398:	e5820000 	str	r0, [r2]
   1039c:	e5823000 	str	r3, [r2]
}
   103a0:	e12fff1e 	bx	lr

000103a4 <bootUp>:
   103a4:	e52de004 	str	lr, [sp, #-4]!
   103a8:	e59f01e0 	ldr	r0, [pc, #480]	; 10590 <.text+0x590>
   103ac:	eb000595 	bl	11a08 <rprintf_devopen>
   103b0:	e3a0000a 	mov	r0, #10	; 0xa
   103b4:	ebffff76 	bl	10194 <delay_ms>
   103b8:	eb0008e6 	bl	12758 <sd_raw_init>
   103bc:	e3500000 	cmp	r0, #0	; 0x0
   103c0:	059f01cc 	ldreq	r0, [pc, #460]	; 10594 <.text+0x594>
   103c4:	0b0005a3 	bleq	11a58 <rprintf>
   103c8:	eb0006a4 	bl	11e60 <openroot>
   103cc:	e3500000 	cmp	r0, #0	; 0x0
   103d0:	159f01c0 	ldrne	r0, [pc, #448]	; 10598 <.text+0x598>
   103d4:	1b00059f 	blne	11a58 <rprintf>
   103d8:	e59f11bc 	ldr	r1, [pc, #444]	; 1059c <.text+0x59c>
   103dc:	e5913000 	ldr	r3, [r1]
   103e0:	e3833601 	orr	r3, r3, #1048576	; 0x100000
   103e4:	e5813000 	str	r3, [r1]
   103e8:	e5913000 	ldr	r3, [r1]
   103ec:	e3c33602 	bic	r3, r3, #2097152	; 0x200000
   103f0:	e5813000 	str	r3, [r1]
   103f4:	e59f21a4 	ldr	r2, [pc, #420]	; 105a0 <.text+0x5a0>
   103f8:	e5923000 	ldr	r3, [r2]
   103fc:	e3833b03 	orr	r3, r3, #3072	; 0xc00
   10400:	e5823000 	str	r3, [r2]
   10404:	e59f0198 	ldr	r0, [pc, #408]	; 105a4 <.text+0x5a4>
   10408:	e5903000 	ldr	r3, [r0]
   1040c:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   10410:	e3833803 	orr	r3, r3, #196608	; 0x30000
   10414:	e5803000 	str	r3, [r0]
   10418:	e5903000 	ldr	r3, [r0]
   1041c:	e3833402 	orr	r3, r3, #33554432	; 0x2000000
   10420:	e5803000 	str	r3, [r0]
   10424:	e5903000 	ldr	r3, [r0]
   10428:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   1042c:	e5803000 	str	r3, [r0]
   10430:	e5913000 	ldr	r3, [r1]
   10434:	e3833080 	orr	r3, r3, #128	; 0x80
   10438:	e5813000 	str	r3, [r1]
   1043c:	e5913000 	ldr	r3, [r1]
   10440:	e3833b03 	orr	r3, r3, #3072	; 0xc00
   10444:	e5813000 	str	r3, [r1]
   10448:	e2422004 	sub	r2, r2, #4	; 0x4
   1044c:	e5923000 	ldr	r3, [r2]
   10450:	e38334cf 	orr	r3, r3, #-822083584	; 0xcf000000
   10454:	e5823000 	str	r3, [r2]
   10458:	e59f3148 	ldr	r3, [pc, #328]	; 105a8 <.text+0x5a8>
   1045c:	e3a02b03 	mov	r2, #3072	; 0xc00
   10460:	e5832000 	str	r2, [r3]
   10464:	e5913000 	ldr	r3, [r1]
   10468:	e3833703 	orr	r3, r3, #786432	; 0xc0000
   1046c:	e5813000 	str	r3, [r1]
   10470:	e5913000 	ldr	r3, [r1]
   10474:	e59f2130 	ldr	r2, [pc, #304]	; 105ac <.text+0x5ac>
   10478:	e3833207 	orr	r3, r3, #1879048192	; 0x70000000
   1047c:	e5813000 	str	r3, [r1]
   10480:	e3a03202 	mov	r3, #536870912	; 0x20000000
   10484:	e5823000 	str	r3, [r2]
   10488:	e0833003 	add	r3, r3, r3
   1048c:	e5823000 	str	r3, [r2]
   10490:	e283320d 	add	r3, r3, #-805306368	; 0xd0000000
   10494:	e5823000 	str	r3, [r2]
   10498:	e5903000 	ldr	r3, [r0]
   1049c:	e3c3360e 	bic	r3, r3, #14680064	; 0xe00000
   104a0:	e5803000 	str	r3, [r0]
   104a4:	e5913000 	ldr	r3, [r1]
   104a8:	e3c33502 	bic	r3, r3, #8388608	; 0x800000
   104ac:	e5813000 	str	r3, [r1]
   104b0:	e59f30f8 	ldr	r3, [pc, #248]	; 105b0 <.text+0x5b0>
   104b4:	e3a02001 	mov	r2, #1	; 0x1
   104b8:	e5832000 	str	r2, [r3]
   104bc:	e59f30f0 	ldr	r3, [pc, #240]	; 105b4 <.text+0x5b4>
   104c0:	e3e02030 	mvn	r2, #48	; 0x30
   104c4:	e5832000 	str	r2, [r3]
   104c8:	e2822041 	add	r2, r2, #65	; 0x41
   104cc:	e2833004 	add	r3, r3, #4	; 0x4
   104d0:	e5832000 	str	r2, [r3]
   104d4:	e2822015 	add	r2, r2, #21	; 0x15
   104d8:	e2833e1f 	add	r3, r3, #496	; 0x1f0
   104dc:	e5832000 	str	r2, [r3]
   104e0:	e59f20d0 	ldr	r2, [pc, #208]	; 105b8 <.text+0x5b8>
   104e4:	e59f30d0 	ldr	r3, [pc, #208]	; 105bc <.text+0x5bc>
   104e8:	e5832000 	str	r2, [r3]
   104ec:	e3a02024 	mov	r2, #36	; 0x24
   104f0:	e2833f41 	add	r3, r3, #260	; 0x104
   104f4:	e5832000 	str	r2, [r3]
   104f8:	e59f20c0 	ldr	r2, [pc, #192]	; 105c0 <.text+0x5c0>
   104fc:	e2433c01 	sub	r3, r3, #256	; 0x100
   10500:	e5832000 	str	r2, [r3]
   10504:	e59f20b8 	ldr	r2, [pc, #184]	; 105c4 <.text+0x5c4>
   10508:	e59f30b8 	ldr	r3, [pc, #184]	; 105c8 <.text+0x5c8>
   1050c:	e5832000 	str	r2, [r3]
   10510:	e59f20b4 	ldr	r2, [pc, #180]	; 105cc <.text+0x5cc>
   10514:	e5923000 	ldr	r3, [r2]
   10518:	e3833001 	orr	r3, r3, #1	; 0x1
   1051c:	e5823000 	str	r3, [r2]
   10520:	e59f30a8 	ldr	r3, [pc, #168]	; 105d0 <.text+0x5d0>
   10524:	e3a01000 	mov	r1, #0	; 0x0
   10528:	e5831000 	str	r1, [r3]
   1052c:	e3a02003 	mov	r2, #3	; 0x3
   10530:	e243305c 	sub	r3, r3, #92	; 0x5c
   10534:	e5832000 	str	r2, [r3]
   10538:	e3a02ffa 	mov	r2, #1000	; 0x3e8
   1053c:	e2833004 	add	r3, r3, #4	; 0x4
   10540:	e5832000 	str	r2, [r3]
   10544:	e59f3088 	ldr	r3, [pc, #136]	; 105d4 <.text+0x5d4>
   10548:	e2422e32 	sub	r2, r2, #800	; 0x320
   1054c:	e5832000 	str	r2, [r3]
   10550:	e59f2080 	ldr	r2, [pc, #128]	; 105d8 <.text+0x5d8>
   10554:	e5923000 	ldr	r3, [r2]
   10558:	e3833001 	orr	r3, r3, #1	; 0x1
   1055c:	e5823000 	str	r3, [r2]
   10560:	e59f3074 	ldr	r3, [pc, #116]	; 105dc <.text+0x5dc>
   10564:	e3a02c0a 	mov	r2, #2560	; 0xa00
   10568:	e4031048 	str	r1, [r3], #-72
   1056c:	e5832000 	str	r2, [r3]
   10570:	e59f3068 	ldr	r3, [pc, #104]	; 105e0 <.text+0x5e0>
   10574:	e2422d27 	sub	r2, r2, #2496	; 0x9c0
   10578:	e5832000 	str	r2, [r3]
   1057c:	e3a02020 	mov	r2, #32	; 0x20
   10580:	e243300c 	sub	r3, r3, #12	; 0xc
   10584:	e5832000 	str	r2, [r3]
   10588:	e49de004 	ldr	lr, [sp], #4
   1058c:	e12fff1e 	bx	lr
   10590:	00011d74 	andeq	r1, r1, r4, ror sp
   10594:	00018c58 	andeq	r8, r1, r8, asr ip
   10598:	00018c68 	andeq	r8, r1, r8, ror #24
   1059c:	e0028008 	and	r8, r2, r8
   105a0:	e002c004 	and	ip, r2, r4
   105a4:	e0028018 	and	r8, r2, r8, lsl r0
   105a8:	e002800c 	and	r8, r2, ip
   105ac:	e0028004 	and	r8, r2, r4
   105b0:	e01fc100 	ands	ip, pc, r0, lsl #2
   105b4:	fffff00c 	swinv	0x00fff00c
   105b8:	000105e4 	andeq	r0, r1, r4, ror #11
   105bc:	fffff100 	swinv	0x00fff100
   105c0:	000106ac 	andeq	r0, r1, ip, lsr #13
   105c4:	000005dc 	ldreqd	r0, [r0], -ip
   105c8:	e000400c 	and	r4, r0, ip
   105cc:	e0004004 	and	r4, r0, r4
   105d0:	e0004070 	and	r4, r0, r0, ror r0
   105d4:	e000800c 	and	r8, r0, ip
   105d8:	e0008004 	and	r8, r0, r4
   105dc:	e0008070 	and	r8, r0, r0, ror r0
   105e0:	e002000c 	and	r0, r2, ip

000105e4 <timer1ISR>:
   105e4:	e92d4010 	stmdb	sp!, {r4, lr}
   105e8:	eb00136a 	bl	15398 <vs1002Config>
   105ec:	ea00000b 	b	10620 <timer1ISR+0x3c>
   105f0:	eb0013eb 	bl	155a4 <vs1002SendMusic>
   105f4:	e59f305c 	ldr	r3, [pc, #92]	; 10658 <.text+0x658>
   105f8:	e3a02020 	mov	r2, #32	; 0x20
   105fc:	e283103d 	add	r1, r3, #61	; 0x3d
   10600:	e5930034 	ldr	r0, [r3, #52]
   10604:	eb000d1f 	bl	13a88 <fat16_read_file>
   10608:	e1a00800 	mov	r0, r0, lsl #16
   1060c:	e3500000 	cmp	r0, #0	; 0x0
   10610:	e59f2044 	ldr	r2, [pc, #68]	; 1065c <.text+0x65c>
   10614:	d3a03001 	movle	r3, #1	; 0x1
   10618:	c3a03000 	movgt	r3, #0	; 0x0
   1061c:	e5c23000 	strb	r3, [r2]
   10620:	e59f3038 	ldr	r3, [pc, #56]	; 10660 <.text+0x660>
   10624:	e5933000 	ldr	r3, [r3]
   10628:	e2134602 	ands	r4, r3, #2097152	; 0x200000
   1062c:	e59f0030 	ldr	r0, [pc, #48]	; 10664 <.text+0x664>
   10630:	e3a01020 	mov	r1, #32	; 0x20
   10634:	1affffed 	bne	105f0 <timer1ISR+0xc>
   10638:	eb001360 	bl	153c0 <vs1002Finish>
   1063c:	e59f2024 	ldr	r2, [pc, #36]	; 10668 <.text+0x668>
   10640:	e3a030ff 	mov	r3, #255	; 0xff
   10644:	e5823000 	str	r3, [r2]
   10648:	e59f301c 	ldr	r3, [pc, #28]	; 1066c <.text+0x66c>
   1064c:	e5834000 	str	r4, [r3]
   10650:	e8bd4010 	ldmia	sp!, {r4, lr}
   10654:	e12fff1e 	bx	lr
   10658:	400012e4 	andmi	r1, r0, r4, ror #5
   1065c:	40000ed1 	ldrmid	r0, [r0], -r1
   10660:	e0028000 	and	r8, r2, r0
   10664:	40001321 	andmi	r1, r0, r1, lsr #6
   10668:	e0008000 	and	r8, r0, r0
   1066c:	fffff030 	swinv	0x00fff030

00010670 <getButton>:
   10670:	e59f2030 	ldr	r2, [pc, #48]	; 106a8 <.text+0x6a8>
   10674:	e5923000 	ldr	r3, [r2]
   10678:	e3130502 	tst	r3, #8388608	; 0x800000
   1067c:	e3a00002 	mov	r0, #2	; 0x2
   10680:	012fff1e 	bxeq	lr
   10684:	e5923000 	ldr	r3, [r2]
   10688:	e3130602 	tst	r3, #2097152	; 0x200000
   1068c:	e3a00001 	mov	r0, #1	; 0x1
   10690:	012fff1e 	bxeq	lr
   10694:	e5923000 	ldr	r3, [r2]
   10698:	e3130501 	tst	r3, #4194304	; 0x400000
   1069c:	13a00000 	movne	r0, #0	; 0x0
   106a0:	03a00003 	moveq	r0, #3	; 0x3
   106a4:	e12fff1e 	bx	lr
   106a8:	e0028010 	and	r8, r2, r0, lsl r0

000106ac <timer0ISR>:
   106ac:	e52de004 	str	lr, [sp, #-4]!
   106b0:	ebffffee 	bl	10670 <getButton>
   106b4:	e59f3078 	ldr	r3, [pc, #120]	; 10734 <.text+0x734>
   106b8:	e5c30000 	strb	r0, [r3]
   106bc:	eb00107e 	bl	148bc <MMA_get_y>
   106c0:	e59f3070 	ldr	r3, [pc, #112]	; 10738 <.text+0x738>
   106c4:	e59f1070 	ldr	r1, [pc, #112]	; 1073c <.text+0x73c>
   106c8:	e5932000 	ldr	r2, [r3]
   106cc:	e59f306c 	ldr	r3, [pc, #108]	; 10740 <.text+0x740>
   106d0:	e1520001 	cmp	r2, r1
   106d4:	e5830000 	str	r0, [r3]
   106d8:	e59fc064 	ldr	ip, [pc, #100]	; 10744 <.text+0x744>
   106dc:	ca000002 	bgt	106ec <timer0ISR+0x40>
   106e0:	e3500faf 	cmp	r0, #700	; 0x2bc
   106e4:	ca000004 	bgt	106fc <timer0ISR+0x50>
   106e8:	ea000005 	b	10704 <timer0ISR+0x58>
   106ec:	e3520faf 	cmp	r2, #700	; 0x2bc
   106f0:	0a000003 	beq	10704 <timer0ISR+0x58>
   106f4:	e1500001 	cmp	r0, r1
   106f8:	ca000001 	bgt	10704 <timer0ISR+0x58>
   106fc:	e3a03001 	mov	r3, #1	; 0x1
   10700:	ea000000 	b	10708 <timer0ISR+0x5c>
   10704:	e3a03000 	mov	r3, #0	; 0x0
   10708:	e5cc3000 	strb	r3, [ip]
   1070c:	e59f3034 	ldr	r3, [pc, #52]	; 10748 <.text+0x748>
   10710:	e3a020ff 	mov	r2, #255	; 0xff
   10714:	e5832000 	str	r2, [r3]
   10718:	e59f3018 	ldr	r3, [pc, #24]	; 10738 <.text+0x738>
   1071c:	e5830000 	str	r0, [r3]
   10720:	e59f3024 	ldr	r3, [pc, #36]	; 1074c <.text+0x74c>
   10724:	e3a02000 	mov	r2, #0	; 0x0
   10728:	e5832000 	str	r2, [r3]
   1072c:	e49de004 	ldr	lr, [sp], #4
   10730:	e12fff1e 	bx	lr
   10734:	4000134d 	andmi	r1, r0, sp, asr #6
   10738:	40001348 	andmi	r1, r0, r8, asr #6
   1073c:	000002bb 	streqh	r0, [r0], -fp
   10740:	40001344 	andmi	r1, r0, r4, asr #6
   10744:	4000134c 	andmi	r1, r0, ip, asr #6
   10748:	e0004000 	and	r4, r0, r0
   1074c:	fffff030 	swinv	0x00fff030

00010750 <loadSongInfo>:
   10750:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   10754:	e1a02000 	mov	r2, r0
   10758:	e1a04000 	mov	r4, r0
   1075c:	e3a00000 	mov	r0, #0	; 0x0
   10760:	e5913008 	ldr	r3, [r1, #8]
   10764:	e0813283 	add	r3, r1, r3, lsl #5
   10768:	e0833000 	add	r3, r3, r0
   1076c:	e5d3300c 	ldrb	r3, [r3, #12]
   10770:	e2800001 	add	r0, r0, #1	; 0x1
   10774:	e350001e 	cmp	r0, #30	; 0x1e
   10778:	e5c23016 	strb	r3, [r2, #22]
   1077c:	e2822001 	add	r2, r2, #1	; 0x1
   10780:	1afffff6 	bne	10760 <loadSongInfo+0x10>
   10784:	e3a02000 	mov	r2, #0	; 0x0
   10788:	e0823004 	add	r3, r2, r4
   1078c:	e5d33016 	ldrb	r3, [r3, #22]
   10790:	e3520015 	cmp	r2, #21	; 0x15
   10794:	1353002e 	cmpne	r3, #46	; 0x2e
   10798:	03a03000 	moveq	r3, #0	; 0x0
   1079c:	07c43002 	streqb	r3, [r4, r2]
   107a0:	03a02016 	moveq	r2, #22	; 0x16
   107a4:	17c43002 	strneb	r3, [r4, r2]
   107a8:	e2822001 	add	r2, r2, #1	; 0x1
   107ac:	e3520015 	cmp	r2, #21	; 0x15
   107b0:	dafffff4 	ble	10788 <loadSongInfo+0x38>
   107b4:	e59f606c 	ldr	r6, [pc, #108]	; 10828 <.text+0x828>
   107b8:	e5963000 	ldr	r3, [r6]
   107bc:	e2845016 	add	r5, r4, #22	; 0x16
   107c0:	e3833c15 	orr	r3, r3, #5376	; 0x1500
   107c4:	e1a00005 	mov	r0, r5
   107c8:	e5863000 	str	r3, [r6]
   107cc:	eb0005dd 	bl	11f48 <root_file_exists>
   107d0:	e3500000 	cmp	r0, #0	; 0x0
   107d4:	05963000 	ldreq	r3, [r6]
   107d8:	03c33dff 	biceq	r3, r3, #16320	; 0x3fc0
   107dc:	03c33030 	biceq	r3, r3, #48	; 0x30
   107e0:	05863000 	streq	r3, [r6]
   107e4:	0a00000d 	beq	10820 <loadSongInfo+0xd0>
   107e8:	e1a00005 	mov	r0, r5
   107ec:	eb0005f4 	bl	11fc4 <root_open>
   107f0:	e5840034 	str	r0, [r4, #52]
   107f4:	eb000f33 	bl	144c8 <fat16_file_size>
   107f8:	e284103d 	add	r1, r4, #61	; 0x3d
   107fc:	e5840038 	str	r0, [r4, #56]
   10800:	e3a02020 	mov	r2, #32	; 0x20
   10804:	e5940034 	ldr	r0, [r4, #52]
   10808:	eb000c9e 	bl	13a88 <fat16_read_file>
   1080c:	e5963000 	ldr	r3, [r6]
   10810:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   10814:	e3c33030 	bic	r3, r3, #48	; 0x30
   10818:	e5863000 	str	r3, [r6]
   1081c:	e3a00001 	mov	r0, #1	; 0x1
   10820:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   10824:	e12fff1e 	bx	lr
   10828:	e002c000 	and	ip, r2, r0

0001082c <closeSong>:
   1082c:	e92d4010 	stmdb	sp!, {r4, lr}
   10830:	e59f4028 	ldr	r4, [pc, #40]	; 10860 <.text+0x860>
   10834:	e5943000 	ldr	r3, [r4]
   10838:	e3833c15 	orr	r3, r3, #5376	; 0x1500
   1083c:	e5843000 	str	r3, [r4]
   10840:	e5900034 	ldr	r0, [r0, #52]
   10844:	eb000c8a 	bl	13a74 <fat16_close_file>
   10848:	e5943000 	ldr	r3, [r4]
   1084c:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   10850:	e3c33030 	bic	r3, r3, #48	; 0x30
   10854:	e5843000 	str	r3, [r4]
   10858:	e8bd4010 	ldmia	sp!, {r4, lr}
   1085c:	e12fff1e 	bx	lr
   10860:	e002c000 	and	ip, r2, r0

00010864 <quickClear>:
   10864:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   10868:	e59f20b8 	ldr	r2, [pc, #184]	; 10928 <.text+0x928>
   1086c:	e5923000 	ldr	r3, [r2]
   10870:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   10874:	e3c33030 	bic	r3, r3, #48	; 0x30
   10878:	e5823000 	str	r3, [r2]
   1087c:	e5d0e006 	ldrb	lr, [r0, #6]
   10880:	e35e0000 	cmp	lr, #0	; 0x0
   10884:	e24dd008 	sub	sp, sp, #8	; 0x8
   10888:	e1a06000 	mov	r6, r0
   1088c:	1a000007 	bne	108b0 <quickClear+0x4c>
   10890:	e5d0c002 	ldrb	ip, [r0, #2]
   10894:	e5d02004 	ldrb	r2, [r0, #4]
   10898:	e1a0100e 	mov	r1, lr
   1089c:	e2800f7b 	add	r0, r0, #492	; 0x1ec
   108a0:	e1a0300e 	mov	r3, lr
   108a4:	e58dc004 	str	ip, [sp, #4]
   108a8:	e58de000 	str	lr, [sp]
   108ac:	eb0011aa 	bl	14f5c <LCDPrintString>
   108b0:	e5d60000 	ldrb	r0, [r6]
   108b4:	e3a01000 	mov	r1, #0	; 0x0
   108b8:	e5d62004 	ldrb	r2, [r6, #4]
   108bc:	e5d63002 	ldrb	r3, [r6, #2]
   108c0:	eb00127f 	bl	152c4 <LCDSetRowColor>
   108c4:	e3a05000 	mov	r5, #0	; 0x0
   108c8:	e1a00285 	mov	r0, r5, lsl #5
   108cc:	e3a04000 	mov	r4, #0	; 0x0
   108d0:	e5d6c002 	ldrb	ip, [r6, #2]
   108d4:	e2855001 	add	r5, r5, #1	; 0x1
   108d8:	e280000c 	add	r0, r0, #12	; 0xc
   108dc:	e5d62004 	ldrb	r2, [r6, #4]
   108e0:	e0860000 	add	r0, r6, r0
   108e4:	e1a01004 	mov	r1, r4
   108e8:	e1a03005 	mov	r3, r5
   108ec:	e88d1010 	stmia	sp, {r4, ip}
   108f0:	eb001199 	bl	14f5c <LCDPrintString>
   108f4:	e59f3030 	ldr	r3, [pc, #48]	; 1092c <.text+0x92c>
   108f8:	e1a01004 	mov	r1, r4
   108fc:	e5d32000 	ldrb	r2, [r3]
   10900:	e59f0028 	ldr	r0, [pc, #40]	; 10930 <.text+0x930>
   10904:	e1a03005 	mov	r3, r5
   10908:	e58d4000 	str	r4, [sp]
   1090c:	e58d4004 	str	r4, [sp, #4]
   10910:	eb001191 	bl	14f5c <LCDPrintString>
   10914:	e355000f 	cmp	r5, #15	; 0xf
   10918:	1affffea 	bne	108c8 <quickClear+0x64>
   1091c:	e28dd008 	add	sp, sp, #8	; 0x8
   10920:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   10924:	e12fff1e 	bx	lr
   10928:	e002c000 	and	ip, r2, r0
   1092c:	40001564 	andmi	r1, r0, r4, ror #10
   10930:	00018be0 	andeq	r8, r1, r0, ror #23

00010934 <printMenu>:
   10934:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   10938:	e59f20c0 	ldr	r2, [pc, #192]	; 10a00 <.text+0xa00>
   1093c:	e5923000 	ldr	r3, [r2]
   10940:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   10944:	e3c33030 	bic	r3, r3, #48	; 0x30
   10948:	e5823000 	str	r3, [r2]
   1094c:	e5d0e006 	ldrb	lr, [r0, #6]
   10950:	e35e0000 	cmp	lr, #0	; 0x0
   10954:	e24dd008 	sub	sp, sp, #8	; 0x8
   10958:	e1a05000 	mov	r5, r0
   1095c:	1a000007 	bne	10980 <printMenu+0x4c>
   10960:	e5d0c002 	ldrb	ip, [r0, #2]
   10964:	e5d02003 	ldrb	r2, [r0, #3]
   10968:	e1a0100e 	mov	r1, lr
   1096c:	e2800f7b 	add	r0, r0, #492	; 0x1ec
   10970:	e1a0300e 	mov	r3, lr
   10974:	e58dc004 	str	ip, [sp, #4]
   10978:	e58de000 	str	lr, [sp]
   1097c:	eb001176 	bl	14f5c <LCDPrintString>
   10980:	e3a04000 	mov	r4, #0	; 0x0
   10984:	e1a00284 	mov	r0, r4, lsl #5
   10988:	e5d5c002 	ldrb	ip, [r5, #2]
   1098c:	e2844001 	add	r4, r4, #1	; 0x1
   10990:	e3a06000 	mov	r6, #0	; 0x0
   10994:	e280000c 	add	r0, r0, #12	; 0xc
   10998:	e5d52003 	ldrb	r2, [r5, #3]
   1099c:	e0850000 	add	r0, r5, r0
   109a0:	e1a01006 	mov	r1, r6
   109a4:	e1a03004 	mov	r3, r4
   109a8:	e88d1040 	stmia	sp, {r6, ip}
   109ac:	eb00116a 	bl	14f5c <LCDPrintString>
   109b0:	e354000f 	cmp	r4, #15	; 0xf
   109b4:	1afffff2 	bne	10984 <printMenu+0x50>
   109b8:	e5d50000 	ldrb	r0, [r5]
   109bc:	e1a01006 	mov	r1, r6
   109c0:	e5d52003 	ldrb	r2, [r5, #3]
   109c4:	e5d53002 	ldrb	r3, [r5, #2]
   109c8:	eb00123d 	bl	152c4 <LCDSetRowColor>
   109cc:	e5950008 	ldr	r0, [r5, #8]
   109d0:	e1a00280 	mov	r0, r0, lsl #5
   109d4:	e5d5c002 	ldrb	ip, [r5, #2]
   109d8:	e280000c 	add	r0, r0, #12	; 0xc
   109dc:	e5d52004 	ldrb	r2, [r5, #4]
   109e0:	e5d53000 	ldrb	r3, [r5]
   109e4:	e0850000 	add	r0, r5, r0
   109e8:	e1a01006 	mov	r1, r6
   109ec:	e88d1040 	stmia	sp, {r6, ip}
   109f0:	eb001159 	bl	14f5c <LCDPrintString>
   109f4:	e28dd008 	add	sp, sp, #8	; 0x8
   109f8:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   109fc:	e12fff1e 	bx	lr
   10a00:	e002c000 	and	ip, r2, r0

00010a04 <highlightRow>:
   10a04:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   10a08:	e59f20d4 	ldr	r2, [pc, #212]	; 10ae4 <.text+0xae4>
   10a0c:	e5923000 	ldr	r3, [r2]
   10a10:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   10a14:	e3c33030 	bic	r3, r3, #48	; 0x30
   10a18:	e5823000 	str	r3, [r2]
   10a1c:	e1a05000 	mov	r5, r0
   10a20:	e24dd008 	sub	sp, sp, #8	; 0x8
   10a24:	e5d52004 	ldrb	r2, [r5, #4]
   10a28:	e5d53002 	ldrb	r3, [r5, #2]
   10a2c:	e1a04001 	mov	r4, r1
   10a30:	e5d00000 	ldrb	r0, [r0]
   10a34:	e3a01000 	mov	r1, #0	; 0x0
   10a38:	eb001221 	bl	152c4 <LCDSetRowColor>
   10a3c:	e5950008 	ldr	r0, [r5, #8]
   10a40:	e1a00280 	mov	r0, r0, lsl #5
   10a44:	e5d5e002 	ldrb	lr, [r5, #2]
   10a48:	e3a0c000 	mov	ip, #0	; 0x0
   10a4c:	e280000c 	add	r0, r0, #12	; 0xc
   10a50:	e5d52003 	ldrb	r2, [r5, #3]
   10a54:	e5d53000 	ldrb	r3, [r5]
   10a58:	e1a0100c 	mov	r1, ip
   10a5c:	e0850000 	add	r0, r5, r0
   10a60:	e88d5000 	stmia	sp, {ip, lr}
   10a64:	eb00113c 	bl	14f5c <LCDPrintString>
   10a68:	e5d53000 	ldrb	r3, [r5]
   10a6c:	e20440ff 	and	r4, r4, #255	; 0xff
   10a70:	e3540001 	cmp	r4, #1	; 0x1
   10a74:	e2430001 	sub	r0, r3, #1	; 0x1
   10a78:	e2831001 	add	r1, r3, #1	; 0x1
   10a7c:	e5953008 	ldr	r3, [r5, #8]
   10a80:	15c51000 	strneb	r1, [r5]
   10a84:	05c50000 	streqb	r0, [r5]
   10a88:	e2432001 	sub	r2, r3, #1	; 0x1
   10a8c:	e2833001 	add	r3, r3, #1	; 0x1
   10a90:	05852008 	streq	r2, [r5, #8]
   10a94:	15853008 	strne	r3, [r5, #8]
   10a98:	e5d50000 	ldrb	r0, [r5]
   10a9c:	e5d52003 	ldrb	r2, [r5, #3]
   10aa0:	e5d53002 	ldrb	r3, [r5, #2]
   10aa4:	e3a01000 	mov	r1, #0	; 0x0
   10aa8:	eb001205 	bl	152c4 <LCDSetRowColor>
   10aac:	e5950008 	ldr	r0, [r5, #8]
   10ab0:	e1a00280 	mov	r0, r0, lsl #5
   10ab4:	e3a0c000 	mov	ip, #0	; 0x0
   10ab8:	e5d5e002 	ldrb	lr, [r5, #2]
   10abc:	e280000c 	add	r0, r0, #12	; 0xc
   10ac0:	e5d52004 	ldrb	r2, [r5, #4]
   10ac4:	e5d53000 	ldrb	r3, [r5]
   10ac8:	e0850000 	add	r0, r5, r0
   10acc:	e1a0100c 	mov	r1, ip
   10ad0:	e88d5000 	stmia	sp, {ip, lr}
   10ad4:	eb001120 	bl	14f5c <LCDPrintString>
   10ad8:	e28dd008 	add	sp, sp, #8	; 0x8
   10adc:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   10ae0:	e12fff1e 	bx	lr
   10ae4:	e002c000 	and	ip, r2, r0

00010ae8 <handleDownButton>:
   10ae8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   10aec:	e5d03000 	ldrb	r3, [r0]
   10af0:	e353000e 	cmp	r3, #14	; 0xe
   10af4:	e1a05001 	mov	r5, r1
   10af8:	e1a04000 	mov	r4, r0
   10afc:	e3a01000 	mov	r1, #0	; 0x0
   10b00:	8a000001 	bhi	10b0c <handleDownButton+0x24>
   10b04:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   10b08:	eaffffbd 	b	10a04 <highlightRow>
   10b0c:	e353000f 	cmp	r3, #15	; 0xf
   10b10:	1a000010 	bne	10b58 <handleDownButton+0x70>
   10b14:	e5d03006 	ldrb	r3, [r0, #6]
   10b18:	e5d02005 	ldrb	r2, [r0, #5]
   10b1c:	e1520003 	cmp	r2, r3
   10b20:	e2831001 	add	r1, r3, #1	; 0x1
   10b24:	9a00000b 	bls	10b58 <handleDownButton+0x70>
   10b28:	e5c01006 	strb	r1, [r0, #6]
   10b2c:	ebffff4c 	bl	10864 <quickClear>
   10b30:	e3a03001 	mov	r3, #1	; 0x1
   10b34:	e5c43000 	strb	r3, [r4]
   10b38:	e3a03000 	mov	r3, #0	; 0x0
   10b3c:	e5843008 	str	r3, [r4, #8]
   10b40:	e1a01005 	mov	r1, r5
   10b44:	e59f0014 	ldr	r0, [pc, #20]	; 10b60 <.text+0xb60>
   10b48:	ebfffd9b 	bl	101bc <getNewFiles>
   10b4c:	e1a00004 	mov	r0, r4
   10b50:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   10b54:	eaffff76 	b	10934 <printMenu>
   10b58:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   10b5c:	e12fff1e 	bx	lr
   10b60:	400010e0 	andmi	r1, r0, r0, ror #1

00010b64 <handleUpButton>:
   10b64:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   10b68:	e5d03000 	ldrb	r3, [r0]
   10b6c:	e3530001 	cmp	r3, #1	; 0x1
   10b70:	e1a05001 	mov	r5, r1
   10b74:	e1a04000 	mov	r4, r0
   10b78:	e3a01001 	mov	r1, #1	; 0x1
   10b7c:	9a000001 	bls	10b88 <handleUpButton+0x24>
   10b80:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   10b84:	eaffff9e 	b	10a04 <highlightRow>
   10b88:	1a00000f 	bne	10bcc <handleUpButton+0x68>
   10b8c:	e5d03006 	ldrb	r3, [r0, #6]
   10b90:	e3530000 	cmp	r3, #0	; 0x0
   10b94:	e2432001 	sub	r2, r3, #1	; 0x1
   10b98:	0a00000b 	beq	10bcc <handleUpButton+0x68>
   10b9c:	e5c02006 	strb	r2, [r0, #6]
   10ba0:	ebffff2f 	bl	10864 <quickClear>
   10ba4:	e3a0300f 	mov	r3, #15	; 0xf
   10ba8:	e5c43000 	strb	r3, [r4]
   10bac:	e3a0300e 	mov	r3, #14	; 0xe
   10bb0:	e5843008 	str	r3, [r4, #8]
   10bb4:	e1a01005 	mov	r1, r5
   10bb8:	e59f0014 	ldr	r0, [pc, #20]	; 10bd4 <.text+0xbd4>
   10bbc:	ebfffd7e 	bl	101bc <getNewFiles>
   10bc0:	e1a00004 	mov	r0, r4
   10bc4:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   10bc8:	eaffff59 	b	10934 <printMenu>
   10bcc:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   10bd0:	e12fff1e 	bx	lr
   10bd4:	400010e0 	andmi	r1, r0, r0, ror #1

00010bd8 <handleMiddleButton>:
   10bd8:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10bdc:	e59f577c 	ldr	r5, [pc, #1916]	; 11360 <.text+0x1360>
   10be0:	e3a03010 	mov	r3, #16	; 0x10
   10be4:	e59f8778 	ldr	r8, [pc, #1912]	; 11364 <.text+0x1364>
   10be8:	e5853000 	str	r3, [r5]
   10bec:	e24dd008 	sub	sp, sp, #8	; 0x8
   10bf0:	e3a000fa 	mov	r0, #250	; 0xfa
   10bf4:	ebfffd66 	bl	10194 <delay_ms>
   10bf8:	e5986000 	ldr	r6, [r8]
   10bfc:	e59f3764 	ldr	r3, [pc, #1892]	; 11368 <.text+0x1368>
   10c00:	e1560003 	cmp	r6, r3
   10c04:	e59f4760 	ldr	r4, [pc, #1888]	; 1136c <.text+0x136c>
   10c08:	1a000066 	bne	10da8 <handleMiddleButton+0x1d0>
   10c0c:	e5d47000 	ldrb	r7, [r4]
   10c10:	e3570000 	cmp	r7, #0	; 0x0
   10c14:	1a000044 	bne	10d2c <handleMiddleButton+0x154>
   10c18:	e59f0750 	ldr	r0, [pc, #1872]	; 11370 <.text+0x1370>
   10c1c:	e1a01006 	mov	r1, r6
   10c20:	ebfffeca 	bl	10750 <loadSongInfo>
   10c24:	e3500000 	cmp	r0, #0	; 0x0
   10c28:	e1a05000 	mov	r5, r0
   10c2c:	e5c40000 	strb	r0, [r4]
   10c30:	1a000012 	bne	10c80 <handleMiddleButton+0xa8>
   10c34:	e59f3738 	ldr	r3, [pc, #1848]	; 11374 <.text+0x1374>
   10c38:	e5d30000 	ldrb	r0, [r3]
   10c3c:	eb000f95 	bl	14a98 <LCDClear>
   10c40:	e58d5000 	str	r5, [sp]
   10c44:	e5983000 	ldr	r3, [r8]
   10c48:	e59f4728 	ldr	r4, [pc, #1832]	; 11378 <.text+0x1378>
   10c4c:	e5d3c002 	ldrb	ip, [r3, #2]
   10c50:	e5d42000 	ldrb	r2, [r4]
   10c54:	e1a01005 	mov	r1, r5
   10c58:	e3a03001 	mov	r3, #1	; 0x1
   10c5c:	e59f0718 	ldr	r0, [pc, #1816]	; 1137c <.text+0x137c>
   10c60:	e58dc004 	str	ip, [sp, #4]
   10c64:	eb0010bc 	bl	14f5c <LCDPrintString>
   10c68:	e3a00ffa 	mov	r0, #1000	; 0x3e8
   10c6c:	ebfffd48 	bl	10194 <delay_ms>
   10c70:	e5d40000 	ldrb	r0, [r4]
   10c74:	eb000f87 	bl	14a98 <LCDClear>
   10c78:	e1a00006 	mov	r0, r6
   10c7c:	ea0001af 	b	11340 <handleMiddleButton+0x768>
   10c80:	eb0011c4 	bl	15398 <vs1002Config>
   10c84:	e1a00007 	mov	r0, r7
   10c88:	e3a01b02 	mov	r1, #2048	; 0x800
   10c8c:	eb0011d2 	bl	153dc <vs1002SCIWrite>
   10c90:	eb0011ca 	bl	153c0 <vs1002Finish>
   10c94:	e59f36e4 	ldr	r3, [pc, #1764]	; 11380 <.text+0x1380>
   10c98:	e3a02202 	mov	r2, #536870912	; 0x20000000
   10c9c:	e5832000 	str	r2, [r3]
   10ca0:	eb0011bc 	bl	15398 <vs1002Config>
   10ca4:	ea00000b 	b	10cd8 <handleMiddleButton+0x100>
   10ca8:	eb00123d 	bl	155a4 <vs1002SendMusic>
   10cac:	e59f36bc 	ldr	r3, [pc, #1724]	; 11370 <.text+0x1370>
   10cb0:	e3a02020 	mov	r2, #32	; 0x20
   10cb4:	e283103d 	add	r1, r3, #61	; 0x3d
   10cb8:	e5930034 	ldr	r0, [r3, #52]
   10cbc:	eb000b71 	bl	13a88 <fat16_read_file>
   10cc0:	e1a00800 	mov	r0, r0, lsl #16
   10cc4:	e3500000 	cmp	r0, #0	; 0x0
   10cc8:	e59f26b4 	ldr	r2, [pc, #1716]	; 11384 <.text+0x1384>
   10ccc:	d3a03001 	movle	r3, #1	; 0x1
   10cd0:	c3a03000 	movgt	r3, #0	; 0x0
   10cd4:	e5c23000 	strb	r3, [r2]
   10cd8:	e59f36a8 	ldr	r3, [pc, #1704]	; 11388 <.text+0x1388>
   10cdc:	e5933000 	ldr	r3, [r3]
   10ce0:	e3130602 	tst	r3, #2097152	; 0x200000
   10ce4:	e59f06a0 	ldr	r0, [pc, #1696]	; 1138c <.text+0x138c>
   10ce8:	e3a01020 	mov	r1, #32	; 0x20
   10cec:	1affffed 	bne	10ca8 <handleMiddleButton+0xd0>
   10cf0:	eb0011b2 	bl	153c0 <vs1002Finish>
   10cf4:	e59f2694 	ldr	r2, [pc, #1684]	; 11390 <.text+0x1390>
   10cf8:	e5923000 	ldr	r3, [r2]
   10cfc:	e3833b03 	orr	r3, r3, #3072	; 0xc00
   10d00:	e5823000 	str	r3, [r2]
   10d04:	e59f2688 	ldr	r2, [pc, #1672]	; 11394 <.text+0x1394>
   10d08:	e5923000 	ldr	r3, [r2]
   10d0c:	e3833020 	orr	r3, r3, #32	; 0x20
   10d10:	e5823000 	str	r3, [r2]
   10d14:	e59f267c 	ldr	r2, [pc, #1660]	; 11398 <.text+0x1398>
   10d18:	e5923000 	ldr	r3, [r2]
   10d1c:	e3833703 	orr	r3, r3, #786432	; 0xc0000
   10d20:	e3833050 	orr	r3, r3, #80	; 0x50
   10d24:	e5823000 	str	r3, [r2]
   10d28:	ea000185 	b	11344 <handleMiddleButton+0x76c>
   10d2c:	e3a03020 	mov	r3, #32	; 0x20
   10d30:	e5853000 	str	r3, [r5]
   10d34:	e59f3660 	ldr	r3, [pc, #1632]	; 1139c <.text+0x139c>
   10d38:	e3a02202 	mov	r2, #536870912	; 0x20000000
   10d3c:	e5832000 	str	r2, [r3]
   10d40:	eb001194 	bl	15398 <vs1002Config>
   10d44:	e3a00000 	mov	r0, #0	; 0x0
   10d48:	e3a01008 	mov	r1, #8	; 0x8
   10d4c:	eb0011a2 	bl	153dc <vs1002SCIWrite>
   10d50:	e3a04000 	mov	r4, #0	; 0x0
   10d54:	e3a00000 	mov	r0, #0	; 0x0
   10d58:	e2844001 	add	r4, r4, #1	; 0x1
   10d5c:	e1a01000 	mov	r1, r0
   10d60:	eb00119d 	bl	153dc <vs1002SCIWrite>
   10d64:	e3540096 	cmp	r4, #150	; 0x96
   10d68:	1afffff9 	bne	10d54 <handleMiddleButton+0x17c>
   10d6c:	eb001193 	bl	153c0 <vs1002Finish>
   10d70:	e59f2620 	ldr	r2, [pc, #1568]	; 11398 <.text+0x1398>
   10d74:	e5923000 	ldr	r3, [r2]
   10d78:	e3833703 	orr	r3, r3, #786432	; 0xc0000
   10d7c:	e3833050 	orr	r3, r3, #80	; 0x50
   10d80:	e5823000 	str	r3, [r2]
   10d84:	e59f05e4 	ldr	r0, [pc, #1508]	; 11370 <.text+0x1370>
   10d88:	ebfffea7 	bl	1082c <closeSong>
   10d8c:	e59f35d8 	ldr	r3, [pc, #1496]	; 1136c <.text+0x136c>
   10d90:	e3a02000 	mov	r2, #0	; 0x0
   10d94:	e5c32000 	strb	r2, [r3]
   10d98:	e59f35f4 	ldr	r3, [pc, #1524]	; 11394 <.text+0x1394>
   10d9c:	e2822010 	add	r2, r2, #16	; 0x10
   10da0:	e5832000 	str	r2, [r3]
   10da4:	ea000166 	b	11344 <handleMiddleButton+0x76c>
   10da8:	e5d43000 	ldrb	r3, [r4]
   10dac:	e3530000 	cmp	r3, #0	; 0x0
   10db0:	0a000002 	beq	10dc0 <handleMiddleButton+0x1e8>
   10db4:	e1a00006 	mov	r0, r6
   10db8:	ebfffea9 	bl	10864 <quickClear>
   10dbc:	ea000002 	b	10dcc <handleMiddleButton+0x1f4>
   10dc0:	e59f35d8 	ldr	r3, [pc, #1496]	; 113a0 <.text+0x13a0>
   10dc4:	e5d30004 	ldrb	r0, [r3, #4]
   10dc8:	eb000f32 	bl	14a98 <LCDClear>
   10dcc:	e59f7590 	ldr	r7, [pc, #1424]	; 11364 <.text+0x1364>
   10dd0:	e5973000 	ldr	r3, [r7]
   10dd4:	e3a05000 	mov	r5, #0	; 0x0
   10dd8:	e5930008 	ldr	r0, [r3, #8]
   10ddc:	e5d32003 	ldrb	r2, [r3, #3]
   10de0:	e58d5000 	str	r5, [sp]
   10de4:	e1a00280 	mov	r0, r0, lsl #5
   10de8:	e5d3c002 	ldrb	ip, [r3, #2]
   10dec:	e59f65a0 	ldr	r6, [pc, #1440]	; 11394 <.text+0x1394>
   10df0:	e280000c 	add	r0, r0, #12	; 0xc
   10df4:	e0830000 	add	r0, r3, r0
   10df8:	e1a01005 	mov	r1, r5
   10dfc:	e3a03001 	mov	r3, #1	; 0x1
   10e00:	e58dc004 	str	ip, [sp, #4]
   10e04:	eb001054 	bl	14f5c <LCDPrintString>
   10e08:	e5963000 	ldr	r3, [r6]
   10e0c:	e3833010 	orr	r3, r3, #16	; 0x10
   10e10:	e5863000 	str	r3, [r6]
   10e14:	e5972000 	ldr	r2, [r7]
   10e18:	e5d24000 	ldrb	r4, [r2]
   10e1c:	e3540001 	cmp	r4, #1	; 0x1
   10e20:	1a00005c 	bne	10f98 <handleMiddleButton+0x3c0>
   10e24:	e5963000 	ldr	r3, [r6]
   10e28:	e3833010 	orr	r3, r3, #16	; 0x10
   10e2c:	e5863000 	str	r3, [r6]
   10e30:	e1a01005 	mov	r1, r5
   10e34:	e5d23002 	ldrb	r3, [r2, #2]
   10e38:	e3a00002 	mov	r0, #2	; 0x2
   10e3c:	e5d22004 	ldrb	r2, [r2, #4]
   10e40:	eb00111f 	bl	152c4 <LCDSetRowColor>
   10e44:	e58d5000 	str	r5, [sp]
   10e48:	e59f3524 	ldr	r3, [pc, #1316]	; 11374 <.text+0x1374>
   10e4c:	e5971000 	ldr	r1, [r7]
   10e50:	e5d32000 	ldrb	r2, [r3]
   10e54:	e59f3548 	ldr	r3, [pc, #1352]	; 113a4 <.text+0x13a4>
   10e58:	e5d1c002 	ldrb	ip, [r1, #2]
   10e5c:	e59f0544 	ldr	r0, [pc, #1348]	; 113a8 <.text+0x13a8>
   10e60:	e5931000 	ldr	r1, [r3]
   10e64:	e3a03002 	mov	r3, #2	; 0x2
   10e68:	e58dc004 	str	ip, [sp, #4]
   10e6c:	eb00103a 	bl	14f5c <LCDPrintString>
   10e70:	ea000040 	b	10f78 <handleMiddleButton+0x3a0>
   10e74:	e59f34e4 	ldr	r3, [pc, #1252]	; 11360 <.text+0x1360>
   10e78:	e3a02010 	mov	r2, #16	; 0x10
   10e7c:	e5832000 	str	r2, [r3]
   10e80:	ebfffcc3 	bl	10194 <delay_ms>
   10e84:	e5d44000 	ldrb	r4, [r4]
   10e88:	e3540002 	cmp	r4, #2	; 0x2
   10e8c:	1a000017 	bne	10ef0 <handleMiddleButton+0x318>
   10e90:	e5953000 	ldr	r3, [r5]
   10e94:	e353001f 	cmp	r3, #31	; 0x1f
   10e98:	e2832001 	add	r2, r3, #1	; 0x1
   10e9c:	ca000004 	bgt	10eb4 <handleMiddleButton+0x2dc>
   10ea0:	e5852000 	str	r2, [r5]
   10ea4:	eb00113b 	bl	15398 <vs1002Config>
   10ea8:	e3a00031 	mov	r0, #49	; 0x31
   10eac:	eb0011a6 	bl	1554c <vs1002SetVolume>
   10eb0:	eb001142 	bl	153c0 <vs1002Finish>
   10eb4:	e5962000 	ldr	r2, [r6]
   10eb8:	e1a00004 	mov	r0, r4
   10ebc:	e5d23002 	ldrb	r3, [r2, #2]
   10ec0:	e3a01000 	mov	r1, #0	; 0x0
   10ec4:	e5d22004 	ldrb	r2, [r2, #4]
   10ec8:	eb0010fd 	bl	152c4 <LCDSetRowColor>
   10ecc:	e5961000 	ldr	r1, [r6]
   10ed0:	e3a03000 	mov	r3, #0	; 0x0
   10ed4:	e5d12003 	ldrb	r2, [r1, #3]
   10ed8:	e58d3000 	str	r3, [sp]
   10edc:	e59f04c4 	ldr	r0, [pc, #1220]	; 113a8 <.text+0x13a8>
   10ee0:	e5d1c002 	ldrb	ip, [r1, #2]
   10ee4:	e5951000 	ldr	r1, [r5]
   10ee8:	e1a03004 	mov	r3, r4
   10eec:	ea00001b 	b	10f60 <handleMiddleButton+0x388>
   10ef0:	e3540001 	cmp	r4, #1	; 0x1
   10ef4:	e59f6468 	ldr	r6, [pc, #1128]	; 11364 <.text+0x1364>
   10ef8:	e59f54a4 	ldr	r5, [pc, #1188]	; 113a4 <.text+0x13a4>
   10efc:	1a000019 	bne	10f68 <handleMiddleButton+0x390>
   10f00:	e5953000 	ldr	r3, [r5]
   10f04:	e3530000 	cmp	r3, #0	; 0x0
   10f08:	e2432001 	sub	r2, r3, #1	; 0x1
   10f0c:	ba000004 	blt	10f24 <handleMiddleButton+0x34c>
   10f10:	e5852000 	str	r2, [r5]
   10f14:	eb00111f 	bl	15398 <vs1002Config>
   10f18:	e3a00030 	mov	r0, #48	; 0x30
   10f1c:	eb00118a 	bl	1554c <vs1002SetVolume>
   10f20:	eb001126 	bl	153c0 <vs1002Finish>
   10f24:	e5962000 	ldr	r2, [r6]
   10f28:	e3a00002 	mov	r0, #2	; 0x2
   10f2c:	e5d23002 	ldrb	r3, [r2, #2]
   10f30:	e3a01000 	mov	r1, #0	; 0x0
   10f34:	e5d22004 	ldrb	r2, [r2, #4]
   10f38:	eb0010e1 	bl	152c4 <LCDSetRowColor>
   10f3c:	e3a03000 	mov	r3, #0	; 0x0
   10f40:	e58d3000 	str	r3, [sp]
   10f44:	e5961000 	ldr	r1, [r6]
   10f48:	e59f3424 	ldr	r3, [pc, #1060]	; 11374 <.text+0x1374>
   10f4c:	e5d1c002 	ldrb	ip, [r1, #2]
   10f50:	e59f0450 	ldr	r0, [pc, #1104]	; 113a8 <.text+0x13a8>
   10f54:	e5951000 	ldr	r1, [r5]
   10f58:	e5d32000 	ldrb	r2, [r3]
   10f5c:	e3a03002 	mov	r3, #2	; 0x2
   10f60:	e58dc004 	str	ip, [sp, #4]
   10f64:	eb000ffc 	bl	14f5c <LCDPrintString>
   10f68:	e59f2424 	ldr	r2, [pc, #1060]	; 11394 <.text+0x1394>
   10f6c:	e5923000 	ldr	r3, [r2]
   10f70:	e3833010 	orr	r3, r3, #16	; 0x10
   10f74:	e5823000 	str	r3, [r2]
   10f78:	e59f442c 	ldr	r4, [pc, #1068]	; 113ac <.text+0x13ac>
   10f7c:	e5d43000 	ldrb	r3, [r4]
   10f80:	e3530002 	cmp	r3, #2	; 0x2
   10f84:	e59f63d8 	ldr	r6, [pc, #984]	; 11364 <.text+0x1364>
   10f88:	e59f5414 	ldr	r5, [pc, #1044]	; 113a4 <.text+0x13a4>
   10f8c:	e3a00096 	mov	r0, #150	; 0x96
   10f90:	9affffb7 	bls	10e74 <handleMiddleButton+0x29c>
   10f94:	ea0000dc 	b	1130c <handleMiddleButton+0x734>
   10f98:	e3540003 	cmp	r4, #3	; 0x3
   10f9c:	1a000066 	bne	1113c <handleMiddleButton+0x564>
   10fa0:	e5d23002 	ldrb	r3, [r2, #2]
   10fa4:	e3a00002 	mov	r0, #2	; 0x2
   10fa8:	e3a01000 	mov	r1, #0	; 0x0
   10fac:	e5d22004 	ldrb	r2, [r2, #4]
   10fb0:	eb0010c3 	bl	152c4 <LCDSetRowColor>
   10fb4:	e58d5000 	str	r5, [sp]
   10fb8:	e59f33b4 	ldr	r3, [pc, #948]	; 11374 <.text+0x1374>
   10fbc:	e5971000 	ldr	r1, [r7]
   10fc0:	e5d32000 	ldrb	r2, [r3]
   10fc4:	e59f33e4 	ldr	r3, [pc, #996]	; 113b0 <.text+0x13b0>
   10fc8:	e5d1c002 	ldrb	ip, [r1, #2]
   10fcc:	e59f03d4 	ldr	r0, [pc, #980]	; 113a8 <.text+0x13a8>
   10fd0:	e5931000 	ldr	r1, [r3]
   10fd4:	e3a03002 	mov	r3, #2	; 0x2
   10fd8:	e58dc004 	str	ip, [sp, #4]
   10fdc:	eb000fde 	bl	14f5c <LCDPrintString>
   10fe0:	e5963000 	ldr	r3, [r6]
   10fe4:	e59f23c0 	ldr	r2, [pc, #960]	; 113ac <.text+0x13ac>
   10fe8:	e3833010 	orr	r3, r3, #16	; 0x10
   10fec:	e5c25000 	strb	r5, [r2]
   10ff0:	e5863000 	str	r3, [r6]
   10ff4:	ea00003c 	b	110ec <handleMiddleButton+0x514>
   10ff8:	e59f3360 	ldr	r3, [pc, #864]	; 11360 <.text+0x1360>
   10ffc:	e3a02010 	mov	r2, #16	; 0x10
   11000:	e5832000 	str	r2, [r3]
   11004:	ebfffc62 	bl	10194 <delay_ms>
   11008:	e5d44000 	ldrb	r4, [r4]
   1100c:	e3540002 	cmp	r4, #2	; 0x2
   11010:	e3a01000 	mov	r1, #0	; 0x0
   11014:	e1a00004 	mov	r0, r4
   11018:	1a000012 	bne	11068 <handleMiddleButton+0x490>
   1101c:	e5952000 	ldr	r2, [r5]
   11020:	e59f338c 	ldr	r3, [pc, #908]	; 113b4 <.text+0x13b4>
   11024:	e1520003 	cmp	r2, r3
   11028:	e2822002 	add	r2, r2, #2	; 0x2
   1102c:	e596c000 	ldr	ip, [r6]
   11030:	d5852000 	strle	r2, [r5]
   11034:	e5dc3002 	ldrb	r3, [ip, #2]
   11038:	e5dc2004 	ldrb	r2, [ip, #4]
   1103c:	eb0010a0 	bl	152c4 <LCDSetRowColor>
   11040:	e3a03000 	mov	r3, #0	; 0x0
   11044:	e58d3000 	str	r3, [sp]
   11048:	e59f3324 	ldr	r3, [pc, #804]	; 11374 <.text+0x1374>
   1104c:	e5961000 	ldr	r1, [r6]
   11050:	e5d32000 	ldrb	r2, [r3]
   11054:	e5d1c002 	ldrb	ip, [r1, #2]
   11058:	e59f0348 	ldr	r0, [pc, #840]	; 113a8 <.text+0x13a8>
   1105c:	e5951000 	ldr	r1, [r5]
   11060:	e1a03004 	mov	r3, r4
   11064:	ea000017 	b	110c8 <handleMiddleButton+0x4f0>
   11068:	e3540001 	cmp	r4, #1	; 0x1
   1106c:	e59f62f0 	ldr	r6, [pc, #752]	; 11364 <.text+0x1364>
   11070:	e3a00002 	mov	r0, #2	; 0x2
   11074:	e3a01000 	mov	r1, #0	; 0x0
   11078:	e59f5330 	ldr	r5, [pc, #816]	; 113b0 <.text+0x13b0>
   1107c:	1a000013 	bne	110d0 <handleMiddleButton+0x4f8>
   11080:	e5952000 	ldr	r2, [r5]
   11084:	e59f332c 	ldr	r3, [pc, #812]	; 113b8 <.text+0x13b8>
   11088:	e1520003 	cmp	r2, r3
   1108c:	e2422002 	sub	r2, r2, #2	; 0x2
   11090:	e596c000 	ldr	ip, [r6]
   11094:	c5852000 	strgt	r2, [r5]
   11098:	e5dc3002 	ldrb	r3, [ip, #2]
   1109c:	e5dc2004 	ldrb	r2, [ip, #4]
   110a0:	eb001087 	bl	152c4 <LCDSetRowColor>
   110a4:	e3a03000 	mov	r3, #0	; 0x0
   110a8:	e58d3000 	str	r3, [sp]
   110ac:	e5961000 	ldr	r1, [r6]
   110b0:	e59f32bc 	ldr	r3, [pc, #700]	; 11374 <.text+0x1374>
   110b4:	e5d1c002 	ldrb	ip, [r1, #2]
   110b8:	e59f02e8 	ldr	r0, [pc, #744]	; 113a8 <.text+0x13a8>
   110bc:	e5951000 	ldr	r1, [r5]
   110c0:	e5d32000 	ldrb	r2, [r3]
   110c4:	e3a03002 	mov	r3, #2	; 0x2
   110c8:	e58dc004 	str	ip, [sp, #4]
   110cc:	eb000fa2 	bl	14f5c <LCDPrintString>
   110d0:	e59f32d8 	ldr	r3, [pc, #728]	; 113b0 <.text+0x13b0>
   110d4:	e5930000 	ldr	r0, [r3]
   110d8:	eb001210 	bl	15920 <ns73SetChannel>
   110dc:	e59f22b0 	ldr	r2, [pc, #688]	; 11394 <.text+0x1394>
   110e0:	e5923000 	ldr	r3, [r2]
   110e4:	e3833010 	orr	r3, r3, #16	; 0x10
   110e8:	e5823000 	str	r3, [r2]
   110ec:	e59f42b8 	ldr	r4, [pc, #696]	; 113ac <.text+0x13ac>
   110f0:	e5d43000 	ldrb	r3, [r4]
   110f4:	e3530002 	cmp	r3, #2	; 0x2
   110f8:	e59f6264 	ldr	r6, [pc, #612]	; 11364 <.text+0x1364>
   110fc:	e59f52ac 	ldr	r5, [pc, #684]	; 113b0 <.text+0x13b0>
   11100:	e3a00064 	mov	r0, #100	; 0x64
   11104:	9affffbb 	bls	10ff8 <handleMiddleButton+0x420>
   11108:	e59f22ac 	ldr	r2, [pc, #684]	; 113bc <.text+0x13bc>
   1110c:	e5923000 	ldr	r3, [r2]
   11110:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   11114:	e5823000 	str	r3, [r2]
   11118:	ebfffc1d 	bl	10194 <delay_ms>
   1111c:	eb001143 	bl	15630 <ns73Config>
   11120:	e5950000 	ldr	r0, [r5]
   11124:	eb0011fd 	bl	15920 <ns73SetChannel>
   11128:	e59f2290 	ldr	r2, [pc, #656]	; 113c0 <.text+0x13c0>
   1112c:	e5923000 	ldr	r3, [r2]
   11130:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   11134:	e5823000 	str	r3, [r2]
   11138:	ea000073 	b	1130c <handleMiddleButton+0x734>
   1113c:	e3540002 	cmp	r4, #2	; 0x2
   11140:	1a000071 	bne	1130c <handleMiddleButton+0x734>
   11144:	e5d23002 	ldrb	r3, [r2, #2]
   11148:	e3a01000 	mov	r1, #0	; 0x0
   1114c:	e1a00004 	mov	r0, r4
   11150:	e5d22004 	ldrb	r2, [r2, #4]
   11154:	eb00105a 	bl	152c4 <LCDSetRowColor>
   11158:	e59f3264 	ldr	r3, [pc, #612]	; 113c4 <.text+0x13c4>
   1115c:	e5d33000 	ldrb	r3, [r3]
   11160:	e3530000 	cmp	r3, #0	; 0x0
   11164:	e5971000 	ldr	r1, [r7]
   11168:	0a000006 	beq	11188 <handleMiddleButton+0x5b0>
   1116c:	e5d12003 	ldrb	r2, [r1, #3]
   11170:	e58d5000 	str	r5, [sp]
   11174:	e59f024c 	ldr	r0, [pc, #588]	; 113c8 <.text+0x13c8>
   11178:	e5d1c002 	ldrb	ip, [r1, #2]
   1117c:	e1a03004 	mov	r3, r4
   11180:	e1a01005 	mov	r1, r5
   11184:	ea000005 	b	111a0 <handleMiddleButton+0x5c8>
   11188:	e5d12003 	ldrb	r2, [r1, #3]
   1118c:	e58d3000 	str	r3, [sp]
   11190:	e59f0234 	ldr	r0, [pc, #564]	; 113cc <.text+0x13cc>
   11194:	e5d1c002 	ldrb	ip, [r1, #2]
   11198:	e1a01003 	mov	r1, r3
   1119c:	e1a03004 	mov	r3, r4
   111a0:	e58dc004 	str	ip, [sp, #4]
   111a4:	eb000f6c 	bl	14f5c <LCDPrintString>
   111a8:	e59f01e4 	ldr	r0, [pc, #484]	; 11394 <.text+0x1394>
   111ac:	e5902000 	ldr	r2, [r0]
   111b0:	e59f31f4 	ldr	r3, [pc, #500]	; 113ac <.text+0x13ac>
   111b4:	e3822010 	orr	r2, r2, #16	; 0x10
   111b8:	e3a01000 	mov	r1, #0	; 0x0
   111bc:	e5c31000 	strb	r1, [r3]
   111c0:	e5802000 	str	r2, [r0]
   111c4:	ea000049 	b	112f0 <handleMiddleButton+0x718>
   111c8:	e59f3190 	ldr	r3, [pc, #400]	; 11360 <.text+0x1360>
   111cc:	e3a02010 	mov	r2, #16	; 0x10
   111d0:	e5832000 	str	r2, [r3]
   111d4:	ebfffbee 	bl	10194 <delay_ms>
   111d8:	e5d44000 	ldrb	r4, [r4]
   111dc:	e3540002 	cmp	r4, #2	; 0x2
   111e0:	e3a01000 	mov	r1, #0	; 0x0
   111e4:	e1a00004 	mov	r0, r4
   111e8:	1a000019 	bne	11254 <handleMiddleButton+0x67c>
   111ec:	e59f31d0 	ldr	r3, [pc, #464]	; 113c4 <.text+0x13c4>
   111f0:	e3a02001 	mov	r2, #1	; 0x1
   111f4:	e5c32000 	strb	r2, [r3]
   111f8:	e5962000 	ldr	r2, [r6]
   111fc:	e5d23002 	ldrb	r3, [r2, #2]
   11200:	e5d22004 	ldrb	r2, [r2, #4]
   11204:	eb00102e 	bl	152c4 <LCDSetRowColor>
   11208:	e5963000 	ldr	r3, [r6]
   1120c:	e5d32003 	ldrb	r2, [r3, #3]
   11210:	e58d5000 	str	r5, [sp]
   11214:	e5d3c002 	ldrb	ip, [r3, #2]
   11218:	e1a01005 	mov	r1, r5
   1121c:	e1a03004 	mov	r3, r4
   11220:	e59f01a0 	ldr	r0, [pc, #416]	; 113c8 <.text+0x13c8>
   11224:	e58dc004 	str	ip, [sp, #4]
   11228:	eb000f4b 	bl	14f5c <LCDPrintString>
   1122c:	e59f2188 	ldr	r2, [pc, #392]	; 113bc <.text+0x13bc>
   11230:	e5923000 	ldr	r3, [r2]
   11234:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   11238:	e3a00064 	mov	r0, #100	; 0x64
   1123c:	e5823000 	str	r3, [r2]
   11240:	ebfffbd3 	bl	10194 <delay_ms>
   11244:	eb0010f9 	bl	15630 <ns73Config>
   11248:	e1a00005 	mov	r0, r5
   1124c:	e3a01081 	mov	r1, #129	; 0x81
   11250:	ea00001d 	b	112cc <handleMiddleButton+0x6f4>
   11254:	e3a05000 	mov	r5, #0	; 0x0
   11258:	e3540001 	cmp	r4, #1	; 0x1
   1125c:	e59f6100 	ldr	r6, [pc, #256]	; 11364 <.text+0x1364>
   11260:	e3a00002 	mov	r0, #2	; 0x2
   11264:	e1a01005 	mov	r1, r5
   11268:	1a00001c 	bne	112e0 <handleMiddleButton+0x708>
   1126c:	e59f3150 	ldr	r3, [pc, #336]	; 113c4 <.text+0x13c4>
   11270:	e5962000 	ldr	r2, [r6]
   11274:	e5c35000 	strb	r5, [r3]
   11278:	e5d23002 	ldrb	r3, [r2, #2]
   1127c:	e5d22004 	ldrb	r2, [r2, #4]
   11280:	eb00100f 	bl	152c4 <LCDSetRowColor>
   11284:	e5963000 	ldr	r3, [r6]
   11288:	e5d32003 	ldrb	r2, [r3, #3]
   1128c:	e58d5000 	str	r5, [sp]
   11290:	e5d3c002 	ldrb	ip, [r3, #2]
   11294:	e1a01005 	mov	r1, r5
   11298:	e3a03002 	mov	r3, #2	; 0x2
   1129c:	e59f0128 	ldr	r0, [pc, #296]	; 113cc <.text+0x13cc>
   112a0:	e58dc004 	str	ip, [sp, #4]
   112a4:	eb000f2c 	bl	14f5c <LCDPrintString>
   112a8:	e59f210c 	ldr	r2, [pc, #268]	; 113bc <.text+0x13bc>
   112ac:	e5923000 	ldr	r3, [r2]
   112b0:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   112b4:	e3a00064 	mov	r0, #100	; 0x64
   112b8:	e5823000 	str	r3, [r2]
   112bc:	ebfffbb4 	bl	10194 <delay_ms>
   112c0:	eb0010da 	bl	15630 <ns73Config>
   112c4:	e1a00005 	mov	r0, r5
   112c8:	e3a01004 	mov	r1, #4	; 0x4
   112cc:	eb0010ea 	bl	1567c <ns73Send>
   112d0:	e59f20e8 	ldr	r2, [pc, #232]	; 113c0 <.text+0x13c0>
   112d4:	e5923000 	ldr	r3, [r2]
   112d8:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   112dc:	e5823000 	str	r3, [r2]
   112e0:	e59f20ac 	ldr	r2, [pc, #172]	; 11394 <.text+0x1394>
   112e4:	e5923000 	ldr	r3, [r2]
   112e8:	e3833010 	orr	r3, r3, #16	; 0x10
   112ec:	e5823000 	str	r3, [r2]
   112f0:	e59f40b4 	ldr	r4, [pc, #180]	; 113ac <.text+0x13ac>
   112f4:	e5d43000 	ldrb	r3, [r4]
   112f8:	e3530002 	cmp	r3, #2	; 0x2
   112fc:	e59f6060 	ldr	r6, [pc, #96]	; 11364 <.text+0x1364>
   11300:	e3a05000 	mov	r5, #0	; 0x0
   11304:	e3a00064 	mov	r0, #100	; 0x64
   11308:	9affffae 	bls	111c8 <handleMiddleButton+0x5f0>
   1130c:	e59f3058 	ldr	r3, [pc, #88]	; 1136c <.text+0x136c>
   11310:	e5d33000 	ldrb	r3, [r3]
   11314:	e3530000 	cmp	r3, #0	; 0x0
   11318:	e59f0044 	ldr	r0, [pc, #68]	; 11364 <.text+0x1364>
   1131c:	0a000002 	beq	1132c <handleMiddleButton+0x754>
   11320:	e5900000 	ldr	r0, [r0]
   11324:	ebfffd4e 	bl	10864 <quickClear>
   11328:	ea000002 	b	11338 <handleMiddleButton+0x760>
   1132c:	e5903000 	ldr	r3, [r0]
   11330:	e5d30004 	ldrb	r0, [r3, #4]
   11334:	eb000dd7 	bl	14a98 <LCDClear>
   11338:	e59f3024 	ldr	r3, [pc, #36]	; 11364 <.text+0x1364>
   1133c:	e5930000 	ldr	r0, [r3]
   11340:	ebfffd7b 	bl	10934 <printMenu>
   11344:	e59f2048 	ldr	r2, [pc, #72]	; 11394 <.text+0x1394>
   11348:	e5923000 	ldr	r3, [r2]
   1134c:	e3833010 	orr	r3, r3, #16	; 0x10
   11350:	e5823000 	str	r3, [r2]
   11354:	e28dd008 	add	sp, sp, #8	; 0x8
   11358:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   1135c:	e12fff1e 	bx	lr
   11360:	fffff014 	swinv	0x00fff014
   11364:	40000ed8 	ldrmid	r0, [r0], -r8
   11368:	400010e0 	andmi	r1, r0, r0, ror #1
   1136c:	40000ed2 	ldrmid	r0, [r0], -r2
   11370:	400012e4 	andmi	r1, r0, r4, ror #5
   11374:	4000000a 	andmi	r0, r0, sl
   11378:	40001564 	andmi	r1, r0, r4, ror #10
   1137c:	00018bf4 	streqd	r8, [r1], -r4
   11380:	e002800c 	and	r8, r2, ip
   11384:	40000ed1 	ldrmid	r0, [r0], -r1
   11388:	e0028000 	and	r8, r2, r0
   1138c:	40001321 	andmi	r1, r0, r1, lsr #6
   11390:	e002c004 	and	ip, r2, r4
   11394:	fffff010 	swinv	0x00fff010
   11398:	e0028008 	and	r8, r2, r8
   1139c:	e0028004 	and	r8, r2, r4
   113a0:	40000edc 	ldrmid	r0, [r0], -ip
   113a4:	40000004 	andmi	r0, r0, r4
   113a8:	00018c7c 	andeq	r8, r1, ip, ror ip
   113ac:	4000134d 	andmi	r1, r0, sp, asr #6
   113b0:	40000000 	andmi	r0, r0, r0
   113b4:	00000432 	andeq	r0, r0, r2, lsr r4
   113b8:	00000375 	andeq	r0, r0, r5, ror r3
   113bc:	e002801c 	and	r8, r2, ip, lsl r0
   113c0:	e0028014 	and	r8, r2, r4, lsl r0
   113c4:	40000ed0 	ldrmid	r0, [r0], -r0
   113c8:	00018c80 	andeq	r8, r1, r0, lsl #25
   113cc:	00018c84 	andeq	r8, r1, r4, lsl #25

000113d0 <main>:
   113d0:	e1a0c00d 	mov	ip, sp
   113d4:	e92dddf0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, fp, ip, lr, pc}
   113d8:	e24cb004 	sub	fp, ip, #4	; 0x4
   113dc:	e24dd008 	sub	sp, sp, #8	; 0x8
   113e0:	ebfffbef 	bl	103a4 <bootUp>
   113e4:	eb000feb 	bl	15398 <vs1002Config>
   113e8:	eb001081 	bl	155f4 <vs1002Reset>
   113ec:	eb001012 	bl	1543c <vs1002Init>
   113f0:	e3a04000 	mov	r4, #0	; 0x0
   113f4:	e3a00030 	mov	r0, #48	; 0x30
   113f8:	eb001053 	bl	1554c <vs1002SetVolume>
   113fc:	e2843001 	add	r3, r4, #1	; 0x1
   11400:	e20340ff 	and	r4, r3, #255	; 0xff
   11404:	e3540002 	cmp	r4, #2	; 0x2
   11408:	1afffff9 	bne	113f4 <main+0x24>
   1140c:	eb000feb 	bl	153c0 <vs1002Finish>
   11410:	eb000dbf 	bl	14b14 <LCDInit>
   11414:	e59f3520 	ldr	r3, [pc, #1312]	; 1193c <.text+0x193c>
   11418:	e5d30000 	ldrb	r0, [r3]
   1141c:	eb000d9d 	bl	14a98 <LCDClear>
   11420:	eb000eac 	bl	14ed8 <LCDPrintLogo>
   11424:	e59f2514 	ldr	r2, [pc, #1300]	; 11940 <.text+0x1940>
   11428:	e5923000 	ldr	r3, [r2]
   1142c:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   11430:	e5823000 	str	r3, [r2]
   11434:	e3a00fe1 	mov	r0, #900	; 0x384
   11438:	ebfffb55 	bl	10194 <delay_ms>
   1143c:	eb00107b 	bl	15630 <ns73Config>
   11440:	eb0010d5 	bl	1579c <ns73Init>
   11444:	e59f04f8 	ldr	r0, [pc, #1272]	; 11944 <.text+0x1944>
   11448:	eb001134 	bl	15920 <ns73SetChannel>
   1144c:	e59f24f4 	ldr	r2, [pc, #1268]	; 11948 <.text+0x1948>
   11450:	e5923000 	ldr	r3, [r2]
   11454:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   11458:	e5823000 	str	r3, [r2]
   1145c:	e3a00064 	mov	r0, #100	; 0x64
   11460:	ebfffb4b 	bl	10194 <delay_ms>
   11464:	e59f24e0 	ldr	r2, [pc, #1248]	; 1194c <.text+0x194c>
   11468:	e5923000 	ldr	r3, [r2]
   1146c:	e3833c15 	orr	r3, r3, #5376	; 0x1500
   11470:	e5823000 	str	r3, [r2]
   11474:	e3a04000 	mov	r4, #0	; 0x0
   11478:	e3a00000 	mov	r0, #0	; 0x0
   1147c:	eb000322 	bl	1210c <rootDirectory_files_stream>
   11480:	e3500000 	cmp	r0, #0	; 0x0
   11484:	e2845001 	add	r5, r4, #1	; 0x1
   11488:	11a04005 	movne	r4, r5
   1148c:	1afffff9 	bne	11478 <main+0xa8>
   11490:	e2853006 	add	r3, r5, #6	; 0x6
   11494:	e3c33003 	bic	r3, r3, #3	; 0x3
   11498:	e063d00d 	rsb	sp, r3, sp
   1149c:	e28da008 	add	sl, sp, #8	; 0x8
   114a0:	e2841002 	add	r1, r4, #2	; 0x2
   114a4:	e1a0000a 	mov	r0, sl
   114a8:	eb000338 	bl	12190 <rootDirectory_files>
   114ac:	e1a03280 	mov	r3, r0, lsl #5
   114b0:	e2833004 	add	r3, r3, #4	; 0x4
   114b4:	e063d00d 	rsb	sp, r3, sp
   114b8:	e3a0e000 	mov	lr, #0	; 0x0
   114bc:	e28d8008 	add	r8, sp, #8	; 0x8
   114c0:	e59f3488 	ldr	r3, [pc, #1160]	; 11950 <.text+0x1950>
   114c4:	e1a06000 	mov	r6, r0
   114c8:	e1a0700e 	mov	r7, lr
   114cc:	e1a0c008 	mov	ip, r8
   114d0:	e1a0400e 	mov	r4, lr
   114d4:	e5830000 	str	r0, [r3]
   114d8:	ea000013 	b	1152c <main+0x15c>
   114dc:	e3a02000 	mov	r2, #0	; 0x0
   114e0:	e1570005 	cmp	r7, r5
   114e4:	83a03000 	movhi	r3, #0	; 0x0
   114e8:	87cc3002 	strhib	r3, [ip, r2]
   114ec:	8a000008 	bhi	11514 <main+0x144>
   114f0:	e7da1007 	ldrb	r1, [sl, r7]
   114f4:	e0840008 	add	r0, r4, r8
   114f8:	e351002c 	cmp	r1, #44	; 0x2c
   114fc:	e1a03000 	mov	r3, r0
   11500:	17c31002 	strneb	r1, [r3, r2]
   11504:	03a03000 	moveq	r3, #0	; 0x0
   11508:	07c03002 	streqb	r3, [r0, r2]
   1150c:	e2877001 	add	r7, r7, #1	; 0x1
   11510:	03a0201f 	moveq	r2, #31	; 0x1f
   11514:	e2822001 	add	r2, r2, #1	; 0x1
   11518:	e352001f 	cmp	r2, #31	; 0x1f
   1151c:	daffffef 	ble	114e0 <main+0x110>
   11520:	e28ee001 	add	lr, lr, #1	; 0x1
   11524:	e2844020 	add	r4, r4, #32	; 0x20
   11528:	e28cc020 	add	ip, ip, #32	; 0x20
   1152c:	e15e0006 	cmp	lr, r6
   11530:	baffffe9 	blt	114dc <main+0x10c>
   11534:	e3a0100f 	mov	r1, #15	; 0xf
   11538:	e1a00006 	mov	r0, r6
   1153c:	eb001cd7 	bl	188a0 <__divsi3>
   11540:	e59f440c 	ldr	r4, [pc, #1036]	; 11954 <.text+0x1954>
   11544:	e2400001 	sub	r0, r0, #1	; 0x1
   11548:	e20050ff 	and	r5, r0, #255	; 0xff
   1154c:	e3a0100f 	mov	r1, #15	; 0xf
   11550:	e1a00006 	mov	r0, r6
   11554:	e5c45005 	strb	r5, [r4, #5]
   11558:	eb001d55 	bl	18ab4 <__modsi3>
   1155c:	e3500000 	cmp	r0, #0	; 0x0
   11560:	12853001 	addne	r3, r5, #1	; 0x1
   11564:	15c43005 	strneb	r3, [r4, #5]
   11568:	e59f33e8 	ldr	r3, [pc, #1000]	; 11958 <.text+0x1958>
   1156c:	e5d3c000 	ldrb	ip, [r3]
   11570:	e59f33e4 	ldr	r3, [pc, #996]	; 1195c <.text+0x195c>
   11574:	e5d33000 	ldrb	r3, [r3]
   11578:	e3a02000 	mov	r2, #0	; 0x0
   1157c:	e5c43004 	strb	r3, [r4, #4]
   11580:	e3a03001 	mov	r3, #1	; 0x1
   11584:	e1a00004 	mov	r0, r4
   11588:	e1a01008 	mov	r1, r8
   1158c:	e5c4c003 	strb	ip, [r4, #3]
   11590:	e5c43000 	strb	r3, [r4]
   11594:	e5842008 	str	r2, [r4, #8]
   11598:	e5c42002 	strb	r2, [r4, #2]
   1159c:	e5c42006 	strb	r2, [r4, #6]
   115a0:	ebfffb05 	bl	101bc <getNewFiles>
   115a4:	e59f13b4 	ldr	r1, [pc, #948]	; 11960 <.text+0x1960>
   115a8:	e1a00004 	mov	r0, r4
   115ac:	e4d12001 	ldrb	r2, [r1], #1
   115b0:	e59f33ac 	ldr	r3, [pc, #940]	; 11964 <.text+0x1964>
   115b4:	e1510003 	cmp	r1, r3
   115b8:	e5c021ec 	strb	r2, [r0, #492]
   115bc:	e2800001 	add	r0, r0, #1	; 0x1
   115c0:	1afffff9 	bne	115ac <main+0x1dc>
   115c4:	e59f039c 	ldr	r0, [pc, #924]	; 11968 <.text+0x1968>
   115c8:	ebfffb37 	bl	102ac <fillSettings>
   115cc:	e59f1378 	ldr	r1, [pc, #888]	; 1194c <.text+0x194c>
   115d0:	e5913000 	ldr	r3, [r1]
   115d4:	e59f2378 	ldr	r2, [pc, #888]	; 11954 <.text+0x1954>
   115d8:	e59f438c 	ldr	r4, [pc, #908]	; 1196c <.text+0x196c>
   115dc:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   115e0:	e3c33030 	bic	r3, r3, #48	; 0x30
   115e4:	e5d20004 	ldrb	r0, [r2, #4]
   115e8:	e5842000 	str	r2, [r4]
   115ec:	e5813000 	str	r3, [r1]
   115f0:	eb000d28 	bl	14a98 <LCDClear>
   115f4:	e5940000 	ldr	r0, [r4]
   115f8:	ebfffccd 	bl	10934 <printMenu>
   115fc:	e59f336c 	ldr	r3, [pc, #876]	; 11970 <.text+0x1970>
   11600:	e5933000 	ldr	r3, [r3]
   11604:	e3130502 	tst	r3, #8388608	; 0x800000
   11608:	0a000013 	beq	1165c <main+0x28c>
   1160c:	e59f3328 	ldr	r3, [pc, #808]	; 1193c <.text+0x193c>
   11610:	e5d30000 	ldrb	r0, [r3]
   11614:	eb000d1f 	bl	14a98 <LCDClear>
   11618:	e3a03004 	mov	r3, #4	; 0x4
   1161c:	e58d3000 	str	r3, [sp]
   11620:	e59f3344 	ldr	r3, [pc, #836]	; 1196c <.text+0x196c>
   11624:	e5931000 	ldr	r1, [r3]
   11628:	e59f332c 	ldr	r3, [pc, #812]	; 1195c <.text+0x195c>
   1162c:	e5d1c002 	ldrb	ip, [r1, #2]
   11630:	e5d32000 	ldrb	r2, [r3]
   11634:	e3a01000 	mov	r1, #0	; 0x0
   11638:	e3a03007 	mov	r3, #7	; 0x7
   1163c:	e59f0330 	ldr	r0, [pc, #816]	; 11974 <.text+0x1974>
   11640:	e58dc004 	str	ip, [sp, #4]
   11644:	eb000e44 	bl	14f5c <LCDPrintString>
   11648:	e59f3328 	ldr	r3, [pc, #808]	; 11978 <.text+0x1978>
   1164c:	e3a02030 	mov	r2, #48	; 0x30
   11650:	e5832000 	str	r2, [r3]
   11654:	eb0010e1 	bl	159e0 <main_msc>
   11658:	ebfffb44 	bl	10370 <reset>
   1165c:	e59f3318 	ldr	r3, [pc, #792]	; 1197c <.text+0x197c>
   11660:	e5d33000 	ldrb	r3, [r3]
   11664:	e3530000 	cmp	r3, #0	; 0x0
   11668:	1a000043 	bne	1177c <main+0x3ac>
   1166c:	e59f330c 	ldr	r3, [pc, #780]	; 11980 <.text+0x1980>
   11670:	e5d34000 	ldrb	r4, [r3]
   11674:	e3540000 	cmp	r4, #0	; 0x0
   11678:	1a00003f 	bne	1177c <main+0x3ac>
   1167c:	e59f3300 	ldr	r3, [pc, #768]	; 11984 <.text+0x1984>
   11680:	e5d33000 	ldrb	r3, [r3]
   11684:	e3530000 	cmp	r3, #0	; 0x0
   11688:	0a00003b 	beq	1177c <main+0x3ac>
   1168c:	e59f32e4 	ldr	r3, [pc, #740]	; 11978 <.text+0x1978>
   11690:	e3a02020 	mov	r2, #32	; 0x20
   11694:	e5832000 	str	r2, [r3]
   11698:	e59f02e8 	ldr	r0, [pc, #744]	; 11988 <.text+0x1988>
   1169c:	ebfffc62 	bl	1082c <closeSong>
   116a0:	e59fc2ac 	ldr	ip, [pc, #684]	; 11954 <.text+0x1954>
   116a4:	e59f32e0 	ldr	r3, [pc, #736]	; 1198c <.text+0x198c>
   116a8:	e5dc1000 	ldrb	r1, [ip]
   116ac:	e3a02202 	mov	r2, #536870912	; 0x20000000
   116b0:	e5832000 	str	r2, [r3]
   116b4:	e59f32d4 	ldr	r3, [pc, #724]	; 11990 <.text+0x1990>
   116b8:	e351000e 	cmp	r1, #14	; 0xe
   116bc:	e5c34000 	strb	r4, [r3]
   116c0:	92812001 	addls	r2, r1, #1	; 0x1
   116c4:	959c3008 	ldrls	r3, [ip, #8]
   116c8:	95cc2000 	strlsb	r2, [ip]
   116cc:	92833001 	addls	r3, r3, #1	; 0x1
   116d0:	958c3008 	strls	r3, [ip, #8]
   116d4:	e5dc3000 	ldrb	r3, [ip]
   116d8:	e353000f 	cmp	r3, #15	; 0xf
   116dc:	1a00000b 	bne	11710 <main+0x340>
   116e0:	e5dc2006 	ldrb	r2, [ip, #6]
   116e4:	e5dc3005 	ldrb	r3, [ip, #5]
   116e8:	e1520003 	cmp	r2, r3
   116ec:	2a000007 	bcs	11710 <main+0x340>
   116f0:	e2822001 	add	r2, r2, #1	; 0x1
   116f4:	e3a03001 	mov	r3, #1	; 0x1
   116f8:	e1a0000c 	mov	r0, ip
   116fc:	e1a01008 	mov	r1, r8
   11700:	e5cc3000 	strb	r3, [ip]
   11704:	e58c4008 	str	r4, [ip, #8]
   11708:	e5cc2006 	strb	r2, [ip, #6]
   1170c:	ebfffaaa 	bl	101bc <getNewFiles>
   11710:	e59f423c 	ldr	r4, [pc, #572]	; 11954 <.text+0x1954>
   11714:	e5d43000 	ldrb	r3, [r4]
   11718:	e0843283 	add	r3, r4, r3, lsl #5
   1171c:	e5d3302c 	ldrb	r3, [r3, #44]
   11720:	e3530000 	cmp	r3, #0	; 0x0
   11724:	0a000014 	beq	1177c <main+0x3ac>
   11728:	e5d40004 	ldrb	r0, [r4, #4]
   1172c:	eb000cd9 	bl	14a98 <LCDClear>
   11730:	e1a00004 	mov	r0, r4
   11734:	ebfffc7e 	bl	10934 <printMenu>
   11738:	e1a01004 	mov	r1, r4
   1173c:	e59f0244 	ldr	r0, [pc, #580]	; 11988 <.text+0x1988>
   11740:	ebfffc02 	bl	10750 <loadSongInfo>
   11744:	e59f3244 	ldr	r3, [pc, #580]	; 11990 <.text+0x1990>
   11748:	e5c30000 	strb	r0, [r3]
   1174c:	eb000f11 	bl	15398 <vs1002Config>
   11750:	e3a00000 	mov	r0, #0	; 0x0
   11754:	e3a01b02 	mov	r1, #2048	; 0x800
   11758:	eb000f1f 	bl	153dc <vs1002SCIWrite>
   1175c:	eb000f17 	bl	153c0 <vs1002Finish>
   11760:	e59f322c 	ldr	r3, [pc, #556]	; 11994 <.text+0x1994>
   11764:	e3a02202 	mov	r2, #536870912	; 0x20000000
   11768:	e5832000 	str	r2, [r3]
   1176c:	e59f2224 	ldr	r2, [pc, #548]	; 11998 <.text+0x1998>
   11770:	e5923000 	ldr	r3, [r2]
   11774:	e3833020 	orr	r3, r3, #32	; 0x20
   11778:	e5823000 	str	r3, [r2]
   1177c:	e59f31f8 	ldr	r3, [pc, #504]	; 1197c <.text+0x197c>
   11780:	e5d33000 	ldrb	r3, [r3]
   11784:	e3530002 	cmp	r3, #2	; 0x2
   11788:	1a000004 	bne	117a0 <main+0x3d0>
   1178c:	e59f31d8 	ldr	r3, [pc, #472]	; 1196c <.text+0x196c>
   11790:	e1a01008 	mov	r1, r8
   11794:	e5930000 	ldr	r0, [r3]
   11798:	ebfffcf1 	bl	10b64 <handleUpButton>
   1179c:	ea00005e 	b	1191c <main+0x54c>
   117a0:	e3530001 	cmp	r3, #1	; 0x1
   117a4:	1a000004 	bne	117bc <main+0x3ec>
   117a8:	e59f31bc 	ldr	r3, [pc, #444]	; 1196c <.text+0x196c>
   117ac:	e1a01008 	mov	r1, r8
   117b0:	e5930000 	ldr	r0, [r3]
   117b4:	ebfffccb 	bl	10ae8 <handleDownButton>
   117b8:	ea000057 	b	1191c <main+0x54c>
   117bc:	e3530003 	cmp	r3, #3	; 0x3
   117c0:	1a000001 	bne	117cc <main+0x3fc>
   117c4:	ebfffd03 	bl	10bd8 <handleMiddleButton>
   117c8:	ea000053 	b	1191c <main+0x54c>
   117cc:	e59f31ac 	ldr	r3, [pc, #428]	; 11980 <.text+0x1980>
   117d0:	e5d33000 	ldrb	r3, [r3]
   117d4:	e3530000 	cmp	r3, #0	; 0x0
   117d8:	0a00004f 	beq	1191c <main+0x54c>
   117dc:	e59f3194 	ldr	r3, [pc, #404]	; 11978 <.text+0x1978>
   117e0:	e3a02010 	mov	r2, #16	; 0x10
   117e4:	e3a00f4b 	mov	r0, #300	; 0x12c
   117e8:	e5832000 	str	r2, [r3]
   117ec:	ebfffa68 	bl	10194 <delay_ms>
   117f0:	eb000c31 	bl	148bc <MMA_get_y>
   117f4:	e3500faf 	cmp	r0, #700	; 0x2bc
   117f8:	da00001c 	ble	11870 <main+0x4a0>
   117fc:	e59f3198 	ldr	r3, [pc, #408]	; 1199c <.text+0x199c>
   11800:	e5933000 	ldr	r3, [r3]
   11804:	e3530faf 	cmp	r3, #700	; 0x2bc
   11808:	da000018 	ble	11870 <main+0x4a0>
   1180c:	e59f317c 	ldr	r3, [pc, #380]	; 11990 <.text+0x1990>
   11810:	e5d33000 	ldrb	r3, [r3]
   11814:	e3530000 	cmp	r3, #0	; 0x0
   11818:	e59f014c 	ldr	r0, [pc, #332]	; 1196c <.text+0x196c>
   1181c:	0a000002 	beq	1182c <main+0x45c>
   11820:	e5900000 	ldr	r0, [r0]
   11824:	ebfffc0e 	bl	10864 <quickClear>
   11828:	ea000002 	b	11838 <main+0x468>
   1182c:	e5903000 	ldr	r3, [r0]
   11830:	e5d30004 	ldrb	r0, [r3, #4]
   11834:	eb000c97 	bl	14a98 <LCDClear>
   11838:	e59f3150 	ldr	r3, [pc, #336]	; 11990 <.text+0x1990>
   1183c:	e5d33000 	ldrb	r3, [r3]
   11840:	e59f1120 	ldr	r1, [pc, #288]	; 11968 <.text+0x1968>
   11844:	e3530000 	cmp	r3, #0	; 0x0
   11848:	e3a03001 	mov	r3, #1	; 0x1
   1184c:	e5c13002 	strb	r3, [r1, #2]
   11850:	e59f3134 	ldr	r3, [pc, #308]	; 1198c <.text+0x198c>
   11854:	e3a02202 	mov	r2, #536870912	; 0x20000000
   11858:	e5832000 	str	r2, [r3]
   1185c:	e59f3108 	ldr	r3, [pc, #264]	; 1196c <.text+0x196c>
   11860:	1282220f 	addne	r2, r2, #-268435456	; 0xf0000000
   11864:	03a02101 	moveq	r2, #1073741824	; 0x40000000
   11868:	e5831000 	str	r1, [r3]
   1186c:	ea000021 	b	118f8 <main+0x528>
   11870:	eb000c11 	bl	148bc <MMA_get_y>
   11874:	e59f2124 	ldr	r2, [pc, #292]	; 119a0 <.text+0x19a0>
   11878:	e1500002 	cmp	r0, r2
   1187c:	ca00001f 	bgt	11900 <main+0x530>
   11880:	e59f3114 	ldr	r3, [pc, #276]	; 1199c <.text+0x199c>
   11884:	e5933000 	ldr	r3, [r3]
   11888:	e1530002 	cmp	r3, r2
   1188c:	ca00001b 	bgt	11900 <main+0x530>
   11890:	e59f30f8 	ldr	r3, [pc, #248]	; 11990 <.text+0x1990>
   11894:	e5d33000 	ldrb	r3, [r3]
   11898:	e3530000 	cmp	r3, #0	; 0x0
   1189c:	e59f00c8 	ldr	r0, [pc, #200]	; 1196c <.text+0x196c>
   118a0:	0a000002 	beq	118b0 <main+0x4e0>
   118a4:	e5900000 	ldr	r0, [r0]
   118a8:	ebfffbed 	bl	10864 <quickClear>
   118ac:	ea000002 	b	118bc <main+0x4ec>
   118b0:	e5903000 	ldr	r3, [r0]
   118b4:	e5d30004 	ldrb	r0, [r3, #4]
   118b8:	eb000c76 	bl	14a98 <LCDClear>
   118bc:	e59f30cc 	ldr	r3, [pc, #204]	; 11990 <.text+0x1990>
   118c0:	e5d33000 	ldrb	r3, [r3]
   118c4:	e59f1088 	ldr	r1, [pc, #136]	; 11954 <.text+0x1954>
   118c8:	e59f20bc 	ldr	r2, [pc, #188]	; 1198c <.text+0x198c>
   118cc:	e3530000 	cmp	r3, #0	; 0x0
   118d0:	e3a03000 	mov	r3, #0	; 0x0
   118d4:	e5c13002 	strb	r3, [r1, #2]
   118d8:	e2833201 	add	r3, r3, #268435456	; 0x10000000
   118dc:	e5823000 	str	r3, [r2]
   118e0:	e2833203 	add	r3, r3, #805306368	; 0x30000000
   118e4:	e5823000 	str	r3, [r2]
   118e8:	e59f307c 	ldr	r3, [pc, #124]	; 1196c <.text+0x196c>
   118ec:	e5831000 	str	r1, [r3]
   118f0:	0a000002 	beq	11900 <main+0x530>
   118f4:	e3a02202 	mov	r2, #536870912	; 0x20000000
   118f8:	e59f3094 	ldr	r3, [pc, #148]	; 11994 <.text+0x1994>
   118fc:	e5832000 	str	r2, [r3]
   11900:	e59f3064 	ldr	r3, [pc, #100]	; 1196c <.text+0x196c>
   11904:	e5930000 	ldr	r0, [r3]
   11908:	ebfffc09 	bl	10934 <printMenu>
   1190c:	e59f2084 	ldr	r2, [pc, #132]	; 11998 <.text+0x1998>
   11910:	e5923000 	ldr	r3, [r2]
   11914:	e3833010 	orr	r3, r3, #16	; 0x10
   11918:	e5823000 	str	r3, [r2]
   1191c:	e59f0074 	ldr	r0, [pc, #116]	; 11998 <.text+0x1998>
   11920:	e5902000 	ldr	r2, [r0]
   11924:	e59f3050 	ldr	r3, [pc, #80]	; 1197c <.text+0x197c>
   11928:	e3822010 	orr	r2, r2, #16	; 0x10
   1192c:	e3a01000 	mov	r1, #0	; 0x0
   11930:	e5c31000 	strb	r1, [r3]
   11934:	e5802000 	str	r2, [r0]
   11938:	eaffff2f 	b	115fc <main+0x22c>
   1193c:	4000000a 	andmi	r0, r0, sl
   11940:	e002801c 	and	r8, r2, ip, lsl r0
   11944:	000003cd 	andeq	r0, r0, sp, asr #7
   11948:	e0028014 	and	r8, r2, r4, lsl r0
   1194c:	e002c000 	and	ip, r2, r0
   11950:	40000ed4 	ldrmid	r0, [r0], -r4
   11954:	400010e0 	andmi	r1, r0, r0, ror #1
   11958:	40000008 	andmi	r0, r0, r8
   1195c:	40001564 	andmi	r1, r0, r4, ror #10
   11960:	00018c04 	andeq	r8, r1, r4, lsl #24
   11964:	00018c1a 	andeq	r8, r1, sl, lsl ip
   11968:	40000edc 	ldrmid	r0, [r0], -ip
   1196c:	40000ed8 	ldrmid	r0, [r0], -r8
   11970:	e0028000 	and	r8, r2, r0
   11974:	00018be4 	andeq	r8, r1, r4, ror #23
   11978:	fffff014 	swinv	0x00fff014
   1197c:	4000134d 	andmi	r1, r0, sp, asr #6
   11980:	4000134c 	andmi	r1, r0, ip, asr #6
   11984:	40000ed1 	ldrmid	r0, [r0], -r1
   11988:	400012e4 	andmi	r1, r0, r4, ror #5
   1198c:	e0028004 	and	r8, r2, r4
   11990:	40000ed2 	ldrmid	r0, [r0], -r2
   11994:	e002800c 	and	r8, r2, ip
   11998:	fffff010 	swinv	0x00fff010
   1199c:	40001348 	andmi	r1, r0, r8, asr #6
   119a0:	000002bb 	streqh	r0, [r0], -fp

000119a4 <_read_r>:
	}
*/
//	return len - i;
	return 0;
}
   119a4:	e3a00000 	mov	r0, #0	; 0x0
   119a8:	e12fff1e 	bx	lr

000119ac <_write_r>:

_ssize_t _write_r (
    struct _reent *r, 
    int file, 
    const void *ptr, 
    size_t len)
{
/*
	int i;
	const unsigned char *p;
	
	p = (const unsigned char*) ptr;
	
	for (i = 0; i < len; i++) {
		if (*p == '\n' ) uart0Putch('\r');
		uart0Putch(*p++);
	}
*/
	return len;
}
   119ac:	e1a00003 	mov	r0, r3
   119b0:	e12fff1e 	bx	lr

000119b4 <_close_r>:

int _close_r(
    struct _reent *r, 
    int file)
{
	return 0;
}
   119b4:	e3a00000 	mov	r0, #0	; 0x0
   119b8:	e12fff1e 	bx	lr

000119bc <_lseek_r>:

_off_t _lseek_r(
    struct _reent *r, 
    int file, 
    _off_t ptr, 
    int dir)
{
	return (_off_t)0;	/*  Always indicate we are at file beginning.	*/
}
   119bc:	e3a00000 	mov	r0, #0	; 0x0
   119c0:	e12fff1e 	bx	lr

000119c4 <_fstat_r>:


int _fstat_r(
    struct _reent *r, 
    int file, 
    struct stat *st)
{
	/*  Always set as character device.				*/
	st->st_mode = S_IFCHR;	
   119c4:	e3a03a02 	mov	r3, #8192	; 0x2000
		/* assigned to strong type with implicit 	*/
		/* signed/unsigned conversion.  Required by 	*/
		/* newlib.					*/

	return 0;
}
   119c8:	e3a00000 	mov	r0, #0	; 0x0
   119cc:	e5823004 	str	r3, [r2, #4]
   119d0:	e12fff1e 	bx	lr

000119d4 <isatty>:

int isatty(int file); /* avoid warning */

int isatty(int file)
{
	return 1;
}
   119d4:	e3a00001 	mov	r0, #1	; 0x1
   119d8:	e12fff1e 	bx	lr

000119dc <_sbrk_r>:

#if 0
static void _exit (int n) {
label:  goto label; /* endless loop */
}
#endif 

/* "malloc clue function" */

	/**** Locally used variables. ****/
extern char end[];              /*  end is set in the linker command 	*/
				/* file and is the end of statically 	*/
				/* allocated data (thus start of heap).	*/

static char *heap_ptr;		/* Points to current end of the heap.	*/

/************************** _sbrk_r *************************************/
/*  Support function.  Adjusts end of heap to provide more memory to	*/
/* memory allocator. Simple and dumb with no sanity checks.		*/
/*  struct _reent *r	-- re-entrancy structure, used by newlib to 	*/
/*			support multiple threads of operation.		*/
/*  ptrdiff_t nbytes	-- number of bytes to add.			*/
/*  Returns pointer to start of new heap area.				*/
/*  Note:  This implementation is not thread safe (despite taking a	*/
/* _reent structure as a parameter).  					*/
/*  Since _s_r is not used in the current implementation, the following	*/
/* messages must be suppressed.						*/

void * _sbrk_r(
    struct _reent *_s_r, 
    ptrdiff_t nbytes)
{
	char  *base;		/*  errno should be set to  ENOMEM on error	*/

	if (!heap_ptr) {	/*  Initialize if first time through.		*/
   119dc:	e59f201c 	ldr	r2, [pc, #28]	; 11a00 <.text+0x1a00>
   119e0:	e5923000 	ldr	r3, [r2]
   119e4:	e3530000 	cmp	r3, #0	; 0x0
		heap_ptr = end;
   119e8:	059f3014 	ldreq	r3, [pc, #20]	; 11a04 <.text+0x1a04>
   119ec:	05823000 	streq	r3, [r2]
	}
	base = heap_ptr;	/*  Point to end of heap.			*/
   119f0:	e5920000 	ldr	r0, [r2]
	heap_ptr += nbytes;	/*  Increase heap.				*/
   119f4:	e0803001 	add	r3, r0, r1
   119f8:	e5823000 	str	r3, [r2]
	
	return base;		/*  Return pointer to start of new heap area.	*/
}
   119fc:	e12fff1e 	bx	lr
   11a00:	40001350 	andmi	r1, r0, r0, asr r3
   11a04:	40002500 	andmi	r2, r0, r0, lsl #10

00011a08 <rprintf_devopen>:
static int (*putcharfunc)(int c);

void rprintf_devopen( int(*put)(int) )
{
    putcharfunc = put;
   11a08:	e59f3004 	ldr	r3, [pc, #4]	; 11a14 <.text+0x1a14>
   11a0c:	e5830000 	str	r0, [r3]
}
   11a10:	e12fff1e 	bx	lr
   11a14:	40001354 	andmi	r1, r0, r4, asr r3

00011a18 <myputchar>:

static void myputchar(unsigned char c)
{
   11a18:	e92d4010 	stmdb	sp!, {r4, lr}
   11a1c:	e20040ff 	and	r4, r0, #255	; 0xff
    if(c == '\n') putcharfunc('\r');
   11a20:	e354000a 	cmp	r4, #10	; 0xa
   11a24:	e3a0000d 	mov	r0, #13	; 0xd
   11a28:	059f3024 	ldreq	r3, [pc, #36]	; 11a54 <.text+0x1a54>
   11a2c:	0593c000 	ldreq	ip, [r3]
   11a30:	01a0e00f 	moveq	lr, pc
   11a34:	012fff1c 	bxeq	ip
    putcharfunc(c);
   11a38:	e1a00004 	mov	r0, r4
   11a3c:	e59f3010 	ldr	r3, [pc, #16]	; 11a54 <.text+0x1a54>
   11a40:	e593c000 	ldr	ip, [r3]
   11a44:	e1a0e00f 	mov	lr, pc
   11a48:	e12fff1c 	bx	ip
}
   11a4c:	e8bd4010 	ldmia	sp!, {r4, lr}
   11a50:	e12fff1e 	bx	lr
   11a54:	40001354 	andmi	r1, r0, r4, asr r3

00011a58 <rprintf>:

void rprintf(char const *format, ...)
{
   11a58:	e92d000f 	stmdb	sp!, {r0, r1, r2, r3}
   11a5c:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
   11a60:	e24dd010 	sub	sp, sp, #16	; 0x10
    unsigned char scratch[SCRATCH];
    unsigned char format_flag;
    unsigned short base;
    unsigned char *ptr;
    unsigned char issigned=0;
    va_list ap;

    #ifdef USE_LONG
        // #warning "use long"
        unsigned char islong=0;
        unsigned long u_val=0;
        long s_val=0;
    #else
        unsigned int u_val=0;
        int s_val=0;
    #endif

    unsigned char fill;
    unsigned char width;

    va_start (ap, format);
   11a64:	e28d3030 	add	r3, sp, #48	; 0x30
   11a68:	e58d300c 	str	r3, [sp, #12]
   11a6c:	e59d702c 	ldr	r7, [sp, #44]
    for (;;)
    {
		delay_ms(1); //Added for VCOM testing - without it, rprintf will overrun the VCOM buffer causing it to crash
   11a70:	e3a00001 	mov	r0, #1	; 0x1
   11a74:	ebfff9c6 	bl	10194 <delay_ms>
   11a78:	e1a02007 	mov	r2, r7
   11a7c:	ea000003 	b	11a90 <rprintf+0x38>
		
        while ((format_flag = *(format++)) != '%')
        {      // Until '%' or '\0'
            if (!format_flag){va_end (ap); return;}
   11a80:	e3530000 	cmp	r3, #0	; 0x0
   11a84:	0a00008c 	beq	11cbc <rprintf+0x264>
                myputchar(format_flag);
   11a88:	ebffffe2 	bl	11a18 <myputchar>
   11a8c:	e1a02004 	mov	r2, r4
   11a90:	e1a04002 	mov	r4, r2
   11a94:	e4d43001 	ldrb	r3, [r4], #1
   11a98:	e3530025 	cmp	r3, #37	; 0x25
   11a9c:	e1a00003 	mov	r0, r3
   11aa0:	1afffff6 	bne	11a80 <rprintf+0x28>
        }

        issigned=0; //default unsigned
        base = 10;

        format_flag = *format++; //get char after '%'
   11aa4:	e5d20001 	ldrb	r0, [r2, #1]

        #ifdef PADDING
            width=0; //no formatting
            fill=0;  //no formatting
            if(format_flag=='0' || format_flag==' ') //SPACE or ZERO padding  ?
   11aa8:	e3500020 	cmp	r0, #32	; 0x20
   11aac:	13500030 	cmpne	r0, #48	; 0x30
   11ab0:	13a03000 	movne	r3, #0	; 0x0
   11ab4:	03a03001 	moveq	r3, #1	; 0x1
   11ab8:	11a08003 	movne	r8, r3
   11abc:	e2827002 	add	r7, r2, #2	; 0x2
   11ac0:	11a0a008 	movne	sl, r8
   11ac4:	1a00000b 	bne	11af8 <rprintf+0xa0>
            {
                fill=format_flag;
                format_flag = *format++; //get char after padding char
   11ac8:	e5d21002 	ldrb	r1, [r2, #2]
                if(format_flag>='0' && format_flag<='9')
   11acc:	e2413030 	sub	r3, r1, #48	; 0x30
   11ad0:	e20330ff 	and	r3, r3, #255	; 0xff
   11ad4:	e3530009 	cmp	r3, #9	; 0x9
                {
                    width=format_flag-'0';
                    format_flag = *format++; //get char after width char
   11ad8:	91a0a000 	movls	sl, r0
   11adc:	95d20003 	ldrlsb	r0, [r2, #3]
   11ae0:	e2827003 	add	r7, r2, #3	; 0x3
   11ae4:	81a0a000 	movhi	sl, r0
   11ae8:	83a08000 	movhi	r8, #0	; 0x0
   11aec:	81a00001 	movhi	r0, r1
   11af0:	91a08003 	movls	r8, r3
   11af4:	92827004 	addls	r7, r2, #4	; 0x4
                }
            }
        #endif

        #ifdef USE_LONG
            islong=0; //default int value
            #ifdef USE_UPPER
            if(format_flag=='l' || format_flag=='L') //Long value
   11af8:	e350004c 	cmp	r0, #76	; 0x4c
   11afc:	1350006c 	cmpne	r0, #108	; 0x6c
            #else
            if(format_flag=='l') //Long value
            #endif
        {
            islong=1;
            format_flag = *format++; //get char after 'l' or 'L'
   11b00:	04d70001 	ldreqb	r0, [r7], #1
   11b04:	13a03000 	movne	r3, #0	; 0x0
   11b08:	03a03001 	moveq	r3, #1	; 0x1
   11b0c:	03a03001 	moveq	r3, #1	; 0x1
        }
        #endif

        switch (format_flag)
   11b10:	e3500058 	cmp	r0, #88	; 0x58
   11b14:	0a00002b 	beq	11bc8 <rprintf+0x170>
   11b18:	8a00000b 	bhi	11b4c <rprintf+0xf4>
   11b1c:	e3500049 	cmp	r0, #73	; 0x49
   11b20:	0a00002a 	beq	11bd0 <rprintf+0x178>
   11b24:	8a000003 	bhi	11b38 <rprintf+0xe0>
   11b28:	e3500043 	cmp	r0, #67	; 0x43
   11b2c:	0a000015 	beq	11b88 <rprintf+0x130>
   11b30:	e3500044 	cmp	r0, #68	; 0x44
   11b34:	ea00000a 	b	11b64 <rprintf+0x10c>
   11b38:	e3500053 	cmp	r0, #83	; 0x53
   11b3c:	0a000017 	beq	11ba0 <rprintf+0x148>
   11b40:	e3500055 	cmp	r0, #85	; 0x55
   11b44:	1a000013 	bne	11b98 <rprintf+0x140>
   11b48:	ea00002e 	b	11c08 <rprintf+0x1b0>
   11b4c:	e3500069 	cmp	r0, #105	; 0x69
   11b50:	0a00001e 	beq	11bd0 <rprintf+0x178>
   11b54:	8a000004 	bhi	11b6c <rprintf+0x114>
   11b58:	e3500063 	cmp	r0, #99	; 0x63
   11b5c:	0a000009 	beq	11b88 <rprintf+0x130>
   11b60:	e3500064 	cmp	r0, #100	; 0x64
   11b64:	1a00000b 	bne	11b98 <rprintf+0x140>
   11b68:	ea000018 	b	11bd0 <rprintf+0x178>
   11b6c:	e3500075 	cmp	r0, #117	; 0x75
   11b70:	0a000024 	beq	11c08 <rprintf+0x1b0>
   11b74:	e3500078 	cmp	r0, #120	; 0x78
   11b78:	0a000012 	beq	11bc8 <rprintf+0x170>
   11b7c:	e3500073 	cmp	r0, #115	; 0x73
   11b80:	1a000004 	bne	11b98 <rprintf+0x140>
   11b84:	ea000005 	b	11ba0 <rprintf+0x148>
        {
            #ifdef USE_CHAR
                case 'c':
                    #ifdef USE_UPPER
                    case 'C':
                #endif
                format_flag = va_arg(ap,int);
   11b88:	e59d200c 	ldr	r2, [sp, #12]
   11b8c:	e2823004 	add	r3, r2, #4	; 0x4
   11b90:	e58d300c 	str	r3, [sp, #12]
   11b94:	e5d20000 	ldrb	r0, [r2]
                // no break -> run into default
            #endif

            default:
                myputchar(format_flag);
   11b98:	ebffff9e 	bl	11a18 <myputchar>
   11b9c:	eaffffb3 	b	11a70 <rprintf+0x18>
                continue;

                #ifdef USE_STRING
                    #ifdef USE_UPPER
                    case 'S':
                #endif
                case 's':
                ptr = (unsigned char*)va_arg(ap,char *);
   11ba0:	e59d300c 	ldr	r3, [sp, #12]
   11ba4:	e4934004 	ldr	r4, [r3], #4
   11ba8:	e58d300c 	str	r3, [sp, #12]
   11bac:	ea000000 	b	11bb4 <rprintf+0x15c>
                while(*ptr) { myputchar(*ptr); ptr++; }
   11bb0:	ebffff98 	bl	11a18 <myputchar>
   11bb4:	e5d43000 	ldrb	r3, [r4]
   11bb8:	e2530000 	subs	r0, r3, #0	; 0x0
   11bbc:	e2844001 	add	r4, r4, #1	; 0x1
   11bc0:	1afffffa 	bne	11bb0 <rprintf+0x158>
   11bc4:	eaffffa9 	b	11a70 <rprintf+0x18>
   11bc8:	e3a06010 	mov	r6, #16	; 0x10
   11bcc:	ea00000e 	b	11c0c <rprintf+0x1b4>
   11bd0:	e59d200c 	ldr	r2, [sp, #12]
                    continue;
                #endif

                #ifdef USE_OCTAL
                    case 'o':
                    #ifdef USE_UPPER
                    case 'O':
                #endif
                base = 8;
                myputchar('0');
                goto CONVERSION_LOOP;
                #endif

                #ifdef USE_INTEGER //don't use %i, is same as %d
                    case 'i':
                    #ifdef USE_UPPER
                    case 'I':
                #endif
                #endif
                case 'd':
                #ifdef USE_UPPER
                    case 'D':
                #endif
                issigned=1;
                // no break -> run into next case
            case 'u':
                #ifdef USE_UPPER
                    case 'U':
                #endif

                //don't insert some case below this if USE_HEX is undefined !
                //or put       goto CONVERSION_LOOP;  before next case.
                #ifdef USE_HEX
                    goto CONVERSION_LOOP;
                    case 'x':
                    #ifdef USE_UPPER
                    case 'X':
                #endif
                base = 16;
                #endif

                CONVERSION_LOOP:

                if(issigned) //Signed types
                {
                    #ifdef USE_LONG
                        if(islong) { s_val = va_arg(ap,long); }
   11bd4:	e3530000 	cmp	r3, #0	; 0x0
   11bd8:	15924000 	ldrne	r4, [r2]
                            else { s_val = va_arg(ap,int); }
   11bdc:	05924000 	ldreq	r4, [r2]
   11be0:	12823004 	addne	r3, r2, #4	; 0x4
   11be4:	02823004 	addeq	r3, r2, #4	; 0x4
   11be8:	158d300c 	strne	r3, [sp, #12]
   11bec:	058d300c 	streq	r3, [sp, #12]
                        #else
                        s_val = va_arg(ap,int);
                    #endif

                    if(s_val < 0) //Value negativ ?
   11bf0:	e3540000 	cmp	r4, #0	; 0x0
                    {
                        s_val = - s_val; //Make it positiv
                        myputchar('-');    //Output sign
   11bf4:	b3a0002d 	movlt	r0, #45	; 0x2d
   11bf8:	b2644000 	rsblt	r4, r4, #0	; 0x0
   11bfc:	bbffff85 	bllt	11a18 <myputchar>
                    }

                    u_val = (unsigned long)s_val;
   11c00:	e3a0600a 	mov	r6, #10	; 0xa
   11c04:	ea000008 	b	11c2c <rprintf+0x1d4>
   11c08:	e3a0600a 	mov	r6, #10	; 0xa
   11c0c:	e59d200c 	ldr	r2, [sp, #12]
                }
                else //Unsigned types
                {
                    #ifdef USE_LONG
                        if(islong) { u_val = va_arg(ap,unsigned long); }
   11c10:	e3530000 	cmp	r3, #0	; 0x0
   11c14:	12823004 	addne	r3, r2, #4	; 0x4
                            else { u_val = va_arg(ap,unsigned int); }
   11c18:	02823004 	addeq	r3, r2, #4	; 0x4
   11c1c:	15924000 	ldrne	r4, [r2]
   11c20:	158d300c 	strne	r3, [sp, #12]
   11c24:	058d300c 	streq	r3, [sp, #12]
   11c28:	05924000 	ldreq	r4, [r2]
                        #else
                        u_val = va_arg(ap,unsigned int);
                    #endif
                }

                ptr = scratch + SCRATCH;
                *--ptr = 0;
   11c2c:	e3a03000 	mov	r3, #0	; 0x0
   11c30:	e5cd300b 	strb	r3, [sp, #11]
   11c34:	e28d500b 	add	r5, sp, #11	; 0xb
                do
                {
                    char ch = u_val % base + '0';
   11c38:	e1a00004 	mov	r0, r4
   11c3c:	e1a01006 	mov	r1, r6
   11c40:	eb001b67 	bl	189e4 <__umodsi3>
   11c44:	e2800030 	add	r0, r0, #48	; 0x30
   11c48:	e20030ff 	and	r3, r0, #255	; 0xff
                    #ifdef USE_HEX
                        if (ch > '9')
   11c4c:	e3530039 	cmp	r3, #57	; 0x39
                        {
                            ch += 'a' - '9' - 1;
                            #ifdef USE_UPPERHEX
                            ch-=0x20;
   11c50:	e2832007 	add	r2, r3, #7	; 0x7
   11c54:	820230ff 	andhi	r3, r2, #255	; 0xff
                        #endif
                    }
                    #endif
                    *--ptr = ch;
                    u_val /= base;
   11c58:	e1a00004 	mov	r0, r4
   11c5c:	e1a01006 	mov	r1, r6
   11c60:	e5453001 	strb	r3, [r5, #-1]
   11c64:	eb001ac8 	bl	1878c <__udivsi3>

                    #ifdef PADDING
                        if(width) width--; //calculate number of padding chars
   11c68:	e3580000 	cmp	r8, #0	; 0x0
   11c6c:	e2483001 	sub	r3, r8, #1	; 0x1
   11c70:	120380ff 	andne	r8, r3, #255	; 0xff
                    #endif
                }
                while (u_val);
   11c74:	e3500000 	cmp	r0, #0	; 0x0
   11c78:	e2455001 	sub	r5, r5, #1	; 0x1
   11c7c:	e1a04000 	mov	r4, r0
   11c80:	1affffec 	bne	11c38 <rprintf+0x1e0>
   11c84:	e1a02005 	mov	r2, r5
   11c88:	ea000000 	b	11c90 <rprintf+0x238>

                #ifdef PADDING
                    while(width--) *--ptr = fill; //insert padding chars
   11c8c:	e562a001 	strb	sl, [r2, #-1]!
   11c90:	e0683005 	rsb	r3, r8, r5
   11c94:	e1520003 	cmp	r2, r3
   11c98:	1afffffb 	bne	11c8c <rprintf+0x234>
   11c9c:	e1a04002 	mov	r4, r2
   11ca0:	ea000000 	b	11ca8 <rprintf+0x250>
                #endif

                while(*ptr) { myputchar(*ptr); ptr++; }
   11ca4:	ebffff5b 	bl	11a18 <myputchar>
   11ca8:	e5d43000 	ldrb	r3, [r4]
   11cac:	e2530000 	subs	r0, r3, #0	; 0x0
   11cb0:	e2844001 	add	r4, r4, #1	; 0x1
   11cb4:	1afffffa 	bne	11ca4 <rprintf+0x24c>
   11cb8:	eaffff6c 	b	11a70 <rprintf+0x18>
                    }
        }
    }
   11cbc:	e28dd010 	add	sp, sp, #16	; 0x10
   11cc0:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
   11cc4:	e28dd010 	add	sp, sp, #16	; 0x10
   11cc8:	e12fff1e 	bx	lr

00011ccc <init_serial0>:
void init_serial0 ( unsigned long baudrate )
{
    unsigned long Fdiv;

    PINSEL0 = 0x00000005;                  /* Enable RxD0 and TxD0              */
   11ccc:	e59f3044 	ldr	r3, [pc, #68]	; 11d18 <.text+0x1d18>
   11cd0:	e92d4010 	stmdb	sp!, {r4, lr}
   11cd4:	e3a02005 	mov	r2, #5	; 0x5
    U0LCR = 0x83;                          /* 8 bits, no Parity, 1 Stop bit     */
   11cd8:	e59f403c 	ldr	r4, [pc, #60]	; 11d1c <.text+0x1d1c>
   11cdc:	e5832000 	str	r2, [r3]
   11ce0:	e3a03083 	mov	r3, #131	; 0x83
   11ce4:	e1a01000 	mov	r1, r0
   11ce8:	e5843000 	str	r3, [r4]
    Fdiv = ( Fpclk / 16 ) / baudrate ;     /* baud rate                        */
   11cec:	e59f002c 	ldr	r0, [pc, #44]	; 11d20 <.text+0x1d20>
   11cf0:	eb001aa5 	bl	1878c <__udivsi3>
    U0DLM = Fdiv / 256;
   11cf4:	e59f3028 	ldr	r3, [pc, #40]	; 11d24 <.text+0x1d24>
    U0DLL = Fdiv % 256;
   11cf8:	e20020ff 	and	r2, r0, #255	; 0xff
   11cfc:	e1a00420 	mov	r0, r0, lsr #8
   11d00:	e4030004 	str	r0, [r3], #-4
   11d04:	e5832000 	str	r2, [r3]
    U0LCR = 0x03;                           /* DLAB = 0                         */
   11d08:	e3a03003 	mov	r3, #3	; 0x3
   11d0c:	e5843000 	str	r3, [r4]
}
   11d10:	e8bd4010 	ldmia	sp!, {r4, lr}
   11d14:	e12fff1e 	bx	lr
   11d18:	e002c000 	and	ip, r2, r0
   11d1c:	e000c00c 	and	ip, r0, ip
   11d20:	000e4e1c 	andeq	r4, lr, ip, lsl lr
   11d24:	e000c004 	and	ip, r0, r4

00011d28 <putchar_serial0>:

/* Write character to Serial Port 0 with \n -> \r\n  */
int putchar_serial0 (int ch)
{
    if (ch == '\n')
   11d28:	e350000a 	cmp	r0, #10	; 0xa
   11d2c:	1a000006 	bne	11d4c <putchar_serial0+0x24>
    {
        while (!(U0LSR & 0x20));
   11d30:	e59f3034 	ldr	r3, [pc, #52]	; 11d6c <.text+0x1d6c>
   11d34:	e5933000 	ldr	r3, [r3]
   11d38:	e3130020 	tst	r3, #32	; 0x20
   11d3c:	0afffffb 	beq	11d30 <putchar_serial0+0x8>
        U0THR = CR;                  /* output CR */
   11d40:	e59f3028 	ldr	r3, [pc, #40]	; 11d70 <.text+0x1d70>
   11d44:	e3a0200d 	mov	r2, #13	; 0xd
   11d48:	e5832000 	str	r2, [r3]
    }
    while (!(U0LSR & 0x20));
   11d4c:	e59f3018 	ldr	r3, [pc, #24]	; 11d6c <.text+0x1d6c>
   11d50:	e5933000 	ldr	r3, [r3]
   11d54:	e3130020 	tst	r3, #32	; 0x20
   11d58:	0afffffb 	beq	11d4c <putchar_serial0+0x24>
    return (U0THR = ch);
   11d5c:	e59f300c 	ldr	r3, [pc, #12]	; 11d70 <.text+0x1d70>
   11d60:	e5830000 	str	r0, [r3]
   11d64:	e5930000 	ldr	r0, [r3]
}
   11d68:	e12fff1e 	bx	lr
   11d6c:	e000c014 	and	ip, r0, r4, lsl r0
   11d70:	e000c000 	and	ip, r0, r0

00011d74 <putc_serial0>:

/* Write character to Serial Port 0 without \n -> \r\n  */
int putc_serial0 (int ch)
{
    while (!(U0LSR & 0x20));
   11d74:	e59f3018 	ldr	r3, [pc, #24]	; 11d94 <.text+0x1d94>
   11d78:	e5933000 	ldr	r3, [r3]
   11d7c:	e3130020 	tst	r3, #32	; 0x20
   11d80:	0afffffb 	beq	11d74 <putc_serial0>
    return (U0THR = ch);
   11d84:	e59f300c 	ldr	r3, [pc, #12]	; 11d98 <.text+0x1d98>
   11d88:	e5830000 	str	r0, [r3]
   11d8c:	e5930000 	ldr	r0, [r3]
}
   11d90:	e12fff1e 	bx	lr
   11d94:	e000c014 	and	ip, r0, r4, lsl r0
   11d98:	e000c000 	and	ip, r0, r0

00011d9c <putstring_serial0>:


void putstring_serial0 (const char *string)
{
   11d9c:	e92d4010 	stmdb	sp!, {r4, lr}
   11da0:	e1a04000 	mov	r4, r0
   11da4:	ea000000 	b	11dac <putstring_serial0+0x10>
    char ch;

    while ((ch = *string))
    {
        putchar_serial0(ch);
   11da8:	ebffffde 	bl	11d28 <putchar_serial0>
   11dac:	e5d43000 	ldrb	r3, [r4]
   11db0:	e2530000 	subs	r0, r3, #0	; 0x0
        string++;
   11db4:	e2844001 	add	r4, r4, #1	; 0x1
   11db8:	1afffffa 	bne	11da8 <putstring_serial0+0xc>
    }
}
   11dbc:	e8bd4010 	ldmia	sp!, {r4, lr}
   11dc0:	e12fff1e 	bx	lr

00011dc4 <getkey_serial0>:


/* Read character from Serial Port   */
int getkey_serial0 (void)
{
	if (U0LSR & 0x01)
   11dc4:	e59f3014 	ldr	r3, [pc, #20]	; 11de0 <.text+0x1de0>
   11dc8:	e5933000 	ldr	r3, [r3]
   11dcc:	e2133001 	ands	r3, r3, #1	; 0x1
   11dd0:	e1a00003 	mov	r0, r3
    {
        return (U0RBR);
   11dd4:	159f3008 	ldrne	r3, [pc, #8]	; 11de4 <.text+0x1de4>
   11dd8:	15930000 	ldrne	r0, [r3]
    }
    else
    {
        return 0;
    }
}
   11ddc:	e12fff1e 	bx	lr
   11de0:	e000c014 	and	ip, r0, r4, lsl r0
   11de4:	e000c000 	and	ip, r0, r0

00011de8 <getc0>:

/* Read character from Serial Port   */
int getc0 (void)
{
	while ( (U0LSR & 0x01) == 0 ); //Wait for character
   11de8:	e59f3014 	ldr	r3, [pc, #20]	; 11e04 <.text+0x1e04>
   11dec:	e5933000 	ldr	r3, [r3]
   11df0:	e3130001 	tst	r3, #1	; 0x1
   11df4:	0afffffb 	beq	11de8 <getc0>
	return U0RBR;
   11df8:	e59f3008 	ldr	r3, [pc, #8]	; 11e08 <.text+0x1e08>
   11dfc:	e5930000 	ldr	r0, [r3]
}
   11e00:	e12fff1e 	bx	lr
   11e04:	e000c014 	and	ip, r0, r4, lsl r0
   11e08:	e000c000 	and	ip, r0, r0

00011e0c <SPI0_send_recv>:
char SPI0_send_recv(char c)
{
    char in;

    S0SPDR = c;						//Place data to be sent into SPI data register
   11e0c:	e59f3028 	ldr	r3, [pc, #40]	; 11e3c <.text+0x1e3c>
   11e10:	e20000ff 	and	r0, r0, #255	; 0xff
   11e14:	e5830000 	str	r0, [r3]
    while(!(S0SPSR & SPIF));		//Wait for transfer to complete
   11e18:	e59f2020 	ldr	r2, [pc, #32]	; 11e40 <.text+0x1e40>
   11e1c:	e5923000 	ldr	r3, [r2]
   11e20:	e3130080 	tst	r3, #128	; 0x80
   11e24:	0afffffb 	beq	11e18 <SPI0_send_recv+0xc>
	in=S0SPSR;
   11e28:	e5923000 	ldr	r3, [r2]
    in = S0SPDR&0xff;				//Return the character placed in the SPI data register by the slave
   11e2c:	e59f3008 	ldr	r3, [pc, #8]	; 11e3c <.text+0x1e3c>
   11e30:	e5930000 	ldr	r0, [r3]
   11e34:	e20000ff 	and	r0, r0, #255	; 0xff
    
	return in;
}
   11e38:	e12fff1e 	bx	lr
   11e3c:	e0020008 	and	r0, r2, r8
   11e40:	e0020004 	and	r0, r2, r4

00011e44 <SPI0_send>:
   11e44:	e20000ff 	and	r0, r0, #255	; 0xff
   11e48:	eaffffef 	b	11e0c <SPI0_send_recv>

00011e4c <SPI0_recv>:
   11e4c:	e52de004 	str	lr, [sp, #-4]!
   11e50:	e3a000ff 	mov	r0, #255	; 0xff
   11e54:	ebffffec 	bl	11e0c <SPI0_send_recv>
   11e58:	e49de004 	ldr	lr, [sp], #4
   11e5c:	e12fff1e 	bx	lr

00011e60 <openroot>:
struct fat16_dir_struct* dd;
struct fat16_file_struct * fd;

int openroot(void)
{
   11e60:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    /* open first partition */
    partition = partition_open((device_read_t) sd_raw_read,
   11e64:	e3a03000 	mov	r3, #0	; 0x0
   11e68:	e59f10ac 	ldr	r1, [pc, #172]	; 11f1c <.text+0x1f1c>
   11e6c:	e59f20ac 	ldr	r2, [pc, #172]	; 11f20 <.text+0x1f20>
   11e70:	e59f00ac 	ldr	r0, [pc, #172]	; 11f24 <.text+0x1f24>
   11e74:	eb000a30 	bl	1473c <partition_open>
   11e78:	e59f40a8 	ldr	r4, [pc, #168]	; 11f28 <.text+0x1f28>
   11e7c:	e1a0c000 	mov	ip, r0
                               (device_read_interval_t) sd_raw_read_interval,
                               (device_write_t) sd_raw_write,
                               0);

    if(!partition)
   11e80:	e35c0000 	cmp	ip, #0	; 0x0
    {
        /* If the partition did not open, assume the storage device
             *      * is a "superfloppy", i.e. has no MBR.
             *           */
        partition = partition_open((device_read_t) sd_raw_read,
   11e84:	e3e03000 	mvn	r3, #0	; 0x0
   11e88:	e59f108c 	ldr	r1, [pc, #140]	; 11f1c <.text+0x1f1c>
   11e8c:	e59f208c 	ldr	r2, [pc, #140]	; 11f20 <.text+0x1f20>
   11e90:	e59f008c 	ldr	r0, [pc, #140]	; 11f24 <.text+0x1f24>
                                   (device_read_interval_t) sd_raw_read_interval,
                                   (device_write_t) sd_raw_write,
                                   -1);
        if(!partition)
        {
            rprintf("opening partition failed\n\r");
            return 1;
        }
    }

    /* open file system */
    fs = fat16_open(partition);
   11e94:	e59f5090 	ldr	r5, [pc, #144]	; 11f2c <.text+0x1f2c>
   11e98:	e584c000 	str	ip, [r4]
   11e9c:	1a000005 	bne	11eb8 <openroot+0x58>
   11ea0:	eb000a25 	bl	1473c <partition_open>
   11ea4:	e1a03000 	mov	r3, r0
   11ea8:	e3530000 	cmp	r3, #0	; 0x0
   11eac:	e59f007c 	ldr	r0, [pc, #124]	; 11f30 <.text+0x1f30>
   11eb0:	e5843000 	str	r3, [r4]
   11eb4:	0a000013 	beq	11f08 <openroot+0xa8>
   11eb8:	e59f3068 	ldr	r3, [pc, #104]	; 11f28 <.text+0x1f28>
   11ebc:	e5930000 	ldr	r0, [r3]
   11ec0:	eb000408 	bl	12ee8 <fat16_open>
    if(!fs)
   11ec4:	e3500000 	cmp	r0, #0	; 0x0
   11ec8:	e5850000 	str	r0, [r5]
    {
        rprintf("opening filesystem failed\n\r");
        return 1;
    }

    /* open root directory */
    fat16_get_dir_entry_of_path(fs, "/", &dir_entry);
   11ecc:	e59f2060 	ldr	r2, [pc, #96]	; 11f34 <.text+0x1f34>
   11ed0:	e59f1060 	ldr	r1, [pc, #96]	; 11f38 <.text+0x1f38>
   11ed4:	059f0060 	ldreq	r0, [pc, #96]	; 11f3c <.text+0x1f3c>
   11ed8:	0a00000a 	beq	11f08 <openroot+0xa8>
   11edc:	eb00067c 	bl	138d4 <fat16_get_dir_entry_of_path>

    dd = fat16_open_dir(fs, &dir_entry);
   11ee0:	e59f104c 	ldr	r1, [pc, #76]	; 11f34 <.text+0x1f34>
   11ee4:	e5950000 	ldr	r0, [r5]
   11ee8:	eb00065a 	bl	13858 <fat16_open_dir>
   11eec:	e59f304c 	ldr	r3, [pc, #76]	; 11f40 <.text+0x1f40>
   11ef0:	e1a02000 	mov	r2, r0
    if(!dd)
   11ef4:	e3500000 	cmp	r0, #0	; 0x0
   11ef8:	e3a01000 	mov	r1, #0	; 0x0
    {
        rprintf("opening root directory failed\n\r");
   11efc:	e59f0040 	ldr	r0, [pc, #64]	; 11f44 <.text+0x1f44>
   11f00:	e5832000 	str	r2, [r3]
   11f04:	1a000001 	bne	11f10 <openroot+0xb0>
   11f08:	ebfffed2 	bl	11a58 <rprintf>
   11f0c:	e3a01001 	mov	r1, #1	; 0x1
        return 1;
    }
    return 0;
}
   11f10:	e1a00001 	mov	r0, r1
   11f14:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   11f18:	e12fff1e 	bx	lr
   11f1c:	00012980 	andeq	r2, r1, r0, lsl #19
   11f20:	00012594 	muleq	r1, r4, r5
   11f24:	0001242c 	andeq	r2, r1, ip, lsr #8
   11f28:	400018a8 	andmi	r1, r0, r8, lsr #17
   11f2c:	40001874 	andmi	r1, r0, r4, ror r8
   11f30:	00018c88 	andeq	r8, r1, r8, lsl #25
   11f34:	40001878 	andmi	r1, r0, r8, ror r8
   11f38:	00018cc0 	andeq	r8, r1, r0, asr #25
   11f3c:	00018ca4 	andeq	r8, r1, r4, lsr #25
   11f40:	400018ac 	andmi	r1, r0, ip, lsr #17
   11f44:	00018cc4 	andeq	r8, r1, r4, asr #25

00011f48 <root_file_exists>:

/* returns 1 if file exists, 0 else */
int root_file_exists(char* name)
{
   11f48:	e52de004 	str	lr, [sp, #-4]!
    return(find_file_in_dir(fs,dd,name,&dir_entry));
   11f4c:	e59f301c 	ldr	r3, [pc, #28]	; 11f70 <.text+0x1f70>
   11f50:	e5931000 	ldr	r1, [r3]
   11f54:	e59f3018 	ldr	r3, [pc, #24]	; 11f74 <.text+0x1f74>
   11f58:	e1a02000 	mov	r2, r0
   11f5c:	e5930000 	ldr	r0, [r3]
   11f60:	e59f3010 	ldr	r3, [pc, #16]	; 11f78 <.text+0x1f78>
   11f64:	eb0009cc 	bl	1469c <find_file_in_dir>
}
   11f68:	e49de004 	ldr	lr, [sp], #4
   11f6c:	e12fff1e 	bx	lr
   11f70:	400018ac 	andmi	r1, r0, ip, lsr #17
   11f74:	40001874 	andmi	r1, r0, r4, ror r8
   11f78:	40001878 	andmi	r1, r0, r8, ror r8

00011f7c <root_open_new>:

/* returns NULL if error, pointer if file opened */
struct fat16_file_struct * root_open_new(char* name)
{
   11f7c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    if(fat16_create_file(dd,name,&dir_entry))
   11f80:	e59f5030 	ldr	r5, [pc, #48]	; 11fb8 <.text+0x1fb8>
   11f84:	e1a04000 	mov	r4, r0
   11f88:	e1a01000 	mov	r1, r0
   11f8c:	e59f2028 	ldr	r2, [pc, #40]	; 11fbc <.text+0x1fbc>
   11f90:	e5950000 	ldr	r0, [r5]
   11f94:	eb00094d 	bl	144d0 <fat16_create_file>
   11f98:	e3500000 	cmp	r0, #0	; 0x0
    {
        return(open_file_in_dir(fs,dd,name));
   11f9c:	e1a02004 	mov	r2, r4
   11fa0:	159f3018 	ldrne	r3, [pc, #24]	; 11fc0 <.text+0x1fc0>
   11fa4:	15951000 	ldrne	r1, [r5]
   11fa8:	15930000 	ldrne	r0, [r3]
   11fac:	1b0009d1 	blne	146f8 <open_file_in_dir>
    }
    else
    {
        return NULL;
    }
}
   11fb0:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   11fb4:	e12fff1e 	bx	lr
   11fb8:	400018ac 	andmi	r1, r0, ip, lsr #17
   11fbc:	40001878 	andmi	r1, r0, r8, ror r8
   11fc0:	40001874 	andmi	r1, r0, r4, ror r8

00011fc4 <root_open>:

struct fat16_file_struct * root_open(char* name)
{
   11fc4:	e52de004 	str	lr, [sp, #-4]!
    return(open_file_in_dir(fs,dd,name));
   11fc8:	e59f3018 	ldr	r3, [pc, #24]	; 11fe8 <.text+0x1fe8>
   11fcc:	e5931000 	ldr	r1, [r3]
   11fd0:	e59f3014 	ldr	r3, [pc, #20]	; 11fec <.text+0x1fec>
   11fd4:	e1a02000 	mov	r2, r0
   11fd8:	e5930000 	ldr	r0, [r3]
   11fdc:	eb0009c5 	bl	146f8 <open_file_in_dir>
}
   11fe0:	e49de004 	ldr	lr, [sp], #4
   11fe4:	e12fff1e 	bx	lr
   11fe8:	400018ac 	andmi	r1, r0, ip, lsr #17
   11fec:	40001874 	andmi	r1, r0, r4, ror r8

00011ff0 <print_disk_info>:

uint8_t print_disk_info(const struct fat16_fs_struct* disk_fs)
{
   11ff0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    if(!disk_fs)
   11ff4:	e2505000 	subs	r5, r0, #0	; 0x0
   11ff8:	e24dd01c 	sub	sp, sp, #28	; 0x1c
        return 0;

    struct sd_raw_info disk_info;
    if(!sd_raw_get_info(&disk_info))
   11ffc:	e1a0400d 	mov	r4, sp
   12000:	e1a0000d 	mov	r0, sp
   12004:	0a00002d 	beq	120c0 <print_disk_info+0xd0>
   12008:	eb00029a 	bl	12a78 <sd_raw_get_info>
   1200c:	e3500000 	cmp	r0, #0	; 0x0
        return 0;

//    int temp = get_output();
//    set_output(UART_ONLY);
    rprintf("manuf:  0x%02x\n\r", disk_info.manufacturer);
   12010:	e59f00b8 	ldr	r0, [pc, #184]	; 120d0 <.text+0x20d0>
   12014:	0a000029 	beq	120c0 <print_disk_info+0xd0>
   12018:	e5dd1000 	ldrb	r1, [sp]
   1201c:	ebfffe8d 	bl	11a58 <rprintf>
    rprintf("oem:    %s\n\r", disk_info.oem);
   12020:	e59f00ac 	ldr	r0, [pc, #172]	; 120d4 <.text+0x20d4>
   12024:	e28d1001 	add	r1, sp, #1	; 0x1
   12028:	ebfffe8a 	bl	11a58 <rprintf>
    rprintf("prod:   %s\n\r", disk_info.product);
   1202c:	e28d1004 	add	r1, sp, #4	; 0x4
   12030:	e59f00a0 	ldr	r0, [pc, #160]	; 120d8 <.text+0x20d8>
   12034:	ebfffe87 	bl	11a58 <rprintf>
    rprintf("rev:    %02x\n\r", disk_info.revision);
   12038:	e59f009c 	ldr	r0, [pc, #156]	; 120dc <.text+0x20dc>
   1203c:	e5dd100a 	ldrb	r1, [sp, #10]
   12040:	ebfffe84 	bl	11a58 <rprintf>
    rprintf("serial: 0x%08lx\n\r", disk_info.serial);
   12044:	e59f0094 	ldr	r0, [pc, #148]	; 120e0 <.text+0x20e0>
   12048:	e59d100c 	ldr	r1, [sp, #12]
   1204c:	ebfffe81 	bl	11a58 <rprintf>
    rprintf("date:   %02d/%02d\n\r", disk_info.manufacturing_month, disk_info.manufacturing_year);
   12050:	e5dd2010 	ldrb	r2, [sp, #16]
   12054:	e59f0088 	ldr	r0, [pc, #136]	; 120e4 <.text+0x20e4>
   12058:	e5dd1011 	ldrb	r1, [sp, #17]
   1205c:	ebfffe7d 	bl	11a58 <rprintf>
    rprintf("size:   %ld\n\r", disk_info.capacity);
   12060:	e59f0080 	ldr	r0, [pc, #128]	; 120e8 <.text+0x20e8>
   12064:	e59d1014 	ldr	r1, [sp, #20]
   12068:	ebfffe7a 	bl	11a58 <rprintf>
    rprintf("copy:   %d\n\r", disk_info.flag_copy);
   1206c:	e59f0078 	ldr	r0, [pc, #120]	; 120ec <.text+0x20ec>
   12070:	e5dd1018 	ldrb	r1, [sp, #24]
   12074:	ebfffe77 	bl	11a58 <rprintf>
    rprintf("wr.pr.: %d/%d\n\r", disk_info.flag_write_protect_temp, disk_info.flag_write_protect);
   12078:	e5dd2019 	ldrb	r2, [sp, #25]
   1207c:	e59f006c 	ldr	r0, [pc, #108]	; 120f0 <.text+0x20f0>
   12080:	e5dd101a 	ldrb	r1, [sp, #26]
   12084:	ebfffe73 	bl	11a58 <rprintf>
    rprintf("format: %d\n\r", disk_info.format);
   12088:	e5dd101b 	ldrb	r1, [sp, #27]
   1208c:	e59f0060 	ldr	r0, [pc, #96]	; 120f4 <.text+0x20f4>
   12090:	ebfffe70 	bl	11a58 <rprintf>
    rprintf("free:   %ld/%ld\n\r", fat16_get_fs_free(disk_fs), fat16_get_fs_size(disk_fs));
   12094:	e1a00005 	mov	r0, r5
   12098:	eb0008c9 	bl	143c4 <fat16_get_fs_free>
   1209c:	e1a04000 	mov	r4, r0
   120a0:	e1a00005 	mov	r0, r5
   120a4:	eb0008bd 	bl	143a0 <fat16_get_fs_size>
   120a8:	e1a01004 	mov	r1, r4
   120ac:	e1a02000 	mov	r2, r0
   120b0:	e59f0040 	ldr	r0, [pc, #64]	; 120f8 <.text+0x20f8>
   120b4:	ebfffe67 	bl	11a58 <rprintf>
   120b8:	e3a00001 	mov	r0, #1	; 0x1
   120bc:	ea000000 	b	120c4 <print_disk_info+0xd4>
//    set_output(temp);
    return 1;
   120c0:	e3a00000 	mov	r0, #0	; 0x0
}
   120c4:	e28dd01c 	add	sp, sp, #28	; 0x1c
   120c8:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   120cc:	e12fff1e 	bx	lr
   120d0:	00018ce4 	andeq	r8, r1, r4, ror #25
   120d4:	00018cf8 	streqd	r8, [r1], -r8
   120d8:	00018d08 	andeq	r8, r1, r8, lsl #26
   120dc:	00018d18 	andeq	r8, r1, r8, lsl sp
   120e0:	00018d28 	andeq	r8, r1, r8, lsr #26
   120e4:	00018d3c 	andeq	r8, r1, ip, lsr sp
   120e8:	00018d50 	andeq	r8, r1, r0, asr sp
   120ec:	00018d60 	andeq	r8, r1, r0, ror #26
   120f0:	00018d70 	andeq	r8, r1, r0, ror sp
   120f4:	00018d80 	andeq	r8, r1, r0, lsl #27
   120f8:	00018d90 	muleq	r1, r0, sp

000120fc <root_disk_info>:

void root_disk_info(void)
{
    print_disk_info(fs);
   120fc:	e59f3004 	ldr	r3, [pc, #4]	; 12108 <.text+0x2108>
   12100:	e5930000 	ldr	r0, [r3]
   12104:	eaffffb9 	b	11ff0 <print_disk_info>
   12108:	40001874 	andmi	r1, r0, r4, ror r8

0001210c <rootDirectory_files_stream>:
}

/* sequential calls return sequential characters
 * of the sequence of file names in the rootdir
 * in place of '\0' it returns ',' only
 * returning a zero when the end of all files
 * has been reached.
 *
 * Assert (1) reset whenever you want to re-start
 */
char rootDirectory_files_stream(int reset)
{

    static int idx = 0;

    /* If reset, we need to reset the dir */
    if(reset)
   1210c:	e3500000 	cmp	r0, #0	; 0x0
   12110:	e52de004 	str	lr, [sp, #-4]!
   12114:	0a000004 	beq	1212c <rootDirectory_files_stream+0x20>
    {
        fat16_reset_dir(dd);
   12118:	e59f3064 	ldr	r3, [pc, #100]	; 12184 <.text+0x2184>
   1211c:	e5930000 	ldr	r0, [r3]
   12120:	eb0006bc 	bl	13c18 <fat16_reset_dir>
   12124:	e3a00000 	mov	r0, #0	; 0x0
   12128:	ea000013 	b	1217c <rootDirectory_files_stream+0x70>
        return 0;
    }

    /* Whenever IDX is zero, we're gonna start a new file,
       * so read a new one.
       * if there's no new file,
       * return 0, because it's over
       */
    if(idx == 0)
   1212c:	e59f3054 	ldr	r3, [pc, #84]	; 12188 <.text+0x2188>
   12130:	e5933000 	ldr	r3, [r3]
   12134:	e3530000 	cmp	r3, #0	; 0x0
    {
        if(fat16_read_dir(dd,&dir_entry)==0)
   12138:	e59f104c 	ldr	r1, [pc, #76]	; 1218c <.text+0x218c>
   1213c:	1a000004 	bne	12154 <rootDirectory_files_stream+0x48>
   12140:	e59f303c 	ldr	r3, [pc, #60]	; 12184 <.text+0x2184>
   12144:	e5930000 	ldr	r0, [r3]
   12148:	eb00049e 	bl	133c8 <fat16_read_dir>
   1214c:	e3500000 	cmp	r0, #0	; 0x0
   12150:	0a000009 	beq	1217c <rootDirectory_files_stream+0x70>
        {
            return '\0';
        }
    }

    /* If we've reached the end of a string,
       * return comma instead of \0,
       * so the list is comma delimited,
       * and terminated with a zero
       */
    if(dir_entry.long_name[idx]=='\0')
   12154:	e59f102c 	ldr	r1, [pc, #44]	; 12188 <.text+0x2188>
   12158:	e59f302c 	ldr	r3, [pc, #44]	; 1218c <.text+0x218c>
   1215c:	e5912000 	ldr	r2, [r1]
   12160:	e7d33002 	ldrb	r3, [r3, r2]
    {
        idx = 0;
        return ',';
    }


    return dir_entry.long_name[idx++];
   12164:	e2822001 	add	r2, r2, #1	; 0x1
   12168:	e3530000 	cmp	r3, #0	; 0x0
   1216c:	05813000 	streq	r3, [r1]
   12170:	15812000 	strne	r2, [r1]
   12174:	e3a0002c 	mov	r0, #44	; 0x2c
   12178:	11a00003 	movne	r0, r3

}
   1217c:	e49de004 	ldr	lr, [sp], #4
   12180:	e12fff1e 	bx	lr
   12184:	400018ac 	andmi	r1, r0, ip, lsr #17
   12188:	40001358 	andmi	r1, r0, r8, asr r3
   1218c:	40001878 	andmi	r1, r0, r8, ror r8

00012190 <rootDirectory_files>:
//Description: Fills buf with len number of chars.  Returns the number of files
//				that were cycled through during the read
//Pre: buf is an array of characters at least as big as len
//		len is the size of the array to read
//Post: buf contains the characters of the filenames in Root, starting at the first file
//		and ending after len characters
int rootDirectory_files(char* buf, int len)
{
   12190:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    int i;
    int num=0;
    /* Loop will walk through every file in directory dd */
    fat16_reset_dir(dd);
   12194:	e59f30ac 	ldr	r3, [pc, #172]	; 12248 <.text+0x2248>
   12198:	e1a04000 	mov	r4, r0
   1219c:	e5930000 	ldr	r0, [r3]
   121a0:	e1a05001 	mov	r5, r1
   121a4:	eb00069b 	bl	13c18 <fat16_reset_dir>
   121a8:	e3a06000 	mov	r6, #0	; 0x0
   121ac:	ea00001b 	b	12220 <rootDirectory_files+0x90>
    while(fat16_read_dir(dd,&dir_entry))
    {
        i = 0;
        /* Spin through the filename */
        while(dir_entry.long_name[i]!='\0')
        {
            /* And copy each character into buf */
            *buf++=dir_entry.long_name[i++];
            len--;
            if(len==1)
   121b0:	e1500003 	cmp	r0, r3
   121b4:	e5c41000 	strb	r1, [r4]
   121b8:	e1a0400c 	mov	r4, ip
   121bc:	1a000005 	bne	121d8 <rootDirectory_files+0x48>
            {
                /* Buf if we ever get to the end of buf, quit */
                *buf='\0';
   121c0:	e3a03000 	mov	r3, #0	; 0x0
   121c4:	e3a06001 	mov	r6, #1	; 0x1
   121c8:	e5cc3000 	strb	r3, [ip]
   121cc:	ea00001a 	b	1223c <rootDirectory_files+0xac>
                return 1;
   121d0:	e59f0074 	ldr	r0, [pc, #116]	; 1224c <.text+0x224c>
   121d4:	e1a0e005 	mov	lr, r5
   121d8:	e5d01000 	ldrb	r1, [r0]
   121dc:	e59f306c 	ldr	r3, [pc, #108]	; 12250 <.text+0x2250>
   121e0:	e24e2001 	sub	r2, lr, #1	; 0x1
   121e4:	e3510000 	cmp	r1, #0	; 0x0
   121e8:	e0853003 	add	r3, r5, r3
   121ec:	e2800001 	add	r0, r0, #1	; 0x1
   121f0:	e1a0e002 	mov	lr, r2
   121f4:	e284c001 	add	ip, r4, #1	; 0x1
   121f8:	1affffec 	bne	121b0 <rootDirectory_files+0x20>
            }
        }
        *buf++=',';
   121fc:	e3a0302c 	mov	r3, #44	; 0x2c
        num++;
        len--;
        if(len==1)
   12200:	e3520001 	cmp	r2, #1	; 0x1
   12204:	e5c43000 	strb	r3, [r4]
   12208:	e2866001 	add	r6, r6, #1	; 0x1
   1220c:	e1a0400c 	mov	r4, ip
   12210:	e1a05002 	mov	r5, r2
        {
            /* Buf if we ever get to the end of buf, quit */
            *buf='\0';
   12214:	01a06002 	moveq	r6, r2
   12218:	05cc1000 	streqb	r1, [ip]
   1221c:	0a000006 	beq	1223c <rootDirectory_files+0xac>
   12220:	e59f3020 	ldr	r3, [pc, #32]	; 12248 <.text+0x2248>
   12224:	e59f1020 	ldr	r1, [pc, #32]	; 1224c <.text+0x224c>
   12228:	e5930000 	ldr	r0, [r3]
   1222c:	eb000465 	bl	133c8 <fat16_read_dir>
   12230:	e3500000 	cmp	r0, #0	; 0x0
   12234:	1affffe5 	bne	121d0 <rootDirectory_files+0x40>
            return 1;
        }
    }
    *buf='\0';
   12238:	e5c40000 	strb	r0, [r4]
    return num;
}
   1223c:	e1a00006 	mov	r0, r6
   12240:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   12244:	e12fff1e 	bx	lr
   12248:	400018ac 	andmi	r1, r0, ip, lsr #17
   1224c:	40001878 	andmi	r1, r0, r8, ror r8
   12250:	40001877 	andmi	r1, r0, r7, ror r8

00012254 <root_format>:

void root_format(void)
{
   12254:	e92d4010 	stmdb	sp!, {r4, lr}
    fat16_reset_dir(dd);
   12258:	e59f303c 	ldr	r3, [pc, #60]	; 1229c <.text+0x229c>
   1225c:	e5930000 	ldr	r0, [r3]
   12260:	ea000003 	b	12274 <root_format+0x20>
    while(fat16_read_dir(dd,&dir_entry))
    {
        fat16_delete_file(fs,&dir_entry);
   12264:	e59f3034 	ldr	r3, [pc, #52]	; 122a0 <.text+0x22a0>
   12268:	e5930000 	ldr	r0, [r3]
   1226c:	eb000820 	bl	142f4 <fat16_delete_file>
        fat16_reset_dir(dd);
   12270:	e5940000 	ldr	r0, [r4]
   12274:	e59f4020 	ldr	r4, [pc, #32]	; 1229c <.text+0x229c>
   12278:	eb000666 	bl	13c18 <fat16_reset_dir>
   1227c:	e59f1020 	ldr	r1, [pc, #32]	; 122a4 <.text+0x22a4>
   12280:	e5940000 	ldr	r0, [r4]
   12284:	eb00044f 	bl	133c8 <fat16_read_dir>
   12288:	e3500000 	cmp	r0, #0	; 0x0
   1228c:	e59f1010 	ldr	r1, [pc, #16]	; 122a4 <.text+0x22a4>
   12290:	1afffff3 	bne	12264 <root_format+0x10>
    }
}
   12294:	e8bd4010 	ldmia	sp!, {r4, lr}
   12298:	e12fff1e 	bx	lr
   1229c:	400018ac 	andmi	r1, r0, ip, lsr #17
   122a0:	40001874 	andmi	r1, r0, r4, ror r8
   122a4:	40001878 	andmi	r1, r0, r8, ror r8

000122a8 <root_delete>:

int root_delete(char* filename)
{
   122a8:	e92d4010 	stmdb	sp!, {r4, lr}
    if(find_file_in_dir(fs,dd,filename,&dir_entry))
   122ac:	e59f3038 	ldr	r3, [pc, #56]	; 122ec <.text+0x22ec>
   122b0:	e59f4038 	ldr	r4, [pc, #56]	; 122f0 <.text+0x22f0>
   122b4:	e5931000 	ldr	r1, [r3]
   122b8:	e1a02000 	mov	r2, r0
   122bc:	e59f3030 	ldr	r3, [pc, #48]	; 122f4 <.text+0x22f4>
   122c0:	e5940000 	ldr	r0, [r4]
   122c4:	eb0008f4 	bl	1469c <find_file_in_dir>
   122c8:	e3500000 	cmp	r0, #0	; 0x0
    {
        fat16_delete_file(fs,&dir_entry);
   122cc:	e59f1020 	ldr	r1, [pc, #32]	; 122f4 <.text+0x22f4>
   122d0:	e3a00001 	mov	r0, #1	; 0x1
   122d4:	0a000002 	beq	122e4 <root_delete+0x3c>
   122d8:	e5940000 	ldr	r0, [r4]
   122dc:	eb000804 	bl	142f4 <fat16_delete_file>
   122e0:	e3a00000 	mov	r0, #0	; 0x0
        return 0;
    }
    return 1;
}
   122e4:	e8bd4010 	ldmia	sp!, {r4, lr}
   122e8:	e12fff1e 	bx	lr
   122ec:	400018ac 	andmi	r1, r0, ip, lsr #17
   122f0:	40001874 	andmi	r1, r0, r4, ror r8
   122f4:	40001878 	andmi	r1, r0, r8, ror r8

000122f8 <sd_raw_available>:
 */
unsigned char sd_raw_available()
{
    unsigned int i;
    configure_pin_available();
   122f8:	e59f2044 	ldr	r2, [pc, #68]	; 12344 <.text+0x2344>
   122fc:	e5923000 	ldr	r3, [r2]
   12300:	e3c33080 	bic	r3, r3, #128	; 0x80
   12304:	e5823000 	str	r3, [r2]
   12308:	e3a02000 	mov	r2, #0	; 0x0
    for(i=0;i<100000;i++);
   1230c:	e59f3034 	ldr	r3, [pc, #52]	; 12348 <.text+0x2348>
   12310:	e2822001 	add	r2, r2, #1	; 0x1
   12314:	e1520003 	cmp	r2, r3
   12318:	1afffffb 	bne	1230c <sd_raw_available+0x14>
    i = get_pin_available();
   1231c:	e59f3028 	ldr	r3, [pc, #40]	; 1234c <.text+0x234c>
    configure_pin_ss();
   12320:	e59f101c 	ldr	r1, [pc, #28]	; 12344 <.text+0x2344>
   12324:	e5932000 	ldr	r2, [r3]
   12328:	e5913000 	ldr	r3, [r1]
   1232c:	e3120080 	tst	r2, #128	; 0x80
   12330:	e3833080 	orr	r3, r3, #128	; 0x80
    return i == 0x00;
}
   12334:	03a00000 	moveq	r0, #0	; 0x0
   12338:	13a00001 	movne	r0, #1	; 0x1
   1233c:	e5813000 	str	r3, [r1]
   12340:	e12fff1e 	bx	lr
   12344:	e0028008 	and	r8, r2, r8
   12348:	000186a0 	andeq	r8, r1, r0, lsr #13
   1234c:	e0028000 	and	r8, r2, r0

00012350 <sd_raw_rec_byte>:

/**
 * \ingroup sd_raw
 * Checks wether the memory card is locked for write access.
 *
 * \returns 1 if the card is locked, 0 if it is not.
 */
unsigned char sd_raw_locked()
{
    return get_pin_locked() == 0x00;
}

/**
 * \ingroup sd_raw
 * Sends a raw byte to the memory card.
 *
 * \param[in] b The byte to sent.
 * \see sd_raw_rec_byte
 */
void sd_raw_send_byte(unsigned char b)
{
    S0SPDR = b;
    /* wait for byte to be shifted out */
    while(!(S0SPSR & 0x80));
}

/**
 * \ingroup sd_raw
 * Receives a raw byte from the memory card.
 *
 * \returns The byte which should be read.
 * \see sd_raw_send_byte
 */
unsigned char sd_raw_rec_byte(void)
{
    /* send dummy data for receiving some */
    S0SPDR = 0xff;
   12350:	e59f3024 	ldr	r3, [pc, #36]	; 1237c <.text+0x237c>
   12354:	e3a020ff 	mov	r2, #255	; 0xff
   12358:	e5832000 	str	r2, [r3]
    while(!(S0SPSR & 0x80));
   1235c:	e59f301c 	ldr	r3, [pc, #28]	; 12380 <.text+0x2380>
   12360:	e5933000 	ldr	r3, [r3]
   12364:	e3130080 	tst	r3, #128	; 0x80
   12368:	0afffffb 	beq	1235c <sd_raw_rec_byte+0xc>

    return S0SPDR;
   1236c:	e59f3008 	ldr	r3, [pc, #8]	; 1237c <.text+0x237c>
   12370:	e5930000 	ldr	r0, [r3]
   12374:	e20000ff 	and	r0, r0, #255	; 0xff
}
   12378:	e12fff1e 	bx	lr
   1237c:	e0020008 	and	r0, r2, r8
   12380:	e0020004 	and	r0, r2, r4

00012384 <sd_raw_locked>:
   12384:	e3a00001 	mov	r0, #1	; 0x1
   12388:	e12fff1e 	bx	lr

0001238c <sd_raw_send_byte>:
   1238c:	e59f3018 	ldr	r3, [pc, #24]	; 123ac <.text+0x23ac>
   12390:	e20000ff 	and	r0, r0, #255	; 0xff
   12394:	e5830000 	str	r0, [r3]
   12398:	e59f3010 	ldr	r3, [pc, #16]	; 123b0 <.text+0x23b0>
   1239c:	e5933000 	ldr	r3, [r3]
   123a0:	e3130080 	tst	r3, #128	; 0x80
   123a4:	0afffffb 	beq	12398 <sd_raw_send_byte+0xc>
   123a8:	e12fff1e 	bx	lr
   123ac:	e0020008 	and	r0, r2, r8
   123b0:	e0020004 	and	r0, r2, r4

000123b4 <sd_raw_send_command_r1>:

/**
 * \ingroup sd_raw
 * Send a command to the memory card which responses with a R1 response.
 *
 * \param[in] command The command to send.
 * \param[in] arg The argument for command.
 * \returns The command answer.
 */
unsigned char sd_raw_send_command_r1(unsigned char command, unsigned int arg)
{
   123b4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   123b8:	e20050ff 	and	r5, r0, #255	; 0xff
   123bc:	e1a04001 	mov	r4, r1
    unsigned char response;
    unsigned char i;

    /* wait some clock cycles */
    sd_raw_rec_byte();
   123c0:	ebffffe2 	bl	12350 <sd_raw_rec_byte>

    /* send command via SPI */
    sd_raw_send_byte(0x40 | command);
   123c4:	e3850040 	orr	r0, r5, #64	; 0x40
   123c8:	ebffffef 	bl	1238c <sd_raw_send_byte>
    sd_raw_send_byte((arg >> 24) & 0xff);
   123cc:	e1a00c24 	mov	r0, r4, lsr #24
   123d0:	ebffffed 	bl	1238c <sd_raw_send_byte>
    sd_raw_send_byte((arg >> 16) & 0xff);
   123d4:	e1a00824 	mov	r0, r4, lsr #16
   123d8:	e20000ff 	and	r0, r0, #255	; 0xff
   123dc:	ebffffea 	bl	1238c <sd_raw_send_byte>
    sd_raw_send_byte((arg >> 8) & 0xff);
   123e0:	e1a00424 	mov	r0, r4, lsr #8
   123e4:	e20000ff 	and	r0, r0, #255	; 0xff
    sd_raw_send_byte((arg >> 0) & 0xff);
   123e8:	e20440ff 	and	r4, r4, #255	; 0xff
   123ec:	ebffffe6 	bl	1238c <sd_raw_send_byte>
   123f0:	e1a00004 	mov	r0, r4
   123f4:	ebffffe4 	bl	1238c <sd_raw_send_byte>
    sd_raw_send_byte((command == CMD_GO_IDLE_STATE) ? 0x95 : 0xff);
   123f8:	e3550000 	cmp	r5, #0	; 0x0
   123fc:	13a000ff 	movne	r0, #255	; 0xff
   12400:	03a00095 	moveq	r0, #149	; 0x95
   12404:	ebffffe0 	bl	1238c <sd_raw_send_byte>
   12408:	e3a0400a 	mov	r4, #10	; 0xa

    /* receive response */
    for(i = 0; i < 10; ++i)
    {
        response = sd_raw_rec_byte();
   1240c:	ebffffcf 	bl	12350 <sd_raw_rec_byte>
        if(response != 0xff)
   12410:	e35000ff 	cmp	r0, #255	; 0xff
            break;
   12414:	e2443001 	sub	r3, r4, #1	; 0x1
   12418:	1a000001 	bne	12424 <sd_raw_send_command_r1+0x70>
   1241c:	e21340ff 	ands	r4, r3, #255	; 0xff
   12420:	1afffff9 	bne	1240c <sd_raw_send_command_r1+0x58>
    }

    return response;
}
   12424:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   12428:	e12fff1e 	bx	lr

0001242c <sd_raw_read>:

/**
 * \ingroup sd_raw
 * Send a command to the memory card which responses with a R2 response.
 *
 * \param[in] command The command to send.
 * \param[in] arg The argument for command.
 * \returns The command answer.
 */
/*
unsigned short sd_raw_send_command_r2(unsigned char command, unsigned int arg)
{
    unsigned short response;
    unsigned char i;

    // wait some clock cycles
    sd_raw_rec_byte();

    // send command via SPI
    sd_raw_send_byte(0x40 | command);
    sd_raw_send_byte((arg >> 24) & 0xff);
    sd_raw_send_byte((arg >> 16) & 0xff);
    sd_raw_send_byte((arg >> 8) & 0xff);
    sd_raw_send_byte((arg >> 0) & 0xff);
    sd_raw_send_byte(command == CMD_GO_IDLE_STATE ? 0x95 : 0xff);

    // receive response
    for(i = 0; i < 10; ++i)
    {
        response = sd_raw_rec_byte();
        if(response != 0xff)
            break;
    }
    response <<= 8;
    response |= sd_raw_rec_byte();

    return response;
}
*/

/**
 * \ingroup sd_raw
 * Reads raw data from the card.
 *
 * \param[in] offset The offset from which to read.
 * \param[out] buffer The buffer into which to write the data.
 * \param[in] length The number of bytes to read.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_read_interval, sd_raw_write
 */
unsigned char sd_raw_read(unsigned int offset, unsigned char* buffer, unsigned short length)
{
   1242c:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12430:	e1a02802 	mov	r2, r2, lsl #16
   12434:	e1a09000 	mov	r9, r0
   12438:	e1a0a001 	mov	sl, r1
   1243c:	e1a08822 	mov	r8, r2, lsr #16
   12440:	ea000047 	b	12564 <sd_raw_read+0x138>
    unsigned int block_address;
    unsigned short block_offset;
    unsigned short read_length;
    while(length > 0)
    {
        /* determine byte count to read at once */
        block_address = offset & 0xfffffe00;
        block_offset = offset & 0x01ff;
   12444:	e1a07b89 	mov	r7, r9, lsl #23
   12448:	e1a07ba7 	mov	r7, r7, lsr #23
        read_length = 512 - block_offset; /* read up to block border */
        if(read_length > length)
            read_length = length;

        #if !SD_RAW_SAVE_RAM
            /* check if the requested data is cached */
            if(block_address != raw_block_address)
   1244c:	e59f3124 	ldr	r3, [pc, #292]	; 12578 <.text+0x2578>
   12450:	e2672c02 	rsb	r2, r7, #512	; 0x200
   12454:	e1a02802 	mov	r2, r2, lsl #16
   12458:	e5930000 	ldr	r0, [r3]
   1245c:	e3c96f7f 	bic	r6, r9, #508	; 0x1fc
   12460:	e3c66003 	bic	r6, r6, #3	; 0x3
   12464:	e1a05822 	mov	r5, r2, lsr #16
   12468:	e1550008 	cmp	r5, r8
   1246c:	21a05008 	movcs	r5, r8
   12470:	e1560000 	cmp	r6, r0
   12474:	0a000031 	beq	12540 <sd_raw_read+0x114>
            #endif
        {
            #if SD_RAW_WRITE_BUFFERING
                if(!raw_block_written)
   12478:	e59f30fc 	ldr	r3, [pc, #252]	; 1257c <.text+0x257c>
   1247c:	e5d33000 	ldrb	r3, [r3]
   12480:	e3530000 	cmp	r3, #0	; 0x0
   12484:	1a000004 	bne	1249c <sd_raw_read+0x70>
                {
                    if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
   12488:	e59f10f0 	ldr	r1, [pc, #240]	; 12580 <.text+0x2580>
   1248c:	e3a02c02 	mov	r2, #512	; 0x200
   12490:	eb00003f 	bl	12594 <sd_raw_write>
   12494:	e3500000 	cmp	r0, #0	; 0x0
   12498:	0a000034 	beq	12570 <sd_raw_read+0x144>
                        return 0;
                }
            #endif

            /* address card */
            select_card();
   1249c:	e59f20e0 	ldr	r2, [pc, #224]	; 12584 <.text+0x2584>
   124a0:	e5923000 	ldr	r3, [r2]
   124a4:	e3833080 	orr	r3, r3, #128	; 0x80

            /* send single block request */
            if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, block_address))
   124a8:	e3a00011 	mov	r0, #17	; 0x11
   124ac:	e1a01006 	mov	r1, r6
   124b0:	e5823000 	str	r3, [r2]
   124b4:	ebffffbe 	bl	123b4 <sd_raw_send_command_r1>
   124b8:	e3500000 	cmp	r0, #0	; 0x0
   124bc:	0a000005 	beq	124d8 <sd_raw_read+0xac>
            {
                unselect_card();
   124c0:	e59f20c0 	ldr	r2, [pc, #192]	; 12588 <.text+0x2588>
   124c4:	e5923000 	ldr	r3, [r2]
   124c8:	e3a00000 	mov	r0, #0	; 0x0
   124cc:	e3833080 	orr	r3, r3, #128	; 0x80
   124d0:	e5823000 	str	r3, [r2]
   124d4:	ea000025 	b	12570 <sd_raw_read+0x144>
                return 0;
            }

            /* wait for data block (start byte 0xfe) */
            while(sd_raw_rec_byte() != 0xfe);
   124d8:	ebffff9c 	bl	12350 <sd_raw_rec_byte>
   124dc:	e35000fe 	cmp	r0, #254	; 0xfe
   124e0:	1afffffc 	bne	124d8 <sd_raw_read+0xac>
   124e4:	e59f40a0 	ldr	r4, [pc, #160]	; 1258c <.text+0x258c>

            #if SD_RAW_SAVE_RAM
                /* read byte block */
                unsigned short read_to = block_offset + read_length;
                for(unsigned short i = 0; i < 512; ++i)
                {
                    unsigned char b = sd_raw_rec_byte();
                    if(i >= block_offset && i < read_to)
                        *buffer++ = b;
                }
            #else
                /* read byte block */
                unsigned char* cache = raw_block;
                unsigned short i;
                for(i = 0; i < 512; ++i)
                    *cache++ = sd_raw_rec_byte();
   124e8:	ebffff98 	bl	12350 <sd_raw_rec_byte>
   124ec:	e59f309c 	ldr	r3, [pc, #156]	; 12590 <.text+0x2590>
   124f0:	e5440001 	strb	r0, [r4, #-1]
   124f4:	e2844001 	add	r4, r4, #1	; 0x1
   124f8:	e1540003 	cmp	r4, r3
   124fc:	1afffff9 	bne	124e8 <sd_raw_read+0xbc>
                raw_block_address = block_address;
   12500:	e59f3070 	ldr	r3, [pc, #112]	; 12578 <.text+0x2578>
    
                memcpy(buffer, raw_block + block_offset, read_length);
   12504:	e59f1074 	ldr	r1, [pc, #116]	; 12580 <.text+0x2580>
   12508:	e1a02005 	mov	r2, r5
   1250c:	e5836000 	str	r6, [r3]
   12510:	e0871001 	add	r1, r7, r1
   12514:	e1a0000a 	mov	r0, sl
   12518:	eb0015de 	bl	17c98 <memcpy>
                buffer += read_length;
            #endif

            /* read crc16 */
            sd_raw_rec_byte();
   1251c:	ebffff8b 	bl	12350 <sd_raw_rec_byte>
            sd_raw_rec_byte();
   12520:	ebffff8a 	bl	12350 <sd_raw_rec_byte>

            /* deaddress card */
            unselect_card();
   12524:	e59f205c 	ldr	r2, [pc, #92]	; 12588 <.text+0x2588>
   12528:	e5923000 	ldr	r3, [r2]
   1252c:	e3833080 	orr	r3, r3, #128	; 0x80
   12530:	e5823000 	str	r3, [r2]
   12534:	e08aa005 	add	sl, sl, r5

            /* let card some time to finish */
            sd_raw_rec_byte();
   12538:	ebffff84 	bl	12350 <sd_raw_rec_byte>
   1253c:	ea000004 	b	12554 <sd_raw_read+0x128>
        }
        #if !SD_RAW_SAVE_RAM
            else
            {
                /* use cached data */
                memcpy(buffer, raw_block + block_offset, read_length);
   12540:	e59f1038 	ldr	r1, [pc, #56]	; 12580 <.text+0x2580>
   12544:	e1a0000a 	mov	r0, sl
   12548:	e0871001 	add	r1, r7, r1
   1254c:	e1a02005 	mov	r2, r5
   12550:	eb0015d0 	bl	17c98 <memcpy>
            }
        #endif

        length -= read_length;
   12554:	e0653008 	rsb	r3, r5, r8
   12558:	e1a03803 	mov	r3, r3, lsl #16
        offset += read_length;
   1255c:	e0899005 	add	r9, r9, r5
   12560:	e1a08823 	mov	r8, r3, lsr #16
   12564:	e3580000 	cmp	r8, #0	; 0x0
   12568:	1affffb5 	bne	12444 <sd_raw_read+0x18>
   1256c:	e3a00001 	mov	r0, #1	; 0x1
    }

    return 1;
}
   12570:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12574:	e12fff1e 	bx	lr
   12578:	40001360 	andmi	r1, r0, r0, ror #6
   1257c:	4000135c 	andmi	r1, r0, ip, asr r3
   12580:	40001364 	andmi	r1, r0, r4, ror #6
   12584:	e002800c 	and	r8, r2, ip
   12588:	e0028004 	and	r8, r2, r4
   1258c:	40001365 	andmi	r1, r0, r5, ror #6
   12590:	40001565 	andmi	r1, r0, r5, ror #10

00012594 <sd_raw_write>:

/**
 * \ingroup sd_raw
 * Continuously reads units of \c interval bytes and calls a callback function.
 *
 * This function starts reading at the specified offset. Every \c interval bytes,
 * it calls the callback function with the associated data buffer.
 *
 * By returning zero, the callback may stop reading.
 *
 * \note Within the callback function, you can not start another read or
 *       write operation.
 * \note This function only works if the following conditions are met:
 *       - (offset - (offset % 512)) % interval == 0
 *       - length % interval == 0
 *
 * \param[in] offset Offset from which to start reading.
 * \param[in] buffer Pointer to a buffer which is at least interval bytes in size.
 * \param[in] interval Number of bytes to read before calling the callback function.
 * \param[in] length Number of bytes to read altogether.
 * \param[in] callback The function to call every interval bytes.
 * \param[in] p An opaque pointer directly passed to the callback function.
 * \returns 0 on failure, 1 on success
 * \see sd_raw_read, sd_raw_write
 */
unsigned char sd_raw_read_interval(unsigned int offset, unsigned char* buffer, unsigned short interval, unsigned short length, sd_raw_interval_handler callback, void* p)
{
    if(!buffer || interval == 0 || length < interval || !callback)
        return 0;

    #if !SD_RAW_SAVE_RAM
        while(length >= interval)
        {
            /* as reading is now buffered, we directly
                     * hand over the request to sd_raw_read()
                     */
            if(!sd_raw_read(offset, buffer, interval))
                return 0;
            if(!callback(buffer, offset, p))
                break;
            offset += interval;
            length -= interval;
        }
    
        return 1;
    #else
        /* address card */
        select_card();
    
        unsigned short block_offset;
        unsigned short read_length;
        unsigned char* buffer_cur;
        unsigned char finished = 0;
        do
        {
            /* determine byte count to read at once */
            block_offset = offset & 0x01ff;
            read_length = 512 - block_offset;
    
            /* send single block request */
            if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, offset & 0xfffffe00))
            {
                unselect_card();
                return 0;
            }
    
            /* wait for data block (start byte 0xfe) */
            while(sd_raw_rec_byte() != 0xfe);
            unsigned short i;
            /* read up to the data of interest */
            for(i = 0; i < block_offset; ++i)
                sd_raw_rec_byte();
    
            /* read interval bytes of data and execute the callback */
            do
            {
                if(read_length < interval || length < interval)
                    break;
    
                buffer_cur = buffer;
                for(i = 0; i < interval; ++i)
                    *buffer_cur++ = sd_raw_rec_byte();
    
                if(!callback(buffer, offset + (512 - read_length), p))
                {
                    finished = 1;
                    break;
                }
    
                read_length -= interval;
                length -= interval;
    
            }
            while(read_length > 0 && length > 0);
    
            /* read rest of data block */
            while(read_length-- > 0)
                sd_raw_rec_byte();
    
            /* read crc16 */
            sd_raw_rec_byte();
            sd_raw_rec_byte();
    
            if(length < interval)
                break;
    
            offset = (offset & 0xfffffe00) + 512;
    
        }
        while(!finished);
    
        /* deaddress card */
        unselect_card();
    
        /* let card some time to finish */
        sd_raw_rec_byte();
    
        return 1;
    #endif
}

/**
 * \ingroup sd_raw
 * Writes raw data to the card.
 *
 * \note If write buffering is enabled, you might have to
 *       call sd_raw_sync() before disconnecting the card
 *       to ensure all remaining data has been written.
 *
 * \param[in] offset The offset where to start writing.
 * \param[in] buffer The buffer containing the data to be written.
 * \param[in] length The number of bytes to write.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_read
 */
unsigned char sd_raw_write(unsigned int offset, const unsigned char* buffer, unsigned short length)
{
   12594:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12598:	e1a02802 	mov	r2, r2, lsl #16
   1259c:	e1a09000 	mov	r9, r0
   125a0:	e1a0a001 	mov	sl, r1
   125a4:	ea000055 	b	12700 <sd_raw_write+0x16c>
    #if SD_RAW_WRITE_SUPPORT
    
        if(get_pin_locked())
            return 0;
    
        unsigned int block_address;
        unsigned short block_offset;
        unsigned short write_length;
        while(length > 0)
        {
            /* determine byte count to write at once */
            block_address = offset & 0xfffffe00;
            block_offset = offset & 0x01ff;
   125a8:	e1a06b89 	mov	r6, r9, lsl #23
   125ac:	e1a06ba6 	mov	r6, r6, lsr #23
            write_length = 512 - block_offset; /* write up to block border */
            if(write_length > length)
                write_length = length;
    
            /* Merge the data to write with the content of the block.
                     * Use the cached block if available.
                     */
            if(block_address != raw_block_address)
   125b0:	e59f7184 	ldr	r7, [pc, #388]	; 1273c <.text+0x273c>
   125b4:	e2663c02 	rsb	r3, r6, #512	; 0x200
   125b8:	e1a03803 	mov	r3, r3, lsl #16
   125bc:	e3c94f7f 	bic	r4, r9, #508	; 0x1fc
   125c0:	e5970000 	ldr	r0, [r7]
   125c4:	e3c44003 	bic	r4, r4, #3	; 0x3
   125c8:	e1a05823 	mov	r5, r3, lsr #16
   125cc:	e1550008 	cmp	r5, r8
   125d0:	21a05008 	movcs	r5, r8
   125d4:	e1540000 	cmp	r4, r0
   125d8:	0a000017 	beq	1263c <sd_raw_write+0xa8>
            {
                #if SD_RAW_WRITE_BUFFERING
                if(!raw_block_written)
   125dc:	e59f315c 	ldr	r3, [pc, #348]	; 12740 <.text+0x2740>
   125e0:	e5d33000 	ldrb	r3, [r3]
   125e4:	e3530000 	cmp	r3, #0	; 0x0
   125e8:	1a000004 	bne	12600 <sd_raw_write+0x6c>
                {
                    if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
   125ec:	e59f1150 	ldr	r1, [pc, #336]	; 12744 <.text+0x2744>
   125f0:	e3a02c02 	mov	r2, #512	; 0x200
   125f4:	ebffffe6 	bl	12594 <sd_raw_write>
   125f8:	e3500000 	cmp	r0, #0	; 0x0
   125fc:	0a000043 	beq	12710 <sd_raw_write+0x17c>
                        return 0;
                }
            #endif

            if(block_offset || write_length < 512)
   12600:	e59f3140 	ldr	r3, [pc, #320]	; 12748 <.text+0x2748>
   12604:	e1550003 	cmp	r5, r3
   12608:	83a03000 	movhi	r3, #0	; 0x0
   1260c:	93a03001 	movls	r3, #1	; 0x1
   12610:	e3560000 	cmp	r6, #0	; 0x0
   12614:	13833001 	orrne	r3, r3, #1	; 0x1
   12618:	e3530000 	cmp	r3, #0	; 0x0
   1261c:	0a000005 	beq	12638 <sd_raw_write+0xa4>
            {
                if(!sd_raw_read(block_address, raw_block, sizeof(raw_block)))
   12620:	e1a00004 	mov	r0, r4
   12624:	e59f1118 	ldr	r1, [pc, #280]	; 12744 <.text+0x2744>
   12628:	e3a02c02 	mov	r2, #512	; 0x200
   1262c:	ebffff7e 	bl	1242c <sd_raw_read>
   12630:	e3500000 	cmp	r0, #0	; 0x0
   12634:	0a000035 	beq	12710 <sd_raw_write+0x17c>
                    return 0;
            }
            raw_block_address = block_address;
   12638:	e5874000 	str	r4, [r7]
        }

        if(buffer != raw_block)
   1263c:	e59f7100 	ldr	r7, [pc, #256]	; 12744 <.text+0x2744>
   12640:	e15a0007 	cmp	sl, r7
   12644:	0a000008 	beq	1266c <sd_raw_write+0xd8>
        {
            memcpy(raw_block + block_offset, buffer, write_length);
   12648:	e1a02005 	mov	r2, r5
   1264c:	e0860007 	add	r0, r6, r7
   12650:	e1a0100a 	mov	r1, sl
   12654:	eb00158f 	bl	17c98 <memcpy>

            #if SD_RAW_WRITE_BUFFERING
                raw_block_written = 0;
   12658:	e59f30e0 	ldr	r3, [pc, #224]	; 12740 <.text+0x2740>
   1265c:	e3a02000 	mov	r2, #0	; 0x0
    
                if(length == write_length)
   12660:	e1580005 	cmp	r8, r5
   12664:	e5c32000 	strb	r2, [r3]
   12668:	0a000030 	beq	12730 <sd_raw_write+0x19c>
                    return 1;
            #endif
        }

        buffer += write_length;

        /* address card */
        select_card();
   1266c:	e59f20d8 	ldr	r2, [pc, #216]	; 1274c <.text+0x274c>
   12670:	e5923000 	ldr	r3, [r2]
   12674:	e3833080 	orr	r3, r3, #128	; 0x80

        /* send single block request */
        if(sd_raw_send_command_r1(CMD_WRITE_SINGLE_BLOCK, block_address))
   12678:	e1a01004 	mov	r1, r4
   1267c:	e3a00018 	mov	r0, #24	; 0x18
   12680:	e5823000 	str	r3, [r2]
   12684:	ebffff4a 	bl	123b4 <sd_raw_send_command_r1>
   12688:	e3500000 	cmp	r0, #0	; 0x0
   1268c:	e08aa005 	add	sl, sl, r5
   12690:	1a000020 	bne	12718 <sd_raw_write+0x184>
        {
            unselect_card();
            return 0;
        }

        /* send start byte */
        sd_raw_send_byte(0xfe);
   12694:	e28000fe 	add	r0, r0, #254	; 0xfe
   12698:	ebffff3b 	bl	1238c <sd_raw_send_byte>
   1269c:	e2874001 	add	r4, r7, #1	; 0x1

        /* write byte block */
        unsigned char* cache = raw_block;
        unsigned short i;
        for(i = 0; i < 512; ++i)
            sd_raw_send_byte(*cache++);
   126a0:	e5540001 	ldrb	r0, [r4, #-1]
   126a4:	ebffff38 	bl	1238c <sd_raw_send_byte>
   126a8:	e59f30a0 	ldr	r3, [pc, #160]	; 12750 <.text+0x2750>
   126ac:	e2844001 	add	r4, r4, #1	; 0x1
   126b0:	e1540003 	cmp	r4, r3
   126b4:	1afffff9 	bne	126a0 <sd_raw_write+0x10c>

        /* write dummy crc16 */
        sd_raw_send_byte(0xff);
   126b8:	e3a000ff 	mov	r0, #255	; 0xff
   126bc:	ebffff32 	bl	1238c <sd_raw_send_byte>
        sd_raw_send_byte(0xff);
   126c0:	e3a000ff 	mov	r0, #255	; 0xff
   126c4:	ebffff30 	bl	1238c <sd_raw_send_byte>

        /* wait while card is busy */
        while(sd_raw_rec_byte() != 0xff);
   126c8:	ebffff20 	bl	12350 <sd_raw_rec_byte>
   126cc:	e35000ff 	cmp	r0, #255	; 0xff
   126d0:	1afffffc 	bne	126c8 <sd_raw_write+0x134>
        sd_raw_rec_byte();
   126d4:	ebffff1d 	bl	12350 <sd_raw_rec_byte>

        /* deaddress card */
        unselect_card();
   126d8:	e59f1074 	ldr	r1, [pc, #116]	; 12754 <.text+0x2754>
   126dc:	e5913000 	ldr	r3, [r1]
   126e0:	e3833080 	orr	r3, r3, #128	; 0x80
   126e4:	e5813000 	str	r3, [r1]

        length -= write_length;
        offset += write_length;

        #if SD_RAW_WRITE_BUFFERING
            raw_block_written = 1;
   126e8:	e59f3050 	ldr	r3, [pc, #80]	; 12740 <.text+0x2740>
   126ec:	e3a01001 	mov	r1, #1	; 0x1
   126f0:	e0652008 	rsb	r2, r5, r8
   126f4:	e5c31000 	strb	r1, [r3]
   126f8:	e1a02802 	mov	r2, r2, lsl #16
   126fc:	e0899005 	add	r9, r9, r5
   12700:	e1a08822 	mov	r8, r2, lsr #16
   12704:	e3580000 	cmp	r8, #0	; 0x0
   12708:	1affffa6 	bne	125a8 <sd_raw_write+0x14>
   1270c:	ea000007 	b	12730 <sd_raw_write+0x19c>
   12710:	e3a00000 	mov	r0, #0	; 0x0
   12714:	ea000006 	b	12734 <sd_raw_write+0x1a0>
   12718:	e59f2034 	ldr	r2, [pc, #52]	; 12754 <.text+0x2754>
   1271c:	e5923000 	ldr	r3, [r2]
   12720:	e3a00000 	mov	r0, #0	; 0x0
   12724:	e3833080 	orr	r3, r3, #128	; 0x80
   12728:	e5823000 	str	r3, [r2]
   1272c:	ea000000 	b	12734 <sd_raw_write+0x1a0>
   12730:	e3a00001 	mov	r0, #1	; 0x1
        #endif
    }

    return 1;
    #else
        return 0;
    #endif
}
   12734:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12738:	e12fff1e 	bx	lr
   1273c:	40001360 	andmi	r1, r0, r0, ror #6
   12740:	4000135c 	andmi	r1, r0, ip, asr r3
   12744:	40001364 	andmi	r1, r0, r4, ror #6
   12748:	000001ff 	streqd	r0, [r0], -pc
   1274c:	e002800c 	and	r8, r2, ip
   12750:	40001565 	andmi	r1, r0, r5, ror #10
   12754:	e0028004 	and	r8, r2, r4

00012758 <sd_raw_init>:
   12758:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   1275c:	e59f61e0 	ldr	r6, [pc, #480]	; 12944 <.text+0x2944>
   12760:	e5963000 	ldr	r3, [r6]
   12764:	e3833080 	orr	r3, r3, #128	; 0x80
   12768:	e5863000 	str	r3, [r6]
   1276c:	e59f21d4 	ldr	r2, [pc, #468]	; 12948 <.text+0x2948>
   12770:	e5923000 	ldr	r3, [r2]
   12774:	e3833a01 	orr	r3, r3, #4096	; 0x1000
   12778:	e5823000 	str	r3, [r2]
   1277c:	e5923000 	ldr	r3, [r2]
   12780:	e3833b01 	orr	r3, r3, #1024	; 0x400
   12784:	e5823000 	str	r3, [r2]
   12788:	e5923000 	ldr	r3, [r2]
   1278c:	e3833c01 	orr	r3, r3, #256	; 0x100
   12790:	e5823000 	str	r3, [r2]
   12794:	e59f51b0 	ldr	r5, [pc, #432]	; 1294c <.text+0x294c>
   12798:	e5953000 	ldr	r3, [r5]
   1279c:	e3833080 	orr	r3, r3, #128	; 0x80
   127a0:	e5853000 	str	r3, [r5]
   127a4:	e59f31a4 	ldr	r3, [pc, #420]	; 12950 <.text+0x2950>
   127a8:	e3a02096 	mov	r2, #150	; 0x96
   127ac:	e5832000 	str	r2, [r3]
   127b0:	e3a02038 	mov	r2, #56	; 0x38
   127b4:	e243300c 	sub	r3, r3, #12	; 0xc
   127b8:	e5832000 	str	r2, [r3]
   127bc:	ebfffecd 	bl	122f8 <sd_raw_available>
   127c0:	e2504000 	subs	r4, r0, #0	; 0x0
   127c4:	059f0188 	ldreq	r0, [pc, #392]	; 12954 <.text+0x2954>
   127c8:	0a000059 	beq	12934 <sd_raw_init+0x1dc>
   127cc:	e5963000 	ldr	r3, [r6]
   127d0:	e3833080 	orr	r3, r3, #128	; 0x80
   127d4:	e5863000 	str	r3, [r6]
   127d8:	e5953000 	ldr	r3, [r5]
   127dc:	e3833080 	orr	r3, r3, #128	; 0x80
   127e0:	e5853000 	str	r3, [r5]
   127e4:	e3a04000 	mov	r4, #0	; 0x0
   127e8:	ebfffed8 	bl	12350 <sd_raw_rec_byte>
   127ec:	e2843001 	add	r3, r4, #1	; 0x1
   127f0:	e1a03803 	mov	r3, r3, lsl #16
   127f4:	e1a04823 	mov	r4, r3, lsr #16
   127f8:	e354000a 	cmp	r4, #10	; 0xa
   127fc:	1afffff9 	bne	127e8 <sd_raw_init+0x90>
   12800:	e59f2150 	ldr	r2, [pc, #336]	; 12958 <.text+0x2958>
   12804:	e5923000 	ldr	r3, [r2]
   12808:	e3833080 	orr	r3, r3, #128	; 0x80
   1280c:	e5823000 	str	r3, [r2]
   12810:	e3a04000 	mov	r4, #0	; 0x0
   12814:	e3a00000 	mov	r0, #0	; 0x0
   12818:	e1a01000 	mov	r1, r0
   1281c:	ebfffee4 	bl	123b4 <sd_raw_send_command_r1>
   12820:	e2843001 	add	r3, r4, #1	; 0x1
   12824:	e3500001 	cmp	r0, #1	; 0x1
   12828:	e1a02803 	mov	r2, r3, lsl #16
   1282c:	0a000004 	beq	12844 <sd_raw_init+0xec>
   12830:	e59f3124 	ldr	r3, [pc, #292]	; 1295c <.text+0x295c>
   12834:	e1540003 	cmp	r4, r3
   12838:	e1a04822 	mov	r4, r2, lsr #16
   1283c:	0a00002a 	beq	128ec <sd_raw_init+0x194>
   12840:	eafffff3 	b	12814 <sd_raw_init+0xbc>
   12844:	e3a04000 	mov	r4, #0	; 0x0
   12848:	e3a01000 	mov	r1, #0	; 0x0
   1284c:	e3a00001 	mov	r0, #1	; 0x1
   12850:	ebfffed7 	bl	123b4 <sd_raw_send_command_r1>
   12854:	e2843001 	add	r3, r4, #1	; 0x1
   12858:	e3100001 	tst	r0, #1	; 0x1
   1285c:	e1a02803 	mov	r2, r3, lsl #16
   12860:	0a000004 	beq	12878 <sd_raw_init+0x120>
   12864:	e59f30f4 	ldr	r3, [pc, #244]	; 12960 <.text+0x2960>
   12868:	e1540003 	cmp	r4, r3
   1286c:	e1a04822 	mov	r4, r2, lsr #16
   12870:	0a000026 	beq	12910 <sd_raw_init+0x1b8>
   12874:	eafffff3 	b	12848 <sd_raw_init+0xf0>
   12878:	e3a00010 	mov	r0, #16	; 0x10
   1287c:	e3a01c02 	mov	r1, #512	; 0x200
   12880:	ebfffecb 	bl	123b4 <sd_raw_send_command_r1>
   12884:	e3500000 	cmp	r0, #0	; 0x0
   12888:	159f20bc 	ldrne	r2, [pc, #188]	; 1294c <.text+0x294c>
   1288c:	15923000 	ldrne	r3, [r2]
   12890:	159f00cc 	ldrne	r0, [pc, #204]	; 12964 <.text+0x2964>
   12894:	13833080 	orrne	r3, r3, #128	; 0x80
   12898:	1a000020 	bne	12920 <sd_raw_init+0x1c8>
   1289c:	e59fc0a8 	ldr	ip, [pc, #168]	; 1294c <.text+0x294c>
   128a0:	e59c3000 	ldr	r3, [ip]
   128a4:	e3833080 	orr	r3, r3, #128	; 0x80
   128a8:	e58c3000 	str	r3, [ip]
   128ac:	e59f30b4 	ldr	r3, [pc, #180]	; 12968 <.text+0x2968>
   128b0:	e3e0c000 	mvn	ip, #0	; 0x0
   128b4:	e583c000 	str	ip, [r3]
   128b8:	e59f3090 	ldr	r3, [pc, #144]	; 12950 <.text+0x2950>
   128bc:	e28cc03d 	add	ip, ip, #61	; 0x3d
   128c0:	e583c000 	str	ip, [r3]
   128c4:	e59f30a0 	ldr	r3, [pc, #160]	; 1296c <.text+0x296c>
   128c8:	e3a05001 	mov	r5, #1	; 0x1
   128cc:	e59f109c 	ldr	r1, [pc, #156]	; 12970 <.text+0x2970>
   128d0:	e3a02c02 	mov	r2, #512	; 0x200
   128d4:	e5c35000 	strb	r5, [r3]
   128d8:	ebfffed3 	bl	1242c <sd_raw_read>
   128dc:	e2504000 	subs	r4, r0, #0	; 0x0
   128e0:	11a00005 	movne	r0, r5
   128e4:	1a000014 	bne	1293c <sd_raw_init+0x1e4>
   128e8:	ea000010 	b	12930 <sd_raw_init+0x1d8>
   128ec:	e1a01000 	mov	r1, r0
   128f0:	e59f007c 	ldr	r0, [pc, #124]	; 12974 <.text+0x2974>
   128f4:	ebfffc57 	bl	11a58 <rprintf>
   128f8:	e59f204c 	ldr	r2, [pc, #76]	; 1294c <.text+0x294c>
   128fc:	e5923000 	ldr	r3, [r2]
   12900:	e3a00000 	mov	r0, #0	; 0x0
   12904:	e3833080 	orr	r3, r3, #128	; 0x80
   12908:	e5823000 	str	r3, [r2]
   1290c:	ea00000a 	b	1293c <sd_raw_init+0x1e4>
   12910:	e59f2034 	ldr	r2, [pc, #52]	; 1294c <.text+0x294c>
   12914:	e5923000 	ldr	r3, [r2]
   12918:	e59f0058 	ldr	r0, [pc, #88]	; 12978 <.text+0x2978>
   1291c:	e3833080 	orr	r3, r3, #128	; 0x80
   12920:	e5823000 	str	r3, [r2]
   12924:	ebfffc4b 	bl	11a58 <rprintf>
   12928:	e3a00000 	mov	r0, #0	; 0x0
   1292c:	ea000002 	b	1293c <sd_raw_init+0x1e4>
   12930:	e59f0044 	ldr	r0, [pc, #68]	; 1297c <.text+0x297c>
   12934:	ebfffc47 	bl	11a58 <rprintf>
   12938:	e1a00004 	mov	r0, r4
   1293c:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   12940:	e12fff1e 	bx	lr
   12944:	e0028008 	and	r8, r2, r8
   12948:	e002c000 	and	ip, r2, r0
   1294c:	e0028004 	and	r8, r2, r4
   12950:	e002000c 	and	r0, r2, ip
   12954:	00018da4 	andeq	r8, r1, r4, lsr #27
   12958:	e002800c 	and	r8, r2, ip
   1295c:	000001ff 	streqd	r0, [r0], -pc
   12960:	00007fff 	streqd	r7, [r0], -pc
   12964:	00018de0 	andeq	r8, r1, r0, ror #27
   12968:	40001360 	andmi	r1, r0, r0, ror #6
   1296c:	4000135c 	andmi	r1, r0, ip, asr r3
   12970:	40001364 	andmi	r1, r0, r4, ror #6
   12974:	00018dbc 	streqh	r8, [r1], -ip
   12978:	00018dd0 	ldreqd	r8, [r1], -r0
   1297c:	00018df8 	streqd	r8, [r1], -r8

00012980 <sd_raw_read_interval>:
   12980:	e1a02802 	mov	r2, r2, lsl #16
   12984:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
   12988:	e1a03803 	mov	r3, r3, lsl #16
   1298c:	e3520000 	cmp	r2, #0	; 0x0
   12990:	13510000 	cmpne	r1, #0	; 0x0
   12994:	e1a07001 	mov	r7, r1
   12998:	e1a06000 	mov	r6, r0
   1299c:	e1a05823 	mov	r5, r3, lsr #16
   129a0:	e28d801c 	add	r8, sp, #28	; 0x1c
   129a4:	e8980500 	ldmia	r8, {r8, sl}
   129a8:	e1a04822 	mov	r4, r2, lsr #16
   129ac:	0a00001a 	beq	12a1c <sd_raw_read_interval+0x9c>
   129b0:	e2783001 	rsbs	r3, r8, #1	; 0x1
   129b4:	33a03000 	movcc	r3, #0	; 0x0
   129b8:	e1550004 	cmp	r5, r4
   129bc:	33833001 	orrcc	r3, r3, #1	; 0x1
   129c0:	e3530000 	cmp	r3, #0	; 0x0
   129c4:	0a00000e 	beq	12a04 <sd_raw_read_interval+0x84>
   129c8:	ea000013 	b	12a1c <sd_raw_read_interval+0x9c>
   129cc:	ebfffe96 	bl	1242c <sd_raw_read>
   129d0:	e3500000 	cmp	r0, #0	; 0x0
   129d4:	e1a01006 	mov	r1, r6
   129d8:	e1a0200a 	mov	r2, sl
   129dc:	e1a00007 	mov	r0, r7
   129e0:	e0866004 	add	r6, r6, r4
   129e4:	0a00000c 	beq	12a1c <sd_raw_read_interval+0x9c>
   129e8:	e1a0e00f 	mov	lr, pc
   129ec:	e12fff18 	bx	r8
   129f0:	e3500000 	cmp	r0, #0	; 0x0
   129f4:	0a00000a 	beq	12a24 <sd_raw_read_interval+0xa4>
   129f8:	e0643005 	rsb	r3, r4, r5
   129fc:	e1a03803 	mov	r3, r3, lsl #16
   12a00:	e1a05823 	mov	r5, r3, lsr #16
   12a04:	e1550004 	cmp	r5, r4
   12a08:	e1a00006 	mov	r0, r6
   12a0c:	e1a01007 	mov	r1, r7
   12a10:	e1a02004 	mov	r2, r4
   12a14:	2affffec 	bcs	129cc <sd_raw_read_interval+0x4c>
   12a18:	ea000001 	b	12a24 <sd_raw_read_interval+0xa4>
   12a1c:	e3a00000 	mov	r0, #0	; 0x0
   12a20:	ea000000 	b	12a28 <sd_raw_read_interval+0xa8>
   12a24:	e3a00001 	mov	r0, #1	; 0x1
   12a28:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
   12a2c:	e12fff1e 	bx	lr

00012a30 <sd_raw_sync>:

/**
 * \ingroup sd_raw
 * Writes the write buffer's content to the card.
 *
 * \note When write buffering is enabled, you should
 *       call this function before disconnecting the
 *       card to ensure all remaining data has been
 *       written.
 *
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_write
 */
unsigned char sd_raw_sync()
{
   12a30:	e52de004 	str	lr, [sp, #-4]!
    #if SD_RAW_WRITE_SUPPORT
        #if SD_RAW_WRITE_BUFFERING
        if(raw_block_written)
   12a34:	e59f3030 	ldr	r3, [pc, #48]	; 12a6c <.text+0x2a6c>
   12a38:	e5d33000 	ldrb	r3, [r3]
   12a3c:	e3530000 	cmp	r3, #0	; 0x0
            return 1;
        if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
   12a40:	e59f1028 	ldr	r1, [pc, #40]	; 12a70 <.text+0x2a70>
   12a44:	e3a02c02 	mov	r2, #512	; 0x200
   12a48:	1a000004 	bne	12a60 <sd_raw_sync+0x30>
   12a4c:	e59f3020 	ldr	r3, [pc, #32]	; 12a74 <.text+0x2a74>
   12a50:	e5930000 	ldr	r0, [r3]
   12a54:	ebfffece 	bl	12594 <sd_raw_write>
   12a58:	e3500000 	cmp	r0, #0	; 0x0
   12a5c:	0a000000 	beq	12a64 <sd_raw_sync+0x34>
   12a60:	e3a00001 	mov	r0, #1	; 0x1
            return 0;
    #endif
    return 1;
    #else
    return 0;
    #endif
}
   12a64:	e49de004 	ldr	lr, [sp], #4
   12a68:	e12fff1e 	bx	lr
   12a6c:	4000135c 	andmi	r1, r0, ip, asr r3
   12a70:	40001364 	andmi	r1, r0, r4, ror #6
   12a74:	40001360 	andmi	r1, r0, r0, ror #6

00012a78 <sd_raw_get_info>:

/**
 * \ingroup sd_raw
 * Reads informational data from the card.
 *
 * This function reads and returns the card's registers
 * containing manufacturing and status information.
 *
 * \note: The information retrieved by this function is
 *        not required in any way to operate on the card,
 *        but it might be nice to display some of the data
 *        to the user.
 *
 * \param[in] info A pointer to the structure into which to save the information.
 * \returns 0 on failure, 1 on success.
 */
unsigned char sd_raw_get_info(struct sd_raw_info* info)
{
   12a78:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(!info || !sd_raw_available())
   12a7c:	e2504000 	subs	r4, r0, #0	; 0x0
   12a80:	0a000090 	beq	12cc8 <.text+0x2cc8>
   12a84:	ebfffe1b 	bl	122f8 <sd_raw_available>
   12a88:	e3500000 	cmp	r0, #0	; 0x0
   12a8c:	0a00008d 	beq	12cc8 <.text+0x2cc8>
        return 0;

    memset(info, 0, sizeof(*info));
   12a90:	e3a01000 	mov	r1, #0	; 0x0
   12a94:	e3a0201c 	mov	r2, #28	; 0x1c
   12a98:	e1a00004 	mov	r0, r4
   12a9c:	eb0014a9 	bl	17d48 <memset>

    select_card();
   12aa0:	e59f222c 	ldr	r2, [pc, #556]	; 12cd4 <.text+0x2cd4>
   12aa4:	e5923000 	ldr	r3, [r2]
   12aa8:	e3833080 	orr	r3, r3, #128	; 0x80

    /* read cid register */
    if(sd_raw_send_command_r1(CMD_SEND_CID, 0))
   12aac:	e3a0000a 	mov	r0, #10	; 0xa
   12ab0:	e3a01000 	mov	r1, #0	; 0x0
   12ab4:	e5823000 	str	r3, [r2]
   12ab8:	ebfffe3d 	bl	123b4 <sd_raw_send_command_r1>
   12abc:	e3500000 	cmp	r0, #0	; 0x0
   12ac0:	1a000037 	bne	12ba4 <.text+0x2ba4>
    {
        unselect_card();
        return 0;
    }
    while(sd_raw_rec_byte() != 0xfe);
   12ac4:	ebfffe21 	bl	12350 <sd_raw_rec_byte>
   12ac8:	e35000fe 	cmp	r0, #254	; 0xfe
   12acc:	1afffffc 	bne	12ac4 <sd_raw_get_info+0x4c>
   12ad0:	e1a05004 	mov	r5, r4
   12ad4:	e3a06000 	mov	r6, #0	; 0x0
   12ad8:	e3a07060 	mov	r7, #96	; 0x60
    unsigned char i;
    for(i = 0; i < 18; ++i)
    {
        unsigned char b = sd_raw_rec_byte();
   12adc:	ebfffe1b 	bl	12350 <sd_raw_rec_byte>

        switch(i)
   12ae0:	e20630ff 	and	r3, r6, #255	; 0xff
   12ae4:	e353000e 	cmp	r3, #14	; 0xe
   12ae8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   12aec:	ea000022 	b	12b7c <.text+0x2b7c>
   12af0:	00012b2c 	andeq	r2, r1, ip, lsr #22
   12af4:	00012b34 	andeq	r2, r1, r4, lsr fp
   12af8:	00012b34 	andeq	r2, r1, r4, lsr fp
   12afc:	00012b3c 	andeq	r2, r1, ip, lsr fp
   12b00:	00012b3c 	andeq	r2, r1, ip, lsr fp
   12b04:	00012b3c 	andeq	r2, r1, ip, lsr fp
   12b08:	00012b3c 	andeq	r2, r1, ip, lsr fp
   12b0c:	00012b3c 	andeq	r2, r1, ip, lsr fp
   12b10:	00012b44 	andeq	r2, r1, r4, asr #22
   12b14:	00012b4c 	andeq	r2, r1, ip, asr #22
   12b18:	00012b4c 	andeq	r2, r1, ip, asr #22
   12b1c:	00012b4c 	andeq	r2, r1, ip, asr #22
   12b20:	00012b4c 	andeq	r2, r1, ip, asr #22
   12b24:	00012b5c 	andeq	r2, r1, ip, asr fp
   12b28:	00012b68 	andeq	r2, r1, r8, ror #22
        {
            case 0:
                info->manufacturer = b;
   12b2c:	e5c40000 	strb	r0, [r4]
   12b30:	ea000011 	b	12b7c <.text+0x2b7c>
                break;
            case 1:
            case 2:
                info->oem[i - 1] = b;
   12b34:	e5c50000 	strb	r0, [r5]
   12b38:	ea00000f 	b	12b7c <.text+0x2b7c>
                break;
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                info->product[i - 3] = b;
   12b3c:	e5c50001 	strb	r0, [r5, #1]
   12b40:	ea00000d 	b	12b7c <.text+0x2b7c>
                break;
            case 8:
                info->revision = b;
   12b44:	e5c4000a 	strb	r0, [r4, #10]
   12b48:	ea00000b 	b	12b7c <.text+0x2b7c>
                break;
            case 9:
            case 10:
            case 11:
            case 12:
                info->serial |= (unsigned int) b << ((12 - i) * 8);
   12b4c:	e594300c 	ldr	r3, [r4, #12]
   12b50:	e1833710 	orr	r3, r3, r0, lsl r7
   12b54:	e584300c 	str	r3, [r4, #12]
   12b58:	ea000007 	b	12b7c <.text+0x2b7c>
                break;
            case 13:
                info->manufacturing_year = b << 4;
   12b5c:	e1a03200 	mov	r3, r0, lsl #4
   12b60:	e5c43010 	strb	r3, [r4, #16]
   12b64:	ea000004 	b	12b7c <.text+0x2b7c>
                break;
            case 14:
                info->manufacturing_year |= b >> 4;
   12b68:	e5d43010 	ldrb	r3, [r4, #16]
                info->manufacturing_month = b & 0x0f;
   12b6c:	e200200f 	and	r2, r0, #15	; 0xf
   12b70:	e1833220 	orr	r3, r3, r0, lsr #4
   12b74:	e5c43010 	strb	r3, [r4, #16]
   12b78:	e5c42011 	strb	r2, [r4, #17]
   12b7c:	e2866001 	add	r6, r6, #1	; 0x1
   12b80:	e3560012 	cmp	r6, #18	; 0x12
   12b84:	e2855001 	add	r5, r5, #1	; 0x1
   12b88:	e2477008 	sub	r7, r7, #8	; 0x8
   12b8c:	1affffd2 	bne	12adc <sd_raw_get_info+0x64>
                break;
        }
    }

    /* read csd register */
    unsigned char csd_read_bl_len = 0;
    unsigned char csd_c_size_mult = 0;
    unsigned short csd_c_size = 0;
    if(sd_raw_send_command_r1(CMD_SEND_CSD, 0))
   12b90:	e3a00009 	mov	r0, #9	; 0x9
   12b94:	e3a01000 	mov	r1, #0	; 0x0
   12b98:	ebfffe05 	bl	123b4 <sd_raw_send_command_r1>
   12b9c:	e3500000 	cmp	r0, #0	; 0x0
   12ba0:	0a000004 	beq	12bb8 <.text+0x2bb8>
    {
        unselect_card();
   12ba4:	e59f212c 	ldr	r2, [pc, #300]	; 12cd8 <.text+0x2cd8>
   12ba8:	e5923000 	ldr	r3, [r2]
   12bac:	e3a00000 	mov	r0, #0	; 0x0
   12bb0:	e3833080 	orr	r3, r3, #128	; 0x80
   12bb4:	ea000041 	b	12cc0 <.text+0x2cc0>
        return 0;
    }
    while(sd_raw_rec_byte() != 0xfe);
   12bb8:	ebfffde4 	bl	12350 <sd_raw_rec_byte>
   12bbc:	e35000fe 	cmp	r0, #254	; 0xfe
   12bc0:	1afffffc 	bne	12bb8 <.text+0x2bb8>
   12bc4:	e3a08000 	mov	r8, #0	; 0x0
   12bc8:	e1a06008 	mov	r6, r8
   12bcc:	e1a07008 	mov	r7, r8
   12bd0:	e1a05008 	mov	r5, r8
    for(i = 0; i < 18; ++i)
    {
        unsigned char b = sd_raw_rec_byte();
   12bd4:	ebfffddd 	bl	12350 <sd_raw_rec_byte>

        switch(i)
   12bd8:	e20630ff 	and	r3, r6, #255	; 0xff
   12bdc:	e2433005 	sub	r3, r3, #5	; 0x5
   12be0:	e3530009 	cmp	r3, #9	; 0x9
   12be4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   12be8:	ea00002d 	b	12ca4 <.text+0x2ca4>
   12bec:	00012c14 	andeq	r2, r1, r4, lsl ip
   12bf0:	00012c1c 	andeq	r2, r1, ip, lsl ip
   12bf4:	00012c28 	andeq	r2, r1, r8, lsr #24
   12bf8:	00012c34 	andeq	r2, r1, r4, lsr ip
   12bfc:	00012c4c 	andeq	r2, r1, ip, asr #24
   12c00:	00012c58 	andeq	r2, r1, r8, asr ip
   12c04:	00012ca4 	andeq	r2, r1, r4, lsr #25
   12c08:	00012ca4 	andeq	r2, r1, r4, lsr #25
   12c0c:	00012ca4 	andeq	r2, r1, r4, lsr #25
   12c10:	00012c74 	andeq	r2, r1, r4, ror ip
        {
            case 5:
                csd_read_bl_len = b & 0x0f;
   12c14:	e200800f 	and	r8, r0, #15	; 0xf
   12c18:	ea000021 	b	12ca4 <.text+0x2ca4>
                break;
            case 6:
                csd_c_size = (unsigned short) (b & 0x03) << 8;
   12c1c:	e2003003 	and	r3, r0, #3	; 0x3
   12c20:	e1a05403 	mov	r5, r3, lsl #8
   12c24:	ea00001e 	b	12ca4 <.text+0x2ca4>
                break;
            case 7:
                csd_c_size |= b;
   12c28:	e1853000 	orr	r3, r5, r0
                csd_c_size <<= 2;
   12c2c:	e1a03903 	mov	r3, r3, lsl #18
   12c30:	ea000003 	b	12c44 <.text+0x2c44>
                break;
            case 8:
                csd_c_size |= b >> 6;
   12c34:	e1a03900 	mov	r3, r0, lsl #18
   12c38:	e1853c23 	orr	r3, r5, r3, lsr #24
                ++csd_c_size;
   12c3c:	e2833001 	add	r3, r3, #1	; 0x1
   12c40:	e1a03803 	mov	r3, r3, lsl #16
   12c44:	e1a05823 	mov	r5, r3, lsr #16
   12c48:	ea000015 	b	12ca4 <.text+0x2ca4>
                break;
            case 9:
                csd_c_size_mult = (b & 0x03) << 1;
   12c4c:	e2003003 	and	r3, r0, #3	; 0x3
   12c50:	e1a07083 	mov	r7, r3, lsl #1
   12c54:	ea000012 	b	12ca4 <.text+0x2ca4>
                break;
            case 10:
                csd_c_size_mult |= b >> 7;
   12c58:	e18733a0 	orr	r3, r7, r0, lsr #7
   12c5c:	e20370ff 	and	r7, r3, #255	; 0xff

                info->capacity = (unsigned int) csd_c_size << (csd_c_size_mult + csd_read_bl_len + 2);
   12c60:	e0873008 	add	r3, r7, r8
   12c64:	e2833002 	add	r3, r3, #2	; 0x2
   12c68:	e1a03315 	mov	r3, r5, lsl r3
   12c6c:	e5843014 	str	r3, [r4, #20]
   12c70:	ea00000b 	b	12ca4 <.text+0x2ca4>

                break;
            case 14:
                if(b & 0x40)
   12c74:	e3100040 	tst	r0, #64	; 0x40
                    info->flag_copy = 1;
   12c78:	13a03001 	movne	r3, #1	; 0x1
   12c7c:	15c43018 	strneb	r3, [r4, #24]
                if(b & 0x20)
   12c80:	e3100020 	tst	r0, #32	; 0x20
                    info->flag_write_protect = 1;
   12c84:	13a03001 	movne	r3, #1	; 0x1
   12c88:	15c43019 	strneb	r3, [r4, #25]
                if(b & 0x10)
   12c8c:	e3100010 	tst	r0, #16	; 0x10
                    info->flag_write_protect_temp = 1;
   12c90:	13a03001 	movne	r3, #1	; 0x1
   12c94:	15c4301a 	strneb	r3, [r4, #26]
                info->format = (b & 0x0c) >> 2;
   12c98:	e200300c 	and	r3, r0, #12	; 0xc
   12c9c:	e1a03143 	mov	r3, r3, asr #2
   12ca0:	e5c4301b 	strb	r3, [r4, #27]
   12ca4:	e2866001 	add	r6, r6, #1	; 0x1
   12ca8:	e3560012 	cmp	r6, #18	; 0x12
   12cac:	1affffc8 	bne	12bd4 <.text+0x2bd4>
                break;
        }
    }

    unselect_card();
   12cb0:	e59f2020 	ldr	r2, [pc, #32]	; 12cd8 <.text+0x2cd8>
   12cb4:	e5923000 	ldr	r3, [r2]
   12cb8:	e3a00001 	mov	r0, #1	; 0x1
   12cbc:	e3833080 	orr	r3, r3, #128	; 0x80
   12cc0:	e5823000 	str	r3, [r2]
   12cc4:	ea000000 	b	12ccc <.text+0x2ccc>

    return 1;
   12cc8:	e3a00000 	mov	r0, #0	; 0x0
}
   12ccc:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   12cd0:	e12fff1e 	bx	lr
   12cd4:	e002800c 	and	r8, r2, ip
   12cd8:	e0028004 	and	r8, r2, r4

00012cdc <SDoff>:

void SDoff(void)
{
    IODIR1 &= ~(CS);
   12cdc:	e59f201c 	ldr	r2, [pc, #28]	; 12d00 <.text+0x2d00>
   12ce0:	e5923000 	ldr	r3, [r2]
   12ce4:	e3c33080 	bic	r3, r3, #128	; 0x80
   12ce8:	e5823000 	str	r3, [r2]
    PINSEL0 &= ~(0x1500);
   12cec:	e59f2010 	ldr	r2, [pc, #16]	; 12d04 <.text+0x2d04>
   12cf0:	e5923000 	ldr	r3, [r2]
   12cf4:	e3c33c15 	bic	r3, r3, #5376	; 0x1500
   12cf8:	e5823000 	str	r3, [r2]
}
   12cfc:	e12fff1e 	bx	lr
   12d00:	e0028018 	and	r8, r2, r8, lsl r0
   12d04:	e002c000 	and	ip, r2, r0

00012d08 <format_card>:

//NES : 10-28-7 
//Low-level formats a 512MB card
//Assumes *many* things
//You must pass this fuction 0xAA to get it to work (safety check)
char format_card(char make_sure)
{
   12d08:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12d0c:	e20000ff 	and	r0, r0, #255	; 0xff
	#define MBR_LOCATION	0x00
	#define BR_LOCATION		(MBR_LOCATION+0x80000)
	#define FAT_TABLE		(BR_LOCATION + (0x200 * 512))
	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))

	//Safety check
	if (make_sure != 0xAA) return 0;
   12d10:	e35000aa 	cmp	r0, #170	; 0xaa
   12d14:	e24ddc02 	sub	sp, sp, #512	; 0x200
   12d18:	13a00000 	movne	r0, #0	; 0x0
   12d1c:	1a00006d 	bne	12ed8 <format_card+0x1d0>
   12d20:	e3a04000 	mov	r4, #0	; 0x0
	
	int i;
	unsigned char my_buff[512];
	for(i = 0 ; i < 512 ; i++) my_buff[i] = 0x00;
   12d24:	e3a06000 	mov	r6, #0	; 0x0
   12d28:	e7c4600d 	strb	r6, [r4, sp]
   12d2c:	e2844001 	add	r4, r4, #1	; 0x1
   12d30:	e3540c02 	cmp	r4, #512	; 0x200
   12d34:	1afffffa 	bne	12d24 <format_card+0x1c>
	
	//Init SD card interface
	sd_raw_init();
   12d38:	ebfffe86 	bl	12758 <sd_raw_init>

	//Erase Master Boot record
	sd_raw_sync();
   12d3c:	ebffff3b 	bl	12a30 <sd_raw_sync>
	sd_raw_write(MBR_LOCATION, my_buff, 512);
   12d40:	e1a02004 	mov	r2, r4
   12d44:	e1a0100d 	mov	r1, sp
   12d48:	e1a00006 	mov	r0, r6
   12d4c:	ebfffe10 	bl	12594 <sd_raw_write>

	//Erase Boot record
	sd_raw_sync();
   12d50:	ebffff36 	bl	12a30 <sd_raw_sync>
	sd_raw_write(BR_LOCATION, my_buff, 512);
   12d54:	e1a02004 	mov	r2, r4
   12d58:	e1a0100d 	mov	r1, sp
   12d5c:	e3a00702 	mov	r0, #524288	; 0x80000
   12d60:	ebfffe0b 	bl	12594 <sd_raw_write>
   12d64:	e3a04703 	mov	r4, #786432	; 0xc0000

	//Erase FAT tables
	for(i = 0 ; i < 0x00F5 ; i++) //0x00F5 = 245 bytes : comes from byte 0x16 from Boot Record
	{
		sd_raw_sync();
   12d68:	ebffff30 	bl	12a30 <sd_raw_sync>
		sd_raw_write( (FAT_TABLE + (i*512)), my_buff, 512);
   12d6c:	e1a00004 	mov	r0, r4
   12d70:	e1a0100d 	mov	r1, sp
   12d74:	e3a02c02 	mov	r2, #512	; 0x200
   12d78:	ebfffe05 	bl	12594 <sd_raw_write>
   12d7c:	e59f3160 	ldr	r3, [pc, #352]	; 12ee4 <.text+0x2ee4>
   12d80:	e2844c02 	add	r4, r4, #512	; 0x200
   12d84:	e1540003 	cmp	r4, r3
   12d88:	e1a0900d 	mov	r9, sp
   12d8c:	1afffff5 	bne	12d68 <format_card+0x60>
	}
	
	//Write Master Boot Record
	#define PART1	0x01BE
	my_buff[PART1 + 0] = 0x00;
	my_buff[PART1 + 1] = 0x00;
	my_buff[PART1 + 2] = 0x01;
	my_buff[PART1 + 3] = 0x01;
	my_buff[PART1 + 4] = 0x06;
   12d90:	e3a03006 	mov	r3, #6	; 0x6
   12d94:	e5cd31c2 	strb	r3, [sp, #450]
	my_buff[PART1 + 5] = 0x1F;
   12d98:	e2833019 	add	r3, r3, #25	; 0x19
   12d9c:	e5cd31c3 	strb	r3, [sp, #451]
	my_buff[PART1 + 6] = 0xE0;
   12da0:	e3e0301f 	mvn	r3, #31	; 0x1f
   12da4:	e3a04000 	mov	r4, #0	; 0x0
   12da8:	e3a02001 	mov	r2, #1	; 0x1
	my_buff[PART1 + 7] = 0xD3;
	my_buff[PART1 + 8] = 0x00;
	my_buff[PART1 + 9] = 0x04;
	my_buff[PART1 + 10] = 0x00;
	my_buff[PART1 + 11] = 0x00;
	my_buff[PART1 + 12] = 0x00;
	my_buff[PART1 + 13] = 0x4C;
	my_buff[PART1 + 14] = 0x0F;
	my_buff[510] = 0x55;
   12dac:	e3a05055 	mov	r5, #85	; 0x55
   12db0:	e3a06004 	mov	r6, #4	; 0x4
   12db4:	e3a0704c 	mov	r7, #76	; 0x4c
   12db8:	e3a0800f 	mov	r8, #15	; 0xf
	my_buff[511] = 0xAA;
   12dbc:	e3e0a055 	mvn	sl, #85	; 0x55
   12dc0:	e5cd31c4 	strb	r3, [sp, #452]
   12dc4:	e3e0302c 	mvn	r3, #44	; 0x2c
   12dc8:	e5cd31c5 	strb	r3, [sp, #453]
   12dcc:	e5cd21c1 	strb	r2, [sp, #449]
   12dd0:	e5cd21c0 	strb	r2, [sp, #448]
   12dd4:	e5cd41be 	strb	r4, [sp, #446]
   12dd8:	e5cd41bf 	strb	r4, [sp, #447]
   12ddc:	e5cd41c6 	strb	r4, [sp, #454]
   12de0:	e5cd61c7 	strb	r6, [sp, #455]
   12de4:	e5cd41c8 	strb	r4, [sp, #456]
   12de8:	e5cd41c9 	strb	r4, [sp, #457]
   12dec:	e5cd41ca 	strb	r4, [sp, #458]
   12df0:	e5cd71cb 	strb	r7, [sp, #459]
   12df4:	e5cd81cc 	strb	r8, [sp, #460]
   12df8:	e5cd51fe 	strb	r5, [sp, #510]
   12dfc:	e5cda1ff 	strb	sl, [sp, #511]

	sd_raw_sync();
   12e00:	ebffff0a 	bl	12a30 <sd_raw_sync>
	sd_raw_write(MBR_LOCATION, my_buff, 512);
   12e04:	e1a0100d 	mov	r1, sp
   12e08:	e3a02c02 	mov	r2, #512	; 0x200
   12e0c:	e1a00004 	mov	r0, r4
   12e10:	ebfffddf 	bl	12594 <sd_raw_write>
	sd_raw_sync();
   12e14:	ebffff05 	bl	12a30 <sd_raw_sync>

	//Write Boot Record
	#define BOOTRECORD1	0x80000
	my_buff[0] = 0xEB;
   12e18:	e3e03014 	mvn	r3, #20	; 0x14
   12e1c:	e5cd3000 	strb	r3, [sp]
	my_buff[1] = 0xFE;
   12e20:	e2833013 	add	r3, r3, #19	; 0x13
   12e24:	e5cd3001 	strb	r3, [sp, #1]
	my_buff[2] = 0x90;
   12e28:	e3e0306f 	mvn	r3, #111	; 0x6f
   12e2c:	e5cd3002 	strb	r3, [sp, #2]
	my_buff[12] = 0x02;
	my_buff[13] = 0x10;
   12e30:	e2833080 	add	r3, r3, #128	; 0x80
   12e34:	e5cd300d 	strb	r3, [sp, #13]
	my_buff[14] = 0x16;
   12e38:	e2833006 	add	r3, r3, #6	; 0x6
   12e3c:	e5cd300e 	strb	r3, [sp, #14]
	my_buff[16] = 0x02;
	my_buff[18] = 0x02;
	my_buff[21] = 0xF8;
   12e40:	e3e03007 	mvn	r3, #7	; 0x7
   12e44:	e5cd3015 	strb	r3, [sp, #21]
	my_buff[22] = 0xF5;
   12e48:	e3e0300a 	mvn	r3, #10	; 0xa
   12e4c:	e5cd3016 	strb	r3, [sp, #22]
	my_buff[24] = 0x20;
	my_buff[26] = 0x20;
	my_buff[29] = 0x04;
	my_buff[33] = 0x4C;
	my_buff[34] = 0x0F;
	my_buff[38] = 0x29;
   12e50:	e2833034 	add	r3, r3, #52	; 0x34
   12e54:	e5cd3026 	strb	r3, [sp, #38]
	my_buff[54] = 0x46;
   12e58:	e283301d 	add	r3, r3, #29	; 0x1d
   12e5c:	e5cd3036 	strb	r3, [sp, #54]
	my_buff[55] = 0x41;
   12e60:	e3a03041 	mov	r3, #65	; 0x41
   12e64:	e5cd3037 	strb	r3, [sp, #55]
	my_buff[56] = 0x54;
   12e68:	e2833013 	add	r3, r3, #19	; 0x13
   12e6c:	e5cd3038 	strb	r3, [sp, #56]
	my_buff[57] = 0x31;
   12e70:	e3a03031 	mov	r3, #49	; 0x31
   12e74:	e3a02020 	mov	r2, #32	; 0x20
   12e78:	e3a01002 	mov	r1, #2	; 0x2
   12e7c:	e5cd3039 	strb	r3, [sp, #57]
	my_buff[58] = 0x36;
   12e80:	e2833005 	add	r3, r3, #5	; 0x5
   12e84:	e5cd303a 	strb	r3, [sp, #58]
   12e88:	e5cd1012 	strb	r1, [sp, #18]
	my_buff[59] = 0x20;
	my_buff[60] = 0x20;
	my_buff[61] = 0x20;
   12e8c:	e5cd203d 	strb	r2, [sp, #61]
   12e90:	e5cd100c 	strb	r1, [sp, #12]
   12e94:	e5cd1010 	strb	r1, [sp, #16]
   12e98:	e5cd2018 	strb	r2, [sp, #24]
   12e9c:	e5cd201a 	strb	r2, [sp, #26]
   12ea0:	e5cd203b 	strb	r2, [sp, #59]
   12ea4:	e5cd203c 	strb	r2, [sp, #60]
   12ea8:	e5cd601d 	strb	r6, [sp, #29]
   12eac:	e5cd7021 	strb	r7, [sp, #33]
   12eb0:	e5cd8022 	strb	r8, [sp, #34]
	my_buff[510] = 0x55;
	my_buff[511] = 0xAA;
   12eb4:	e5cda1ff 	strb	sl, [sp, #511]
   12eb8:	e5cd51fe 	strb	r5, [sp, #510]
	
	sd_raw_sync();
   12ebc:	ebfffedb 	bl	12a30 <sd_raw_sync>
	sd_raw_write(BR_LOCATION, my_buff, 512);
   12ec0:	e1a0100d 	mov	r1, sp
   12ec4:	e3a02c02 	mov	r2, #512	; 0x200
   12ec8:	e3a00702 	mov	r0, #524288	; 0x80000
   12ecc:	ebfffdb0 	bl	12594 <sd_raw_write>
	sd_raw_sync();
   12ed0:	ebfffed6 	bl	12a30 <sd_raw_sync>
   12ed4:	e1a00005 	mov	r0, r5
	
	return(0x55); //Successful format
}
   12ed8:	e28ddc02 	add	sp, sp, #512	; 0x200
   12edc:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12ee0:	e12fff1e 	bx	lr
   12ee4:	000dea00 	andeq	lr, sp, r0, lsl #20

00012ee8 <fat16_open>:
 * \returns 0 on error, a FAT16 filesystem descriptor on success.
 * \see fat16_open
 */
struct fat16_fs_struct* fat16_open(struct partition_struct* partition)
{
   12ee8:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(!partition ||
   12eec:	e2509000 	subs	r9, r0, #0	; 0x0
   12ef0:	e24dd028 	sub	sp, sp, #40	; 0x28
   12ef4:	0a00006f 	beq	130b8 <fat16_open+0x1d0>
   12ef8:	e5993008 	ldr	r3, [r9, #8]
   12efc:	e3530000 	cmp	r3, #0	; 0x0
   12f00:	0a00006c 	beq	130b8 <fat16_open+0x1d0>
        #if FAT16_WRITE_SUPPORT
        !partition->device_write
       #else
        0
       #endif
       )
    return 0;

    struct fat16_fs_struct* fs = malloc(sizeof(*fs));
   12f04:	e3a0001c 	mov	r0, #28	; 0x1c
   12f08:	eb001170 	bl	174d0 <malloc>
    if(!fs)
   12f0c:	e250a000 	subs	sl, r0, #0	; 0x0
   12f10:	1a000002 	bne	12f20 <fat16_open+0x38>
    {
        rprintf("MALLOC FAILS\n\r");
   12f14:	e59f01b0 	ldr	r0, [pc, #432]	; 130cc <.text+0x30cc>
   12f18:	ebffface 	bl	11a58 <rprintf>
   12f1c:	ea000066 	b	130bc <fat16_open+0x1d4>
        return 0;
    }
    memset(fs, 0, sizeof(*fs));
   12f20:	e3a01000 	mov	r1, #0	; 0x0
   12f24:	e3a0201c 	mov	r2, #28	; 0x1c
   12f28:	eb001386 	bl	17d48 <memset>

    fs->partition = partition;
    if(!fat16_read_header(fs))
    {
        rprintf("Failed Reading Header\n\r");
        free(fs);
        return 0;
    }

    return fs;
}

/**
 * \ingroup fat16_fs
 * Closes a FAT16 filesystem.
 *
 * When this function returns, the given filesystem descriptor
 * will be invalid.
 *
 * \param[in] fs The filesystem to close.
 * \see fat16_open
 */
void fat16_close(struct fat16_fs_struct* fs)
{
    if(!fs)
        return;

    free(fs);
}

/**
 * \ingroup fat16_fs
 * Reads and parses the header of a FAT16 filesystem.
 *
 * \param[inout] fs The filesystem for which to parse the header.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_read_header(struct fat16_fs_struct* fs)
{
    if(!fs)
        return 0;

    struct partition_struct* partition = fs->partition;
    if(!partition)
    {
        rprintf("Partition = 0\n\r");
        return 0;
    }

    /* read fat parameters */
    uint8_t buffer[25];
    uint32_t partition_offset = partition->offset * 512;
   12f2c:	e5993010 	ldr	r3, [r9, #16]
   12f30:	e1a03483 	mov	r3, r3, lsl #9
   12f34:	e58d3000 	str	r3, [sp]
   12f38:	e58a9000 	str	r9, [sl]

    if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
   12f3c:	e283000b 	add	r0, r3, #11	; 0xb
   12f40:	e28d100f 	add	r1, sp, #15	; 0xf
   12f44:	e3a02019 	mov	r2, #25	; 0x19
   12f48:	e599c000 	ldr	ip, [r9]
   12f4c:	e1a0e00f 	mov	lr, pc
   12f50:	e12fff1c 	bx	ip
   12f54:	e3500000 	cmp	r0, #0	; 0x0
   12f58:	0a00004c 	beq	13090 <fat16_open+0x1a8>
        return 0;

    uint16_t bytes_per_sector = ((uint16_t) buffer[0x00]) |
    ((uint16_t) buffer[0x01] << 8);
    uint8_t sectors_per_cluster = buffer[0x02];
    uint16_t reserved_sectors = ((uint16_t) buffer[0x03]) |
    ((uint16_t) buffer[0x04] << 8);
    uint8_t fat_copies = buffer[0x05];
    uint16_t max_root_entries = ((uint16_t) buffer[0x06]) |
    ((uint16_t) buffer[0x07] << 8);
    uint16_t sector_count_16 = ((uint16_t) buffer[0x08]) |
    ((uint16_t) buffer[0x09] << 8);
    uint16_t sectors_per_fat = ((uint16_t) buffer[0x0b]) |
    ((uint16_t) buffer[0x0c] << 8);
   12f5c:	e5dd201b 	ldrb	r2, [sp, #27]
    uint32_t sector_count = ((uint32_t) buffer[0x15]) |
    ((uint32_t) buffer[0x16] << 8) |
    ((uint32_t) buffer[0x17] << 16) |
    ((uint32_t) buffer[0x18] << 24);
   12f60:	e5dd0025 	ldrb	r0, [sp, #37]
   12f64:	e5dd301a 	ldrb	r3, [sp, #26]
   12f68:	e5dd1024 	ldrb	r1, [sp, #36]
   12f6c:	e1833402 	orr	r3, r3, r2, lsl #8
   12f70:	e1811400 	orr	r1, r1, r0, lsl #8
   12f74:	e5dd4012 	ldrb	r4, [sp, #18]
   12f78:	e5dd0013 	ldrb	r0, [sp, #19]
   12f7c:	e1a0b003 	mov	fp, r3
   12f80:	e5ddc015 	ldrb	ip, [sp, #21]
   12f84:	e5dd3016 	ldrb	r3, [sp, #22]
   12f88:	e1840400 	orr	r0, r4, r0, lsl #8
   12f8c:	e5dd7026 	ldrb	r7, [sp, #38]
   12f90:	e5dd6018 	ldrb	r6, [sp, #24]
   12f94:	e5dd2027 	ldrb	r2, [sp, #39]
   12f98:	e5dd8017 	ldrb	r8, [sp, #23]
   12f9c:	e5dd500f 	ldrb	r5, [sp, #15]
   12fa0:	e5dde010 	ldrb	lr, [sp, #16]
   12fa4:	e58d0008 	str	r0, [sp, #8]
   12fa8:	e18c0403 	orr	r0, ip, r3, lsl #8
   12fac:	e5dd3011 	ldrb	r3, [sp, #17]
   12fb0:	e1811807 	orr	r1, r1, r7, lsl #16

    if(sectors_per_fat == 0)
   12fb4:	e35b0000 	cmp	fp, #0	; 0x0
   12fb8:	e1888406 	orr	r8, r8, r6, lsl #8
   12fbc:	e185540e 	orr	r5, r5, lr, lsl #8
   12fc0:	e1816c02 	orr	r6, r1, r2, lsl #24
   12fc4:	e58d3004 	str	r3, [sp, #4]
   12fc8:	e5dd2014 	ldrb	r2, [sp, #20]
   12fcc:	0a00002f 	beq	13090 <fat16_open+0x1a8>
    /* this is not a FAT16 */
        return 0;

    if(sector_count == 0)
   12fd0:	e3560000 	cmp	r6, #0	; 0x0
   12fd4:	1a000002 	bne	12fe4 <fat16_open+0xfc>
    {
        if(sector_count_16 == 0)
   12fd8:	e3580000 	cmp	r8, #0	; 0x0
   12fdc:	0a00002b 	beq	13090 <fat16_open+0x1a8>
    /* illegal volume size */
            return 0;
        else
            sector_count = sector_count_16;
   12fe0:	e1a06008 	mov	r6, r8
    }

    /* ensure we really have a FAT16 fs here */
    uint32_t data_sector_count = sector_count
    - reserved_sectors
    - (uint32_t) sectors_per_fat * fat_copies
    - ((max_root_entries * 32 + bytes_per_sector - 1) / bytes_per_sector);
   12fe4:	e0080b92 	mul	r8, r2, fp
    uint32_t data_cluster_count = data_sector_count / sectors_per_cluster;
   12fe8:	e1a0b280 	mov	fp, r0, lsl #5
   12fec:	e59d3008 	ldr	r3, [sp, #8]
   12ff0:	e08b0005 	add	r0, fp, r5
   12ff4:	e1a01005 	mov	r1, r5
   12ff8:	e2400001 	sub	r0, r0, #1	; 0x1
   12ffc:	e0634006 	rsb	r4, r3, r6
   13000:	eb001626 	bl	188a0 <__divsi3>
   13004:	e0684004 	rsb	r4, r8, r4
   13008:	e0600004 	rsb	r0, r0, r4
   1300c:	e59d1004 	ldr	r1, [sp, #4]
   13010:	eb0015dd 	bl	1878c <__udivsi3>
    if(data_cluster_count < 4085 || data_cluster_count >= 65525)
   13014:	e2403eff 	sub	r3, r0, #4080	; 0xff0
   13018:	e2433005 	sub	r3, r3, #5	; 0x5
   1301c:	e3530a0f 	cmp	r3, #61440	; 0xf000
   13020:	e1a07000 	mov	r7, r0
   13024:	2a000019 	bcs	13090 <fat16_open+0x1a8>
    /* this is not a FAT16 */
        return 0;

    partition->type = PARTITION_TYPE_FAT16;

    /* fill header information */
    struct fat16_header_struct* header = &fs->header;
   13028:	e28a4004 	add	r4, sl, #4	; 0x4
   1302c:	e3a03006 	mov	r3, #6	; 0x6
   13030:	e5c9300c 	strb	r3, [r9, #12]
    memset(header, 0, sizeof(*header));
   13034:	e3a01000 	mov	r1, #0	; 0x0
   13038:	e3a02018 	mov	r2, #24	; 0x18
   1303c:	e1a00004 	mov	r0, r4
   13040:	eb001340 	bl	17d48 <memset>

    header->size = sector_count * bytes_per_sector;

    header->fat_offset = /* jump to partition */
   13044:	e59d3000 	ldr	r3, [sp]
   13048:	e59d0008 	ldr	r0, [sp, #8]
   1304c:	e0203095 	mla	r0, r5, r0, r3
    partition_offset +
    /* jump to fat */
    (uint32_t) reserved_sectors * bytes_per_sector;
    header->fat_size = (data_cluster_count + 2) * 2;

    header->sector_size = bytes_per_sector;
    header->cluster_size = (uint32_t) bytes_per_sector * sectors_per_cluster;
   13050:	e59dc004 	ldr	ip, [sp, #4]

    header->root_dir_offset = /* jump to fats */
   13054:	e02e0895 	mla	lr, r5, r8, r0
   13058:	e0010695 	mul	r1, r5, r6
   1305c:	e00c0c95 	mul	ip, r5, ip
   13060:	e1a03087 	mov	r3, r7, lsl #1
    header->fat_offset +
    /* jump to root directory entries */
    (uint32_t) fat_copies * sectors_per_fat * bytes_per_sector;

    header->cluster_zero_offset = /* jump to root directory entries */
   13064:	e08e200b 	add	r2, lr, fp
   13068:	e2833004 	add	r3, r3, #4	; 0x4
   1306c:	e3a06001 	mov	r6, #1	; 0x1
   13070:	e5842014 	str	r2, [r4, #20]
   13074:	e58a1004 	str	r1, [sl, #4]
   13078:	e5843008 	str	r3, [r4, #8]
   1307c:	e1c4c0be 	strh	ip, [r4, #14]
   13080:	e5840004 	str	r0, [r4, #4]
   13084:	e1c450bc 	strh	r5, [r4, #12]
   13088:	e584e010 	str	lr, [r4, #16]
   1308c:	ea000000 	b	13094 <fat16_open+0x1ac>
   13090:	e3a06000 	mov	r6, #0	; 0x0
   13094:	e20640ff 	and	r4, r6, #255	; 0xff
   13098:	e3540000 	cmp	r4, #0	; 0x0
   1309c:	1a000006 	bne	130bc <fat16_open+0x1d4>
   130a0:	e59f0028 	ldr	r0, [pc, #40]	; 130d0 <.text+0x30d0>
   130a4:	ebfffa6b 	bl	11a58 <rprintf>
   130a8:	e1a0000a 	mov	r0, sl
   130ac:	eb00110f 	bl	174f0 <free>
   130b0:	e1a0a004 	mov	sl, r4
   130b4:	ea000000 	b	130bc <fat16_open+0x1d4>
   130b8:	e3a0a000 	mov	sl, #0	; 0x0
   130bc:	e1a0000a 	mov	r0, sl
   130c0:	e28dd028 	add	sp, sp, #40	; 0x28
   130c4:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   130c8:	e12fff1e 	bx	lr
   130cc:	00018e0c 	andeq	r8, r1, ip, lsl #28
   130d0:	00018e1c 	andeq	r8, r1, ip, lsl lr

000130d4 <fat16_close>:
   130d4:	e3500000 	cmp	r0, #0	; 0x0
   130d8:	e52de004 	str	lr, [sp, #-4]!
   130dc:	1b001103 	blne	174f0 <free>
   130e0:	e49de004 	ldr	lr, [sp], #4
   130e4:	e12fff1e 	bx	lr

000130e8 <fat16_get_next_cluster>:
    header->root_dir_offset +
    /* skip root directory entries */
    (uint32_t) max_root_entries * 32;

    return 1;
}

/**
 * \ingroup fat16_fs
 * Reads a directory entry of the root directory.
 *
 * \param[in] fs Descriptor of file system to use.
 * \param[in] entry_num The index of the directory entry to read.
 * \param[out] dir_entry Directory entry descriptor which will get filled.
 * \returns 0 on failure, 1 on success
 * \see fat16_read_sub_dir_entry, fat16_read_dir_entry_by_path
 */
uint8_t fat16_read_root_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !dir_entry)
        return 0;

    /* we read from the root directory entry */
    const struct fat16_header_struct* header = &fs->header;
    device_read_interval_t device_read_interval = fs->partition->device_read_interval;
    uint8_t buffer[32];

    /* seek to the n-th entry */
    struct fat16_read_callback_arg arg;
    memset(&arg, 0, sizeof(arg));
    arg.entry_num = entry_num;
    if(!device_read_interval(header->root_dir_offset,
        buffer,
       sizeof(buffer),
       header->cluster_zero_offset - header->root_dir_offset,
       fat16_dir_entry_seek_callback,
       &arg) ||
       arg.entry_offset == 0
       )
    return 0;

    /* read entry */
    memset(dir_entry, 0, sizeof(*dir_entry));
    if(!device_read_interval(arg.entry_offset,
        buffer,
       sizeof(buffer),
       arg.byte_count,
       fat16_dir_entry_read_callback,
       dir_entry))
    return 0;

    return dir_entry->long_name[0] != '\0' ? 1 : 0;
}

/**
 * \ingroup fat16_fs
 * Reads a directory entry of a given parent directory.
 *
 * \param[in] fs Descriptor of file system to use.
 * \param[in] entry_num The index of the directory entry to read.
 * \param[in] parent Directory entry descriptor in which to read directory entry.
 * \param[out] dir_entry Directory entry descriptor which will get filled.
 * \returns 0 on failure, 1 on success
 * \see fat16_read_root_dir_entry, fat16_read_dir_entry_by_path
 */
uint8_t fat16_read_sub_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, const struct fat16_dir_entry_struct* parent, struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !parent || !dir_entry)
        return 0;

    /* we are in a parent directory and want to search within its directory entry table */
    if(!(parent->attributes & FAT16_ATTRIB_DIR))
        return 0;

    /* loop through all clusters of the directory */
    uint8_t buffer[32];
    uint32_t cluster_offset;
    uint16_t cluster_size = fs->header.cluster_size;
    uint16_t cluster_num = parent->cluster;
    struct fat16_read_callback_arg arg;

    while(1)
    {
        /* calculate new cluster offset */
        cluster_offset = fs->header.cluster_zero_offset + (uint32_t) (cluster_num - 2) * cluster_size;

        /* seek to the n-th entry */
        memset(&arg, 0, sizeof(arg));
        arg.entry_num = entry_num;
        if(!fs->partition->device_read_interval(cluster_offset,
            buffer,
           sizeof(buffer),
           cluster_size,
           fat16_dir_entry_seek_callback,
           &arg)
           )
        return 0;

        /* check if we found the entry */
        if(arg.entry_offset)
            break;

        /* get number of next cluster */
        if(!(cluster_num = fat16_get_next_cluster(fs, cluster_num)))
            return 0; /* directory entry not found */
    }

    memset(dir_entry, 0, sizeof(*dir_entry));

    /* read entry */
    if(!fs->partition->device_read_interval(arg.entry_offset,
        buffer,
       sizeof(buffer),
       arg.byte_count,
       fat16_dir_entry_read_callback,
       dir_entry))
    return 0;

    return dir_entry->long_name[0] != '\0' ? 1 : 0;
}

/**
 * \ingroup fat16_fs
 * Callback function for seeking through subdirectory entries.
 */
uint8_t fat16_dir_entry_seek_callback(uint8_t* buffer, uint32_t offset, void* p)
{
    struct fat16_read_callback_arg* arg = p;

    /* skip deleted or empty entries */
    if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
        return 1;

    if(arg->entry_cur == arg->entry_num)
    {
        arg->entry_offset = offset;
        arg->byte_count = buffer[11] == 0x0f ?
        ((buffer[0] & FAT16_DIRENTRY_LFNSEQMASK) + 1) * 32 :
        32;
        return 0;
    }

    /* if we read a 8.3 entry, we reached a new directory entry */
    if(buffer[11] != 0x0f)
        ++arg->entry_cur;

    return 1;
}

/**
 * \ingroup fat16_fs
 * Callback function for reading a directory entry.
 */
uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p)
{
    struct fat16_dir_entry_struct* dir_entry = p;

    /* there should not be any deleted or empty entries */
    if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
        return 0;

    if(!dir_entry->entry_offset)
        dir_entry->entry_offset = offset;

    switch(fat16_interpret_dir_entry(dir_entry, buffer))
    {
        case 0: /* failure */
            return 0;
            case 1: /* buffer successfully parsed, continue */
            return 1;
            case 2: /* directory entry complete, finish */
            return 0;
        }

    return 0;
}

/**
 * \ingroup fat16_fs
 * Interprets a raw directory entry and puts the contained
 * information into the directory entry.
 *
 * For a single file there may exist multiple directory
 * entries. All except the last one are lfn entries, which
 * contain parts of the long filename. The last directory
 * entry is a traditional 8.3 style one. It contains all
 * other information like size, cluster, date and time.
 *
 * \param[in,out] dir_entry The directory entry to fill.
 * \param[in] raw_entry A pointer to 32 bytes of raw data.
 * \returns 0 on failure, 1 on success and 2 if the
 *          directory entry is complete.
 */
uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* raw_entry)
{
    if(!dir_entry || !raw_entry || !raw_entry[0])
        return 0;

    char* long_name = dir_entry->long_name;
    if(raw_entry[11] == 0x0f)
    {
        uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;

        if(char_offset + 12 < sizeof(dir_entry->long_name))
        {
            /* Lfn supports unicode, but we do not, for now.
                                                 * So we assume pure ascii and read only every
                                                 * second byte.
                                                 */
            long_name[char_offset + 0] = raw_entry[1];
            long_name[char_offset + 1] = raw_entry[3];
            long_name[char_offset + 2] = raw_entry[5];
            long_name[char_offset + 3] = raw_entry[7];
            long_name[char_offset + 4] = raw_entry[9];
            long_name[char_offset + 5] = raw_entry[14];
            long_name[char_offset + 6] = raw_entry[16];
            long_name[char_offset + 7] = raw_entry[18];
            long_name[char_offset + 8] = raw_entry[20];
            long_name[char_offset + 9] = raw_entry[22];
            long_name[char_offset + 10] = raw_entry[24];
            long_name[char_offset + 11] = raw_entry[28];
            long_name[char_offset + 12] = raw_entry[30];
        }

        return 1;
    }
    else
    {
        /* if we do not have a long name, take the short one */
        if(long_name[0] == '\0')
        {
            uint8_t i;
            for(i = 0; i < 8; ++i)
            {
                if(raw_entry[i] == ' ')
                    break;
                long_name[i] = raw_entry[i];
            }
            if(raw_entry[8] != ' ')
            {
                long_name[i++] = '.';

                uint8_t j = 8;
                for(; j < 11; ++j)
                {
                    if(raw_entry[j] != ' ')
                    {
                        long_name[i++] = raw_entry[j];
                    }
                    else
                    {
                        break;
                    }
                }
            }

            long_name[i] = '\0';
        }

        /* extract properties of file and store them within the structure */
        dir_entry->attributes = raw_entry[11];
        dir_entry->cluster = ((uint16_t) raw_entry[26]) |
        ((uint16_t) raw_entry[27] << 8);
        dir_entry->file_size = ((uint32_t) raw_entry[28]) |
        ((uint32_t) raw_entry[29] << 8) |
        ((uint32_t) raw_entry[30] << 16) |
        ((uint32_t) raw_entry[31] << 24);

        return 2;
    }
}

/**
 * \ingroup fat16_file
 * Retrieves the directory entry of a path.
 *
 * The given path may both describe a file or a directory.
 *
 * \param[in] fs The FAT16 filesystem on which to search.
 * \param[in] path The path of which to read the directory entry.
 * \param[out] dir_entry The directory entry to fill.
 * \returns 0 on failure, 1 on success.
 * \see fat16_read_dir
 */
uint8_t fat16_get_dir_entry_of_path(struct fat16_fs_struct* fs, const char* path, struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !path || path[0] == '\0' || !dir_entry)
        return 0;

    if(path[0] == '/')
        ++path;

    /* begin with the root directory */
    memset(dir_entry, 0, sizeof(*dir_entry));
    dir_entry->attributes = FAT16_ATTRIB_DIR;

    if(path[0] == '\0')
        return 1;

    while(1)
    {
        struct fat16_dir_struct* dd = fat16_open_dir(fs, dir_entry);
        if(!dd)
            break;

        /* extract the next hierarchy we will search for */
        const char* sep_pos = strchr(path, '/');
        if(!sep_pos)
            sep_pos = path + strlen(path);
        uint8_t length_to_sep = sep_pos - path;

        /* read directory entries */
        while(fat16_read_dir(dd, dir_entry))
        {
            /* check if we have found the next hierarchy */
            if((strlen(dir_entry->long_name) != length_to_sep ||
                strncmp(path, dir_entry->long_name, length_to_sep) != 0))
            continue;

            fat16_close_dir(dd);
            dd = 0;

            if(path[length_to_sep] == '\0')
    /* we iterated through the whole path and have found the file */
                return 1;

            if(dir_entry->attributes & FAT16_ATTRIB_DIR)
            {
                /* we found a parent directory of the file we are searching for */
                path = sep_pos + 1;
                break;
            }

            /* a parent of the file exists, but not the file itself */
            return 0;
        }

        fat16_close_dir(dd);
    }

    return 0;
}

/**
 * \ingroup fat16_fs
 * Retrieves the next following cluster of a given cluster.
 *
 * Using the filesystem file allocation table, this function returns
 * the number of the cluster containing the data directly following
 * the data within the cluster with the given number.
 *
 * \param[in] fs The filesystem for which to determine the next cluster.
 * \param[in] cluster_num The number of the cluster for which to determine its successor.
 * \returns The wanted cluster number, or 0 on error.
 */
uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
   130e8:	e52de004 	str	lr, [sp, #-4]!
   130ec:	e1a03801 	mov	r3, r1, lsl #16
   130f0:	e1a03823 	mov	r3, r3, lsr #16
   130f4:	e24dd004 	sub	sp, sp, #4	; 0x4
    if(!fs || cluster_num < 2)
        return 0;

    /* read appropriate fat entry */
    uint8_t fat_entry[2];
    if(!fs->partition->device_read(fs->header.fat_offset + 2 * cluster_num, fat_entry, 2))
   130f8:	e3a02002 	mov	r2, #2	; 0x2
   130fc:	e3500000 	cmp	r0, #0	; 0x0
   13100:	13530001 	cmpne	r3, #1	; 0x1
   13104:	e08d1002 	add	r1, sp, r2
   13108:	e1a0c000 	mov	ip, r0
   1310c:	9a00001a 	bls	1317c <fat16_get_next_cluster+0x94>
   13110:	e5900008 	ldr	r0, [r0, #8]
   13114:	e0200293 	mla	r0, r3, r2, r0
   13118:	e59c3000 	ldr	r3, [ip]
   1311c:	e593c000 	ldr	ip, [r3]
   13120:	e1a0e00f 	mov	lr, pc
   13124:	e12fff1c 	bx	ip
   13128:	e3500000 	cmp	r0, #0	; 0x0
        return 0;

    /* determine next cluster from fat */
    cluster_num = ((uint16_t) fat_entry[0]) |
    ((uint16_t) fat_entry[1] << 8);
	///*
    if(cluster_num == FAT16_CLUSTER_FREE ||
   1312c:	e59f1058 	ldr	r1, [pc, #88]	; 1318c <.text+0x318c>
   13130:	0a000011 	beq	1317c <fat16_get_next_cluster+0x94>
   13134:	e5dd2002 	ldrb	r2, [sp, #2]
   13138:	e5dd3003 	ldrb	r3, [sp, #3]
   1313c:	e1920403 	orrs	r0, r2, r3, lsl #8
   13140:	13a03000 	movne	r3, #0	; 0x0
   13144:	03a03001 	moveq	r3, #1	; 0x1
   13148:	e1500001 	cmp	r0, r1
   1314c:	03833001 	orreq	r3, r3, #1	; 0x1
   13150:	e2802010 	add	r2, r0, #16	; 0x10
   13154:	e3530000 	cmp	r3, #0	; 0x0
   13158:	e1a02802 	mov	r2, r2, lsl #16
   1315c:	1a000006 	bne	1317c <fat16_get_next_cluster+0x94>
   13160:	e1500001 	cmp	r0, r1
   13164:	93a03000 	movls	r3, #0	; 0x0
   13168:	83a03001 	movhi	r3, #1	; 0x1
   1316c:	e3520806 	cmp	r2, #393216	; 0x60000
   13170:	93833001 	orrls	r3, r3, #1	; 0x1
   13174:	e3530000 	cmp	r3, #0	; 0x0
   13178:	0a000000 	beq	13180 <fat16_get_next_cluster+0x98>
        cluster_num == FAT16_CLUSTER_BAD ||
       (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX) ||
	   //********************************************************************************
       //(cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
	   (cluster_num >= FAT16_CLUSTER_LAST_MIN))
	   //********************************************************************************
    //*/
	return 0;

    return cluster_num;
   1317c:	e3a00000 	mov	r0, #0	; 0x0
}
   13180:	e28dd004 	add	sp, sp, #4	; 0x4
   13184:	e49de004 	ldr	lr, [sp], #4
   13188:	e12fff1e 	bx	lr
   1318c:	0000fff7 	streqd	pc, [r0], -r7

00013190 <fat16_dir_entry_seek_callback>:
   13190:	e5d03000 	ldrb	r3, [r0]
   13194:	e3530000 	cmp	r3, #0	; 0x0
   13198:	135300e5 	cmpne	r3, #229	; 0xe5
   1319c:	0a000015 	beq	131f8 <fat16_dir_entry_seek_callback+0x68>
   131a0:	e1d2c0b0 	ldrh	ip, [r2]
   131a4:	e1d230b2 	ldrh	r3, [r2, #2]
   131a8:	e153000c 	cmp	r3, ip
   131ac:	1a00000b 	bne	131e0 <fat16_dir_entry_seek_callback+0x50>
   131b0:	e5821004 	str	r1, [r2, #4]
   131b4:	e5d0300b 	ldrb	r3, [r0, #11]
   131b8:	e353000f 	cmp	r3, #15	; 0xf
   131bc:	05d03000 	ldreqb	r3, [r0]
   131c0:	0203303f 	andeq	r3, r3, #63	; 0x3f
   131c4:	01a03283 	moveq	r3, r3, lsl #5
   131c8:	02833020 	addeq	r3, r3, #32	; 0x20
   131cc:	e3a01020 	mov	r1, #32	; 0x20
   131d0:	e3a00000 	mov	r0, #0	; 0x0
   131d4:	020310ff 	andeq	r1, r3, #255	; 0xff
   131d8:	e5c21008 	strb	r1, [r2, #8]
   131dc:	e12fff1e 	bx	lr
   131e0:	e5d0300b 	ldrb	r3, [r0, #11]
   131e4:	e28c1001 	add	r1, ip, #1	; 0x1
   131e8:	e353000f 	cmp	r3, #15	; 0xf
   131ec:	e3a00001 	mov	r0, #1	; 0x1
   131f0:	11c210b0 	strneh	r1, [r2]
   131f4:	112fff1e 	bxne	lr
   131f8:	e3a00001 	mov	r0, #1	; 0x1
   131fc:	e12fff1e 	bx	lr

00013200 <fat16_dir_entry_read_callback>:
   13200:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   13204:	e5d03000 	ldrb	r3, [r0]
   13208:	e3530000 	cmp	r3, #0	; 0x0
   1320c:	135300e5 	cmpne	r3, #229	; 0xe5
   13210:	e1a0c002 	mov	ip, r2
   13214:	0a000068 	beq	133bc <fat16_dir_entry_read_callback+0x1bc>
   13218:	e5923028 	ldr	r3, [r2, #40]
   1321c:	e3530000 	cmp	r3, #0	; 0x0
   13220:	05821028 	streq	r1, [r2, #40]
   13224:	e3500000 	cmp	r0, #0	; 0x0
   13228:	0a00005f 	beq	133ac <fat16_dir_entry_read_callback+0x1ac>
   1322c:	e5d02000 	ldrb	r2, [r0]
   13230:	e3520000 	cmp	r2, #0	; 0x0
   13234:	0a00005c 	beq	133ac <fat16_dir_entry_read_callback+0x1ac>
   13238:	e5d0300b 	ldrb	r3, [r0, #11]
   1323c:	e353000f 	cmp	r3, #15	; 0xf
   13240:	e280500b 	add	r5, r0, #11	; 0xb
   13244:	1a000026 	bne	132e4 <fat16_dir_entry_read_callback+0xe4>
   13248:	e202203f 	and	r2, r2, #63	; 0x3f
   1324c:	e3a0300d 	mov	r3, #13	; 0xd
   13250:	e0030392 	mul	r3, r2, r3
   13254:	e243300d 	sub	r3, r3, #13	; 0xd
   13258:	e1a03803 	mov	r3, r3, lsl #16
   1325c:	e1a02823 	mov	r2, r3, lsr #16
   13260:	e282300c 	add	r3, r2, #12	; 0xc
   13264:	e353001f 	cmp	r3, #31	; 0x1f
   13268:	83a01001 	movhi	r1, #1	; 0x1
   1326c:	8a00004f 	bhi	133b0 <fat16_dir_entry_read_callback+0x1b0>
   13270:	e5d03001 	ldrb	r3, [r0, #1]
   13274:	e7cc3002 	strb	r3, [ip, r2]
   13278:	e5d03003 	ldrb	r3, [r0, #3]
   1327c:	e08c2002 	add	r2, ip, r2
   13280:	e5c23001 	strb	r3, [r2, #1]
   13284:	e5d03005 	ldrb	r3, [r0, #5]
   13288:	e5c23002 	strb	r3, [r2, #2]
   1328c:	e5d03007 	ldrb	r3, [r0, #7]
   13290:	e5c23003 	strb	r3, [r2, #3]
   13294:	e5d03009 	ldrb	r3, [r0, #9]
   13298:	e5c23004 	strb	r3, [r2, #4]
   1329c:	e5d0300e 	ldrb	r3, [r0, #14]
   132a0:	e5c23005 	strb	r3, [r2, #5]
   132a4:	e5d03010 	ldrb	r3, [r0, #16]
   132a8:	e5c23006 	strb	r3, [r2, #6]
   132ac:	e5d03012 	ldrb	r3, [r0, #18]
   132b0:	e5c23007 	strb	r3, [r2, #7]
   132b4:	e5d03014 	ldrb	r3, [r0, #20]
   132b8:	e5c23008 	strb	r3, [r2, #8]
   132bc:	e5d03016 	ldrb	r3, [r0, #22]
   132c0:	e5c23009 	strb	r3, [r2, #9]
   132c4:	e5d03018 	ldrb	r3, [r0, #24]
   132c8:	e5c2300a 	strb	r3, [r2, #10]
   132cc:	e5d0301c 	ldrb	r3, [r0, #28]
   132d0:	e5c2300b 	strb	r3, [r2, #11]
   132d4:	e5d0301e 	ldrb	r3, [r0, #30]
   132d8:	e3a01001 	mov	r1, #1	; 0x1
   132dc:	e5c2300c 	strb	r3, [r2, #12]
   132e0:	ea000032 	b	133b0 <fat16_dir_entry_read_callback+0x1b0>
   132e4:	e5dc2000 	ldrb	r2, [ip]
   132e8:	e3520000 	cmp	r2, #0	; 0x0
   132ec:	1a00001e 	bne	1336c <fat16_dir_entry_read_callback+0x16c>
   132f0:	e1a01002 	mov	r1, r2
   132f4:	e7d23000 	ldrb	r3, [r2, r0]
   132f8:	e3530020 	cmp	r3, #32	; 0x20
   132fc:	e281e001 	add	lr, r1, #1	; 0x1
   13300:	0a000004 	beq	13318 <fat16_dir_entry_read_callback+0x118>
   13304:	e20e10ff 	and	r1, lr, #255	; 0xff
   13308:	e3510008 	cmp	r1, #8	; 0x8
   1330c:	e7c2300c 	strb	r3, [r2, ip]
   13310:	e2822001 	add	r2, r2, #1	; 0x1
   13314:	1afffff6 	bne	132f4 <fat16_dir_entry_read_callback+0xf4>
   13318:	e5d03008 	ldrb	r3, [r0, #8]
   1331c:	e3530020 	cmp	r3, #32	; 0x20
   13320:	0a00000f 	beq	13364 <fat16_dir_entry_read_callback+0x164>
   13324:	e3a0302e 	mov	r3, #46	; 0x2e
   13328:	e2812001 	add	r2, r1, #1	; 0x1
   1332c:	e7cc3001 	strb	r3, [ip, r1]
   13330:	e3a0e003 	mov	lr, #3	; 0x3
   13334:	e20210ff 	and	r1, r2, #255	; 0xff
   13338:	e1a03000 	mov	r3, r0
   1333c:	e5d32008 	ldrb	r2, [r3, #8]
   13340:	e3520020 	cmp	r2, #32	; 0x20
   13344:	e24ee001 	sub	lr, lr, #1	; 0x1
   13348:	e2814001 	add	r4, r1, #1	; 0x1
   1334c:	e2833001 	add	r3, r3, #1	; 0x1
   13350:	0a000003 	beq	13364 <fat16_dir_entry_read_callback+0x164>
   13354:	e21ee0ff 	ands	lr, lr, #255	; 0xff
   13358:	e7cc2001 	strb	r2, [ip, r1]
   1335c:	e20410ff 	and	r1, r4, #255	; 0xff
   13360:	1afffff5 	bne	1333c <fat16_dir_entry_read_callback+0x13c>
   13364:	e3a03000 	mov	r3, #0	; 0x0
   13368:	e7cc3001 	strb	r3, [ip, r1]
   1336c:	e5d53000 	ldrb	r3, [r5]
   13370:	e5cc3020 	strb	r3, [ip, #32]
   13374:	e5d0201b 	ldrb	r2, [r0, #27]
   13378:	e5d0301a 	ldrb	r3, [r0, #26]
   1337c:	e1833402 	orr	r3, r3, r2, lsl #8
   13380:	e1cc32b2 	strh	r3, [ip, #34]
   13384:	e5d0201d 	ldrb	r2, [r0, #29]
   13388:	e5d0301c 	ldrb	r3, [r0, #28]
   1338c:	e5d0101e 	ldrb	r1, [r0, #30]
   13390:	e1833402 	orr	r3, r3, r2, lsl #8
   13394:	e5d0201f 	ldrb	r2, [r0, #31]
   13398:	e1833801 	orr	r3, r3, r1, lsl #16
   1339c:	e1833c02 	orr	r3, r3, r2, lsl #24
   133a0:	e3a01002 	mov	r1, #2	; 0x2
   133a4:	e58c3024 	str	r3, [ip, #36]
   133a8:	ea000000 	b	133b0 <fat16_dir_entry_read_callback+0x1b0>
   133ac:	e3a01000 	mov	r1, #0	; 0x0
   133b0:	e20100ff 	and	r0, r1, #255	; 0xff
   133b4:	e3500001 	cmp	r0, #1	; 0x1
   133b8:	0a000000 	beq	133c0 <fat16_dir_entry_read_callback+0x1c0>
   133bc:	e3a00000 	mov	r0, #0	; 0x0
   133c0:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   133c4:	e12fff1e 	bx	lr

000133c8 <fat16_read_dir>:

/**
 * \ingroup fat16_fs
 * Appends a new cluster chain to an existing one.
 *
 * Set cluster_num to zero to create a completely new one.
 *
 * \param[in] fs The file system on which to operate.
 * \param[in] cluster_num The cluster to which to append the new chain.
 * \param[in] count The number of clusters to allocate.
 * \returns 0 on failure, the number of the first new cluster on success.
 */
uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint16_t count)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs)
            return 0;
    
        device_read_t device_read = fs->partition->device_read;
        device_write_t device_write = fs->partition->device_write;
        uint32_t fat_offset = fs->header.fat_offset;
        uint16_t cluster_max = fs->header.fat_size / 2;
        uint16_t cluster_next = 0;
        uint16_t count_left = count;
        uint8_t buffer[2];
        uint16_t cluster_new;
        for(cluster_new = 0; cluster_new < cluster_max; ++cluster_new)
        {
            if(!device_read(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
                return 0;
    
            /* check if this is a free cluster */
            if(buffer[0] == (FAT16_CLUSTER_FREE & 0xff) &&
                buffer[1] == ((FAT16_CLUSTER_FREE >> 8) & 0xff))
            {
                /* allocate cluster */
                if(count_left == count)
                {
                    buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
                    buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
                }
                else
                {
                    buffer[0] = cluster_next & 0xff;
                    buffer[1] = (cluster_next >> 8) & 0xff;
                }
    
                if(!device_write(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
                    break;
    
                cluster_next = cluster_new;
                if(--count_left == 0)
                    break;
            }
        }
    
        do
        {
            if(count_left > 0)
                break;
    
            /* We allocated a new cluster chain. Now join
                                             * it with the existing one.
                                             */
            if(cluster_num >= 2)
            {
                buffer[0] = cluster_next & 0xff;
                buffer[1] = (cluster_next >> 8) & 0xff;
                if(!device_write(fat_offset + 2 * cluster_num, buffer, sizeof(buffer)))
                    break;
            }
    
            return cluster_next;
    
        }
        while(0);
    
        /* No space left on device or writing error.
                             * Free up all clusters already allocated.
                             */
        fat16_free_clusters(fs, cluster_next);
    
        return 0;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_fs
 * Frees a cluster chain, or a part thereof.
 *
 * Marks the specified cluster and all clusters which are sequentially
 * referenced by it as free. They may then be used again for future
 * file allocations.
 *
 * \note If this function is used for freeing just a part of a cluster
 *       chain, the new end of the chain is not correctly terminated
 *       within the FAT. Use fat16_terminate_clusters() instead.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] cluster_num The starting cluster of the chain which to free.
 * \returns 0 on failure, 1 on success.
 * \see fat16_terminate_clusters
 */
uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs || cluster_num < 2)
            return 0;
    
        uint32_t fat_offset = fs->header.fat_offset;
        uint8_t buffer[2];
        while(cluster_num)
        {
            if(!fs->partition->device_read(fat_offset + 2 * cluster_num, buffer, 2))
                return 0;
    
            /* get next cluster of current cluster before freeing current cluster */
            uint16_t cluster_num_next = ((uint16_t) buffer[0]) |
            ((uint16_t) buffer[1] << 8);
    
            if(cluster_num_next == FAT16_CLUSTER_FREE)
                return 1;
            if(cluster_num_next == FAT16_CLUSTER_BAD ||
                (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
               cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
               )
               )
            return 0;
			///*
			//**********************************************************
            //if((cluster_num_next >= FAT16_CLUSTER_LAST_MIN) &&
            //    (cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
            //   )
			if(cluster_num_next >= FAT16_CLUSTER_LAST_MIN)
			//***********************************************************
			//*/
            cluster_num_next = 0;
    
            /* free cluster */
            buffer[0] = FAT16_CLUSTER_FREE & 0xff;
            buffer[1] = (FAT16_CLUSTER_FREE >> 8) & 0xff;
            fs->partition->device_write(fat_offset + 2 * cluster_num, buffer, 2);
    
            /* We continue in any case here, even if freeing the cluster failed.
                                             * The cluster is lost, but maybe we can still free up some later ones.
                                             */
    
            cluster_num = cluster_num_next;
        }
    
        return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_fs
 * Frees a part of a cluster chain and correctly terminates the rest.
 *
 * Marks the specified cluster as the new end of a cluster chain and
 * frees all following clusters.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] cluster_num The new end of the cluster chain.
 * \returns 0 on failure, 1 on success.
 * \see fat16_free_clusters
 */
uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs || cluster_num < 2)
            return 0;
    
        /* fetch next cluster before overwriting the cluster entry */
        uint16_t cluster_num_next = fat16_get_next_cluster(fs, cluster_num);
    
        /* mark cluster as the last one */
        uint8_t buffer[2];
        buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
        buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
        if(!fs->partition->device_write(fs->header.fat_offset + 2 * cluster_num, buffer, 2))
            return 0;
    
        /* free remaining clusters */
        if(cluster_num_next)
            return fat16_free_clusters(fs, cluster_num_next);
        else
            return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Opens a file on a FAT16 filesystem.
 *
 * \param[in] fs The filesystem on which the file to open lies.
 * \param[in] dir_entry The directory entry of the file to open.
 * \returns The file handle, or 0 on failure.
 * \see fat16_close_file
 */
struct fat16_file_struct* fat16_open_file(struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !dir_entry || (dir_entry->attributes & FAT16_ATTRIB_DIR))
        return 0;

    struct fat16_file_struct* fd = malloc(sizeof(*fd));
    if(!fd)
        return 0;

    memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
    fd->fs = fs;
    fd->pos = 0;
    fd->pos_cluster = dir_entry->cluster;

    return fd;
}

/**
 * \ingroup fat16_file
 * Closes a file.
 *
 * \param[in] fd The file handle of the file to close.
 * \see fat16_open_file
 */
void fat16_close_file(struct fat16_file_struct* fd)
{
    if(fd)
        free(fd);
}

/**
 * \ingroup fat16_file
 * Reads data from a file.
 *
 * The data requested is read from the current file location.
 *
 * \param[in] fd The file handle of the file from which to read.
 * \param[out] buffer The buffer into which to write.
 * \param[in] buffer_len The amount of data to read.
 * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 * \see fat16_write_file
 */
int16_t fat16_read_file(struct fat16_file_struct* fd, uint8_t* buffer, uint16_t buffer_len)
{
    /* check arguments */
    if(!fd || !buffer || buffer_len < 1)
        return -1;

    /* determine number of bytes to read */
    if(fd->pos + buffer_len > fd->dir_entry.file_size)
        buffer_len = fd->dir_entry.file_size - fd->pos;
    if(buffer_len == 0)
        return 0;

    uint16_t cluster_size = fd->fs->header.cluster_size;
    uint16_t cluster_num = fd->pos_cluster;
    uint16_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = fd->pos % cluster_size;

    /* find cluster in which to start reading */
    if(!cluster_num)
    {
        cluster_num = fd->dir_entry.cluster;

        if(!cluster_num)
        {
            if(!fd->pos)
                return 0;
            else
                return -1;
        }

        if(fd->pos)
        {
            uint32_t pos = fd->pos;
            while(pos >= cluster_size)
            {
                pos -= cluster_size;
                cluster_num = fat16_get_next_cluster(fd->fs, cluster_num);
                if(!cluster_num)
                    return -1;
            }
        }
    }

    /* read data */
    do
    {
        /* calculate data size to copy from cluster */
        uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
        (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
        uint16_t copy_length = cluster_size - first_cluster_offset;
        if(copy_length > buffer_left)
            copy_length = buffer_left;

        /* read data */
        if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
            return buffer_len - buffer_left;

        /* calculate new file position */
        buffer += copy_length;
        buffer_left -= copy_length;
        fd->pos += copy_length;

        if(first_cluster_offset + copy_length >= cluster_size)
        {
            /* we are on a cluster boundary, so get the next cluster */
            if((cluster_num = fat16_get_next_cluster(fd->fs, cluster_num)))
            {
                first_cluster_offset = 0;
            }
            else
            {
                fd->pos_cluster = 0;
                return buffer_len - buffer_left;
            }
        }

        fd->pos_cluster = cluster_num;

    }
    while(buffer_left > 0); /* check if we are done */

    return buffer_len;
}

/**
 * \ingroup fat16_file
 * Writes data to a file.
 *
 * The data is written to the current file location.
 *
 * \param[in] fd The file handle of the file to which to write.
 * \param[in] buffer The buffer from which to read the data to be written.
 * \param[in] buffer_len The amount of data to write.
 * \returns The number of bytes written, 0 on disk full, or -1 on failure.
 * \see fat16_read_file
 */
int16_t fat16_write_file(struct fat16_file_struct* fd, const uint8_t* buffer, uint16_t buffer_len)
{
    #if FAT16_WRITE_SUPPORT
        /* check arguments */
        if(!fd || !buffer || buffer_len < 1)
            return -1;
        if(fd->pos > fd->dir_entry.file_size)
            return -1;
    
        uint16_t cluster_size = fd->fs->header.cluster_size;
        uint16_t cluster_num = fd->pos_cluster;
        uint16_t buffer_left = buffer_len;
        uint16_t first_cluster_offset = fd->pos % cluster_size;
    
        /* find cluster in which to start writing */
        if(!cluster_num)
        {
            cluster_num = fd->dir_entry.cluster;
    
            if(!cluster_num)
            {
                if(!fd->pos)
                {
                    /* empty file */
                    fd->dir_entry.cluster = cluster_num = fat16_append_clusters(fd->fs, 0, 1);
                    if(!cluster_num)
                        return -1;
                }
                else
                {
                    return -1;
                }
            }
    
            if(fd->pos)
            {
                uint32_t pos = fd->pos;
                uint16_t cluster_num_next;
                while(pos >= cluster_size)
                {
                    pos -= cluster_size;
                    cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                    if(!cluster_num_next && pos == 0)
        /* the file exactly ends on a cluster boundary, and we append to it */
                        cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
                    if(!cluster_num_next)
                        return -1;
    
                    cluster_num = cluster_num_next;
                }
            }
        }
    
        /* write data */
        do
        {
            /* calculate data size to write to cluster */
            uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
            (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
            uint16_t write_length = cluster_size - first_cluster_offset;
            if(write_length > buffer_left)
                write_length = buffer_left;
    
            /* write data which fits into the current cluster */
            if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
                break;
    
            /* calculate new file position */
            buffer += write_length;
            buffer_left -= write_length;
            fd->pos += write_length;
    
            if(first_cluster_offset + write_length >= cluster_size)
            {
                /* we are on a cluster boundary, so get the next cluster */
                uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                if(!cluster_num_next && buffer_left > 0)
        /* we reached the last cluster, append a new one */
                    cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
                if(!cluster_num_next)
                {
                    fd->pos_cluster = 0;
                    break;
                }
    
                cluster_num = cluster_num_next;
                first_cluster_offset = 0;
            }
    
            fd->pos_cluster = cluster_num;
    
        }
        while(buffer_left > 0); /* check if we are done */
    
        /* update directory entry */
        if(fd->pos > fd->dir_entry.file_size)
        {
            uint32_t size_old = fd->dir_entry.file_size;
    
            /* update file size */
            fd->dir_entry.file_size = fd->pos;
            /* write directory entry */
            if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
            {
                /* We do not return an error here since we actually wrote
                                                             * some data to disk. So we calculate the amount of data
                                                             * we wrote to disk and which lies within the old file size.
                                                             */
                buffer_left = fd->pos - size_old;
                fd->pos = size_old;
            }
        }
    
        return buffer_len - buffer_left;
    
    #else
        return -1;
    #endif
}

/**
 * \ingroup fat16_file
 * Repositions the read/write file offset.
 *
 * Changes the file offset where the next call to fat16_read_file()
 * or fat16_write_file() starts reading/writing.
 *
 * If the new offset is beyond the end of the file, fat16_resize_file()
 * is implicitly called, i.e. the file is expanded.
 *
 * The new offset can be given in different ways determined by
 * the \c whence parameter:
 * - \b FAT16_SEEK_SET: \c *offset is relative to the beginning of the file.
 * - \b FAT16_SEEK_CUR: \c *offset is relative to the current file position.
 * - \b FAT16_SEEK_END: \c *offset is relative to the end of the file.
 *
 * The resulting absolute offset is written to the location the \c offset
 * parameter points to.
 *
 * \param[in] fd The file decriptor of the file on which to seek.
 * \param[in,out] offset A pointer to the new offset, as affected by the \c whence
 *                   parameter. The function writes the new absolute offset
 *                   to this location before it returns.
 * \param[in] whence Affects the way \c offset is interpreted, see above.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_seek_file(struct fat16_file_struct* fd, int32_t* offset, uint8_t whence)
{
    if(!fd || !offset)
        return 0;

    uint32_t new_pos = fd->pos;
    switch(whence)
    {
        case FAT16_SEEK_SET:
            new_pos = *offset;
            break;
        case FAT16_SEEK_CUR:
            new_pos += *offset;
            break;
        case FAT16_SEEK_END:
            new_pos = fd->dir_entry.file_size + *offset;
            break;
        default:
            return 0;
    }

    if(new_pos > fd->dir_entry.file_size && !fat16_resize_file(fd, new_pos))
        return 0;

    fd->pos = new_pos;
    fd->pos_cluster = 0;

    *offset = new_pos;
    return 1;
}

/**
 * \ingroup fat16_file
 * Resizes a file to have a specific size.
 *
 * Enlarges or shrinks the file pointed to by the file descriptor to have
 * exactly the specified size.
 *
 * If the file is truncated, all bytes having an equal or larger offset
 * than the given size are lost. If the file is expanded, the additional
 * bytes are allocated.
 *
 * \note Please be aware that this function just allocates or deallocates disk
 * space, it does not explicitely clear it. To avoid data leakage, this
 * must be done manually.
 *
 * \param[in] fd The file decriptor of the file which to resize.
 * \param[in] size The new size of the file.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_resize_file(struct fat16_file_struct* fd, uint32_t size)
{
    #if FAT16_WRITE_SUPPORT
        if(!fd)
            return 0;
    
        uint16_t cluster_num = fd->dir_entry.cluster;
        uint16_t cluster_size = fd->fs->header.cluster_size;
        uint32_t size_new = size;
    
        do
        {
            if(cluster_num == 0 && size_new == 0)
        /* the file stays empty */
                break;
    
            /* seek to the next cluster as long as we need the space */
            while(size_new > cluster_size)
            {
                /* get next cluster of file */
                uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                if(cluster_num_next)
                {
                    cluster_num = cluster_num_next;
                    size_new -= cluster_size;
                }
                else
                {
                    break;
                }
            }
    
            if(size_new > cluster_size || cluster_num == 0)
            {
                /* Allocate new cluster chain and append
                                                             * it to the existing one, if available.
                                                             */
                uint16_t cluster_count = size_new / cluster_size;
                if((uint32_t) cluster_count * cluster_size < size_new)
                    ++cluster_count;
                uint16_t cluster_new_chain = fat16_append_clusters(fd->fs, cluster_num, cluster_count);
                if(!cluster_new_chain)
                    return 0;
    
                if(!cluster_num)
                {
                    cluster_num = cluster_new_chain;
                    fd->dir_entry.cluster = cluster_num;
                }
            }
    
            /* write new directory entry */
            fd->dir_entry.file_size = size;
            if(size == 0)
                fd->dir_entry.cluster = 0;
            if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
                return 0;
    
            if(size == 0)
            {
                /* free all clusters of file */
                fat16_free_clusters(fd->fs, cluster_num);
            }
            else if(size_new <= cluster_size)
            {
                /* free all clusters no longer needed */
                fat16_terminate_clusters(fd->fs, cluster_num);
            }
    
        }
        while(0);
    
        /* correct file position */
        if(size < fd->pos)
        {
            fd->pos = size;
            fd->pos_cluster = 0;
        }
    
        return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_dir
 * Opens a directory.
 *
 * \param[in] fs The filesystem on which the directory to open resides.
 * \param[in] dir_entry The directory entry which stands for the directory to open.
 * \returns An opaque directory descriptor on success, 0 on failure.
 * \see fat16_close_dir
 */
struct fat16_dir_struct* fat16_open_dir(struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !dir_entry || !(dir_entry->attributes & FAT16_ATTRIB_DIR))
        return 0;

    struct fat16_dir_struct* dd = malloc(sizeof(*dd));
    if(!dd)
        return 0;

    memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
    dd->fs = fs;
    dd->entry_next = 0;

    return dd;
}

/**
 * \ingroup fat16_dir
 * Closes a directory descriptor.
 *
 * This function destroys a directory descriptor which was
 * previously obtained by calling fat16_open_dir(). When this
 * function returns, the given descriptor will be invalid.
 *
 * \param[in] dd The directory descriptor to close.
 * \see fat16_open_dir
 */
void fat16_close_dir(struct fat16_dir_struct* dd)
{
    if(dd)
        free(dd);
}

/**
 * \ingroup fat16_dir
 * Reads the next directory entry contained within a parent directory.
 *
 * \param[in] dd The descriptor of the parent directory from which to read the entry.
 * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
 * \returns 0 on failure, 1 on success.
 * \see fat16_reset_dir
 */
uint8_t fat16_read_dir(struct fat16_dir_struct* dd, struct fat16_dir_entry_struct* dir_entry)
{
   133c8:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(!dd || !dir_entry)
   133cc:	e1a0a001 	mov	sl, r1
   133d0:	e2711001 	rsbs	r1, r1, #1	; 0x1
   133d4:	33a01000 	movcc	r1, #0	; 0x0
   133d8:	e35a0000 	cmp	sl, #0	; 0x0
   133dc:	13500000 	cmpne	r0, #0	; 0x0
   133e0:	e24dd038 	sub	sp, sp, #56	; 0x38
   133e4:	e1a08000 	mov	r8, r0
   133e8:	0a00007c 	beq	135e0 <fat16_read_dir+0x218>
        return 0;

    if(dd->dir_entry.cluster == 0)
   133ec:	e1d032b6 	ldrh	r3, [r0, #38]
   133f0:	e3530000 	cmp	r3, #0	; 0x0
   133f4:	e5906000 	ldr	r6, [r0]
   133f8:	e1d033b0 	ldrh	r3, [r0, #48]
   133fc:	1a00002d 	bne	134b8 <fat16_read_dir+0xf0>
   13400:	e3560000 	cmp	r6, #0	; 0x0
   13404:	11a07001 	movne	r7, r1
   13408:	03817001 	orreq	r7, r1, #1	; 0x1
   1340c:	e3570000 	cmp	r7, #0	; 0x0
   13410:	e1a09003 	mov	r9, r3
   13414:	1a000068 	bne	135bc <fat16_read_dir+0x1f4>
   13418:	e5963000 	ldr	r3, [r6]
   1341c:	e28d502c 	add	r5, sp, #44	; 0x2c
   13420:	e2864004 	add	r4, r6, #4	; 0x4
   13424:	e1a01007 	mov	r1, r7
   13428:	e3a0200c 	mov	r2, #12	; 0xc
   1342c:	e1a00005 	mov	r0, r5
   13430:	e5936004 	ldr	r6, [r3, #4]
   13434:	eb001243 	bl	17d48 <memset>
   13438:	e2840010 	add	r0, r4, #16	; 0x10
   1343c:	e8900009 	ldmia	r0, {r0, r3}
   13440:	e59f21a8 	ldr	r2, [pc, #424]	; 135f0 <.text+0x35f0>
   13444:	e0603003 	rsb	r3, r0, r3
   13448:	e1a03803 	mov	r3, r3, lsl #16
   1344c:	e28d400c 	add	r4, sp, #12	; 0xc
   13450:	e58d2000 	str	r2, [sp]
   13454:	e1cd92be 	strh	r9, [sp, #46]
   13458:	e58d5004 	str	r5, [sp, #4]
   1345c:	e1a03823 	mov	r3, r3, lsr #16
   13460:	e1a01004 	mov	r1, r4
   13464:	e3a02020 	mov	r2, #32	; 0x20
   13468:	e1a0e00f 	mov	lr, pc
   1346c:	e12fff16 	bx	r6
   13470:	e3500000 	cmp	r0, #0	; 0x0
   13474:	0a000050 	beq	135bc <fat16_read_dir+0x1f4>
   13478:	e59d3030 	ldr	r3, [sp, #48]
   1347c:	e3530000 	cmp	r3, #0	; 0x0
   13480:	0a00004d 	beq	135bc <fat16_read_dir+0x1f4>
   13484:	e1a01007 	mov	r1, r7
   13488:	e3a0202c 	mov	r2, #44	; 0x2c
   1348c:	e1a0000a 	mov	r0, sl
   13490:	eb00122c 	bl	17d48 <memset>
   13494:	e59f2158 	ldr	r2, [pc, #344]	; 135f4 <.text+0x35f4>
   13498:	e5dd3034 	ldrb	r3, [sp, #52]
   1349c:	e88d0404 	stmia	sp, {r2, sl}
   134a0:	e1a01004 	mov	r1, r4
   134a4:	e59d0030 	ldr	r0, [sp, #48]
   134a8:	e3a02020 	mov	r2, #32	; 0x20
   134ac:	e1a0e00f 	mov	lr, pc
   134b0:	e12fff16 	bx	r6
   134b4:	ea00003a 	b	135a4 <fat16_read_dir+0x1dc>
   134b8:	e3700004 	cmn	r0, #4	; 0x4
   134bc:	13560000 	cmpne	r6, #0	; 0x0
    {
        /* read entry from root directory */
        if(fat16_read_root_dir_entry(dd->fs, dd->entry_next, dir_entry))
        {
            ++dd->entry_next;
            return 1;
   134c0:	e58d3008 	str	r3, [sp, #8]
   134c4:	e2800004 	add	r0, r0, #4	; 0x4
   134c8:	0a00003b 	beq	135bc <fat16_read_dir+0x1f4>
   134cc:	e3510000 	cmp	r1, #0	; 0x0
   134d0:	1a000039 	bne	135bc <fat16_read_dir+0x1f4>
   134d4:	e5d03020 	ldrb	r3, [r0, #32]
   134d8:	e3130010 	tst	r3, #16	; 0x10
   134dc:	0a000036 	beq	135bc <fat16_read_dir+0x1f4>
   134e0:	e1d072b2 	ldrh	r7, [r0, #34]
   134e4:	e1d691b2 	ldrh	r9, [r6, #18]
   134e8:	e5962018 	ldr	r2, [r6, #24]
   134ec:	e2473002 	sub	r3, r7, #2	; 0x2
   134f0:	e0252399 	mla	r5, r9, r3, r2
   134f4:	e28d402c 	add	r4, sp, #44	; 0x2c
   134f8:	e3a01000 	mov	r1, #0	; 0x0
   134fc:	e3a0200c 	mov	r2, #12	; 0xc
   13500:	e1a00004 	mov	r0, r4
   13504:	eb00120f 	bl	17d48 <memset>
   13508:	e59d3008 	ldr	r3, [sp, #8]
   1350c:	e1cd32be 	strh	r3, [sp, #46]
   13510:	e59f30d8 	ldr	r3, [pc, #216]	; 135f0 <.text+0x35f0>
   13514:	e28db00c 	add	fp, sp, #12	; 0xc
   13518:	e596c000 	ldr	ip, [r6]
   1351c:	e1a0100b 	mov	r1, fp
   13520:	e58d3000 	str	r3, [sp]
   13524:	e1a00005 	mov	r0, r5
   13528:	e58d4004 	str	r4, [sp, #4]
   1352c:	e3a02020 	mov	r2, #32	; 0x20
   13530:	e1a03009 	mov	r3, r9
   13534:	e59cc004 	ldr	ip, [ip, #4]
   13538:	e1a0e00f 	mov	lr, pc
   1353c:	e12fff1c 	bx	ip
   13540:	e3500000 	cmp	r0, #0	; 0x0
   13544:	e1a01007 	mov	r1, r7
   13548:	e1a00006 	mov	r0, r6
   1354c:	0a00001a 	beq	135bc <fat16_read_dir+0x1f4>
   13550:	e59d3030 	ldr	r3, [sp, #48]
   13554:	e3530000 	cmp	r3, #0	; 0x0
   13558:	1a000003 	bne	1356c <fat16_read_dir+0x1a4>
   1355c:	ebfffee1 	bl	130e8 <fat16_get_next_cluster>
   13560:	e2507000 	subs	r7, r0, #0	; 0x0
   13564:	0a000014 	beq	135bc <fat16_read_dir+0x1f4>
   13568:	eaffffde 	b	134e8 <fat16_read_dir+0x120>
   1356c:	e3a01000 	mov	r1, #0	; 0x0
   13570:	e3a0202c 	mov	r2, #44	; 0x2c
   13574:	e1a0000a 	mov	r0, sl
   13578:	eb0011f2 	bl	17d48 <memset>
   1357c:	e59f2070 	ldr	r2, [pc, #112]	; 135f4 <.text+0x35f4>
   13580:	e596c000 	ldr	ip, [r6]
   13584:	e5dd3034 	ldrb	r3, [sp, #52]
   13588:	e88d0404 	stmia	sp, {r2, sl}
   1358c:	e1a0100b 	mov	r1, fp
   13590:	e59d0030 	ldr	r0, [sp, #48]
   13594:	e3a02020 	mov	r2, #32	; 0x20
   13598:	e59cc004 	ldr	ip, [ip, #4]
   1359c:	e1a0e00f 	mov	lr, pc
   135a0:	e12fff1c 	bx	ip
   135a4:	e3500000 	cmp	r0, #0	; 0x0
   135a8:	0a000003 	beq	135bc <fat16_read_dir+0x1f4>
   135ac:	e5da3000 	ldrb	r3, [sl]
   135b0:	e2530000 	subs	r0, r3, #0	; 0x0
   135b4:	13a00001 	movne	r0, #1	; 0x1
   135b8:	ea000000 	b	135c0 <fat16_read_dir+0x1f8>
   135bc:	e3a00000 	mov	r0, #0	; 0x0
        }
    }
    else
    {
        /* read entry from a subdirectory */
        if(fat16_read_sub_dir_entry(dd->fs, dd->entry_next, &dd->dir_entry, dir_entry))
   135c0:	e3500000 	cmp	r0, #0	; 0x0
        {
            ++dd->entry_next;
            return 1;
        }
    }

    /* restart reading */
    dd->entry_next = 0;
   135c4:	03a03000 	moveq	r3, #0	; 0x0
   135c8:	01c833b0 	streqh	r3, [r8, #48]
   135cc:	11d833b0 	ldrneh	r3, [r8, #48]
   135d0:	13a00001 	movne	r0, #1	; 0x1
   135d4:	12833001 	addne	r3, r3, #1	; 0x1
   135d8:	11c833b0 	strneh	r3, [r8, #48]
   135dc:	1a000000 	bne	135e4 <fat16_read_dir+0x21c>
   135e0:	e3a00000 	mov	r0, #0	; 0x0

    return 0;
}
   135e4:	e28dd038 	add	sp, sp, #56	; 0x38
   135e8:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   135ec:	e12fff1e 	bx	lr
   135f0:	00013190 	muleq	r1, r0, r1
   135f4:	00013200 	andeq	r3, r1, r0, lsl #4

000135f8 <fat16_close_dir>:
   135f8:	e3500000 	cmp	r0, #0	; 0x0
   135fc:	e52de004 	str	lr, [sp, #-4]!
   13600:	1b000fba 	blne	174f0 <free>
   13604:	e49de004 	ldr	lr, [sp], #4
   13608:	e12fff1e 	bx	lr

0001360c <fat16_free_clusters>:
   1360c:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   13610:	e1a01801 	mov	r1, r1, lsl #16
   13614:	e1a03821 	mov	r3, r1, lsr #16
   13618:	e3500000 	cmp	r0, #0	; 0x0
   1361c:	13530001 	cmpne	r3, #1	; 0x1
   13620:	e24dd004 	sub	sp, sp, #4	; 0x4
   13624:	e1a05000 	mov	r5, r0
   13628:	85907008 	ldrhi	r7, [r0, #8]
   1362c:	8a00001e 	bhi	136ac <fat16_free_clusters+0xa0>
   13630:	ea000025 	b	136cc <fat16_free_clusters+0xc0>
   13634:	e5953000 	ldr	r3, [r5]
   13638:	e593c000 	ldr	ip, [r3]
   1363c:	e1a0e00f 	mov	lr, pc
   13640:	e12fff1c 	bx	ip
   13644:	e3a0e000 	mov	lr, #0	; 0x0
   13648:	e150000e 	cmp	r0, lr
   1364c:	e1a01006 	mov	r1, r6
   13650:	e3a02002 	mov	r2, #2	; 0x2
   13654:	e1a00004 	mov	r0, r4
   13658:	0a00001b 	beq	136cc <fat16_free_clusters+0xc0>
   1365c:	e5dd3002 	ldrb	r3, [sp, #2]
   13660:	e5ddc003 	ldrb	ip, [sp, #3]
   13664:	e183340c 	orr	r3, r3, ip, lsl #8
   13668:	e1a04003 	mov	r4, r3
   1366c:	e154000e 	cmp	r4, lr
   13670:	e2833010 	add	r3, r3, #16	; 0x10
   13674:	e1a03803 	mov	r3, r3, lsl #16
   13678:	0a000015 	beq	136d4 <fat16_free_clusters+0xc8>
   1367c:	e3530807 	cmp	r3, #458752	; 0x70000
   13680:	9a000011 	bls	136cc <fat16_free_clusters+0xc0>
   13684:	e59f3058 	ldr	r3, [pc, #88]	; 136e4 <.text+0x36e4>
   13688:	e5cde003 	strb	lr, [sp, #3]
   1368c:	e5cde002 	strb	lr, [sp, #2]
   13690:	e1540003 	cmp	r4, r3
   13694:	81a0400e 	movhi	r4, lr
   13698:	e5953000 	ldr	r3, [r5]
   1369c:	e593c008 	ldr	ip, [r3, #8]
   136a0:	e1a0e00f 	mov	lr, pc
   136a4:	e12fff1c 	bx	ip
   136a8:	e1a03004 	mov	r3, r4
   136ac:	e0874083 	add	r4, r7, r3, lsl #1
   136b0:	e28d6002 	add	r6, sp, #2	; 0x2
   136b4:	e3530000 	cmp	r3, #0	; 0x0
   136b8:	e1a01006 	mov	r1, r6
   136bc:	e3a02002 	mov	r2, #2	; 0x2
   136c0:	e1a00004 	mov	r0, r4
   136c4:	1affffda 	bne	13634 <fat16_free_clusters+0x28>
   136c8:	ea000001 	b	136d4 <fat16_free_clusters+0xc8>
   136cc:	e3a00000 	mov	r0, #0	; 0x0
   136d0:	ea000000 	b	136d8 <fat16_free_clusters+0xcc>
   136d4:	e3a00001 	mov	r0, #1	; 0x1
   136d8:	e28dd004 	add	sp, sp, #4	; 0x4
   136dc:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   136e0:	e12fff1e 	bx	lr
   136e4:	0000fff7 	streqd	pc, [r0], -r7

000136e8 <fat16_append_clusters>:
   136e8:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   136ec:	e1a01801 	mov	r1, r1, lsl #16
   136f0:	e24dd014 	sub	sp, sp, #20	; 0x14
   136f4:	e1a02802 	mov	r2, r2, lsl #16
   136f8:	e1a01821 	mov	r1, r1, lsr #16
   136fc:	e2507000 	subs	r7, r0, #0	; 0x0
   13700:	e58d1000 	str	r1, [sp]
   13704:	e1a09822 	mov	r9, r2, lsr #16
   13708:	0a00004e 	beq	13848 <fat16_append_clusters+0x160>
   1370c:	e5972000 	ldr	r2, [r7]
   13710:	e597300c 	ldr	r3, [r7, #12]
   13714:	e5921008 	ldr	r1, [r2, #8]
   13718:	e1a03783 	mov	r3, r3, lsl #15
   1371c:	e3a05000 	mov	r5, #0	; 0x0
   13720:	e5922000 	ldr	r2, [r2]
   13724:	e597b008 	ldr	fp, [r7, #8]
   13728:	e1a03823 	mov	r3, r3, lsr #16
   1372c:	e1a06009 	mov	r6, r9
   13730:	e1a0a005 	mov	sl, r5
   13734:	e58d1008 	str	r1, [sp, #8]
   13738:	e58d2004 	str	r2, [sp, #4]
   1373c:	e58d300c 	str	r3, [sp, #12]
   13740:	ea000023 	b	137d4 <fat16_append_clusters+0xec>
   13744:	e08b8084 	add	r8, fp, r4, lsl #1
   13748:	e1a00008 	mov	r0, r8
   1374c:	e28d1012 	add	r1, sp, #18	; 0x12
   13750:	e3a02002 	mov	r2, #2	; 0x2
   13754:	e59d3004 	ldr	r3, [sp, #4]
   13758:	e1a0e00f 	mov	lr, pc
   1375c:	e12fff13 	bx	r3
   13760:	e3500000 	cmp	r0, #0	; 0x0
   13764:	0a000037 	beq	13848 <fat16_append_clusters+0x160>
   13768:	e5dd3012 	ldrb	r3, [sp, #18]
   1376c:	e3530000 	cmp	r3, #0	; 0x0
   13770:	1a000016 	bne	137d0 <fat16_append_clusters+0xe8>
   13774:	e5dd3013 	ldrb	r3, [sp, #19]
   13778:	e3530000 	cmp	r3, #0	; 0x0
   1377c:	1a000013 	bne	137d0 <fat16_append_clusters+0xe8>
   13780:	e1560009 	cmp	r6, r9
   13784:	03e03000 	mvneq	r3, #0	; 0x0
   13788:	11a03425 	movne	r3, r5, lsr #8
   1378c:	05cd3013 	streqb	r3, [sp, #19]
   13790:	05cd3012 	streqb	r3, [sp, #18]
   13794:	15cd3013 	strneb	r3, [sp, #19]
   13798:	15cd5012 	strneb	r5, [sp, #18]
   1379c:	e1a00008 	mov	r0, r8
   137a0:	e28d1012 	add	r1, sp, #18	; 0x12
   137a4:	e3a02002 	mov	r2, #2	; 0x2
   137a8:	e59d3008 	ldr	r3, [sp, #8]
   137ac:	e1a0e00f 	mov	lr, pc
   137b0:	e12fff13 	bx	r3
   137b4:	e3500000 	cmp	r0, #0	; 0x0
   137b8:	0a00000a 	beq	137e8 <fat16_append_clusters+0x100>
   137bc:	e2463001 	sub	r3, r6, #1	; 0x1
   137c0:	e1a03803 	mov	r3, r3, lsl #16
   137c4:	e1b06823 	movs	r6, r3, lsr #16
   137c8:	0a000019 	beq	13834 <fat16_append_clusters+0x14c>
   137cc:	e1a05004 	mov	r5, r4
   137d0:	e28aa001 	add	sl, sl, #1	; 0x1
   137d4:	e1a0380a 	mov	r3, sl, lsl #16
   137d8:	e59d100c 	ldr	r1, [sp, #12]
   137dc:	e1a04823 	mov	r4, r3, lsr #16
   137e0:	e1540001 	cmp	r4, r1
   137e4:	3affffd6 	bcc	13744 <fat16_append_clusters+0x5c>
   137e8:	e3560000 	cmp	r6, #0	; 0x0
   137ec:	1a000012 	bne	1383c <fat16_append_clusters+0x154>
   137f0:	e59d3000 	ldr	r3, [sp]
   137f4:	e3530001 	cmp	r3, #1	; 0x1
   137f8:	9a00000b 	bls	1382c <fat16_append_clusters+0x144>
   137fc:	e59d1000 	ldr	r1, [sp]
   13800:	e1a03425 	mov	r3, r5, lsr #8
   13804:	e5cd3013 	strb	r3, [sp, #19]
   13808:	e08b0081 	add	r0, fp, r1, lsl #1
   1380c:	e5cd5012 	strb	r5, [sp, #18]
   13810:	e28d1012 	add	r1, sp, #18	; 0x12
   13814:	e3a02002 	mov	r2, #2	; 0x2
   13818:	e59d3008 	ldr	r3, [sp, #8]
   1381c:	e1a0e00f 	mov	lr, pc
   13820:	e12fff13 	bx	r3
   13824:	e3500000 	cmp	r0, #0	; 0x0
   13828:	0a000003 	beq	1383c <fat16_append_clusters+0x154>
   1382c:	e1a00005 	mov	r0, r5
   13830:	ea000005 	b	1384c <fat16_append_clusters+0x164>
   13834:	e1a05004 	mov	r5, r4
   13838:	eaffffec 	b	137f0 <fat16_append_clusters+0x108>
   1383c:	e1a00007 	mov	r0, r7
   13840:	e1a01005 	mov	r1, r5
   13844:	ebffff70 	bl	1360c <fat16_free_clusters>
   13848:	e3a00000 	mov	r0, #0	; 0x0
   1384c:	e28dd014 	add	sp, sp, #20	; 0x14
   13850:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13854:	e12fff1e 	bx	lr

00013858 <fat16_open_dir>:
   13858:	e3510000 	cmp	r1, #0	; 0x0
   1385c:	13500000 	cmpne	r0, #0	; 0x0
   13860:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13864:	e1a07000 	mov	r7, r0
   13868:	e1a05001 	mov	r5, r1
   1386c:	13a08000 	movne	r8, #0	; 0x0
   13870:	03a08001 	moveq	r8, #1	; 0x1
   13874:	0a000012 	beq	138c4 <fat16_open_dir+0x6c>
   13878:	e5d13020 	ldrb	r3, [r1, #32]
   1387c:	e3130010 	tst	r3, #16	; 0x10
   13880:	e3a00034 	mov	r0, #52	; 0x34
   13884:	0a00000e 	beq	138c4 <fat16_open_dir+0x6c>
   13888:	eb000f10 	bl	174d0 <malloc>
   1388c:	e2506000 	subs	r6, r0, #0	; 0x0
   13890:	e2864004 	add	r4, r6, #4	; 0x4
   13894:	0a00000a 	beq	138c4 <fat16_open_dir+0x6c>
   13898:	e1a0c005 	mov	ip, r5
   1389c:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
   138a0:	e1a0e004 	mov	lr, r4
   138a4:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
   138a8:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
   138ac:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
   138b0:	e89c0007 	ldmia	ip, {r0, r1, r2}
   138b4:	e5867000 	str	r7, [r6]
   138b8:	e88e0007 	stmia	lr, {r0, r1, r2}
   138bc:	e1c683b0 	strh	r8, [r6, #48]
   138c0:	ea000000 	b	138c8 <fat16_open_dir+0x70>
   138c4:	e3a06000 	mov	r6, #0	; 0x0
   138c8:	e1a00006 	mov	r0, r6
   138cc:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   138d0:	e12fff1e 	bx	lr

000138d4 <fat16_get_dir_entry_of_path>:
   138d4:	e3510000 	cmp	r1, #0	; 0x0
   138d8:	13500000 	cmpne	r0, #0	; 0x0
   138dc:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   138e0:	e1a09000 	mov	r9, r0
   138e4:	e1a04001 	mov	r4, r1
   138e8:	e1a05002 	mov	r5, r2
   138ec:	0a00003c 	beq	139e4 <fat16_get_dir_entry_of_path+0x110>
   138f0:	e5d13000 	ldrb	r3, [r1]
   138f4:	e3520000 	cmp	r2, #0	; 0x0
   138f8:	13530000 	cmpne	r3, #0	; 0x0
   138fc:	13a01000 	movne	r1, #0	; 0x0
   13900:	03a01001 	moveq	r1, #1	; 0x1
   13904:	0a000036 	beq	139e4 <fat16_get_dir_entry_of_path+0x110>
   13908:	e353002f 	cmp	r3, #47	; 0x2f
   1390c:	e1a00002 	mov	r0, r2
   13910:	e3a0202c 	mov	r2, #44	; 0x2c
   13914:	02844001 	addeq	r4, r4, #1	; 0x1
   13918:	eb00110a 	bl	17d48 <memset>
   1391c:	e3a03010 	mov	r3, #16	; 0x10
   13920:	e5c53020 	strb	r3, [r5, #32]
   13924:	e5d43000 	ldrb	r3, [r4]
   13928:	e3530000 	cmp	r3, #0	; 0x0
   1392c:	0a00002e 	beq	139ec <fat16_get_dir_entry_of_path+0x118>
   13930:	e1a00009 	mov	r0, r9
   13934:	e1a01005 	mov	r1, r5
   13938:	ebffffc6 	bl	13858 <fat16_open_dir>
   1393c:	e2507000 	subs	r7, r0, #0	; 0x0
   13940:	0a000027 	beq	139e4 <fat16_get_dir_entry_of_path+0x110>
   13944:	e1a00004 	mov	r0, r4
   13948:	e3a0102f 	mov	r1, #47	; 0x2f
   1394c:	eb001127 	bl	17df0 <strchr>
   13950:	e2508000 	subs	r8, r0, #0	; 0x0
   13954:	1a000002 	bne	13964 <fat16_get_dir_entry_of_path+0x90>
   13958:	e1a00004 	mov	r0, r4
   1395c:	eb0011af 	bl	18020 <strlen>
   13960:	e0848000 	add	r8, r4, r0
   13964:	e0643008 	rsb	r3, r4, r8
   13968:	e20360ff 	and	r6, r3, #255	; 0xff
   1396c:	ea000013 	b	139c0 <fat16_get_dir_entry_of_path+0xec>
   13970:	eb0011aa 	bl	18020 <strlen>
   13974:	e1500006 	cmp	r0, r6
   13978:	e1a01005 	mov	r1, r5
   1397c:	e1a02006 	mov	r2, r6
   13980:	e1a00004 	mov	r0, r4
   13984:	1a00000d 	bne	139c0 <fat16_get_dir_entry_of_path+0xec>
   13988:	eb0011cd 	bl	180c4 <strncmp>
   1398c:	e250a000 	subs	sl, r0, #0	; 0x0
   13990:	1a00000a 	bne	139c0 <fat16_get_dir_entry_of_path+0xec>
   13994:	e1a00007 	mov	r0, r7
   13998:	ebffff16 	bl	135f8 <fat16_close_dir>
   1399c:	e7d43006 	ldrb	r3, [r4, r6]
   139a0:	e3530000 	cmp	r3, #0	; 0x0
   139a4:	0a000010 	beq	139ec <fat16_get_dir_entry_of_path+0x118>
   139a8:	e5d53020 	ldrb	r3, [r5, #32]
   139ac:	e3130010 	tst	r3, #16	; 0x10
   139b0:	0a00000b 	beq	139e4 <fat16_get_dir_entry_of_path+0x110>
   139b4:	e2884001 	add	r4, r8, #1	; 0x1
   139b8:	e1a0700a 	mov	r7, sl
   139bc:	ea000005 	b	139d8 <fat16_get_dir_entry_of_path+0x104>
   139c0:	e1a01005 	mov	r1, r5
   139c4:	e1a00007 	mov	r0, r7
   139c8:	ebfffe7e 	bl	133c8 <fat16_read_dir>
   139cc:	e3500000 	cmp	r0, #0	; 0x0
   139d0:	e1a00005 	mov	r0, r5
   139d4:	1affffe5 	bne	13970 <fat16_get_dir_entry_of_path+0x9c>
   139d8:	e1a00007 	mov	r0, r7
   139dc:	ebffff05 	bl	135f8 <fat16_close_dir>
   139e0:	eaffffd2 	b	13930 <fat16_get_dir_entry_of_path+0x5c>
   139e4:	e3a00000 	mov	r0, #0	; 0x0
   139e8:	ea000000 	b	139f0 <fat16_get_dir_entry_of_path+0x11c>
   139ec:	e3a00001 	mov	r0, #1	; 0x1
   139f0:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   139f4:	e12fff1e 	bx	lr

000139f8 <fat16_open_file>:
   139f8:	e3510000 	cmp	r1, #0	; 0x0
   139fc:	13500000 	cmpne	r0, #0	; 0x0
   13a00:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13a04:	e1a05001 	mov	r5, r1
   13a08:	e1a07000 	mov	r7, r0
   13a0c:	0a000014 	beq	13a64 <fat16_open_file+0x6c>
   13a10:	e5d13020 	ldrb	r3, [r1, #32]
   13a14:	e2138010 	ands	r8, r3, #16	; 0x10
   13a18:	e3a00038 	mov	r0, #56	; 0x38
   13a1c:	1a000010 	bne	13a64 <fat16_open_file+0x6c>
   13a20:	eb000eaa 	bl	174d0 <malloc>
   13a24:	e2506000 	subs	r6, r0, #0	; 0x0
   13a28:	e2864004 	add	r4, r6, #4	; 0x4
   13a2c:	0a00000c 	beq	13a64 <fat16_open_file+0x6c>
   13a30:	e1a0c005 	mov	ip, r5
   13a34:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
   13a38:	e1a0e004 	mov	lr, r4
   13a3c:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
   13a40:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
   13a44:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
   13a48:	e89c0007 	ldmia	ip, {r0, r1, r2}
   13a4c:	e88e0007 	stmia	lr, {r0, r1, r2}
   13a50:	e1d552b2 	ldrh	r5, [r5, #34]
   13a54:	e5867000 	str	r7, [r6]
   13a58:	e5868030 	str	r8, [r6, #48]
   13a5c:	e1c653b4 	strh	r5, [r6, #52]
   13a60:	ea000000 	b	13a68 <fat16_open_file+0x70>
   13a64:	e3a06000 	mov	r6, #0	; 0x0
   13a68:	e1a00006 	mov	r0, r6
   13a6c:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   13a70:	e12fff1e 	bx	lr

00013a74 <fat16_close_file>:
   13a74:	e3500000 	cmp	r0, #0	; 0x0
   13a78:	e52de004 	str	lr, [sp, #-4]!
   13a7c:	1b000e9b 	blne	174f0 <free>
   13a80:	e49de004 	ldr	lr, [sp], #4
   13a84:	e12fff1e 	bx	lr

00013a88 <fat16_read_file>:
   13a88:	e1a02802 	mov	r2, r2, lsl #16
   13a8c:	e3510000 	cmp	r1, #0	; 0x0
   13a90:	13500000 	cmpne	r0, #0	; 0x0
   13a94:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13a98:	e1a06000 	mov	r6, r0
   13a9c:	e1a0b001 	mov	fp, r1
   13aa0:	e1a08822 	mov	r8, r2, lsr #16
   13aa4:	0a00004d 	beq	13be0 <fat16_read_file+0x158>
   13aa8:	e3580000 	cmp	r8, #0	; 0x0
   13aac:	0a00004b 	beq	13be0 <fat16_read_file+0x158>
   13ab0:	e5904030 	ldr	r4, [r0, #48]
   13ab4:	e5902028 	ldr	r2, [r0, #40]
   13ab8:	e0843008 	add	r3, r4, r8
   13abc:	e1530002 	cmp	r3, r2
   13ac0:	9a000003 	bls	13ad4 <fat16_read_file+0x4c>
   13ac4:	e0643002 	rsb	r3, r4, r2
   13ac8:	e1a03803 	mov	r3, r3, lsl #16
   13acc:	e1b08823 	movs	r8, r3, lsr #16
   13ad0:	0a00004d 	beq	13c0c <fat16_read_file+0x184>
   13ad4:	e5963000 	ldr	r3, [r6]
   13ad8:	e1d3a1b2 	ldrh	sl, [r3, #18]
   13adc:	e1a00004 	mov	r0, r4
   13ae0:	e1a0100a 	mov	r1, sl
   13ae4:	eb0013be 	bl	189e4 <__umodsi3>
   13ae8:	e1d653b4 	ldrh	r5, [r6, #52]
   13aec:	e1a00800 	mov	r0, r0, lsl #16
   13af0:	e3550000 	cmp	r5, #0	; 0x0
   13af4:	e1a09820 	mov	r9, r0, lsr #16
   13af8:	1a000010 	bne	13b40 <fat16_read_file+0xb8>
   13afc:	e1d652b6 	ldrh	r5, [r6, #38]
   13b00:	e3550000 	cmp	r5, #0	; 0x0
   13b04:	1a000002 	bne	13b14 <fat16_read_file+0x8c>
   13b08:	e3540000 	cmp	r4, #0	; 0x0
   13b0c:	0a00003e 	beq	13c0c <fat16_read_file+0x184>
   13b10:	ea000032 	b	13be0 <fat16_read_file+0x158>
   13b14:	e3540000 	cmp	r4, #0	; 0x0
   13b18:	1a000004 	bne	13b30 <fat16_read_file+0xa8>
   13b1c:	ea000007 	b	13b40 <fat16_read_file+0xb8>
   13b20:	e5960000 	ldr	r0, [r6]
   13b24:	ebfffd6f 	bl	130e8 <fat16_get_next_cluster>
   13b28:	e2505000 	subs	r5, r0, #0	; 0x0
   13b2c:	0a00002b 	beq	13be0 <fat16_read_file+0x158>
   13b30:	e154000a 	cmp	r4, sl
   13b34:	e1a01005 	mov	r1, r5
   13b38:	e06a4004 	rsb	r4, sl, r4
   13b3c:	2afffff7 	bcs	13b20 <fat16_read_file+0x98>
   13b40:	e1a07008 	mov	r7, r8
   13b44:	e5961000 	ldr	r1, [r6]
   13b48:	e5912018 	ldr	r2, [r1, #24]
   13b4c:	e2453002 	sub	r3, r5, #2	; 0x2
   13b50:	e020239a 	mla	r0, sl, r3, r2
   13b54:	e069300a 	rsb	r3, r9, sl
   13b58:	e1a03803 	mov	r3, r3, lsl #16
   13b5c:	e1a04823 	mov	r4, r3, lsr #16
   13b60:	e1540007 	cmp	r4, r7
   13b64:	21a04007 	movcs	r4, r7
   13b68:	e5913000 	ldr	r3, [r1]
   13b6c:	e1a02004 	mov	r2, r4
   13b70:	e1a0100b 	mov	r1, fp
   13b74:	e0800009 	add	r0, r0, r9
   13b78:	e593c000 	ldr	ip, [r3]
   13b7c:	e1a0e00f 	mov	lr, pc
   13b80:	e12fff1c 	bx	ip
   13b84:	e0643007 	rsb	r3, r4, r7
   13b88:	e3500000 	cmp	r0, #0	; 0x0
   13b8c:	e1a01005 	mov	r1, r5
   13b90:	e0892004 	add	r2, r9, r4
   13b94:	e1a00803 	mov	r0, r3, lsl #16
   13b98:	0a000012 	beq	13be8 <fat16_read_file+0x160>
   13b9c:	e5963030 	ldr	r3, [r6, #48]
   13ba0:	e152000a 	cmp	r2, sl
   13ba4:	e0833004 	add	r3, r3, r4
   13ba8:	e5863030 	str	r3, [r6, #48]
   13bac:	e1a07820 	mov	r7, r0, lsr #16
   13bb0:	e08bb004 	add	fp, fp, r4
   13bb4:	ba000004 	blt	13bcc <fat16_read_file+0x144>
   13bb8:	e5960000 	ldr	r0, [r6]
   13bbc:	ebfffd49 	bl	130e8 <fat16_get_next_cluster>
   13bc0:	e2505000 	subs	r5, r0, #0	; 0x0
   13bc4:	e3a09000 	mov	r9, #0	; 0x0
   13bc8:	0a00000a 	beq	13bf8 <fat16_read_file+0x170>
   13bcc:	e3570000 	cmp	r7, #0	; 0x0
   13bd0:	e1c653b4 	strh	r5, [r6, #52]
   13bd4:	1affffda 	bne	13b44 <fat16_read_file+0xbc>
   13bd8:	e1a03808 	mov	r3, r8, lsl #16
   13bdc:	ea000003 	b	13bf0 <fat16_read_file+0x168>
   13be0:	e3e00000 	mvn	r0, #0	; 0x0
   13be4:	ea000009 	b	13c10 <fat16_read_file+0x188>
   13be8:	e0673008 	rsb	r3, r7, r8
   13bec:	e1a03803 	mov	r3, r3, lsl #16
   13bf0:	e1a00843 	mov	r0, r3, asr #16
   13bf4:	ea000005 	b	13c10 <fat16_read_file+0x188>
   13bf8:	e0673008 	rsb	r3, r7, r8
   13bfc:	e1a03803 	mov	r3, r3, lsl #16
   13c00:	e1a00843 	mov	r0, r3, asr #16
   13c04:	e1c653b4 	strh	r5, [r6, #52]
   13c08:	ea000000 	b	13c10 <fat16_read_file+0x188>
   13c0c:	e3a00000 	mov	r0, #0	; 0x0
   13c10:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13c14:	e12fff1e 	bx	lr

00013c18 <fat16_reset_dir>:

/**
 * \ingroup fat16_dir
 * Resets a directory handle.
 *
 * Resets the directory handle such that reading restarts
 * with the first directory entry.
 *
 * \param[in] dd The directory handle to reset.
 * \returns 0 on failure, 1 on success.
 * \see fat16_read_dir
 */
uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
{
    if(!dd)
   13c18:	e3500000 	cmp	r0, #0	; 0x0
   13c1c:	e1a03000 	mov	r3, r0
        return 0;

    dd->entry_next = 0;
   13c20:	13a03000 	movne	r3, #0	; 0x0
   13c24:	11c033b0 	strneh	r3, [r0, #48]
   13c28:	13a03001 	movne	r3, #1	; 0x1
    return 1;
}
   13c2c:	e1a00003 	mov	r0, r3
   13c30:	e12fff1e 	bx	lr

00013c34 <fat16_write_dir_entry>:

/**
 * \ingroup fat16_fs
 * Writes a directory entry to disk.
 *
 * \note The file name is not checked for invalid characters.
 *
 * \note The generation of the short 8.3 file name is quite
 * simple. The first eight characters are used for the filename.
 * The extension, if any, is made up of the first three characters
 * following the last dot within the long filename. If the
 * filename (without the extension) is longer than eight characters,
 * the lower byte of the cluster number replaces the last two
 * characters to avoid name clashes. In any other case, it is your
 * responsibility to avoid name clashes.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] dir_entry The directory entry to write.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
   13c34:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    #if FAT16_WRITE_SUPPORT
        if(!fs || !dir_entry)
   13c38:	e3510000 	cmp	r1, #0	; 0x0
   13c3c:	13500000 	cmpne	r0, #0	; 0x0
   13c40:	e24dd020 	sub	sp, sp, #32	; 0x20
   13c44:	e1a06001 	mov	r6, r1
   13c48:	0a000098 	beq	13eb0 <fat16_write_dir_entry+0x27c>
            return 0;
    
        device_write_t device_write = fs->partition->device_write;
   13c4c:	e5903000 	ldr	r3, [r0]
        uint32_t offset = dir_entry->entry_offset;
        uint8_t name_len = strlen(dir_entry->long_name);
   13c50:	e1a00001 	mov	r0, r1
   13c54:	e5939008 	ldr	r9, [r3, #8]
   13c58:	eb0010f0 	bl	18020 <strlen>
   13c5c:	e20050ff 	and	r5, r0, #255	; 0xff
        uint8_t lfn_entry_count = (name_len + 12) / 13;
   13c60:	e3a0100d 	mov	r1, #13	; 0xd
   13c64:	e285000c 	add	r0, r5, #12	; 0xc
   13c68:	eb00130c 	bl	188a0 <__divsi3>
        uint8_t buffer[32];
    
        /* write 8.3 entry */
    
        /* generate 8.3 file name */
        memset(&buffer[0], ' ', 11);
   13c6c:	e3a01020 	mov	r1, #32	; 0x20
   13c70:	e1a03000 	mov	r3, r0
   13c74:	e3a0200b 	mov	r2, #11	; 0xb
   13c78:	e1a0000d 	mov	r0, sp
   13c7c:	e203a0ff 	and	sl, r3, #255	; 0xff
   13c80:	e5968028 	ldr	r8, [r6, #40]
   13c84:	eb00102f 	bl	17d48 <memset>
        char* name_ext = strrchr(dir_entry->long_name, '.');
   13c88:	e1a00006 	mov	r0, r6
   13c8c:	e3a0102e 	mov	r1, #46	; 0x2e
   13c90:	eb0011c0 	bl	18398 <strrchr>
        if(name_ext)
   13c94:	e3500000 	cmp	r0, #0	; 0x0
   13c98:	e1a0700d 	mov	r7, sp
   13c9c:	0a00000b 	beq	13cd0 <fat16_write_dir_entry+0x9c>
        {
            ++name_ext;
   13ca0:	e2804001 	add	r4, r0, #1	; 0x1
    
            uint8_t name_ext_len = strlen(name_ext);
   13ca4:	e1a00004 	mov	r0, r4
   13ca8:	eb0010dc 	bl	18020 <strlen>
   13cac:	e20020ff 	and	r2, r0, #255	; 0xff
            name_len -= name_ext_len + 1;
   13cb0:	e0623005 	rsb	r3, r2, r5
   13cb4:	e2433001 	sub	r3, r3, #1	; 0x1
    
            if(name_ext_len > 3)
                name_ext_len = 3;
    
            memcpy(&buffer[8], name_ext, name_ext_len);
   13cb8:	e3520003 	cmp	r2, #3	; 0x3
   13cbc:	23a02003 	movcs	r2, #3	; 0x3
   13cc0:	e1a01004 	mov	r1, r4
   13cc4:	e28d0008 	add	r0, sp, #8	; 0x8
   13cc8:	e20350ff 	and	r5, r3, #255	; 0xff
   13ccc:	eb000ff1 	bl	17c98 <memcpy>
        }
    
        if(name_len <= 8)
   13cd0:	e3550008 	cmp	r5, #8	; 0x8
   13cd4:	8a000004 	bhi	13cec <fat16_write_dir_entry+0xb8>
        {
            memcpy(buffer, dir_entry->long_name, name_len);
   13cd8:	e1a0000d 	mov	r0, sp
   13cdc:	e1a02005 	mov	r2, r5
   13ce0:	e1a01006 	mov	r1, r6
   13ce4:	eb000feb 	bl	17c98 <memcpy>
   13ce8:	ea00000e 	b	13d28 <fat16_write_dir_entry+0xf4>
        }
        else
        {
            memcpy(buffer, dir_entry->long_name, 8);
   13cec:	e3a02008 	mov	r2, #8	; 0x8
   13cf0:	e1a0000d 	mov	r0, sp
   13cf4:	e1a01006 	mov	r1, r6
   13cf8:	eb000fe6 	bl	17c98 <memcpy>
    
            /* Minimize 8.3 name clashes by appending
                                             * the lower byte of the cluster number.
                                             */
            uint8_t num = dir_entry->cluster & 0xff;
   13cfc:	e5d63022 	ldrb	r3, [r6, #34]
    
            buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
   13d00:	e353009f 	cmp	r3, #159	; 0x9f
   13d04:	e1a02223 	mov	r2, r3, lsr #4
            num &= 0x0f;
   13d08:	e203300f 	and	r3, r3, #15	; 0xf
   13d0c:	92822030 	addls	r2, r2, #48	; 0x30
   13d10:	82822061 	addhi	r2, r2, #97	; 0x61
            buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
   13d14:	e3530009 	cmp	r3, #9	; 0x9
   13d18:	92833030 	addls	r3, r3, #48	; 0x30
   13d1c:	82833061 	addhi	r3, r3, #97	; 0x61
   13d20:	e5cd2006 	strb	r2, [sp, #6]
   13d24:	e5cd3007 	strb	r3, [sp, #7]
        }
    
        /* fill directory entry buffer */
        memset(&buffer[11], 0, sizeof(buffer) - 11);
   13d28:	e3a01000 	mov	r1, #0	; 0x0
   13d2c:	e3a02015 	mov	r2, #21	; 0x15
   13d30:	e28d000b 	add	r0, sp, #11	; 0xb
   13d34:	eb001003 	bl	17d48 <memset>
        buffer[0x0b] = dir_entry->attributes;
   13d38:	e5d63020 	ldrb	r3, [r6, #32]
   13d3c:	e5cd300b 	strb	r3, [sp, #11]

        //Not used in bootloader
		#ifdef MAIN_FIRMWARE
			//Added modified date/time 12-26-07
			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			//*******************************************
			//char * current_time;
			//*******************************************
/*			current_time = GPS_get_time();
			char * current_date;
			current_date = GPS_get_date();
			
			uint16_t modified_time, modified_date;
			uint8_t c_hour, c_minute, c_second;
			uint8_t c_year, c_month, c_day;
			
			c_hour = (current_time[0] - '0') * 10;
			c_hour += (current_time[1] - '0');
			c_minute = (current_time[3] - '0') * 10;
			c_minute += (current_time[4] - '0');
			c_second = (current_time[6] - '0') * 10;
			c_second += (current_time[7] - '0');
			
			c_day = (current_date[0] - '0') * 10;
			c_day += (current_date[1] - '0');
			c_month = (current_date[3] - '0') * 10;
			c_month += (current_date[4] - '0');
			c_year = (current_date[6] - '0') * 10;
			c_year += (current_date[7] - '0');
			
			//Correct for 1980 = 0, 2000 = 20, year code
			c_year += 20;
			
			modified_time = (c_hour << (16-5)) | (c_minute << (16-11)) | (c_second);
			modified_date = (c_year << (16-7)) | (c_month << (16-11)) | (c_day);

			//Do a little error correction
			if (c_year < 26) //26 = 2006
			{
				modified_time = 0;
				modified_date = 0;
			}

			//rprintf("c_time=%d, %d, %d\n", c_hour, c_minute, c_second);
			//rprintf("c_date=%d, %d, %d\n", c_month, c_day, c_year);
			//rprintf("mod_time=%x\n", modified_time);
			//rprintf("mod_date=%x\n", modified_date);
			
			buffer[0x16] = (modified_time >> 0) & 0xFF;
			buffer[0x17] = (modified_time >> 8) & 0xFF;
			buffer[0x18] = (modified_date >> 0) & 0xFF;
			buffer[0x19] = (modified_date >> 8) & 0xFF;
			*/
			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
		#endif

        buffer[0x1a] = (dir_entry->cluster >> 0) & 0xff;
   13d40:	e1d622b2 	ldrh	r2, [r6, #34]
        buffer[0x1b] = (dir_entry->cluster >> 8) & 0xff;
   13d44:	e1a03422 	mov	r3, r2, lsr #8
   13d48:	e5cd201a 	strb	r2, [sp, #26]
   13d4c:	e5cd301b 	strb	r3, [sp, #27]
        buffer[0x1c] = (dir_entry->file_size >> 0) & 0xff;
   13d50:	e5963024 	ldr	r3, [r6, #36]
        buffer[0x1d] = (dir_entry->file_size >> 8) & 0xff;
        buffer[0x1e] = (dir_entry->file_size >> 16) & 0xff;
        buffer[0x1f] = (dir_entry->file_size >> 24) & 0xff;
   13d54:	e1a00c23 	mov	r0, r3, lsr #24
   13d58:	e1a02423 	mov	r2, r3, lsr #8
   13d5c:	e1a01823 	mov	r1, r3, lsr #16
   13d60:	e5cd201d 	strb	r2, [sp, #29]
   13d64:	e5cd101e 	strb	r1, [sp, #30]
   13d68:	e5cd001f 	strb	r0, [sp, #31]
   13d6c:	e5cd301c 	strb	r3, [sp, #28]
    
        /* write to disk */
        if(!device_write(offset + (uint32_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
   13d70:	e088028a 	add	r0, r8, sl, lsl #5
   13d74:	e1a0100d 	mov	r1, sp
   13d78:	e3a02020 	mov	r2, #32	; 0x20
   13d7c:	e1a0e00f 	mov	lr, pc
   13d80:	e12fff19 	bx	r9
   13d84:	e3500000 	cmp	r0, #0	; 0x0
   13d88:	e1a0400d 	mov	r4, sp
   13d8c:	0a000047 	beq	13eb0 <fat16_write_dir_entry+0x27c>
            return 0;
    
        /* calculate checksum of 8.3 name */
        uint8_t checksum = buffer[0];
   13d90:	e5dd7000 	ldrb	r7, [sp]
   13d94:	e1a0100d 	mov	r1, sp
        uint8_t i;
        for(i = 1; i < 11; ++i)
            checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
   13d98:	e1a03387 	mov	r3, r7, lsl #7
   13d9c:	e5f12001 	ldrb	r2, [r1, #1]!
   13da0:	e18330a7 	orr	r3, r3, r7, lsr #1
   13da4:	e0822003 	add	r2, r2, r3
   13da8:	e28d300a 	add	r3, sp, #10	; 0xa
   13dac:	e1510003 	cmp	r1, r3
   13db0:	e20270ff 	and	r7, r2, #255	; 0xff
   13db4:	1afffff7 	bne	13d98 <fat16_write_dir_entry+0x164>
   13db8:	e1a0500a 	mov	r5, sl
   13dbc:	ea000037 	b	13ea0 <fat16_write_dir_entry+0x26c>
    
        /* write lfn entries */
        uint8_t lfn_entry;
        for(lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
        {
            memset(buffer, 0, sizeof(buffer));
   13dc0:	e3a01000 	mov	r1, #0	; 0x0
   13dc4:	e3a02020 	mov	r2, #32	; 0x20
   13dc8:	e1a0000d 	mov	r0, sp
   13dcc:	eb000fdd 	bl	17d48 <memset>
            memset(&buffer[0x01], 0xff, 10);
   13dd0:	e3a010ff 	mov	r1, #255	; 0xff
   13dd4:	e3a0200a 	mov	r2, #10	; 0xa
   13dd8:	e28d0001 	add	r0, sp, #1	; 0x1
   13ddc:	eb000fd9 	bl	17d48 <memset>
            memset(&buffer[0x0e], 0xff, 12);
   13de0:	e3a010ff 	mov	r1, #255	; 0xff
   13de4:	e3a0200c 	mov	r2, #12	; 0xc
   13de8:	e28d000e 	add	r0, sp, #14	; 0xe
   13dec:	eb000fd5 	bl	17d48 <memset>
            memset(&buffer[0x1c], 0xff, 4);
   13df0:	e28d001c 	add	r0, sp, #28	; 0x1c
   13df4:	e3a010ff 	mov	r1, #255	; 0xff
   13df8:	e3a02004 	mov	r2, #4	; 0x4
   13dfc:	eb000fd1 	bl	17d48 <memset>
    
            buffer[0x00] = lfn_entry;
            if(lfn_entry == lfn_entry_count)
   13e00:	e155000a 	cmp	r5, sl
                buffer[0x00] |= FAT16_DIRENTRY_LFNLAST;
   13e04:	03853040 	orreq	r3, r5, #64	; 0x40
   13e08:	e5cd5000 	strb	r5, [sp]
   13e0c:	05cd3000 	streqb	r3, [sp]
    
            /* set file name */
            const char* long_name_curr = dir_entry->long_name + (lfn_entry - 1) * 13;
   13e10:	e3a0300d 	mov	r3, #13	; 0xd
   13e14:	e0236395 	mla	r3, r5, r3, r6
   13e18:	e3a0c001 	mov	ip, #1	; 0x1
   13e1c:	e243e00d 	sub	lr, r3, #13	; 0xd
            i = 1;
            while(i < 0x1f)
            {
                buffer[i++] = *long_name_curr;
                buffer[i++] = 0;
   13e20:	e28c2002 	add	r2, ip, #2	; 0x2
   13e24:	e28c3001 	add	r3, ip, #1	; 0x1
   13e28:	e28d4020 	add	r4, sp, #32	; 0x20
   13e2c:	e20330ff 	and	r3, r3, #255	; 0xff
   13e30:	e5de0000 	ldrb	r0, [lr]
   13e34:	e084100c 	add	r1, r4, ip
   13e38:	e202c0ff 	and	ip, r2, #255	; 0xff
    
                switch(i)
   13e3c:	e35c000b 	cmp	ip, #11	; 0xb
   13e40:	e0842003 	add	r2, r4, r3
   13e44:	e3a03000 	mov	r3, #0	; 0x0
   13e48:	e5410020 	strb	r0, [r1, #-32]
   13e4c:	03a0c00e 	moveq	ip, #14	; 0xe
   13e50:	e5423020 	strb	r3, [r2, #-32]
   13e54:	0a000001 	beq	13e60 <fat16_write_dir_entry+0x22c>
   13e58:	e35c001a 	cmp	ip, #26	; 0x1a
   13e5c:	028cc002 	addeq	ip, ip, #2	; 0x2
                {
                    case 0x0b:
                        i = 0x0e;
                        break;
                    case 0x1a:
                        i = 0x1c;
                        break;
                }
    
                if(!*long_name_curr++)
   13e60:	e4de3001 	ldrb	r3, [lr], #1
   13e64:	e3530000 	cmp	r3, #0	; 0x0
   13e68:	0a000001 	beq	13e74 <fat16_write_dir_entry+0x240>
   13e6c:	e35c001e 	cmp	ip, #30	; 0x1e
   13e70:	9affffea 	bls	13e20 <fat16_write_dir_entry+0x1ec>
                    break;
            }
    
            /* mark as lfn entry */
            buffer[0x0b] = 0x0f;
   13e74:	e3a0300f 	mov	r3, #15	; 0xf
   13e78:	e5cd300b 	strb	r3, [sp, #11]
    
            /* set checksum */
            buffer[0x0d] = checksum;
    
            /* write entry */
            device_write(offset, buffer, sizeof(buffer));
   13e7c:	e1a00008 	mov	r0, r8
   13e80:	e5cd700d 	strb	r7, [sp, #13]
   13e84:	e1a0100d 	mov	r1, sp
   13e88:	e3a02020 	mov	r2, #32	; 0x20
   13e8c:	e1a0e00f 	mov	lr, pc
   13e90:	e12fff19 	bx	r9
   13e94:	e2453001 	sub	r3, r5, #1	; 0x1
    
            offset += sizeof(buffer);
   13e98:	e2888020 	add	r8, r8, #32	; 0x20
   13e9c:	e20350ff 	and	r5, r3, #255	; 0xff
   13ea0:	e3550000 	cmp	r5, #0	; 0x0
   13ea4:	1affffc5 	bne	13dc0 <fat16_write_dir_entry+0x18c>
   13ea8:	e3a00001 	mov	r0, #1	; 0x1
   13eac:	ea000000 	b	13eb4 <fat16_write_dir_entry+0x280>
   13eb0:	e3a00000 	mov	r0, #0	; 0x0
        }
    
        return 1;
    
    #else
        return 0;
    #endif
}
   13eb4:	e28dd020 	add	sp, sp, #32	; 0x20
   13eb8:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13ebc:	e12fff1e 	bx	lr

00013ec0 <fat16_resize_file>:
   13ec0:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13ec4:	e2506000 	subs	r6, r0, #0	; 0x0
   13ec8:	e24dd004 	sub	sp, sp, #4	; 0x4
   13ecc:	e1a08001 	mov	r8, r1
   13ed0:	0a00005e 	beq	14050 <fat16_resize_file+0x190>
   13ed4:	e1d642b6 	ldrh	r4, [r6, #38]
   13ed8:	e5963000 	ldr	r3, [r6]
   13edc:	e2719001 	rsbs	r9, r1, #1	; 0x1
   13ee0:	33a09000 	movcc	r9, #0	; 0x0
   13ee4:	e3540000 	cmp	r4, #0	; 0x0
   13ee8:	03510000 	cmpeq	r1, #0	; 0x0
   13eec:	e1d371b2 	ldrh	r7, [r3, #18]
   13ef0:	11a05001 	movne	r5, r1
   13ef4:	1a000006 	bne	13f14 <fat16_resize_file+0x54>
   13ef8:	ea00004c 	b	14030 <fat16_resize_file+0x170>
   13efc:	e5960000 	ldr	r0, [r6]
   13f00:	ebfffc78 	bl	130e8 <fat16_get_next_cluster>
   13f04:	e3500000 	cmp	r0, #0	; 0x0
   13f08:	0a000004 	beq	13f20 <fat16_resize_file+0x60>
   13f0c:	e0675005 	rsb	r5, r7, r5
   13f10:	e1a04000 	mov	r4, r0
   13f14:	e1550007 	cmp	r5, r7
   13f18:	e1a01004 	mov	r1, r4
   13f1c:	8afffff6 	bhi	13efc <fat16_resize_file+0x3c>
   13f20:	e274a001 	rsbs	sl, r4, #1	; 0x1
   13f24:	33a0a000 	movcc	sl, #0	; 0x0
   13f28:	e1550007 	cmp	r5, r7
   13f2c:	91a0300a 	movls	r3, sl
   13f30:	838a3001 	orrhi	r3, sl, #1	; 0x1
   13f34:	e3530000 	cmp	r3, #0	; 0x0
   13f38:	0a000011 	beq	13f84 <fat16_resize_file+0xc4>
   13f3c:	e1a01007 	mov	r1, r7
   13f40:	e1a00005 	mov	r0, r5
   13f44:	eb001210 	bl	1878c <__udivsi3>
   13f48:	e1a00800 	mov	r0, r0, lsl #16
   13f4c:	e1a02820 	mov	r2, r0, lsr #16
   13f50:	e0030297 	mul	r3, r7, r2
   13f54:	e1530005 	cmp	r3, r5
   13f58:	32823001 	addcc	r3, r2, #1	; 0x1
   13f5c:	31a03803 	movcc	r3, r3, lsl #16
   13f60:	31a02823 	movcc	r2, r3, lsr #16
   13f64:	e5960000 	ldr	r0, [r6]
   13f68:	e1a01004 	mov	r1, r4
   13f6c:	ebfffddd 	bl	136e8 <fat16_append_clusters>
   13f70:	e3500000 	cmp	r0, #0	; 0x0
   13f74:	0a000035 	beq	14050 <fat16_resize_file+0x190>
   13f78:	e35a0000 	cmp	sl, #0	; 0x0
   13f7c:	11c602b6 	strneh	r0, [r6, #38]
   13f80:	11a04000 	movne	r4, r0
   13f84:	e3590000 	cmp	r9, #0	; 0x0
   13f88:	13a03000 	movne	r3, #0	; 0x0
   13f8c:	11c632b6 	strneh	r3, [r6, #38]
   13f90:	e5868028 	str	r8, [r6, #40]
   13f94:	e5960000 	ldr	r0, [r6]
   13f98:	e2861004 	add	r1, r6, #4	; 0x4
   13f9c:	ebffff24 	bl	13c34 <fat16_write_dir_entry>
   13fa0:	e3500000 	cmp	r0, #0	; 0x0
   13fa4:	0a000029 	beq	14050 <fat16_resize_file+0x190>
   13fa8:	e3590000 	cmp	r9, #0	; 0x0
   13fac:	11a01004 	movne	r1, r4
   13fb0:	15960000 	ldrne	r0, [r6]
   13fb4:	1a00001c 	bne	1402c <fat16_resize_file+0x16c>
   13fb8:	e1550007 	cmp	r5, r7
   13fbc:	8a00001b 	bhi	14030 <fat16_resize_file+0x170>
   13fc0:	e1a03804 	mov	r3, r4, lsl #16
   13fc4:	e5965000 	ldr	r5, [r6]
   13fc8:	e1a04823 	mov	r4, r3, lsr #16
   13fcc:	e3550000 	cmp	r5, #0	; 0x0
   13fd0:	13540001 	cmpne	r4, #1	; 0x1
   13fd4:	9a000015 	bls	14030 <fat16_resize_file+0x170>
   13fd8:	e1a01004 	mov	r1, r4
   13fdc:	e1a00005 	mov	r0, r5
   13fe0:	ebfffc40 	bl	130e8 <fat16_get_next_cluster>
   13fe4:	e3e03000 	mvn	r3, #0	; 0x0
   13fe8:	e5cd3003 	strb	r3, [sp, #3]
   13fec:	e5cd3002 	strb	r3, [sp, #2]
   13ff0:	e1a07000 	mov	r7, r0
   13ff4:	e5950008 	ldr	r0, [r5, #8]
   13ff8:	e5953000 	ldr	r3, [r5]
   13ffc:	e0800084 	add	r0, r0, r4, lsl #1
   14000:	e28d1002 	add	r1, sp, #2	; 0x2
   14004:	e3a02002 	mov	r2, #2	; 0x2
   14008:	e593c008 	ldr	ip, [r3, #8]
   1400c:	e1a0e00f 	mov	lr, pc
   14010:	e12fff1c 	bx	ip
   14014:	e3500000 	cmp	r0, #0	; 0x0
   14018:	0a000004 	beq	14030 <fat16_resize_file+0x170>
   1401c:	e3570000 	cmp	r7, #0	; 0x0
   14020:	0a000002 	beq	14030 <fat16_resize_file+0x170>
   14024:	e1a00005 	mov	r0, r5
   14028:	e1a01007 	mov	r1, r7
   1402c:	ebfffd76 	bl	1360c <fat16_free_clusters>
   14030:	e5963030 	ldr	r3, [r6, #48]
   14034:	e1580003 	cmp	r8, r3
   14038:	33a03000 	movcc	r3, #0	; 0x0
   1403c:	23a00001 	movcs	r0, #1	; 0x1
   14040:	33a00001 	movcc	r0, #1	; 0x1
   14044:	35868030 	strcc	r8, [r6, #48]
   14048:	31c633b4 	strcch	r3, [r6, #52]
   1404c:	ea000000 	b	14054 <fat16_resize_file+0x194>
   14050:	e3a00000 	mov	r0, #0	; 0x0
   14054:	e28dd004 	add	sp, sp, #4	; 0x4
   14058:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1405c:	e12fff1e 	bx	lr

00014060 <fat16_seek_file>:
   14060:	e3510000 	cmp	r1, #0	; 0x0
   14064:	13500000 	cmpne	r0, #0	; 0x0
   14068:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   1406c:	e20220ff 	and	r2, r2, #255	; 0xff
   14070:	e1a05000 	mov	r5, r0
   14074:	e1a06001 	mov	r6, r1
   14078:	0a00001b 	beq	140ec <fat16_seek_file+0x8c>
   1407c:	e3520001 	cmp	r2, #1	; 0x1
   14080:	e5901030 	ldr	r1, [r0, #48]
   14084:	0a000004 	beq	1409c <fat16_seek_file+0x3c>
   14088:	35964000 	ldrcc	r4, [r6]
   1408c:	3a000008 	bcc	140b4 <fat16_seek_file+0x54>
   14090:	e3520002 	cmp	r2, #2	; 0x2
   14094:	1a000014 	bne	140ec <fat16_seek_file+0x8c>
   14098:	ea000002 	b	140a8 <fat16_seek_file+0x48>
   1409c:	e5963000 	ldr	r3, [r6]
   140a0:	e0814003 	add	r4, r1, r3
   140a4:	ea000002 	b	140b4 <fat16_seek_file+0x54>
   140a8:	e5902028 	ldr	r2, [r0, #40]
   140ac:	e5963000 	ldr	r3, [r6]
   140b0:	e0824003 	add	r4, r2, r3
   140b4:	e5953028 	ldr	r3, [r5, #40]
   140b8:	e1540003 	cmp	r4, r3
   140bc:	9a000004 	bls	140d4 <fat16_seek_file+0x74>
   140c0:	e1a00005 	mov	r0, r5
   140c4:	e1a01004 	mov	r1, r4
   140c8:	ebffff7c 	bl	13ec0 <fat16_resize_file>
   140cc:	e3500000 	cmp	r0, #0	; 0x0
   140d0:	0a000005 	beq	140ec <fat16_seek_file+0x8c>
   140d4:	e3a03000 	mov	r3, #0	; 0x0
   140d8:	e3a00001 	mov	r0, #1	; 0x1
   140dc:	e5854030 	str	r4, [r5, #48]
   140e0:	e1c533b4 	strh	r3, [r5, #52]
   140e4:	e5864000 	str	r4, [r6]
   140e8:	ea000000 	b	140f0 <fat16_seek_file+0x90>
   140ec:	e3a00000 	mov	r0, #0	; 0x0
   140f0:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   140f4:	e12fff1e 	bx	lr

000140f8 <fat16_write_file>:
   140f8:	e1a02802 	mov	r2, r2, lsl #16
   140fc:	e3510000 	cmp	r1, #0	; 0x0
   14100:	13500000 	cmpne	r0, #0	; 0x0
   14104:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14108:	e1a06000 	mov	r6, r0
   1410c:	e1a09001 	mov	r9, r1
   14110:	e1a0b822 	mov	fp, r2, lsr #16
   14114:	0a000073 	beq	142e8 <fat16_write_file+0x1f0>
   14118:	e35b0000 	cmp	fp, #0	; 0x0
   1411c:	0a000071 	beq	142e8 <fat16_write_file+0x1f0>
   14120:	e5904030 	ldr	r4, [r0, #48]
   14124:	e5903028 	ldr	r3, [r0, #40]
   14128:	e1540003 	cmp	r4, r3
   1412c:	8a00006d 	bhi	142e8 <fat16_write_file+0x1f0>
   14130:	e5907000 	ldr	r7, [r0]
   14134:	e1d781b2 	ldrh	r8, [r7, #18]
   14138:	e1a00004 	mov	r0, r4
   1413c:	e1a01008 	mov	r1, r8
   14140:	eb001227 	bl	189e4 <__umodsi3>
   14144:	e1d653b4 	ldrh	r5, [r6, #52]
   14148:	e1a00800 	mov	r0, r0, lsl #16
   1414c:	e3550000 	cmp	r5, #0	; 0x0
   14150:	e1a0a820 	mov	sl, r0, lsr #16
   14154:	1a000020 	bne	141dc <fat16_write_file+0xe4>
   14158:	e1d652b6 	ldrh	r5, [r6, #38]
   1415c:	e3550000 	cmp	r5, #0	; 0x0
   14160:	1a000009 	bne	1418c <fat16_write_file+0x94>
   14164:	e3540000 	cmp	r4, #0	; 0x0
   14168:	1a00005e 	bne	142e8 <fat16_write_file+0x1f0>
   1416c:	e1a01005 	mov	r1, r5
   14170:	e1a00007 	mov	r0, r7
   14174:	e3a02001 	mov	r2, #1	; 0x1
   14178:	ebfffd5a 	bl	136e8 <fat16_append_clusters>
   1417c:	e3500000 	cmp	r0, #0	; 0x0
   14180:	e1a05000 	mov	r5, r0
   14184:	e1c602b6 	strh	r0, [r6, #38]
   14188:	0a000056 	beq	142e8 <fat16_write_file+0x1f0>
   1418c:	e5964030 	ldr	r4, [r6, #48]
   14190:	e3540000 	cmp	r4, #0	; 0x0
   14194:	1a00000c 	bne	141cc <fat16_write_file+0xd4>
   14198:	ea00000f 	b	141dc <fat16_write_file+0xe4>
   1419c:	e1c603b4 	strh	r0, [r6, #52]
   141a0:	ea00003e 	b	142a0 <fat16_write_file+0x1a8>
   141a4:	e5960000 	ldr	r0, [r6]
   141a8:	ebfffbce 	bl	130e8 <fat16_get_next_cluster>
   141ac:	e3500000 	cmp	r0, #0	; 0x0
   141b0:	03540000 	cmpeq	r4, #0	; 0x0
   141b4:	e1a01005 	mov	r1, r5
   141b8:	e3a02001 	mov	r2, #1	; 0x1
   141bc:	05960000 	ldreq	r0, [r6]
   141c0:	0bfffd48 	bleq	136e8 <fat16_append_clusters>
   141c4:	e2505000 	subs	r5, r0, #0	; 0x0
   141c8:	0a000046 	beq	142e8 <fat16_write_file+0x1f0>
   141cc:	e1540008 	cmp	r4, r8
   141d0:	e1a01005 	mov	r1, r5
   141d4:	e0684004 	rsb	r4, r8, r4
   141d8:	2afffff1 	bcs	141a4 <fat16_write_file+0xac>
   141dc:	e1a0700b 	mov	r7, fp
   141e0:	e5961000 	ldr	r1, [r6]
   141e4:	e5912018 	ldr	r2, [r1, #24]
   141e8:	e2453002 	sub	r3, r5, #2	; 0x2
   141ec:	e0202398 	mla	r0, r8, r3, r2
   141f0:	e06a3008 	rsb	r3, sl, r8
   141f4:	e1a03803 	mov	r3, r3, lsl #16
   141f8:	e1a04823 	mov	r4, r3, lsr #16
   141fc:	e1540007 	cmp	r4, r7
   14200:	21a04007 	movcs	r4, r7
   14204:	e5913000 	ldr	r3, [r1]
   14208:	e1a02004 	mov	r2, r4
   1420c:	e1a01009 	mov	r1, r9
   14210:	e080000a 	add	r0, r0, sl
   14214:	e593c008 	ldr	ip, [r3, #8]
   14218:	e1a0e00f 	mov	lr, pc
   1421c:	e12fff1c 	bx	ip
   14220:	e0643007 	rsb	r3, r4, r7
   14224:	e3500000 	cmp	r0, #0	; 0x0
   14228:	e1a01005 	mov	r1, r5
   1422c:	e08a2004 	add	r2, sl, r4
   14230:	e1a00803 	mov	r0, r3, lsl #16
   14234:	0a000019 	beq	142a0 <fat16_write_file+0x1a8>
   14238:	e5963030 	ldr	r3, [r6, #48]
   1423c:	e1520008 	cmp	r2, r8
   14240:	e0833004 	add	r3, r3, r4
   14244:	e5863030 	str	r3, [r6, #48]
   14248:	e1a07820 	mov	r7, r0, lsr #16
   1424c:	e0899004 	add	r9, r9, r4
   14250:	ba00000f 	blt	14294 <fat16_write_file+0x19c>
   14254:	e5960000 	ldr	r0, [r6]
   14258:	ebfffba2 	bl	130e8 <fat16_get_next_cluster>
   1425c:	e3a0a000 	mov	sl, #0	; 0x0
   14260:	e150000a 	cmp	r0, sl
   14264:	13a03000 	movne	r3, #0	; 0x0
   14268:	03a03001 	moveq	r3, #1	; 0x1
   1426c:	e157000a 	cmp	r7, sl
   14270:	03a03000 	moveq	r3, #0	; 0x0
   14274:	e153000a 	cmp	r3, sl
   14278:	e1a01005 	mov	r1, r5
   1427c:	e3a02001 	mov	r2, #1	; 0x1
   14280:	15960000 	ldrne	r0, [r6]
   14284:	1bfffd17 	blne	136e8 <fat16_append_clusters>
   14288:	e3500000 	cmp	r0, #0	; 0x0
   1428c:	e1a05000 	mov	r5, r0
   14290:	0affffc1 	beq	1419c <fat16_write_file+0xa4>
   14294:	e3570000 	cmp	r7, #0	; 0x0
   14298:	e1c653b4 	strh	r5, [r6, #52]
   1429c:	1affffcf 	bne	141e0 <fat16_write_file+0xe8>
   142a0:	e5963030 	ldr	r3, [r6, #48]
   142a4:	e5964028 	ldr	r4, [r6, #40]
   142a8:	e1530004 	cmp	r3, r4
   142ac:	9a000009 	bls	142d8 <fat16_write_file+0x1e0>
   142b0:	e5863028 	str	r3, [r6, #40]
   142b4:	e5960000 	ldr	r0, [r6]
   142b8:	e2861004 	add	r1, r6, #4	; 0x4
   142bc:	ebfffe5c 	bl	13c34 <fat16_write_dir_entry>
   142c0:	e3500000 	cmp	r0, #0	; 0x0
   142c4:	05963030 	ldreq	r3, [r6, #48]
   142c8:	00643003 	rsbeq	r3, r4, r3
   142cc:	01a03803 	moveq	r3, r3, lsl #16
   142d0:	05864030 	streq	r4, [r6, #48]
   142d4:	01a07823 	moveq	r7, r3, lsr #16
   142d8:	e067300b 	rsb	r3, r7, fp
   142dc:	e1a03803 	mov	r3, r3, lsl #16
   142e0:	e1a00843 	mov	r0, r3, asr #16
   142e4:	ea000000 	b	142ec <fat16_write_file+0x1f4>
   142e8:	e3e00000 	mvn	r0, #0	; 0x0
   142ec:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   142f0:	e12fff1e 	bx	lr

000142f4 <fat16_delete_file>:

/**
 * \ingroup fat16_file
 * Creates a file.
 *
 * Creates a file and obtains the directory entry of the
 * new file. If the file to create already exists, the
 * directory entry of the existing file will be returned
 * within the dir_entry parameter.
 *
 * \note The file name is not checked for invalid characters.
 *
 * \note The generation of the short 8.3 file name is quite
 * simple. The first eight characters are used for the filename.
 * The extension, if any, is made up of the first three characters
 * following the last dot within the long filename. If the
 * filename (without the extension) is longer than eight characters,
 * the lower byte of the cluster number replaces the last two
 * characters to avoid name clashes. In any other case, it is your
 * responsibility to avoid name clashes.
 *
 * \param[in] parent The handle of the directory in which to create the file.
 * \param[in] file The name of the file to create.
 * \param[out] dir_entry The directory entry to fill for the new file.
 * \returns 0 on failure, 1 on success.
 * \see fat16_delete_file
 */
uint8_t fat16_create_file(struct fat16_dir_struct* parent, const char* file, struct fat16_dir_entry_struct* dir_entry)
{
    #if FAT16_WRITE_SUPPORT
        if(!parent || !file || !file[0])
            return 0;
    
        /* check if the file already exists */
        while(1)
        {
            if(!fat16_read_dir(parent, dir_entry))
                break;
    
            if(strcmp(file, dir_entry->long_name) == 0)
            {
                fat16_reset_dir(parent);
                return 1;
            }
        }
    
        memset(dir_entry, 0, sizeof(*dir_entry));
        strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
    
        /* search for a place where to write the directory entry to disk */
        uint8_t free_dir_entries_needed = strlen(file) / 13 + 1 + 1;
        uint8_t free_dir_entries_found = 0;
        struct fat16_fs_struct* fs = parent->fs;
        uint16_t cluster_num = parent->dir_entry.cluster;
        uint32_t dir_entry_offset = 0;
        uint32_t offset = 0;
        uint32_t offset_to = 0;
    
        if(cluster_num == 0)
        {
            /* we read/write from the root directory entry */
            offset = fs->header.root_dir_offset;
            offset_to = fs->header.cluster_zero_offset;
            dir_entry_offset = offset;
        }
    
        while(1)
        {
            if(offset == offset_to)
            {
                if(cluster_num == 0)
				/* We iterated through the whole root directory entry
                * and could not find enough space for the directory entry.
                */
                return 0;
    
                if(offset)
                {
                    /* We reached a cluster boundary and have to
                    * switch to the next cluster.
                    */
    
                    uint16_t cluster_next = fat16_get_next_cluster(fs, cluster_num);
                    if(!cluster_next)
                    {
                        cluster_next = fat16_append_clusters(fs, cluster_num, 1);
                        if(!cluster_next)
                            return 0;
    
                        /* we appended a new cluster and know it is free */
                        dir_entry_offset = fs->header.cluster_zero_offset +
                        (uint32_t) (cluster_next - 2) * fs->header.cluster_size;
    
                        /* TODO: This cluster has to be zeroed in an efficient way, or at least
                        *       every 32th byte should be set to FAT16_DIRENTRY_DELETED.
                        */
                        break;
                    }
                    cluster_num = cluster_next;
                }
    
                offset = fs->header.cluster_zero_offset +
                (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
                offset_to = offset + fs->header.cluster_size;
                dir_entry_offset = offset;
                free_dir_entries_found = 0;
            }
    
            /* read next lfn or 8.3 entry */
            uint8_t first_char;
            if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
                return 0;
    
            /* check if we found a free directory entry */
            if(first_char == FAT16_DIRENTRY_DELETED || !first_char)
            {
                /* check if we have the needed number of available entries */
                ++free_dir_entries_found;
                if(free_dir_entries_found >= free_dir_entries_needed)
                    break;
    
                offset += 32;
            }
            else
            {
                offset += 32;
                dir_entry_offset = offset;
                free_dir_entries_found = 0;
            }
        }

        /* write directory entry to disk */
        dir_entry->entry_offset = dir_entry_offset;
        if(!fat16_write_dir_entry(fs, dir_entry))
            return 0;
    
        return 1;
    
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Deletes a file or directory.
 *
 * It is not checked if the file to delete is a directory.
 * If a directory is deleted without first deleting its
 * subdirectories and files, disk space occupied by these
 * files will get wasted as there is no chance to release
 * it and mark it as free.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] dir_entry The directory entry of the file to delete.
 * \returns 0 on failure, 1 on success.
 * \see fat16_create_file
 */
uint8_t fat16_delete_file(struct fat16_fs_struct* fs, struct fat16_dir_entry_struct* dir_entry)
{
   142f4:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    #if FAT16_WRITE_SUPPORT
        if(!fs || !dir_entry)
   142f8:	e3510000 	cmp	r1, #0	; 0x0
   142fc:	13500000 	cmpne	r0, #0	; 0x0
   14300:	e24dd00c 	sub	sp, sp, #12	; 0xc
   14304:	e1a06000 	mov	r6, r0
   14308:	e1a07001 	mov	r7, r1
   1430c:	0a00001f 	beq	14390 <fat16_delete_file+0x9c>
            return 0;
    
        /* get offset of the file's directory entry */
        uint32_t dir_entry_offset = dir_entry->entry_offset;
   14310:	e5915028 	ldr	r5, [r1, #40]
        if(!dir_entry_offset)
   14314:	e3550000 	cmp	r5, #0	; 0x0
   14318:	0a00001c 	beq	14390 <fat16_delete_file+0x9c>
            return 0;
    
        uint8_t buffer[12];
        while(1)
        {
            /* read directory entry */
            if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
   1431c:	e1a0100d 	mov	r1, sp
   14320:	e1a00005 	mov	r0, r5
   14324:	e3a0200c 	mov	r2, #12	; 0xc
   14328:	e5963000 	ldr	r3, [r6]
   1432c:	e593c000 	ldr	ip, [r3]
   14330:	e1a0e00f 	mov	lr, pc
   14334:	e12fff1c 	bx	ip
   14338:	e3500000 	cmp	r0, #0	; 0x0
   1433c:	e1a0400d 	mov	r4, sp
                return 0;
    
            /* mark the directory entry as deleted */
            buffer[0] = FAT16_DIRENTRY_DELETED;
    
            /* write back entry */
            if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
   14340:	e1a00005 	mov	r0, r5
   14344:	e1a0100d 	mov	r1, sp
   14348:	e3a0200c 	mov	r2, #12	; 0xc
                return 0;
    
            /* check if we deleted the whole entry */
            if(buffer[11] != 0x0f)
                break;
    
            dir_entry_offset += 32;
   1434c:	e2855020 	add	r5, r5, #32	; 0x20
   14350:	0a00000e 	beq	14390 <fat16_delete_file+0x9c>
   14354:	e3e0301a 	mvn	r3, #26	; 0x1a
   14358:	e5cd3000 	strb	r3, [sp]
   1435c:	e5963000 	ldr	r3, [r6]
   14360:	e593c008 	ldr	ip, [r3, #8]
   14364:	e1a0e00f 	mov	lr, pc
   14368:	e12fff1c 	bx	ip
   1436c:	e3500000 	cmp	r0, #0	; 0x0
   14370:	0a000006 	beq	14390 <fat16_delete_file+0x9c>
   14374:	e5dd300b 	ldrb	r3, [sp, #11]
   14378:	e353000f 	cmp	r3, #15	; 0xf
   1437c:	0affffe6 	beq	1431c <fat16_delete_file+0x28>
        }
    
        /* We deleted the directory entry. The next thing to do is
                             * marking all occupied clusters as free.
                             */
        return fat16_free_clusters(fs, dir_entry->cluster);
   14380:	e1a00006 	mov	r0, r6
   14384:	e1d712b2 	ldrh	r1, [r7, #34]
   14388:	ebfffc9f 	bl	1360c <fat16_free_clusters>
   1438c:	ea000000 	b	14394 <fat16_delete_file+0xa0>
   14390:	e3a00000 	mov	r0, #0	; 0x0
    #else
        return 0;
    #endif
}
   14394:	e28dd00c 	add	sp, sp, #12	; 0xc
   14398:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   1439c:	e12fff1e 	bx	lr

000143a0 <fat16_get_fs_size>:

/**
 * \ingroup fat16_fs
 * Returns the amount of total storage capacity of the filesystem in bytes.
 *
 * \param[in] fs The filesystem on which to operate.
 * \returns 0 on failure, the filesystem size in bytes otherwise.
 */
uint32_t fat16_get_fs_size(const struct fat16_fs_struct* fs)
{
    if(!fs)
   143a0:	e3500000 	cmp	r0, #0	; 0x0
        return 0;

    return (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
   143a4:	1590300c 	ldrne	r3, [r0, #12]
   143a8:	e1a02000 	mov	r2, r0
   143ac:	11a030a3 	movne	r3, r3, lsr #1
   143b0:	11d021b2 	ldrneh	r2, [r0, #18]
   143b4:	12433002 	subne	r3, r3, #2	; 0x2
   143b8:	10020293 	mulne	r2, r3, r2
}
   143bc:	e1a00002 	mov	r0, r2
   143c0:	e12fff1e 	bx	lr

000143c4 <fat16_get_fs_free>:

/**
 * \ingroup fat16_fs
 * Returns the amount of free storage capacity on the filesystem in bytes.
 *
 * \note As the FAT16 filesystem is cluster based, this function does not
 *       return continuous values but multiples of the cluster size.
 *
 * \param[in] fs The filesystem on which to operate.
 * \returns 0 on failure, the free filesystem space in bytes otherwise.
 */
uint32_t fat16_get_fs_free(const struct fat16_fs_struct* fs)
{
   143c4:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    if(!fs)
   143c8:	e2506000 	subs	r6, r0, #0	; 0x0
   143cc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   143d0:	0a000021 	beq	1445c <fat16_get_fs_free+0x98>
        return 0;

    uint8_t fat[32];
    struct fat16_usage_count_callback_arg count_arg;
    count_arg.cluster_count = 0;
    count_arg.buffer_size = sizeof(fat);
   143d4:	e3a03020 	mov	r3, #32	; 0x20
   143d8:	e5cd302a 	strb	r3, [sp, #42]

    uint32_t fat_offset = fs->header.fat_offset;
   143dc:	e5967008 	ldr	r7, [r6, #8]
    uint32_t fat_size = fs->header.fat_size;
   143e0:	e596500c 	ldr	r5, [r6, #12]
   143e4:	e3a03000 	mov	r3, #0	; 0x0
   143e8:	e1cd32b8 	strh	r3, [sp, #40]
   143ec:	ea000012 	b	1443c <fat16_get_fs_free+0x78>
    while(fat_size > 0)
    {
        uint16_t length = UINT16_MAX - 1;
        if(fat_size < length)
   143f0:	e59f3074 	ldr	r3, [pc, #116]	; 1446c <.text+0x446c>
   143f4:	e1550003 	cmp	r5, r3
            length = fat_size;

        if(!fs->partition->device_read_interval(fat_offset,
   143f8:	e59f3070 	ldr	r3, [pc, #112]	; 14470 <.text+0x4470>
   143fc:	91a04822 	movls	r4, r2, lsr #16
   14400:	e596c000 	ldr	ip, [r6]
   14404:	e58d3000 	str	r3, [sp]
   14408:	e28d3028 	add	r3, sp, #40	; 0x28
   1440c:	e58d3004 	str	r3, [sp, #4]
   14410:	e1a00007 	mov	r0, r7
   14414:	e28d1008 	add	r1, sp, #8	; 0x8
   14418:	e3a02020 	mov	r2, #32	; 0x20
   1441c:	e1a03004 	mov	r3, r4
   14420:	e59cc004 	ldr	ip, [ip, #4]
   14424:	e1a0e00f 	mov	lr, pc
   14428:	e12fff1c 	bx	ip
   1442c:	e3500000 	cmp	r0, #0	; 0x0
   14430:	0a000009 	beq	1445c <fat16_get_fs_free+0x98>
            fat,
           sizeof(fat),
           length,
           fat16_get_fs_free_callback,
           &count_arg
           )
           )
        return 0;

        fat_offset += length;
        fat_size -= length;
   14434:	e0645005 	rsb	r5, r4, r5
   14438:	e0877004 	add	r7, r7, r4
   1443c:	e3550000 	cmp	r5, #0	; 0x0
   14440:	e59f402c 	ldr	r4, [pc, #44]	; 14474 <.text+0x4474>
   14444:	e1a02805 	mov	r2, r5, lsl #16
   14448:	1affffe8 	bne	143f0 <fat16_get_fs_free+0x2c>
    }

    return (uint32_t) count_arg.cluster_count * fs->header.cluster_size;
   1444c:	e1d621b2 	ldrh	r2, [r6, #18]
   14450:	e1dd32b8 	ldrh	r3, [sp, #40]
   14454:	e0000392 	mul	r0, r2, r3
   14458:	ea000000 	b	14460 <fat16_get_fs_free+0x9c>
   1445c:	e3a00000 	mov	r0, #0	; 0x0
}
   14460:	e28dd02c 	add	sp, sp, #44	; 0x2c
   14464:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   14468:	e12fff1e 	bx	lr
   1446c:	0000fffd 	streqd	pc, [r0], -sp
   14470:	00014478 	andeq	r4, r1, r8, ror r4
   14474:	0000fffe 	streqd	pc, [r0], -lr

00014478 <fat16_get_fs_free_callback>:

/**
 * \ingroup fat16_fs
 * Callback function used for counting free clusters.
 */
uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p)
{
   14478:	e92d4010 	stmdb	sp!, {r4, lr}
    struct fat16_usage_count_callback_arg* count_arg = (struct fat16_usage_count_callback_arg*) p;
    uint8_t buffer_size = count_arg->buffer_size;
   1447c:	e5d24002 	ldrb	r4, [r2, #2]
   14480:	e1a0c002 	mov	ip, r2
   14484:	e1a01000 	mov	r1, r0
   14488:	e3a0e000 	mov	lr, #0	; 0x0
   1448c:	ea000007 	b	144b0 <fat16_get_fs_free_callback+0x38>
    uint8_t i;
    for(i = 0; i < buffer_size; i += 2)
    {
        if((((uint16_t) buffer[1] << 8) | ((uint16_t) buffer[0] << 0)) == FAT16_CLUSTER_FREE)
   14490:	e7de3000 	ldrb	r3, [lr, r0]
   14494:	e5d12001 	ldrb	r2, [r1, #1]
   14498:	e1932402 	orrs	r2, r3, r2, lsl #8
            ++(count_arg->cluster_count);
   1449c:	01dc30b0 	ldreqh	r3, [ip]
   144a0:	02833001 	addeq	r3, r3, #1	; 0x1
   144a4:	01cc30b0 	streqh	r3, [ip]

        buffer += 2;
   144a8:	e2811002 	add	r1, r1, #2	; 0x2
   144ac:	e28ee002 	add	lr, lr, #2	; 0x2
   144b0:	e20e30ff 	and	r3, lr, #255	; 0xff
   144b4:	e1530004 	cmp	r3, r4
   144b8:	3afffff4 	bcc	14490 <fat16_get_fs_free_callback+0x18>
    }

    return 1;
}
   144bc:	e3a00001 	mov	r0, #1	; 0x1
   144c0:	e8bd4010 	ldmia	sp!, {r4, lr}
   144c4:	e12fff1e 	bx	lr

000144c8 <fat16_file_size>:

uint8_t find_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd, const char* name, struct fat16_dir_entry_struct* dir_entry)
{
    while(fat16_read_dir(dd, dir_entry))
    {
        if(strcmp(dir_entry->long_name, name) == 0)
        {
            fat16_reset_dir(dd);
            return 1;
        }
    }

    return 0;
}

struct fat16_file_struct* open_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd, const char* name)
{
    struct fat16_dir_entry_struct file_entry;
    if(!find_file_in_dir(fs, dd, name, &file_entry))
        return 0;

    return fat16_open_file(fs, &file_entry);
}

int fat16_file_size(struct fat16_file_struct * file)
{
    return(file->dir_entry.file_size);
}
   144c8:	e5900028 	ldr	r0, [r0, #40]
   144cc:	e12fff1e 	bx	lr

000144d0 <fat16_create_file>:
   144d0:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   144d4:	e2706001 	rsbs	r6, r0, #1	; 0x1
   144d8:	33a06000 	movcc	r6, #0	; 0x0
   144dc:	e3500000 	cmp	r0, #0	; 0x0
   144e0:	13510000 	cmpne	r1, #0	; 0x0
   144e4:	e24dd004 	sub	sp, sp, #4	; 0x4
   144e8:	e1a05000 	mov	r5, r0
   144ec:	e1a04001 	mov	r4, r1
   144f0:	e1a08002 	mov	r8, r2
   144f4:	0a000062 	beq	14684 <fat16_create_file+0x1b4>
   144f8:	e5d13000 	ldrb	r3, [r1]
   144fc:	e3530000 	cmp	r3, #0	; 0x0
   14500:	0a00005f 	beq	14684 <fat16_create_file+0x1b4>
   14504:	e1a01008 	mov	r1, r8
   14508:	e1a00005 	mov	r0, r5
   1450c:	ebfffbad 	bl	133c8 <fat16_read_dir>
   14510:	e2503000 	subs	r3, r0, #0	; 0x0
   14514:	e1a01008 	mov	r1, r8
   14518:	e1a00004 	mov	r0, r4
   1451c:	0a000007 	beq	14540 <fat16_create_file+0x70>
   14520:	eb000e80 	bl	17f28 <strcmp>
   14524:	e3500000 	cmp	r0, #0	; 0x0
   14528:	1afffff5 	bne	14504 <fat16_create_file+0x34>
   1452c:	e3560000 	cmp	r6, #0	; 0x0
   14530:	02800001 	addeq	r0, r0, #1	; 0x1
   14534:	01c563b0 	streqh	r6, [r5, #48]
   14538:	0a000054 	beq	14690 <fat16_create_file+0x1c0>
   1453c:	ea000052 	b	1468c <fat16_create_file+0x1bc>
   14540:	e1a01003 	mov	r1, r3
   14544:	e3a0202c 	mov	r2, #44	; 0x2c
   14548:	e1a00008 	mov	r0, r8
   1454c:	eb000dfd 	bl	17d48 <memset>
   14550:	e1a01004 	mov	r1, r4
   14554:	e3a0201f 	mov	r2, #31	; 0x1f
   14558:	e1a00008 	mov	r0, r8
   1455c:	eb000f37 	bl	18240 <strncpy>
   14560:	e1a00004 	mov	r0, r4
   14564:	eb000ead 	bl	18020 <strlen>
   14568:	e3a0100d 	mov	r1, #13	; 0xd
   1456c:	eb001086 	bl	1878c <__udivsi3>
   14570:	e1d562b6 	ldrh	r6, [r5, #38]
   14574:	e2800002 	add	r0, r0, #2	; 0x2
   14578:	e3560000 	cmp	r6, #0	; 0x0
   1457c:	e200b0ff 	and	fp, r0, #255	; 0xff
   14580:	e5955000 	ldr	r5, [r5]
   14584:	1a00001a 	bne	145f4 <fat16_create_file+0x124>
   14588:	e2854014 	add	r4, r5, #20	; 0x14
   1458c:	e8940210 	ldmia	r4, {r4, r9}
   14590:	e1a07004 	mov	r7, r4
   14594:	e1a0a006 	mov	sl, r6
   14598:	e1540009 	cmp	r4, r9
   1459c:	1a00001b 	bne	14610 <fat16_create_file+0x140>
   145a0:	e3560000 	cmp	r6, #0	; 0x0
   145a4:	0a000036 	beq	14684 <fat16_create_file+0x1b4>
   145a8:	e3540000 	cmp	r4, #0	; 0x0
   145ac:	0a000010 	beq	145f4 <fat16_create_file+0x124>
   145b0:	e1a01006 	mov	r1, r6
   145b4:	e1a00005 	mov	r0, r5
   145b8:	ebfffaca 	bl	130e8 <fat16_get_next_cluster>
   145bc:	e3500000 	cmp	r0, #0	; 0x0
   145c0:	11a06000 	movne	r6, r0
   145c4:	1a00000a 	bne	145f4 <fat16_create_file+0x124>
   145c8:	e1a01006 	mov	r1, r6
   145cc:	e1a00005 	mov	r0, r5
   145d0:	e3a02001 	mov	r2, #1	; 0x1
   145d4:	ebfffc43 	bl	136e8 <fat16_append_clusters>
   145d8:	e3500000 	cmp	r0, #0	; 0x0
   145dc:	0a000028 	beq	14684 <fat16_create_file+0x1b4>
   145e0:	e1d511b2 	ldrh	r1, [r5, #18]
   145e4:	e5952018 	ldr	r2, [r5, #24]
   145e8:	e2403002 	sub	r3, r0, #2	; 0x2
   145ec:	e0272391 	mla	r7, r1, r3, r2
   145f0:	ea00001d 	b	1466c <fat16_create_file+0x19c>
   145f4:	e1d511b2 	ldrh	r1, [r5, #18]
   145f8:	e5952018 	ldr	r2, [r5, #24]
   145fc:	e2463002 	sub	r3, r6, #2	; 0x2
   14600:	e0242391 	mla	r4, r1, r3, r2
   14604:	e3a0a000 	mov	sl, #0	; 0x0
   14608:	e0849001 	add	r9, r4, r1
   1460c:	e1a07004 	mov	r7, r4
   14610:	e5953000 	ldr	r3, [r5]
   14614:	e1a00004 	mov	r0, r4
   14618:	e28d1003 	add	r1, sp, #3	; 0x3
   1461c:	e3a02001 	mov	r2, #1	; 0x1
   14620:	e593c000 	ldr	ip, [r3]
   14624:	e1a0e00f 	mov	lr, pc
   14628:	e12fff1c 	bx	ip
   1462c:	e3500000 	cmp	r0, #0	; 0x0
   14630:	0a000013 	beq	14684 <fat16_create_file+0x1b4>
   14634:	e5dd3003 	ldrb	r3, [sp, #3]
   14638:	e3530000 	cmp	r3, #0	; 0x0
   1463c:	135300e5 	cmpne	r3, #229	; 0xe5
   14640:	13a03000 	movne	r3, #0	; 0x0
   14644:	03a03001 	moveq	r3, #1	; 0x1
   14648:	12847020 	addne	r7, r4, #32	; 0x20
   1464c:	11a0a003 	movne	sl, r3
   14650:	11a04007 	movne	r4, r7
   14654:	1affffcf 	bne	14598 <fat16_create_file+0xc8>
   14658:	e28a3001 	add	r3, sl, #1	; 0x1
   1465c:	e203a0ff 	and	sl, r3, #255	; 0xff
   14660:	e15a000b 	cmp	sl, fp
   14664:	32844020 	addcc	r4, r4, #32	; 0x20
   14668:	3affffca 	bcc	14598 <fat16_create_file+0xc8>
   1466c:	e5887028 	str	r7, [r8, #40]
   14670:	e1a00005 	mov	r0, r5
   14674:	e1a01008 	mov	r1, r8
   14678:	ebfffd6d 	bl	13c34 <fat16_write_dir_entry>
   1467c:	e3500000 	cmp	r0, #0	; 0x0
   14680:	1a000001 	bne	1468c <fat16_create_file+0x1bc>
   14684:	e3a00000 	mov	r0, #0	; 0x0
   14688:	ea000000 	b	14690 <fat16_create_file+0x1c0>
   1468c:	e3a00001 	mov	r0, #1	; 0x1
   14690:	e28dd004 	add	sp, sp, #4	; 0x4
   14694:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14698:	e12fff1e 	bx	lr

0001469c <find_file_in_dir>:
   1469c:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   146a0:	e1a04001 	mov	r4, r1
   146a4:	e1a06002 	mov	r6, r2
   146a8:	e1a05003 	mov	r5, r3
   146ac:	ea000007 	b	146d0 <find_file_in_dir+0x34>
   146b0:	eb000e1c 	bl	17f28 <strcmp>
   146b4:	e3500000 	cmp	r0, #0	; 0x0
   146b8:	1a000004 	bne	146d0 <find_file_in_dir+0x34>
   146bc:	e3540000 	cmp	r4, #0	; 0x0
   146c0:	03a03001 	moveq	r3, #1	; 0x1
   146c4:	13a03001 	movne	r3, #1	; 0x1
   146c8:	11c403b0 	strneh	r0, [r4, #48]
   146cc:	ea000006 	b	146ec <find_file_in_dir+0x50>
   146d0:	e1a01005 	mov	r1, r5
   146d4:	e1a00004 	mov	r0, r4
   146d8:	ebfffb3a 	bl	133c8 <fat16_read_dir>
   146dc:	e2503000 	subs	r3, r0, #0	; 0x0
   146e0:	e1a01006 	mov	r1, r6
   146e4:	e1a00005 	mov	r0, r5
   146e8:	1afffff0 	bne	146b0 <find_file_in_dir+0x14>
   146ec:	e1a00003 	mov	r0, r3
   146f0:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   146f4:	e12fff1e 	bx	lr

000146f8 <open_file_in_dir>:
   146f8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   146fc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   14700:	e1a0300d 	mov	r3, sp
   14704:	e1a04000 	mov	r4, r0
   14708:	ebffffe3 	bl	1469c <find_file_in_dir>
   1470c:	e3500000 	cmp	r0, #0	; 0x0
   14710:	e1a03000 	mov	r3, r0
   14714:	e1a0500d 	mov	r5, sp
   14718:	e1a00004 	mov	r0, r4
   1471c:	e1a0100d 	mov	r1, sp
   14720:	0a000001 	beq	1472c <open_file_in_dir+0x34>
   14724:	ebfffcb3 	bl	139f8 <fat16_open_file>
   14728:	e1a03000 	mov	r3, r0
   1472c:	e1a00003 	mov	r0, r3
   14730:	e28dd02c 	add	sp, sp, #44	; 0x2c
   14734:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   14738:	e12fff1e 	bx	lr

0001473c <partition_open>:
 * \returns 0 on failure, a partition descriptor on success.
 * \see partition_close
 */
struct partition_struct* partition_open(device_read_t device_read, device_read_interval_t device_read_interval, device_write_t device_write, int8_t index0)
{
   1473c:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
    struct partition_struct* new_partition = 0;
    uint8_t buffer[0x10];

    if(!device_read || !device_read_interval || index0 >= 4)
   14740:	e3510000 	cmp	r1, #0	; 0x0
   14744:	13500000 	cmpne	r0, #0	; 0x0
   14748:	e24dd010 	sub	sp, sp, #16	; 0x10
   1474c:	e1a06000 	mov	r6, r0
   14750:	e1a07001 	mov	r7, r1
   14754:	13a08000 	movne	r8, #0	; 0x0
   14758:	03a08001 	moveq	r8, #1	; 0x1
   1475c:	e1a0a002 	mov	sl, r2
   14760:	e20330ff 	and	r3, r3, #255	; 0xff
   14764:	0a000030 	beq	1482c <partition_open+0xf0>
   14768:	e1a03c03 	mov	r3, r3, lsl #24
   1476c:	e1a05c43 	mov	r5, r3, asr #24
   14770:	e3550003 	cmp	r5, #3	; 0x3
   14774:	ca00002c 	bgt	1482c <partition_open+0xf0>
        return 0;

    if(index0 >= 0)
   14778:	e3550000 	cmp	r5, #0	; 0x0
   1477c:	ba00000b 	blt	147b0 <partition_open+0x74>
    {
        /* read specified partition table index */
        if(!device_read(0x01be + index0 * 0x10, buffer, sizeof(buffer)))
   14780:	e1a00205 	mov	r0, r5, lsl #4
   14784:	e2800f6f 	add	r0, r0, #444	; 0x1bc
   14788:	e2800002 	add	r0, r0, #2	; 0x2
   1478c:	e1a0100d 	mov	r1, sp
   14790:	e3a02010 	mov	r2, #16	; 0x10
   14794:	e1a0e00f 	mov	lr, pc
   14798:	e12fff16 	bx	r6
   1479c:	e3500000 	cmp	r0, #0	; 0x0
   147a0:	0a000021 	beq	1482c <partition_open+0xf0>
            return 0;

        /* abort on empty partition entry */
        if(buffer[4] == 0x00)
   147a4:	e5dd3004 	ldrb	r3, [sp, #4]
   147a8:	e3530000 	cmp	r3, #0	; 0x0
   147ac:	0a00001e 	beq	1482c <partition_open+0xf0>
            return 0;
    }

    /* allocate partition descriptor */
    new_partition = malloc(sizeof(*new_partition));
   147b0:	e3a00018 	mov	r0, #24	; 0x18
   147b4:	eb000b45 	bl	174d0 <malloc>
    if(!new_partition)
   147b8:	e2504000 	subs	r4, r0, #0	; 0x0
   147bc:	0a00001a 	beq	1482c <partition_open+0xf0>
        return 0;
    memset(new_partition, 0, sizeof(*new_partition));
   147c0:	e1a01008 	mov	r1, r8
   147c4:	e3a02018 	mov	r2, #24	; 0x18
   147c8:	eb000d5e 	bl	17d48 <memset>

    /* fill partition descriptor */
    new_partition->device_read = device_read;
    new_partition->device_read_interval = device_read_interval;
    new_partition->device_write = device_write;

    if(index0 >= 0)
   147cc:	e3550000 	cmp	r5, #0	; 0x0
    {
        new_partition->type = buffer[4];
        new_partition->offset = ((uint32_t) buffer[8]) |
                                ((uint32_t) buffer[9] << 8) |
                                ((uint32_t) buffer[10] << 16) |
                                ((uint32_t) buffer[11] << 24);
        new_partition->length = ((uint32_t) buffer[12]) |
                                ((uint32_t) buffer[13] << 8) |
                                ((uint32_t) buffer[14] << 16) |
                                ((uint32_t) buffer[15] << 24);
    }
    else
    {
        new_partition->type = 0xff;
   147d0:	b3e03000 	mvnlt	r3, #0	; 0x0
   147d4:	e88404c0 	stmia	r4, {r6, r7, sl}
   147d8:	b5c4300c 	strltb	r3, [r4, #12]
   147dc:	ba000013 	blt	14830 <partition_open+0xf4>
   147e0:	e5dd3004 	ldrb	r3, [sp, #4]
   147e4:	e5c4300c 	strb	r3, [r4, #12]
   147e8:	e5dd2009 	ldrb	r2, [sp, #9]
   147ec:	e5dd3008 	ldrb	r3, [sp, #8]
   147f0:	e5dd100a 	ldrb	r1, [sp, #10]
   147f4:	e1833402 	orr	r3, r3, r2, lsl #8
   147f8:	e5dd200b 	ldrb	r2, [sp, #11]
   147fc:	e1833801 	orr	r3, r3, r1, lsl #16
   14800:	e1833c02 	orr	r3, r3, r2, lsl #24
   14804:	e5843010 	str	r3, [r4, #16]
   14808:	e5dd200d 	ldrb	r2, [sp, #13]
   1480c:	e5dd300c 	ldrb	r3, [sp, #12]
   14810:	e5dd100e 	ldrb	r1, [sp, #14]
   14814:	e1833402 	orr	r3, r3, r2, lsl #8
   14818:	e5dd200f 	ldrb	r2, [sp, #15]
   1481c:	e1833801 	orr	r3, r3, r1, lsl #16
   14820:	e1833c02 	orr	r3, r3, r2, lsl #24
   14824:	e5843014 	str	r3, [r4, #20]
   14828:	ea000000 	b	14830 <partition_open+0xf4>
   1482c:	e3a04000 	mov	r4, #0	; 0x0
    }

    return new_partition;
}
   14830:	e1a00004 	mov	r0, r4
   14834:	e28dd010 	add	sp, sp, #16	; 0x10
   14838:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
   1483c:	e12fff1e 	bx	lr

00014840 <partition_close>:

/**
 * Closes a partition.
 *
 * This function destroys a partition descriptor which was
 * previously obtained from a call to partition_open().
 * When this function returns, the given descriptor will be
 * invalid.
 *
 * \param[in] partition The partition descriptor to destroy.
 * \returns 0 on failure, 1 on success.
 * \see partition_open
 */
uint8_t partition_close(struct partition_struct* partition)
{
    if(!partition)
   14840:	e2503000 	subs	r3, r0, #0	; 0x0
   14844:	e52de004 	str	lr, [sp, #-4]!
   14848:	0a000001 	beq	14854 <partition_close+0x14>
        return 0;

    /* destroy partition descriptor */
    free(partition);
   1484c:	eb000b27 	bl	174f0 <free>
   14850:	e3a03001 	mov	r3, #1	; 0x1

    return 1;
}
   14854:	e1a00003 	mov	r0, r3
   14858:	e49de004 	ldr	lr, [sp], #4
   1485c:	e12fff1e 	bx	lr

00014860 <get_adc_1>:
//         and can only be used within this file!
static int get_adc_1(int channel)
{
    int val;
    AD1CR = 0;
   14860:	e59f2044 	ldr	r2, [pc, #68]	; 148ac <.text+0x48ac>
    AD1GDR = 0;
   14864:	e59f3044 	ldr	r3, [pc, #68]	; 148b0 <.text+0x48b0>

    AD1CR = 0x00200600 | channel;
   14868:	e3800602 	orr	r0, r0, #2097152	; 0x200000
   1486c:	e3a01000 	mov	r1, #0	; 0x0
   14870:	e3800c06 	orr	r0, r0, #1536	; 0x600
   14874:	e5821000 	str	r1, [r2]
   14878:	e5831000 	str	r1, [r3]
   1487c:	e5820000 	str	r0, [r2]
    AD1CR |= 0x01000000;
   14880:	e5923000 	ldr	r3, [r2]
   14884:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   14888:	e5823000 	str	r3, [r2]
    do
    {
        val = AD1GDR;                   // Read A/D Data Register
   1488c:	e59f301c 	ldr	r3, [pc, #28]	; 148b0 <.text+0x48b0>
   14890:	e5930000 	ldr	r0, [r3]
    }
    while ((val & 0x80000000) == 0);  //Wait for the conversion to complete
   14894:	e3500000 	cmp	r0, #0	; 0x0
   14898:	aafffffb 	bge	1488c <get_adc_1+0x2c>
   1489c:	e1a00340 	mov	r0, r0, asr #6
    val = ((val >> 6) & 0x03FF);  //Extract the A/D result

    return val;
}
   148a0:	e1a00b00 	mov	r0, r0, lsl #22
   148a4:	e1a00b20 	mov	r0, r0, lsr #22
   148a8:	e12fff1e 	bx	lr
   148ac:	e0060000 	and	r0, r6, r0
   148b0:	e0060004 	and	r0, r6, r4

000148b4 <MMA_get_x>:
   148b4:	e3a00008 	mov	r0, #8	; 0x8
   148b8:	eaffffe8 	b	14860 <get_adc_1>

000148bc <MMA_get_y>:
   148bc:	e3a00010 	mov	r0, #16	; 0x10
   148c0:	eaffffe6 	b	14860 <get_adc_1>

000148c4 <MMA_get_z>:
   148c4:	e3a00020 	mov	r0, #32	; 0x20
   148c8:	eaffffe4 	b	14860 <get_adc_1>

000148cc <MMA_change_mode>:

//Usage: MMA_change_mode(RANGE_2G);
//Inputs: char mode - The mode to be set (Modes are defined in MMA7260.h)
//Outputs: None
//Description: Sets the sensitivity of the MMA7260 accelerometer based on
//             the input "mode" value.
void MMA_change_mode(char mode){

    /*
	Setup the MMA g-select
	GS1/GS2
	0/0 = 1.5g
	1/0 = 2g
	0/1 = 4g
	1/1 = 6g
	*/
	IODIR0|=(GS1 | GS2);
   148cc:	e59f2074 	ldr	r2, [pc, #116]	; 14948 <.text+0x4948>
   148d0:	e5923000 	ldr	r3, [r2]
   148d4:	e20000ff 	and	r0, r0, #255	; 0xff
   148d8:	e3833b03 	orr	r3, r3, #3072	; 0xc00
	if(mode==RANGE_15G)	IOCLR0=(GS1 | GS2);
   148dc:	e3500031 	cmp	r0, #49	; 0x31
   148e0:	e5823000 	str	r3, [r2]
   148e4:	03a02b03 	moveq	r2, #3072	; 0xc00
   148e8:	059f305c 	ldreq	r3, [pc, #92]	; 1494c <.text+0x494c>
   148ec:	0a000013 	beq	14940 <MMA_change_mode+0x74>
	else if(mode==RANGE_2G){
   148f0:	e3500032 	cmp	r0, #50	; 0x32
   148f4:	1a000005 	bne	14910 <MMA_change_mode+0x44>
		IOSET0=GS1;
   148f8:	e59f3050 	ldr	r3, [pc, #80]	; 14950 <.text+0x4950>
   148fc:	e3a02b02 	mov	r2, #2048	; 0x800
   14900:	e5832000 	str	r2, [r3]
		IOCLR0=GS2;
   14904:	e2422b01 	sub	r2, r2, #1024	; 0x400
   14908:	e2833008 	add	r3, r3, #8	; 0x8
   1490c:	ea00000b 	b	14940 <MMA_change_mode+0x74>
	}
	else if(mode==RANGE_4G){
   14910:	e3500033 	cmp	r0, #51	; 0x33
   14914:	1a000005 	bne	14930 <MMA_change_mode+0x64>
		IOCLR0=GS1;
   14918:	e59f302c 	ldr	r3, [pc, #44]	; 1494c <.text+0x494c>
   1491c:	e3a02b02 	mov	r2, #2048	; 0x800
   14920:	e5832000 	str	r2, [r3]
		IOSET0=GS2;
   14924:	e2422b01 	sub	r2, r2, #1024	; 0x400
   14928:	e2433008 	sub	r3, r3, #8	; 0x8
   1492c:	ea000003 	b	14940 <MMA_change_mode+0x74>
	}
	else if(mode==RANGE_6G)IOSET0=(GS1 | GS2);
   14930:	e3500034 	cmp	r0, #52	; 0x34
   14934:	112fff1e 	bxne	lr
   14938:	e59f3010 	ldr	r3, [pc, #16]	; 14950 <.text+0x4950>
   1493c:	e3a02b03 	mov	r2, #3072	; 0xc00
   14940:	e5832000 	str	r2, [r3]
   14944:	e12fff1e 	bx	lr
   14948:	e0028008 	and	r8, r2, r8
   1494c:	e002800c 	and	r8, r2, ip
   14950:	e0028004 	and	r8, r2, r4

00014954 <LCDCommand>:
//Outputs: None
//Description: Sends a 9 bit command over SPI to the LCD with
//			   the first bit HIGH indicating "command" mode.
void LCDCommand(unsigned char data)
{
   14954:	e52de004 	str	lr, [sp, #-4]!

	IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);		//Assign LCD pins as Outputs
   14958:	e59f1088 	ldr	r1, [pc, #136]	; 149e8 <.text+0x49e8>
   1495c:	e5913000 	ldr	r3, [r1]
   14960:	e3833703 	orr	r3, r3, #786432	; 0xc0000
	
	IOCLR0 = LCD_CS;      // enable chip, p0.20 goes low
   14964:	e59f2080 	ldr	r2, [pc, #128]	; 149ec <.text+0x49ec>
   14968:	e3833050 	orr	r3, r3, #80	; 0x50
   1496c:	e5813000 	str	r3, [r1]
   14970:	e3a03702 	mov	r3, #524288	; 0x80000
   14974:	e5823000 	str	r3, [r2]
    IOCLR0 = LCD_DIO;     // output low on data out (9th bit low = command), p0.19
   14978:	e3a03040 	mov	r3, #64	; 0x40
   1497c:	e5823000 	str	r3, [r2]

    IOCLR0 = LCD_SCK;      // send clock pulse
    IOSET0 = LCD_SCK;
   14980:	e59f3068 	ldr	r3, [pc, #104]	; 149f0 <.text+0x49f0>
   14984:	e3a0c010 	mov	ip, #16	; 0x10
   14988:	e582c000 	str	ip, [r2]
   1498c:	e583c000 	str	ip, [r3]
   14990:	e20000ff 	and	r0, r0, #255	; 0xff
   14994:	e3a0e008 	mov	lr, #8	; 0x8

    for (char j = 0; j < 8; j++)
    {
        if ((data & 0x80) == 0x80) IOSET0 = LCD_DIO;
   14998:	e3100080 	tst	r0, #128	; 0x80
   1499c:	159f304c 	ldrne	r3, [pc, #76]	; 149f0 <.text+0x49f0>
        else IOCLR0 = LCD_DIO;
   149a0:	059f3044 	ldreq	r3, [pc, #68]	; 149ec <.text+0x49ec>
   149a4:	13a02040 	movne	r2, #64	; 0x40
   149a8:	03a02040 	moveq	r2, #64	; 0x40
   149ac:	e5832000 	str	r2, [r3]

        IOCLR0 = LCD_SCK;   // send clock pulse
        IOSET0 = LCD_SCK;

        data <<= 1;
   149b0:	e24e3001 	sub	r3, lr, #1	; 0x1
   149b4:	e59fc034 	ldr	ip, [pc, #52]	; 149f0 <.text+0x49f0>
   149b8:	e213e0ff 	ands	lr, r3, #255	; 0xff
   149bc:	e59f3028 	ldr	r3, [pc, #40]	; 149ec <.text+0x49ec>
   149c0:	e3a02010 	mov	r2, #16	; 0x10
   149c4:	e1a01080 	mov	r1, r0, lsl #1
   149c8:	e5832000 	str	r2, [r3]
   149cc:	e20100ff 	and	r0, r1, #255	; 0xff
   149d0:	e58c2000 	str	r2, [ip]
   149d4:	1affffef 	bne	14998 <LCDCommand+0x44>
    }

    IOSET0 = LCD_CS;    		// disable
   149d8:	e3a03702 	mov	r3, #524288	; 0x80000
   149dc:	e58c3000 	str	r3, [ip]

}
   149e0:	e49de004 	ldr	lr, [sp], #4
   149e4:	e12fff1e 	bx	lr
   149e8:	e0028008 	and	r8, r2, r8
   149ec:	e002800c 	and	r8, r2, ip
   149f0:	e0028004 	and	r8, r2, r4

000149f4 <LCDData>:

//Usage: LCDData(RAMWR);
//Inputs: char data - character data to be sent to the LCD
//Outputs: None
//Description: Sends a 9 bit command over SPI to the LCD with
//			   the first bit LOW indicating "data" mode.
void LCDData(unsigned char data)
{
   149f4:	e52de004 	str	lr, [sp, #-4]!

	IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);		//Assign LCD pins as Outputs
   149f8:	e59fc08c 	ldr	ip, [pc, #140]	; 14a8c <.text+0x4a8c>
   149fc:	e59c3000 	ldr	r3, [ip]
   14a00:	e3833703 	orr	r3, r3, #786432	; 0xc0000
	
	IOCLR0 = LCD_SCK;      // send clock pulse
   14a04:	e59f1084 	ldr	r1, [pc, #132]	; 14a90 <.text+0x4a90>
   14a08:	e3833050 	orr	r3, r3, #80	; 0x50
   14a0c:	e58c3000 	str	r3, [ip]
	IOCLR0 = LCD_CS;      // enable chip, p0.20 goes low    
	//#ifdef	PHILLIPS
		//for (char i = 0; i < 1; i++) asm volatile ("nop");
	//#endif
	IOSET0 = LCD_DIO;    // output high on data out (9th bit high = data), p0.19
   14a10:	e59fe07c 	ldr	lr, [pc, #124]	; 14a94 <.text+0x4a94>
   14a14:	e3a02010 	mov	r2, #16	; 0x10
   14a18:	e3a03702 	mov	r3, #524288	; 0x80000
   14a1c:	e5812000 	str	r2, [r1]
   14a20:	e5813000 	str	r3, [r1]
   14a24:	e3a03040 	mov	r3, #64	; 0x40
   14a28:	e58e3000 	str	r3, [lr]
   14a2c:	e20000ff 	and	r0, r0, #255	; 0xff
    IOCLR0 = LCD_SCK;    // send clock pulse
   14a30:	e5812000 	str	r2, [r1]
	//#ifdef	PHILLIPS
		//for (char i = 0; i < 1; i++) asm volatile ("nop");
	//#endif
    IOSET0 = LCD_SCK;
   14a34:	e58e2000 	str	r2, [lr]
   14a38:	e3a0e008 	mov	lr, #8	; 0x8
	for (char j = 0; j < 8; j++)
    {
        if ((data & 0x80) == 0x80) IOSET0 = LCD_DIO;
   14a3c:	e3100080 	tst	r0, #128	; 0x80
   14a40:	159f304c 	ldrne	r3, [pc, #76]	; 14a94 <.text+0x4a94>
        else IOCLR0 = LCD_DIO;
   14a44:	059f3044 	ldreq	r3, [pc, #68]	; 14a90 <.text+0x4a90>
   14a48:	13a02040 	movne	r2, #64	; 0x40
   14a4c:	03a02040 	moveq	r2, #64	; 0x40
   14a50:	e5832000 	str	r2, [r3]
        IOCLR0 = LCD_SCK;   // send clock pulse
		//#ifdef	PHILLIPS
			//for (char i = 0; i < delay; i++) asm volatile ("nop");
		//#endif
        IOSET0 = LCD_SCK;
		//#ifdef	PHILLIPS
			//for (char i = 0; i < delay; i++) asm volatile ("nop");
		//#endif
        data <<= 1;
   14a54:	e24e3001 	sub	r3, lr, #1	; 0x1
   14a58:	e59fc034 	ldr	ip, [pc, #52]	; 14a94 <.text+0x4a94>
   14a5c:	e213e0ff 	ands	lr, r3, #255	; 0xff
   14a60:	e59f3028 	ldr	r3, [pc, #40]	; 14a90 <.text+0x4a90>
   14a64:	e3a02010 	mov	r2, #16	; 0x10
   14a68:	e1a01080 	mov	r1, r0, lsl #1
   14a6c:	e5832000 	str	r2, [r3]
   14a70:	e20100ff 	and	r0, r1, #255	; 0xff
   14a74:	e58c2000 	str	r2, [ip]
   14a78:	1affffef 	bne	14a3c <LCDData+0x48>
    }

    IOSET0 = LCD_CS;     		// disable
   14a7c:	e3a03702 	mov	r3, #524288	; 0x80000
   14a80:	e58c3000 	str	r3, [ip]
}
   14a84:	e49de004 	ldr	lr, [sp], #4
   14a88:	e12fff1e 	bx	lr
   14a8c:	e0028008 	and	r8, r2, r8
   14a90:	e002800c 	and	r8, r2, ip
   14a94:	e0028004 	and	r8, r2, r4

00014a98 <LCDClear>:
   14a98:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   14a9c:	e1a03000 	mov	r3, r0
   14aa0:	e3a00075 	mov	r0, #117	; 0x75
   14aa4:	e20350ff 	and	r5, r3, #255	; 0xff
   14aa8:	ebffffa9 	bl	14954 <LCDCommand>
   14aac:	e3a00000 	mov	r0, #0	; 0x0
   14ab0:	ebffffcf 	bl	149f4 <LCDData>
   14ab4:	e3a00083 	mov	r0, #131	; 0x83
   14ab8:	ebffffcd 	bl	149f4 <LCDData>
   14abc:	e3a00015 	mov	r0, #21	; 0x15
   14ac0:	ebffffa3 	bl	14954 <LCDCommand>
   14ac4:	e3a00000 	mov	r0, #0	; 0x0
   14ac8:	ebffffc9 	bl	149f4 <LCDData>
   14acc:	e3a00083 	mov	r0, #131	; 0x83
   14ad0:	ebffffc7 	bl	149f4 <LCDData>
   14ad4:	e3a0005c 	mov	r0, #92	; 0x5c
   14ad8:	ebffff9d 	bl	14954 <LCDCommand>
   14adc:	e59f4024 	ldr	r4, [pc, #36]	; 14b08 <.text+0x4b08>
   14ae0:	e1a00005 	mov	r0, r5
   14ae4:	ebffffc2 	bl	149f4 <LCDData>
   14ae8:	e2544001 	subs	r4, r4, #1	; 0x1
   14aec:	1afffffb 	bne	14ae0 <LCDClear+0x48>
   14af0:	e59f2014 	ldr	r2, [pc, #20]	; 14b0c <.text+0x4b0c>
   14af4:	e5c24000 	strb	r4, [r2]
   14af8:	e59f2010 	ldr	r2, [pc, #16]	; 14b10 <.text+0x4b10>
   14afc:	e5c24000 	strb	r4, [r2]
   14b00:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   14b04:	e12fff1e 	bx	lr
   14b08:	00007530 	andeq	r7, r0, r0, lsr r5
   14b0c:	40001565 	andmi	r1, r0, r5, ror #10
   14b10:	40001566 	andmi	r1, r0, r6, ror #10

00014b14 <LCDInit>:

//Usage: LCDInit();
//Inputs: None
//Outputs: None
//Description:  Initializes the LCD regardless of if the controlller is an EPSON or PHILLIPS.
void LCDInit(void)
{
   14b14:	e92d4010 	stmdb	sp!, {r4, lr}
    int j;

	delay_ms(200);
   14b18:	e3a000c8 	mov	r0, #200	; 0xc8
   14b1c:	ebffed9c 	bl	10194 <delay_ms>
	
    // reset display
	IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);		//Assign LCD pins as Outputs
   14b20:	e59f2174 	ldr	r2, [pc, #372]	; 14c9c <.text+0x4c9c>
   14b24:	e5923000 	ldr	r3, [r2]
   14b28:	e3833703 	orr	r3, r3, #786432	; 0xc0000
   14b2c:	e3833050 	orr	r3, r3, #80	; 0x50
   14b30:	e5823000 	str	r3, [r2]
		
    IOCLR0 = (LCD_SCK | LCD_DIO);							//output_low (SPI_CLK);//output_low (SPI_DO);
   14b34:	e59f3164 	ldr	r3, [pc, #356]	; 14ca0 <.text+0x4ca0>
   14b38:	e3a02050 	mov	r2, #80	; 0x50
   14b3c:	e4032008 	str	r2, [r3], #-8
    IOSET0 = LCD_CS;				//output_high (LCD_CS);
   14b40:	e3a02702 	mov	r2, #524288	; 0x80000
   14b44:	e5832000 	str	r2, [r3]
   14b48:	e3a03010 	mov	r3, #16	; 0x10
    for (j = 0; j < 16; j++)asm volatile ("nop");
   14b4c:	e1a00000 	nop			(mov r0,r0)
   14b50:	e2533001 	subs	r3, r3, #1	; 0x1
   14b54:	1afffffc 	bne	14b4c <LCDInit+0x38>
    IOCLR0 = LCD_RES;				//output_low (LCD_RESET);
   14b58:	e59f3140 	ldr	r3, [pc, #320]	; 14ca0 <.text+0x4ca0>
   14b5c:	e3a02701 	mov	r2, #262144	; 0x40000
   14b60:	e5832000 	str	r2, [r3]
   14b64:	e59f3138 	ldr	r3, [pc, #312]	; 14ca4 <.text+0x4ca4>
    for (j = 0; j < 300000; j++)asm volatile ("nop");
   14b68:	e1a00000 	nop			(mov r0,r0)
   14b6c:	e2533001 	subs	r3, r3, #1	; 0x1
   14b70:	1afffffc 	bne	14b68 <LCDInit+0x54>
    IOSET0 = LCD_RES;				//output_high (LCD_RESET);
   14b74:	e59f312c 	ldr	r3, [pc, #300]	; 14ca8 <.text+0x4ca8>
   14b78:	e3a02701 	mov	r2, #262144	; 0x40000
   14b7c:	e5832000 	str	r2, [r3]
    IOSET0 = (LCD_SCK | LCD_DIO);
   14b80:	e3a02050 	mov	r2, #80	; 0x50
   14b84:	e5832000 	str	r2, [r3]
   14b88:	e59f4114 	ldr	r4, [pc, #276]	; 14ca4 <.text+0x4ca4>
    for (j = 0; j < 300000; j++)asm volatile ("nop");	//delay_ms(100);
   14b8c:	e1a00000 	nop			(mov r0,r0)
   14b90:	e2544001 	subs	r4, r4, #1	; 0x1
   14b94:	1afffffc 	bne	14b8c <LCDInit+0x78>
	
    LCDCommand(DISCTL);  	// display control(EPSON)
   14b98:	e3a000ca 	mov	r0, #202	; 0xca
   14b9c:	ebffff6c 	bl	14954 <LCDCommand>
    LCDData(0x0C);   		// 12 = 1100 - CL dividing ratio [don't divide] switching period 8H (default)
   14ba0:	e3a0000c 	mov	r0, #12	; 0xc
   14ba4:	ebffff92 	bl	149f4 <LCDData>
	LCDData(0x20);    
   14ba8:	e3a00020 	mov	r0, #32	; 0x20
   14bac:	ebffff90 	bl	149f4 <LCDData>
	LCDData(0x02);
   14bb0:	e3a00002 	mov	r0, #2	; 0x2
   14bb4:	ebffff8e 	bl	149f4 <LCDData>
	
	LCDData(0x01);
   14bb8:	e3a00001 	mov	r0, #1	; 0x1
   14bbc:	ebffff8c 	bl	149f4 <LCDData>
	
    LCDCommand(COMSCN);  	// common scanning direction(EPSON)
   14bc0:	e3a000bb 	mov	r0, #187	; 0xbb
   14bc4:	ebffff62 	bl	14954 <LCDCommand>
    LCDData(0x01);
   14bc8:	e3a00001 	mov	r0, #1	; 0x1
   14bcc:	ebffff88 	bl	149f4 <LCDData>
    
    LCDCommand(OSCON);  	// internal oscialltor ON(EPSON)
   14bd0:	e3a000d1 	mov	r0, #209	; 0xd1
   14bd4:	ebffff5e 	bl	14954 <LCDCommand>
	
    LCDCommand(SLPOUT);  	// sleep out(EPSON)
   14bd8:	e3a00094 	mov	r0, #148	; 0x94
   14bdc:	ebffff5c 	bl	14954 <LCDCommand>
	LCDCommand(SLEEPOUT);	//sleep out(PHILLIPS)
   14be0:	e3a00011 	mov	r0, #17	; 0x11
   14be4:	ebffff5a 	bl	14954 <LCDCommand>
    
    LCDCommand(PWRCTR); 	// power ctrl(EPSON)
   14be8:	e3a00020 	mov	r0, #32	; 0x20
   14bec:	ebffff58 	bl	14954 <LCDCommand>
    LCDData(0x0F);    		//everything on, no external reference resistors
   14bf0:	e3a0000f 	mov	r0, #15	; 0xf
   14bf4:	ebffff7e 	bl	149f4 <LCDData>
    LCDCommand(BSTRON);		//Booset On(PHILLIPS)
   14bf8:	e3a00003 	mov	r0, #3	; 0x3
   14bfc:	ebffff54 	bl	14954 <LCDCommand>
	
	LCDCommand(DISINV);  	// invert display mode(EPSON)
   14c00:	e3a000a7 	mov	r0, #167	; 0xa7
   14c04:	ebffff52 	bl	14954 <LCDCommand>
	LCDCommand(INVON);		// invert display mode(PHILLIPS)
   14c08:	e3a00021 	mov	r0, #33	; 0x21
   14c0c:	ebffff50 	bl	14954 <LCDCommand>
    
    LCDCommand(DATCTL);  	// data control(EPSON)
   14c10:	e3a000bc 	mov	r0, #188	; 0xbc
   14c14:	ebffff4e 	bl	14954 <LCDCommand>
    LCDData(0x03);			//correct for normal sin7
   14c18:	e3a00003 	mov	r0, #3	; 0x3
   14c1c:	ebffff74 	bl	149f4 <LCDData>
	LCDData(0x00);   		// normal RGB arrangement
   14c20:	e1a00004 	mov	r0, r4
   14c24:	ebffff72 	bl	149f4 <LCDData>
	//LCDData(0x01);		// 8-bit Grayscale
	LCDData(0x02);			// 16-bit Grayscale Type A
   14c28:	e3a00002 	mov	r0, #2	; 0x2
   14c2c:	ebffff70 	bl	149f4 <LCDData>
	
	LCDCommand(MADCTL);		//Memory Access Control(PHILLIPS)
   14c30:	e3a00036 	mov	r0, #54	; 0x36
   14c34:	ebffff46 	bl	14954 <LCDCommand>
	LCDData(0xC8);
   14c38:	e3a000c8 	mov	r0, #200	; 0xc8
   14c3c:	ebffff6c 	bl	149f4 <LCDData>
	
	LCDCommand(COLMOD);		//Set Color Mode(PHILLIPS)
   14c40:	e3a0003a 	mov	r0, #58	; 0x3a
   14c44:	ebffff42 	bl	14954 <LCDCommand>
	LCDData(0x02);	
   14c48:	e3a00002 	mov	r0, #2	; 0x2
   14c4c:	ebffff68 	bl	149f4 <LCDData>
	
    LCDCommand(VOLCTR);  	// electronic volume, this is the contrast/brightness(EPSON)
   14c50:	e3a00081 	mov	r0, #129	; 0x81
   14c54:	ebffff3e 	bl	14954 <LCDCommand>
    //LCDData(0x18);   		// volume (contrast) setting - fine tuning, original
	LCDData(0x24);   		// volume (contrast) setting - fine tuning, original
   14c58:	e3a00024 	mov	r0, #36	; 0x24
   14c5c:	ebffff64 	bl	149f4 <LCDData>
    LCDData(0x03);   		// internal resistor ratio - coarse adjustment
   14c60:	e3a00003 	mov	r0, #3	; 0x3
   14c64:	ebffff62 	bl	149f4 <LCDData>
	LCDCommand(SETCON);		//Set Contrast(PHILLIPS)
   14c68:	e3a00025 	mov	r0, #37	; 0x25
   14c6c:	ebffff38 	bl	14954 <LCDCommand>
	LCDData(0x30);	
   14c70:	e3a00030 	mov	r0, #48	; 0x30
   14c74:	ebffff5e 	bl	149f4 <LCDData>
	
    /*
    LCDCommand(RGBSET8);   // setup 8-bit color lookup table  [RRRGGGBB](EPSON)
    //RED
    LCDData(0);
    LCDData(2);
    LCDData(4);
    LCDData(6);
    LCDData(8);
    LCDData(10);
    LCDData(12);
    LCDData(15);
    // GREEN
    LCDData(0);
    LCDData(2);
    LCDData(4);
    LCDData(6);
    LCDData(8);
    LCDData(10);
    LCDData(12);
    LCDData(15);
    //BLUE
    LCDData(0);
    LCDData(4);
    LCDData(9);
    LCDData(15);
	*/
    
    LCDCommand(NOP);  	// nop(EPSON)
   14c78:	e3a00025 	mov	r0, #37	; 0x25
   14c7c:	ebffff34 	bl	14954 <LCDCommand>
	LCDCommand(NOPP);		// nop(PHILLIPS)
   14c80:	e1a00004 	mov	r0, r4
   14c84:	ebffff32 	bl	14954 <LCDCommand>

    LCDCommand(DISON);   	// display on(EPSON)
   14c88:	e3a000af 	mov	r0, #175	; 0xaf
   14c8c:	ebffff30 	bl	14954 <LCDCommand>
	LCDCommand(DISPON);	// display on(PHILLIPS)
   14c90:	e3a00029 	mov	r0, #41	; 0x29
}
   14c94:	e8bd4010 	ldmia	sp!, {r4, lr}
   14c98:	eaffff2d 	b	14954 <LCDCommand>
   14c9c:	e0028008 	and	r8, r2, r8
   14ca0:	e002800c 	and	r8, r2, ip
   14ca4:	000493e0 	andeq	r9, r4, r0, ror #7
   14ca8:	e0028004 	and	r8, r2, r4

00014cac <LCDSetPixel>:

//Usage: LCDPrintChar('1', white,&x_offset, &y_offset, inverted)
//Inputs: char txt - character to be printed
//		  char text_color - desired color
//	 	  char *x_pos - pointer to the row position of the character
//		  char *y_pos - pointer to the column position of the character
//		  char inverted - indicates if the character should be positioned normally, or oriented to the right side of the screen
//Outputs: char *x_pos - Now holds the next available row position for a character on the screen
//		   char *y_pos - Now holds the next available column position for a character on the screen
//Description: Prints a character in the desired color at the given x and y position.  If the character is to be inverted,
//			   then the right side of the LCD becomes the "top" so the text will be viewed at a different orientation.
//**NOTE** Because this function is static, it is essentially a "private" function
//         and can only be used within this file!
static unsigned char LCDPrintChar(char txt, char text_color, char *x_pos, char *y_pos, char inverted)
{
    short text_array_offset = (txt - 32)*5, j;
    char k, temp;
	
    
    if (txt == 10)
    {
        y_pos += 8;
        return(0);
    }

    else if (txt == 13)
    {
        x_pos = 0;
        return(0);
    }

	#ifdef PHILLIPS
    for (j = text_array_offset; j < text_array_offset+5; j++)
    {
        temp = text_array[j];

        for (k = 0; k < 8; k++)
        {
			if(inverted==0){
				if ((temp & 0x80) == 0x80) LCDSetPixel(text_color, *y_pos + k, *x_pos + j + 2 - text_array_offset);
				temp <<= 1;
			}
			else if(inverted==1){

				if ((temp & 0x01) == 0x01) LCDSetPixel(text_color, *y_pos + j + 2 - text_array_offset, *x_pos + k);

				temp >>= 1;	
			}
        }
    }
	#endif
	#ifdef EPSON
    for (j = text_array_offset+4; j >= text_array_offset; j--)
    {
        temp = text_array[j];

        for (k = 8; k > 0; k--)
        {
			if(inverted==0){
				if ((temp & 0x80) == 0x80) LCDSetPixel(text_color, *y_pos + k, *x_pos - j - 2 + text_array_offset);
				temp <<= 1;
			}
			else if(inverted==1){

				if ((temp & 0x01) == 0x01) LCDSetPixel(text_color, *y_pos - j - 2 + text_array_offset, *x_pos + k);

				temp >>= 1;	
			}
        }
    }
	#endif
	#ifdef PHILLIPS
	if(inverted==0){

		if ((*x_pos + 12) > 132) *x_pos = 0, *y_pos += 8;
		else *x_pos += 6;

	}
	else if(inverted==1){

		if ((*y_pos + 12) > 132) *y_pos = 0, *x_pos += 8;
		else *y_pos += 6;	

	}

    if ((*y_pos + 8) > 132)
    {
        //clear_screen();
        return 1;
    }
	#endif
	#ifdef EPSON
	if(inverted==0){

		if ((*x_pos - 12) > 132) *x_pos = 0, *y_pos -= 8;
		else *x_pos -= 6;

	}
	else if(inverted==1){

		if ((*y_pos - 12) > 132) *y_pos = 0, *x_pos -= 8;
		else *y_pos -= 6;	

	}

    if ((*y_pos + 8) > 132)
    {
        //clear_screen();
        return 1;
    }
	#endif
    else return 0;

}

//Usage: LCDPrintLogo();
//Inputs: None
//Outputs: None
//Description: Prints the logo_spark array to the LCD.
void LCDPrintLogo(void)
{
    int x = 4, y = 25, logo_ix = 0, z;
    char logo;
    
    for (logo_ix = 0; logo_ix < 1120; logo_ix++)
    {
        logo = logo_spark[logo_ix];
		for (z = 0; z < 8; z++)
        {
			#ifdef PHILLIPS
            if ((logo & 0x80) == 0x80) LCDSetPixel(red, y, x);
			#endif
			#ifdef EPSON
            if ((logo & 0x80) == 0x80) LCDSetPixel(red, 132-y, 132-x);			
			#endif
            x++;
            if (x == 132)
            {
                x = 4;
                y++;
            }
            
            logo <<= 1;
        }
    }

}

//Usage: LCDPrintString("Hello %d", 5, black, 0, 0, 1);
//Inputs: const char *txt - string of characters to be printed
//		  int variable - if a variable is to be printed in the string it should be placed here, else put a 0
//		  text_color - desired color of the string
//		  char row - desired row for the string
//		  char column - desired column for the string
//		  char inverterted - indication of desired orientation
//Outputs: None
//Description: Prints a string, including variables, in the desired color at the given row and column.  If inverterted,
//			   the right side of the LCD will become the "top."
void LCDPrintString(const char *txt, int variable, char text_color, char row, char column, char inverted)
{
#ifdef PHILLIPS
	if(inverted==0){
		x_offset=column*6;
		y_offset=row*8;
	}
	else if(inverted==1){
		x_offset=(15-row)*8+3;
		y_offset=(column*6);
	}
#endif
#ifdef EPSON
	if(inverted==0){
		x_offset=column*6+21*6;
		y_offset=15*8-row*8;
	}
	else if(inverted==1){
		x_offset=row*8+3;
		y_offset=column*6+21*6;
	}
#endif
    int	  temp;
    short i, k, l, m;
    short temp2;
    
    short decimal_output[9];
    
    for(i = 0 ; i < 22; i++)		//Only print the length of the screen
    {
        //delay_ms(3);
        
        k = txt[i];

        if (k == '\0') break;
        
        else if (k == '%') //Print var
        {
            i++;
            k = txt[i];

            if (k == '\0') break;
        	
            else if (k == '\\') //Print special characters
            {
                i++;
                k = txt[i];
                
                LCDPrintChar(k, white, &x_offset, &y_offset, inverted);
                

            } //End Special Characters
            else if (k == 'b') //Print Binary
            {
                for( m = 0 ; m < 32 ; m++ )
                {
                    if ((variable & 0x80000000) == 0x80000000) LCDPrintChar('1', white,&x_offset, &y_offset, inverted);
                    if ((variable & 0x80000000) == 0) LCDPrintChar('0', white,&x_offset, &y_offset, inverted);
                    if (((m+1) % 4) == 0) LCDPrintChar(' ', white,&x_offset, &y_offset, inverted);
                    
                    variable = variable << 1;
                }
            } //End Binary               
            else if (k == 'd') //Print Decimal
            {
                //Print negative sign and take 2's compliment
                
                if(variable < 0)
                {
                    LCDPrintChar('-', text_color,&x_offset, &y_offset, inverted);
                    variable *= -1;
                }
                
                
                if (variable == 0)
                    LCDPrintChar('0', text_color,&x_offset, &y_offset, inverted);
                else
                {
                    //Divide number by a series of 10s
                    for(m = 9 ; variable > 0 ; m--)
                    {
                        temp = variable % 10;
                        decimal_output[m] = temp+48;
                        variable = variable / 10;               
                    }
                
                    for(m++ ; m < 10 ; m++)
                    {
                        LCDPrintChar(decimal_output[m], text_color,&x_offset, &y_offset, inverted);
                    }
                }
    
            } //End Decimal
            else if (k == 'h') //Print Hex
            {
                //New trick 3-15-04
                LCDPrintChar('0', white,&x_offset, &y_offset, inverted);
                LCDPrintChar('x', white,&x_offset, &y_offset, inverted);
                
                for (m = 0; m < 8; m++)
                {
                	temp = variable & 0xF0000000;
                	temp2 = temp >>= 28;
                	//LCDPrintChar(bin2Hex(temp2));
                	variable <<= 4;
                }
            } //End Hex
            else if (k == 'f') //Print Float
            {
                LCDPrintChar('!', white,&x_offset, &y_offset, inverted);
            } //End Float
            else if (k == 'u') //Print Direct Character
            {
                //All ascii characters below 20 are special and screwy characters
                //if(my_byte > 20) 
                    LCDPrintChar(variable, text_color,&x_offset, &y_offset, inverted);
            } //End Direct
                        
        } //End Special Chars           
        
        else if (k == '/')
        {
            l = txt[i+1];
            if (l == 'r') LCDPrintChar(13, white,&x_offset, &y_offset, inverted);
            else if (l == 'n') LCDPrintChar(10, white,&x_offset, &y_offset, inverted);
            i += 1;
        }

        else LCDPrintChar(k, text_color,&x_offset, &y_offset, inverted);
    }    
}

//Usage: LCDSetPixel(white, 0, 0);
//Inputs: unsigned char color - desired color of the pixel
//		  unsigned char x - Page address of pixel to be colored
//		  unsigned char y - column address of pixel to be colored
//Outputs: None
//Description: Sets the starting page(row) and column (x & y) coordinates in ram,
//  		   then writes the colour to display memory.  The ending x & y are left
//  		   maxed out so one can continue sending colour data bytes to the 'open'
//  		   RAMWR command to fill further memory.  issuing any red command
//  		   finishes RAMWR.
//**NOTE** Because this function is static, it is essentially a "private" function
//         and can only be used within this file!
static void LCDSetPixel(unsigned char color, unsigned char x, unsigned char y)
{
   14cac:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	unsigned int temp_register;
	
	temp_register = VICIntEnable;
	VICIntEnClr = 0x20;
   14cb0:	e59f3078 	ldr	r3, [pc, #120]	; 14d30 <.text+0x4d30>
   14cb4:	e59f7078 	ldr	r7, [pc, #120]	; 14d34 <.text+0x4d34>
   14cb8:	e20250ff 	and	r5, r2, #255	; 0xff
   14cbc:	e3a02020 	mov	r2, #32	; 0x20
   14cc0:	e20140ff 	and	r4, r1, #255	; 0xff
   14cc4:	e5978000 	ldr	r8, [r7]
   14cc8:	e1a06000 	mov	r6, r0
   14ccc:	e5832000 	str	r2, [r3]
	#ifdef EPSON
		LCDCommand(PASET);   // page start/end ram
   14cd0:	e3a00075 	mov	r0, #117	; 0x75
   14cd4:	ebffff1e 	bl	14954 <LCDCommand>
		LCDData(x);
   14cd8:	e1a00004 	mov	r0, r4
   14cdc:	ebffff44 	bl	149f4 <LCDData>
		LCDData(ENDPAGE);
   14ce0:	e3a00084 	mov	r0, #132	; 0x84
   14ce4:	ebffff42 	bl	149f4 <LCDData>
  
		LCDCommand(CASET);   // column start/end ram
   14ce8:	e3a00015 	mov	r0, #21	; 0x15
   14cec:	ebffff18 	bl	14954 <LCDCommand>
		LCDData(y);
   14cf0:	e1a00005 	mov	r0, r5
   14cf4:	ebffff3e 	bl	149f4 <LCDData>
		LCDData(ENDCOL);
   14cf8:	e3a00082 	mov	r0, #130	; 0x82
   14cfc:	ebffff3c 	bl	149f4 <LCDData>
   14d00:	e20660ff 	and	r6, r6, #255	; 0xff
  
		LCDCommand(RAMWR);    // write
   14d04:	e3a0005c 	mov	r0, #92	; 0x5c
   14d08:	ebffff11 	bl	14954 <LCDCommand>
		LCDData(color);
   14d0c:	e1a00006 	mov	r0, r6
   14d10:	ebffff37 	bl	149f4 <LCDData>
		LCDData(NOP);
   14d14:	e3a00025 	mov	r0, #37	; 0x25
   14d18:	ebffff35 	bl	149f4 <LCDData>
		LCDData(NOP);
   14d1c:	e3a00025 	mov	r0, #37	; 0x25
   14d20:	ebffff33 	bl	149f4 <LCDData>
	#endif
	#ifdef	PHILLIPS
		LCDCommand(PASETP);   // page start/end ram
		LCDData(x);
		LCDData(ENDPAGE);
  
		LCDCommand(CASETP);   // column start/end ram
		LCDData(y);
		LCDData(ENDCOL);
  
		LCDCommand(RAMWRP);    // write
		LCDData(color);
	#endif
	VICIntEnable = temp_register;
   14d24:	e5878000 	str	r8, [r7]
}
   14d28:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   14d2c:	e12fff1e 	bx	lr
   14d30:	fffff014 	swinv	0x00fff014
   14d34:	fffff010 	swinv	0x00fff010

00014d38 <LCDPrintChar>:
   14d38:	e200c0ff 	and	ip, r0, #255	; 0xff
   14d3c:	e3a00005 	mov	r0, #5	; 0x5
   14d40:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14d44:	e00e009c 	mul	lr, ip, r0
   14d48:	e24e00a0 	sub	r0, lr, #160	; 0xa0
   14d4c:	e24dd004 	sub	sp, sp, #4	; 0x4
   14d50:	e1a00800 	mov	r0, r0, lsl #16
   14d54:	e20110ff 	and	r1, r1, #255	; 0xff
   14d58:	e35c000a 	cmp	ip, #10	; 0xa
   14d5c:	e1a06002 	mov	r6, r2
   14d60:	e1a05003 	mov	r5, r3
   14d64:	e58d1000 	str	r1, [sp]
   14d68:	e1a09820 	mov	r9, r0, lsr #16
   14d6c:	e5dda028 	ldrb	sl, [sp, #40]
   14d70:	0a000053 	beq	14ec4 <LCDPrintChar+0x18c>
   14d74:	e35c000d 	cmp	ip, #13	; 0xd
   14d78:	0a000051 	beq	14ec4 <LCDPrintChar+0x18c>
   14d7c:	e24e309c 	sub	r3, lr, #156	; 0x9c
   14d80:	e1a03803 	mov	r3, r3, lsl #16
   14d84:	e1a08823 	mov	r8, r3, lsr #16
   14d88:	e20870ff 	and	r7, r8, #255	; 0xff
   14d8c:	ea00002a 	b	14e3c <LCDPrintChar+0x104>
   14d90:	e59f313c 	ldr	r3, [pc, #316]	; 14ed4 <.text+0x4ed4>
   14d94:	e7d34002 	ldrb	r4, [r3, r2]
   14d98:	e3a0b008 	mov	fp, #8	; 0x8
   14d9c:	e35a0000 	cmp	sl, #0	; 0x0
   14da0:	1a00000e 	bne	14de0 <LCDPrintChar+0xa8>
   14da4:	e3140080 	tst	r4, #128	; 0x80
   14da8:	e59d0000 	ldr	r0, [sp]
   14dac:	0a000008 	beq	14dd4 <LCDPrintChar+0x9c>
   14db0:	e5d62000 	ldrb	r2, [r6]
   14db4:	e5d51000 	ldrb	r1, [r5]
   14db8:	e0672002 	rsb	r2, r7, r2
   14dbc:	e0892002 	add	r2, r9, r2
   14dc0:	e08b1001 	add	r1, fp, r1
   14dc4:	e2422002 	sub	r2, r2, #2	; 0x2
   14dc8:	e20110ff 	and	r1, r1, #255	; 0xff
   14dcc:	e20220ff 	and	r2, r2, #255	; 0xff
   14dd0:	ebffffb5 	bl	14cac <LCDSetPixel>
   14dd4:	e1a03084 	mov	r3, r4, lsl #1
   14dd8:	e20340ff 	and	r4, r3, #255	; 0xff
   14ddc:	ea00000e 	b	14e1c <LCDPrintChar+0xe4>
   14de0:	e35a0001 	cmp	sl, #1	; 0x1
   14de4:	1a00000c 	bne	14e1c <LCDPrintChar+0xe4>
   14de8:	e3140001 	tst	r4, #1	; 0x1
   14dec:	e59d0000 	ldr	r0, [sp]
   14df0:	e1a040a4 	mov	r4, r4, lsr #1
   14df4:	0a000008 	beq	14e1c <LCDPrintChar+0xe4>
   14df8:	e5d51000 	ldrb	r1, [r5]
   14dfc:	e5d62000 	ldrb	r2, [r6]
   14e00:	e0671001 	rsb	r1, r7, r1
   14e04:	e0891001 	add	r1, r9, r1
   14e08:	e08b2002 	add	r2, fp, r2
   14e0c:	e2411002 	sub	r1, r1, #2	; 0x2
   14e10:	e20110ff 	and	r1, r1, #255	; 0xff
   14e14:	e20220ff 	and	r2, r2, #255	; 0xff
   14e18:	ebffffa3 	bl	14cac <LCDSetPixel>
   14e1c:	e24b3001 	sub	r3, fp, #1	; 0x1
   14e20:	e213b0ff 	ands	fp, r3, #255	; 0xff
   14e24:	1affffdc 	bne	14d9c <LCDPrintChar+0x64>
   14e28:	e2483001 	sub	r3, r8, #1	; 0x1
   14e2c:	e1a03803 	mov	r3, r3, lsl #16
   14e30:	e2472001 	sub	r2, r7, #1	; 0x1
   14e34:	e1a08823 	mov	r8, r3, lsr #16
   14e38:	e20270ff 	and	r7, r2, #255	; 0xff
   14e3c:	e1a03808 	mov	r3, r8, lsl #16
   14e40:	e1530809 	cmp	r3, r9, lsl #16
   14e44:	e1a02843 	mov	r2, r3, asr #16
   14e48:	aaffffd0 	bge	14d90 <LCDPrintChar+0x58>
   14e4c:	e35a0000 	cmp	sl, #0	; 0x0
   14e50:	1a000008 	bne	14e78 <LCDPrintChar+0x140>
   14e54:	e5d62000 	ldrb	r2, [r6]
   14e58:	e242300c 	sub	r3, r2, #12	; 0xc
   14e5c:	e3530084 	cmp	r3, #132	; 0x84
   14e60:	d2423006 	suble	r3, r2, #6	; 0x6
   14e64:	da00000e 	ble	14ea4 <LCDPrintChar+0x16c>
   14e68:	e5c6a000 	strb	sl, [r6]
   14e6c:	e5d53000 	ldrb	r3, [r5]
   14e70:	e2433008 	sub	r3, r3, #8	; 0x8
   14e74:	ea00000c 	b	14eac <LCDPrintChar+0x174>
   14e78:	e35a0001 	cmp	sl, #1	; 0x1
   14e7c:	1a00000b 	bne	14eb0 <LCDPrintChar+0x178>
   14e80:	e5d52000 	ldrb	r2, [r5]
   14e84:	e242300c 	sub	r3, r2, #12	; 0xc
   14e88:	e3530084 	cmp	r3, #132	; 0x84
   14e8c:	d2423006 	suble	r3, r2, #6	; 0x6
   14e90:	da000005 	ble	14eac <LCDPrintChar+0x174>
   14e94:	e3a03000 	mov	r3, #0	; 0x0
   14e98:	e5c53000 	strb	r3, [r5]
   14e9c:	e5d63000 	ldrb	r3, [r6]
   14ea0:	e2433008 	sub	r3, r3, #8	; 0x8
   14ea4:	e5c63000 	strb	r3, [r6]
   14ea8:	ea000000 	b	14eb0 <LCDPrintChar+0x178>
   14eac:	e5c53000 	strb	r3, [r5]
   14eb0:	e5d53000 	ldrb	r3, [r5]
   14eb4:	e2833008 	add	r3, r3, #8	; 0x8
   14eb8:	e3530084 	cmp	r3, #132	; 0x84
   14ebc:	c3a00001 	movgt	r0, #1	; 0x1
   14ec0:	ca000000 	bgt	14ec8 <LCDPrintChar+0x190>
   14ec4:	e3a00000 	mov	r0, #0	; 0x0
   14ec8:	e28dd004 	add	sp, sp, #4	; 0x4
   14ecc:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14ed0:	e12fff1e 	bx	lr
   14ed4:	4000000b 	andmi	r0, r0, fp

00014ed8 <LCDPrintLogo>:
   14ed8:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14edc:	e59f706c 	ldr	r7, [pc, #108]	; 14f50 <.text+0x4f50>
   14ee0:	e3a05004 	mov	r5, #4	; 0x4
   14ee4:	e3a08019 	mov	r8, #25	; 0x19
   14ee8:	e5d74000 	ldrb	r4, [r7]
   14eec:	e3a06008 	mov	r6, #8	; 0x8
   14ef0:	e3e0107b 	mvn	r1, #123	; 0x7b
   14ef4:	e1a02001 	mov	r2, r1
   14ef8:	e0652002 	rsb	r2, r5, r2
   14efc:	e0681001 	rsb	r1, r8, r1
   14f00:	e3140080 	tst	r4, #128	; 0x80
   14f04:	e2855001 	add	r5, r5, #1	; 0x1
   14f08:	e20110ff 	and	r1, r1, #255	; 0xff
   14f0c:	e20220ff 	and	r2, r2, #255	; 0xff
   14f10:	159f303c 	ldrne	r3, [pc, #60]	; 14f54 <.text+0x4f54>
   14f14:	15d30000 	ldrneb	r0, [r3]
   14f18:	1bffff63 	blne	14cac <LCDSetPixel>
   14f1c:	e3550084 	cmp	r5, #132	; 0x84
   14f20:	e1a03084 	mov	r3, r4, lsl #1
   14f24:	02888001 	addeq	r8, r8, #1	; 0x1
   14f28:	03a05004 	moveq	r5, #4	; 0x4
   14f2c:	e2566001 	subs	r6, r6, #1	; 0x1
   14f30:	e20340ff 	and	r4, r3, #255	; 0xff
   14f34:	1affffed 	bne	14ef0 <LCDPrintLogo+0x18>
   14f38:	e59f3018 	ldr	r3, [pc, #24]	; 14f58 <.text+0x4f58>
   14f3c:	e2877001 	add	r7, r7, #1	; 0x1
   14f40:	e1570003 	cmp	r7, r3
   14f44:	1affffe7 	bne	14ee8 <LCDPrintLogo+0x10>
   14f48:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   14f4c:	e12fff1e 	bx	lr
   14f50:	400001e6 	andmi	r0, r0, r6, ror #3
   14f54:	40000009 	andmi	r0, r0, r9
   14f58:	40000646 	andmi	r0, r0, r6, asr #12

00014f5c <LCDPrintString>:
   14f5c:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14f60:	e24dd018 	sub	sp, sp, #24	; 0x18
   14f64:	e5dd503c 	ldrb	r5, [sp, #60]
   14f68:	e3550000 	cmp	r5, #0	; 0x0
   14f6c:	e1a09000 	mov	r9, r0
   14f70:	e1a07001 	mov	r7, r1
   14f74:	e202a0ff 	and	sl, r2, #255	; 0xff
   14f78:	e20300ff 	and	r0, r3, #255	; 0xff
   14f7c:	e5dd1038 	ldrb	r1, [sp, #56]
   14f80:	1a000007 	bne	14fa4 <LCDPrintString+0x48>
   14f84:	e3a03006 	mov	r3, #6	; 0x6
   14f88:	e0020391 	mul	r2, r1, r3
   14f8c:	e1a01180 	mov	r1, r0, lsl #3
   14f90:	e59f3320 	ldr	r3, [pc, #800]	; 152b8 <.text+0x52b8>
   14f94:	e282207e 	add	r2, r2, #126	; 0x7e
   14f98:	e2611078 	rsb	r1, r1, #120	; 0x78
   14f9c:	e5c32000 	strb	r2, [r3]
   14fa0:	ea000008 	b	14fc8 <LCDPrintString+0x6c>
   14fa4:	e3550001 	cmp	r5, #1	; 0x1
   14fa8:	1a000008 	bne	14fd0 <LCDPrintString+0x74>
   14fac:	e3a03006 	mov	r3, #6	; 0x6
   14fb0:	e0010193 	mul	r1, r3, r1
   14fb4:	e59f22fc 	ldr	r2, [pc, #764]	; 152b8 <.text+0x52b8>
   14fb8:	e1a03180 	mov	r3, r0, lsl #3
   14fbc:	e2833003 	add	r3, r3, #3	; 0x3
   14fc0:	e5c23000 	strb	r3, [r2]
   14fc4:	e281107e 	add	r1, r1, #126	; 0x7e
   14fc8:	e59f32ec 	ldr	r3, [pc, #748]	; 152bc <.text+0x52bc>
   14fcc:	e5c31000 	strb	r1, [r3]
   14fd0:	e3a06000 	mov	r6, #0	; 0x0
   14fd4:	e1a04806 	mov	r4, r6, lsl #16
   14fd8:	e1a03844 	mov	r3, r4, asr #16
   14fdc:	e7d90003 	ldrb	r0, [r9, r3]
   14fe0:	e3500000 	cmp	r0, #0	; 0x0
   14fe4:	0a0000b0 	beq	152ac <LCDPrintString+0x350>
   14fe8:	e3500025 	cmp	r0, #37	; 0x25
   14fec:	1a00008a 	bne	1521c <LCDPrintString+0x2c0>
   14ff0:	e2863001 	add	r3, r6, #1	; 0x1
   14ff4:	e1a03803 	mov	r3, r3, lsl #16
   14ff8:	e7d92843 	ldrb	r2, [r9, r3, asr #16]
   14ffc:	e3520000 	cmp	r2, #0	; 0x0
   15000:	e1a08823 	mov	r8, r3, lsr #16
   15004:	0a0000a8 	beq	152ac <LCDPrintString+0x350>
   15008:	e352005c 	cmp	r2, #92	; 0x5c
   1500c:	1a000009 	bne	15038 <LCDPrintString+0xdc>
   15010:	e59f32a8 	ldr	r3, [pc, #680]	; 152c0 <.text+0x52c0>
   15014:	e286c002 	add	ip, r6, #2	; 0x2
   15018:	e1a0c80c 	mov	ip, ip, lsl #16
   1501c:	e5d31000 	ldrb	r1, [r3]
   15020:	e7d9084c 	ldrb	r0, [r9, ip, asr #16]
   15024:	e59f228c 	ldr	r2, [pc, #652]	; 152b8 <.text+0x52b8>
   15028:	e59f328c 	ldr	r3, [pc, #652]	; 152bc <.text+0x52bc>
   1502c:	e1a0882c 	mov	r8, ip, lsr #16
   15030:	e58d5000 	str	r5, [sp]
   15034:	ea00002e 	b	150f4 <LCDPrintString+0x198>
   15038:	e3520062 	cmp	r2, #98	; 0x62
   1503c:	1a000019 	bne	150a8 <LCDPrintString+0x14c>
   15040:	e3a04001 	mov	r4, #1	; 0x1
   15044:	e59f1274 	ldr	r1, [pc, #628]	; 152c0 <.text+0x52c0>
   15048:	e3570000 	cmp	r7, #0	; 0x0
   1504c:	e59f2264 	ldr	r2, [pc, #612]	; 152b8 <.text+0x52b8>
   15050:	e59f3264 	ldr	r3, [pc, #612]	; 152bc <.text+0x52bc>
   15054:	b5d11000 	ldrltb	r1, [r1]
   15058:	a5d11000 	ldrgeb	r1, [r1]
   1505c:	a59f2254 	ldrge	r2, [pc, #596]	; 152b8 <.text+0x52b8>
   15060:	a59f3254 	ldrge	r3, [pc, #596]	; 152bc <.text+0x52bc>
   15064:	e3a00031 	mov	r0, #49	; 0x31
   15068:	a3a00030 	movge	r0, #48	; 0x30
   1506c:	e58d5000 	str	r5, [sp]
   15070:	ebffff30 	bl	14d38 <LCDPrintChar>
   15074:	e3140003 	tst	r4, #3	; 0x3
   15078:	e59f2238 	ldr	r2, [pc, #568]	; 152b8 <.text+0x52b8>
   1507c:	e59f3238 	ldr	r3, [pc, #568]	; 152bc <.text+0x52bc>
   15080:	e3a00020 	mov	r0, #32	; 0x20
   15084:	e1a07087 	mov	r7, r7, lsl #1
   15088:	e2844001 	add	r4, r4, #1	; 0x1
   1508c:	059f122c 	ldreq	r1, [pc, #556]	; 152c0 <.text+0x52c0>
   15090:	05d11000 	ldreqb	r1, [r1]
   15094:	058d5000 	streq	r5, [sp]
   15098:	0bffff26 	bleq	14d38 <LCDPrintChar>
   1509c:	e3540021 	cmp	r4, #33	; 0x21
   150a0:	0a00007c 	beq	15298 <LCDPrintString+0x33c>
   150a4:	eaffffe6 	b	15044 <LCDPrintString+0xe8>
   150a8:	e3520064 	cmp	r2, #100	; 0x64
   150ac:	1a000034 	bne	15184 <LCDPrintString+0x228>
   150b0:	e3570000 	cmp	r7, #0	; 0x0
   150b4:	aa000006 	bge	150d4 <LCDPrintString+0x178>
   150b8:	e3a0002d 	mov	r0, #45	; 0x2d
   150bc:	e1a0100a 	mov	r1, sl
   150c0:	e59f21f0 	ldr	r2, [pc, #496]	; 152b8 <.text+0x52b8>
   150c4:	e59f31f0 	ldr	r3, [pc, #496]	; 152bc <.text+0x52bc>
   150c8:	e58d5000 	str	r5, [sp]
   150cc:	ebffff19 	bl	14d38 <LCDPrintChar>
   150d0:	e2677000 	rsb	r7, r7, #0	; 0x0
   150d4:	e3570000 	cmp	r7, #0	; 0x0
   150d8:	13a04009 	movne	r4, #9	; 0x9
   150dc:	1a000010 	bne	15124 <LCDPrintString+0x1c8>
   150e0:	e59f21d0 	ldr	r2, [pc, #464]	; 152b8 <.text+0x52b8>
   150e4:	e59f31d0 	ldr	r3, [pc, #464]	; 152bc <.text+0x52bc>
   150e8:	e1a0100a 	mov	r1, sl
   150ec:	e3a00030 	mov	r0, #48	; 0x30
   150f0:	e58d5000 	str	r5, [sp]
   150f4:	ebffff0f 	bl	14d38 <LCDPrintChar>
   150f8:	ea000066 	b	15298 <LCDPrintString+0x33c>
   150fc:	eb000e6c 	bl	18ab4 <__modsi3>
   15100:	e2803030 	add	r3, r0, #48	; 0x30
   15104:	e14631b2 	strh	r3, [r6, #-18]
   15108:	e1a00007 	mov	r0, r7
   1510c:	e3a0100a 	mov	r1, #10	; 0xa
   15110:	eb000de2 	bl	188a0 <__divsi3>
   15114:	e2443001 	sub	r3, r4, #1	; 0x1
   15118:	e1a03803 	mov	r3, r3, lsl #16
   1511c:	e1a07000 	mov	r7, r0
   15120:	e1a04823 	mov	r4, r3, lsr #16
   15124:	e1a03804 	mov	r3, r4, lsl #16
   15128:	e28d2018 	add	r2, sp, #24	; 0x18
   1512c:	e3570000 	cmp	r7, #0	; 0x0
   15130:	e1a00007 	mov	r0, r7
   15134:	e3a0100a 	mov	r1, #10	; 0xa
   15138:	e08267c3 	add	r6, r2, r3, asr #15
   1513c:	caffffee 	bgt	150fc <LCDPrintString+0x1a0>
   15140:	ea000002 	b	15150 <LCDPrintString+0x1f4>
   15144:	e55c0012 	ldrb	r0, [ip, #-18]
   15148:	e58d5000 	str	r5, [sp]
   1514c:	ebfffef9 	bl	14d38 <LCDPrintChar>
   15150:	e2843001 	add	r3, r4, #1	; 0x1
   15154:	e1a03803 	mov	r3, r3, lsl #16
   15158:	e1a04823 	mov	r4, r3, lsr #16
   1515c:	e1a00804 	mov	r0, r4, lsl #16
   15160:	e1a00840 	mov	r0, r0, asr #16
   15164:	e28de018 	add	lr, sp, #24	; 0x18
   15168:	e3500009 	cmp	r0, #9	; 0x9
   1516c:	e1a0100a 	mov	r1, sl
   15170:	e59f2140 	ldr	r2, [pc, #320]	; 152b8 <.text+0x52b8>
   15174:	e59f3140 	ldr	r3, [pc, #320]	; 152bc <.text+0x52bc>
   15178:	e08ec080 	add	ip, lr, r0, lsl #1
   1517c:	dafffff0 	ble	15144 <LCDPrintString+0x1e8>
   15180:	ea000044 	b	15298 <LCDPrintString+0x33c>
   15184:	e3520068 	cmp	r2, #104	; 0x68
   15188:	1a000014 	bne	151e0 <LCDPrintString+0x284>
   1518c:	e59f412c 	ldr	r4, [pc, #300]	; 152c0 <.text+0x52c0>
   15190:	e59f2120 	ldr	r2, [pc, #288]	; 152b8 <.text+0x52b8>
   15194:	e5d41000 	ldrb	r1, [r4]
   15198:	e59f311c 	ldr	r3, [pc, #284]	; 152bc <.text+0x52bc>
   1519c:	e3a00030 	mov	r0, #48	; 0x30
   151a0:	e58d5000 	str	r5, [sp]
   151a4:	ebfffee3 	bl	14d38 <LCDPrintChar>
   151a8:	e5d41000 	ldrb	r1, [r4]
   151ac:	e59f3108 	ldr	r3, [pc, #264]	; 152bc <.text+0x52bc>
   151b0:	e3a00078 	mov	r0, #120	; 0x78
   151b4:	e59f20fc 	ldr	r2, [pc, #252]	; 152b8 <.text+0x52b8>
   151b8:	e58d5000 	str	r5, [sp]
   151bc:	ebfffedd 	bl	14d38 <LCDPrintChar>
   151c0:	e3a03000 	mov	r3, #0	; 0x0
   151c4:	e2833001 	add	r3, r3, #1	; 0x1
   151c8:	e1a03803 	mov	r3, r3, lsl #16
   151cc:	e3530702 	cmp	r3, #524288	; 0x80000
   151d0:	e1a07207 	mov	r7, r7, lsl #4
   151d4:	e1a03823 	mov	r3, r3, lsr #16
   151d8:	0a00002e 	beq	15298 <LCDPrintString+0x33c>
   151dc:	eafffff8 	b	151c4 <LCDPrintString+0x268>
   151e0:	e3520066 	cmp	r2, #102	; 0x66
   151e4:	1a000005 	bne	15200 <LCDPrintString+0x2a4>
   151e8:	e59f30d0 	ldr	r3, [pc, #208]	; 152c0 <.text+0x52c0>
   151ec:	e59f20c4 	ldr	r2, [pc, #196]	; 152b8 <.text+0x52b8>
   151f0:	e5d31000 	ldrb	r1, [r3]
   151f4:	e59f30c0 	ldr	r3, [pc, #192]	; 152bc <.text+0x52bc>
   151f8:	e3a00021 	mov	r0, #33	; 0x21
   151fc:	eaffffbb 	b	150f0 <LCDPrintString+0x194>
   15200:	e3520075 	cmp	r2, #117	; 0x75
   15204:	1a000023 	bne	15298 <LCDPrintString+0x33c>
   15208:	e59f20a8 	ldr	r2, [pc, #168]	; 152b8 <.text+0x52b8>
   1520c:	e59f30a8 	ldr	r3, [pc, #168]	; 152bc <.text+0x52bc>
   15210:	e20700ff 	and	r0, r7, #255	; 0xff
   15214:	e1a0100a 	mov	r1, sl
   15218:	eaffffb4 	b	150f0 <LCDPrintString+0x194>
   1521c:	e350002f 	cmp	r0, #47	; 0x2f
   15220:	1a000016 	bne	15280 <LCDPrintString+0x324>
   15224:	e0893003 	add	r3, r9, r3
   15228:	e5d33001 	ldrb	r3, [r3, #1]
   1522c:	e3530072 	cmp	r3, #114	; 0x72
   15230:	1a000005 	bne	1524c <LCDPrintString+0x2f0>
   15234:	e59f3084 	ldr	r3, [pc, #132]	; 152c0 <.text+0x52c0>
   15238:	e59f2078 	ldr	r2, [pc, #120]	; 152b8 <.text+0x52b8>
   1523c:	e5d31000 	ldrb	r1, [r3]
   15240:	e59f3074 	ldr	r3, [pc, #116]	; 152bc <.text+0x52bc>
   15244:	e3a0000d 	mov	r0, #13	; 0xd
   15248:	ea000006 	b	15268 <LCDPrintString+0x30c>
   1524c:	e353006e 	cmp	r3, #110	; 0x6e
   15250:	1a000006 	bne	15270 <LCDPrintString+0x314>
   15254:	e59f3064 	ldr	r3, [pc, #100]	; 152c0 <.text+0x52c0>
   15258:	e59f2058 	ldr	r2, [pc, #88]	; 152b8 <.text+0x52b8>
   1525c:	e5d31000 	ldrb	r1, [r3]
   15260:	e59f3054 	ldr	r3, [pc, #84]	; 152bc <.text+0x52bc>
   15264:	e3a0000a 	mov	r0, #10	; 0xa
   15268:	e58d5000 	str	r5, [sp]
   1526c:	ebfffeb1 	bl	14d38 <LCDPrintChar>
   15270:	e2863001 	add	r3, r6, #1	; 0x1
   15274:	e1a03803 	mov	r3, r3, lsl #16
   15278:	e1a08823 	mov	r8, r3, lsr #16
   1527c:	ea000005 	b	15298 <LCDPrintString+0x33c>
   15280:	e1a0100a 	mov	r1, sl
   15284:	e59f202c 	ldr	r2, [pc, #44]	; 152b8 <.text+0x52b8>
   15288:	e59f302c 	ldr	r3, [pc, #44]	; 152bc <.text+0x52bc>
   1528c:	e58d5000 	str	r5, [sp]
   15290:	ebfffea8 	bl	14d38 <LCDPrintChar>
   15294:	e1a08824 	mov	r8, r4, lsr #16
   15298:	e2883001 	add	r3, r8, #1	; 0x1
   1529c:	e1a03803 	mov	r3, r3, lsl #16
   152a0:	e3530815 	cmp	r3, #1376256	; 0x150000
   152a4:	e1a06823 	mov	r6, r3, lsr #16
   152a8:	daffff49 	ble	14fd4 <LCDPrintString+0x78>
   152ac:	e28dd018 	add	sp, sp, #24	; 0x18
   152b0:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   152b4:	e12fff1e 	bx	lr
   152b8:	40001566 	andmi	r1, r0, r6, ror #10
   152bc:	40001565 	andmi	r1, r0, r5, ror #10
   152c0:	4000000a 	andmi	r0, r0, sl

000152c4 <LCDSetRowColor>:

//Usage: LCDSetRowColor(0,0,white, 0);
//Inputs: unsigned char row - row to be set
//		  unsigned char column - this indicates where to start coloring the row
//		  char color - desired color to change the row to
//		  char inverted - indicates if row goes from left to right, or top to bottom
//Outputs: None
//Description:  Changes the color or a row starting at the position indicated in column.
void LCDSetRowColor(unsigned char row, unsigned char column, char color, char inverted){
   152c4:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#ifdef PHILLIPS
	if(inverted==ORIENTUP){
		row *= 8;
		column *=6;
	}
	else if(inverted==ORIENTLEFT){
		row=(15-row)*8+3;
		column = (column*6);
	}

	for (int j = column; j < ROW_LENGTH; j++)
	{
		for (int k = 0; k < 8; k++)
		{
			if(inverted==ORIENTUP){
				LCDSetPixel(color, row + k, j);
			}
			else if(inverted==ORIENTLEFT){
				LCDSetPixel(color, j, row+k);
			}
		}
	}
#endif
#ifdef EPSON
	if(inverted==ORIENTUP){
   152c8:	e21370ff 	ands	r7, r3, #255	; 0xff
   152cc:	e20060ff 	and	r6, r0, #255	; 0xff
   152d0:	e20110ff 	and	r1, r1, #255	; 0xff
   152d4:	e20280ff 	and	r8, r2, #255	; 0xff
		row = 15*8-row*8;
		column *=6;
   152d8:	03a03006 	moveq	r3, #6	; 0x6
   152dc:	00020391 	muleq	r2, r1, r3
   152e0:	01a03186 	moveq	r3, r6, lsl #3
   152e4:	02633078 	rsbeq	r3, r3, #120	; 0x78
   152e8:	0a000005 	beq	15304 <LCDSetRowColor+0x40>
	}
	else if(inverted==ORIENTLEFT){
   152ec:	e3570001 	cmp	r7, #1	; 0x1
   152f0:	1a000005 	bne	1530c <LCDSetRowColor+0x48>
		row=row*8+3;
		column = column*6;
   152f4:	e3a03006 	mov	r3, #6	; 0x6
   152f8:	e0020391 	mul	r2, r1, r3
   152fc:	e1a03186 	mov	r3, r6, lsl #3
   15300:	e2833003 	add	r3, r3, #3	; 0x3
   15304:	e20360ff 	and	r6, r3, #255	; 0xff
   15308:	e20210ff 	and	r1, r2, #255	; 0xff
	}

	for (int j = column; j < ROW_LENGTH; j++)
   1530c:	e1a05001 	mov	r5, r1
   15310:	ea000012 	b	15360 <LCDSetRowColor+0x9c>
   15314:	e1a04006 	mov	r4, r6
	{
		for (int k = 0; k < 8; k++)
		{
			if(inverted==ORIENTUP){
   15318:	e3570000 	cmp	r7, #0	; 0x0
				LCDSetPixel(color, row + k, j);
   1531c:	e1a00008 	mov	r0, r8
   15320:	e1a01004 	mov	r1, r4
   15324:	e20520ff 	and	r2, r5, #255	; 0xff
   15328:	0a000004 	beq	15340 <LCDSetRowColor+0x7c>
			}
			else if(inverted==ORIENTLEFT){
   1532c:	e3570001 	cmp	r7, #1	; 0x1
				LCDSetPixel(color, j, row+k);
   15330:	e1a02004 	mov	r2, r4
   15334:	e1a00008 	mov	r0, r8
   15338:	e20510ff 	and	r1, r5, #255	; 0xff
   1533c:	1a000000 	bne	15344 <LCDSetRowColor+0x80>
   15340:	ebfffe59 	bl	14cac <LCDSetPixel>
   15344:	e2842001 	add	r2, r4, #1	; 0x1
   15348:	e2863008 	add	r3, r6, #8	; 0x8
   1534c:	e20330ff 	and	r3, r3, #255	; 0xff
   15350:	e20240ff 	and	r4, r2, #255	; 0xff
   15354:	e1540003 	cmp	r4, r3
   15358:	1affffee 	bne	15318 <LCDSetRowColor+0x54>
   1535c:	e2855001 	add	r5, r5, #1	; 0x1
   15360:	e3550083 	cmp	r5, #131	; 0x83
   15364:	daffffea 	ble	15314 <LCDSetRowColor+0x50>
			}
		}
	}
#endif
}
   15368:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   1536c:	e12fff1e 	bx	lr

00015370 <LCDContrast>:

//Usage: LCDContrast(0x03);
//Inputs: char setting - character representing desired contrast
//Outputs: None
//Description: Sets the LCD contrast to "setting"
void LCDContrast(char setting){
   15370:	e92d4010 	stmdb	sp!, {r4, lr}
   15374:	e1a04000 	mov	r4, r0
	#ifdef	EPSON
		LCDCommand(VOLCTR);	// electronic volume, this is the contrast/brightness
   15378:	e3a00081 	mov	r0, #129	; 0x81
   1537c:	ebfffd74 	bl	14954 <LCDCommand>
		LCDData(0x18);		// volume (contrast) setting - fine tuning, original
   15380:	e3a00018 	mov	r0, #24	; 0x18
   15384:	ebfffd9a 	bl	149f4 <LCDData>
   15388:	e20440ff 	and	r4, r4, #255	; 0xff
		LCDData(setting);	// internal resistor ratio - coarse adjustment
   1538c:	e1a00004 	mov	r0, r4
	#endif
	#ifdef	PHILLIPS
		LCDCommand(SETCON);	//Sets contrast for phillips screen
		LCDCommand(setting);
	#endif
}
   15390:	e8bd4010 	ldmia	sp!, {r4, lr}
   15394:	eafffd96 	b	149f4 <LCDData>

00015398 <vs1002Config>:
//Description: Configures the LPC2148 for communication with the mp3 player
void vs1002Config(void){
	
	//Setup I/O Ports
	PINSEL0	|= (SCLK_PINSEL | MISO_PINSEL | MOSI_PINSEL);	// SPI pin connections
   15398:	e59f301c 	ldr	r3, [pc, #28]	; 153bc <.text+0x53bc>
   1539c:	e5932000 	ldr	r2, [r3]
   153a0:	e3822c15 	orr	r2, r2, #5376	; 0x1500
   153a4:	e5832000 	str	r2, [r3]
	PINSEL0 &= 0x0FFFFF0F;									
   153a8:	e5932000 	ldr	r2, [r3]
   153ac:	e3c2220f 	bic	r2, r2, #-268435456	; 0xf0000000
   153b0:	e3c220f0 	bic	r2, r2, #240	; 0xf0
   153b4:	e5832000 	str	r2, [r3]
	
}
   153b8:	e12fff1e 	bx	lr
   153bc:	e002c000 	and	ip, r2, r0

000153c0 <vs1002Finish>:

//Usage: vs1002Finish();
//Inputs: None
//Outputs: None
//Description: Relinquishes control of the SPI lines to the MP3 player
void vs1002Finish(void){
	PINSEL0 &= 0xFFFFC00F;		// Relinquish SPI pin connections
   153c0:	e59f2010 	ldr	r2, [pc, #16]	; 153d8 <.text+0x53d8>
   153c4:	e5923000 	ldr	r3, [r2]
   153c8:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   153cc:	e3c33030 	bic	r3, r3, #48	; 0x30
   153d0:	e5823000 	str	r3, [r2]
}
   153d4:	e12fff1e 	bx	lr
   153d8:	e002c000 	and	ip, r2, r0

000153dc <vs1002SCIWrite>:

//Usage: register_value = vs1002SCIRead(SCI_MODE);
//Inputs: unsigned char address - Address of the register to be read
//Ouputs: None
//Description: Returns the value of the vs1002 register defined by "address"
unsigned short int vs1002SCIRead(unsigned char address)
{
	unsigned short int temp;
	SELECT_MP3_SCI();
	
	//delay_ms(1);
	SPI0_send(READ_COMMAND);
	SPI0_send(address);
   	temp = 	SPI0_recv();					
   	temp <<= 8;							
   	temp |= SPI0_recv();				
	//delay_ms(1);
	UNSELECT_MP3_SCI();
	
	delay_ms(1);
	return temp;
}

//Usage: vs1002SCIWrite(SCI_MODE, SM_SDINEW);
//Inputs: unsigned char address - Adress of the register to be written to
//		  unsigned short int data - Data to write to the register
//Outputs: None
//Description: Writes "data" to the register defined in "address"
void vs1002SCIWrite(unsigned char address, unsigned short int data)
{	
	SELECT_MP3_SCI();
   153dc:	e59f3050 	ldr	r3, [pc, #80]	; 15434 <.text+0x5434>
   153e0:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   153e4:	e3a06601 	mov	r6, #1048576	; 0x100000
   153e8:	e5836000 	str	r6, [r3]
   153ec:	e20050ff 	and	r5, r0, #255	; 0xff

	SPI0_send(WRITE_COMMAND);
   153f0:	e3a00002 	mov	r0, #2	; 0x2
   153f4:	e1a04801 	mov	r4, r1, lsl #16
   153f8:	ebfff291 	bl	11e44 <SPI0_send>
	SPI0_send(address);
   153fc:	e1a00005 	mov	r0, r5
   15400:	ebfff28f 	bl	11e44 <SPI0_send>
	SPI0_send(data >> 8);						// Send High Byte of data
   15404:	e1a00c24 	mov	r0, r4, lsr #24
   15408:	e1a04824 	mov	r4, r4, lsr #16
	SPI0_send(data & 0x00ff);					// Send Low Byte of data
   1540c:	e20440ff 	and	r4, r4, #255	; 0xff
   15410:	ebfff28b 	bl	11e44 <SPI0_send>
   15414:	e1a00004 	mov	r0, r4
   15418:	ebfff289 	bl	11e44 <SPI0_send>

	UNSELECT_MP3_SCI();
   1541c:	e59f3014 	ldr	r3, [pc, #20]	; 15438 <.text+0x5438>
	delay_ms(1);
   15420:	e3a00001 	mov	r0, #1	; 0x1
   15424:	e5836000 	str	r6, [r3]
   15428:	ebffeb59 	bl	10194 <delay_ms>
}
   1542c:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   15430:	e12fff1e 	bx	lr
   15434:	e002800c 	and	r8, r2, ip
   15438:	e0028004 	and	r8, r2, r4

0001543c <vs1002Init>:
   1543c:	e52de004 	str	lr, [sp, #-4]!
   15440:	e3a01b02 	mov	r1, #2048	; 0x800
   15444:	e3a00000 	mov	r0, #0	; 0x0
   15448:	ebffffe3 	bl	153dc <vs1002SCIWrite>
   1544c:	e3a00001 	mov	r0, #1	; 0x1
   15450:	ebffeb4f 	bl	10194 <delay_ms>
   15454:	e59f1008 	ldr	r1, [pc, #8]	; 15464 <.text+0x5464>
   15458:	e3a00003 	mov	r0, #3	; 0x3
   1545c:	e49de004 	ldr	lr, [sp], #4
   15460:	eaffffdd 	b	153dc <vs1002SCIWrite>
   15464:	00009964 	andeq	r9, r0, r4, ror #18

00015468 <vs1002SCIRead>:
   15468:	e59f3054 	ldr	r3, [pc, #84]	; 154c4 <.text+0x54c4>
   1546c:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   15470:	e3a06601 	mov	r6, #1048576	; 0x100000
   15474:	e5836000 	str	r6, [r3]
   15478:	e20040ff 	and	r4, r0, #255	; 0xff
   1547c:	e3a00003 	mov	r0, #3	; 0x3
   15480:	ebfff26f 	bl	11e44 <SPI0_send>
   15484:	e1a00004 	mov	r0, r4
   15488:	ebfff26d 	bl	11e44 <SPI0_send>
   1548c:	ebfff26e 	bl	11e4c <SPI0_recv>
   15490:	e1a04c00 	mov	r4, r0, lsl #24
   15494:	ebfff26c 	bl	11e4c <SPI0_recv>
   15498:	e59f3028 	ldr	r3, [pc, #40]	; 154c8 <.text+0x54c8>
   1549c:	e1a05000 	mov	r5, r0
   154a0:	e5836000 	str	r6, [r3]
   154a4:	e3a00001 	mov	r0, #1	; 0x1
   154a8:	ebffeb39 	bl	10194 <delay_ms>
   154ac:	e1a04824 	mov	r4, r4, lsr #16
   154b0:	e1844005 	orr	r4, r4, r5
   154b4:	e1a04804 	mov	r4, r4, lsl #16
   154b8:	e1a00824 	mov	r0, r4, lsr #16
   154bc:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   154c0:	e12fff1e 	bx	lr
   154c4:	e002800c 	and	r8, r2, ip
   154c8:	e0028004 	and	r8, r2, r4

000154cc <vs1002SineTest>:

//Usage: vs1002SineTest(126);
//Inputs: unsigned char pitch - pitch of the sine wave to be produced
//Outputs: None
//Description: Runs the Sine Test defined in the vs1002 datasheet
//**NOTE: ** for a sine wave test @ 5168 hz, send sequence: 0x53, 0xEF, 0x6E, 126, 0, 0, 0, 0
void vs1002SineTest(unsigned char pitch)
{
	SELECT_MP3_SDI();
   154cc:	e59f3060 	ldr	r3, [pc, #96]	; 15534 <.text+0x5534>
   154d0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   154d4:	e3a05801 	mov	r5, #65536	; 0x10000
   154d8:	e5835000 	str	r5, [r3]
   154dc:	e1a04000 	mov	r4, r0
	
   	SPI0_send(0x53);
   154e0:	e3a00053 	mov	r0, #83	; 0x53
   154e4:	ebfff256 	bl	11e44 <SPI0_send>
	SPI0_send(0xEF);
   154e8:	e3a000ef 	mov	r0, #239	; 0xef
   154ec:	ebfff254 	bl	11e44 <SPI0_send>
   154f0:	e20440ff 	and	r4, r4, #255	; 0xff
	SPI0_send(0x6E);
   154f4:	e3a0006e 	mov	r0, #110	; 0x6e
   154f8:	ebfff251 	bl	11e44 <SPI0_send>
   	SPI0_send(pitch);						//Send the Pitch	
   154fc:	e1a00004 	mov	r0, r4
   15500:	ebfff24f 	bl	11e44 <SPI0_send>
	SPI0_send(0);
   15504:	e3a00000 	mov	r0, #0	; 0x0
   15508:	ebfff24d 	bl	11e44 <SPI0_send>
	SPI0_send(0);
   1550c:	e3a00000 	mov	r0, #0	; 0x0
   15510:	ebfff24b 	bl	11e44 <SPI0_send>
	SPI0_send(0);
   15514:	e3a00000 	mov	r0, #0	; 0x0
   15518:	ebfff249 	bl	11e44 <SPI0_send>
	SPI0_send(0);
   1551c:	e3a00000 	mov	r0, #0	; 0x0
   15520:	ebfff247 	bl	11e44 <SPI0_send>
	
   	UNSELECT_MP3_SDI();
   15524:	e59f300c 	ldr	r3, [pc, #12]	; 15538 <.text+0x5538>
   15528:	e5835000 	str	r5, [r3]
}
   1552c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   15530:	e12fff1e 	bx	lr
   15534:	e002801c 	and	r8, r2, ip, lsl r0
   15538:	e0028014 	and	r8, r2, r4, lsl r0

0001553c <vs1002Mute>:

//Usage: vs1002Mute();
//Inputs: None
//Outputs: None
//Description: Mutes the output of the vs1002 MP3 player
void vs1002Mute(void){
	vs1002SCIWrite(SCI_VOL, SV_MUTE);
   1553c:	e59f1004 	ldr	r1, [pc, #4]	; 15548 <.text+0x5548>
   15540:	e3a0000b 	mov	r0, #11	; 0xb
   15544:	eaffffa4 	b	153dc <vs1002SCIWrite>
   15548:	0000ffff 	streqd	pc, [r0], -pc

0001554c <vs1002SetVolume>:
}


//Usage: vs1002SetVolume(INCREASE);
//Inputs: char setting - either INCREASE(1) or DECREASE(0)
//Outputs: None
//Description: Increases or decreases the volume of the MP3 player based on the value of "setting"
void vs1002SetVolume(char setting){
   1554c:	e92d4010 	stmdb	sp!, {r4, lr}
   15550:	e20040ff 	and	r4, r0, #255	; 0xff
	unsigned short int currentVolume=0;
	
	currentVolume = vs1002SCIRead(SCI_VOL);
   15554:	e3a0000b 	mov	r0, #11	; 0xb
   15558:	ebffffc2 	bl	15468 <vs1002SCIRead>
	if(setting == INCREASE){
   1555c:	e3540031 	cmp	r4, #49	; 0x31
   15560:	1a000004 	bne	15578 <vs1002SetVolume+0x2c>
		if(currentVolume == SV_MAX_VOLUME);	//Don't Change the current volume
		else currentVolume -= 0x0808;		//Increment both channels equally
   15564:	e2403b02 	sub	r3, r0, #2048	; 0x800
   15568:	e2433008 	sub	r3, r3, #8	; 0x8
   1556c:	e1a03803 	mov	r3, r3, lsl #16
   15570:	e3500000 	cmp	r0, #0	; 0x0
   15574:	ea000004 	b	1558c <vs1002SetVolume+0x40>
	}
	else{
		if(currentVolume == SV_MUTE);			//Don't change the current volume
		else currentVolume += 0x0808;
   15578:	e2803b02 	add	r3, r0, #2048	; 0x800
   1557c:	e59f201c 	ldr	r2, [pc, #28]	; 155a0 <.text+0x55a0>
   15580:	e2833008 	add	r3, r3, #8	; 0x8
   15584:	e1500002 	cmp	r0, r2
   15588:	e1a03803 	mov	r3, r3, lsl #16
   1558c:	11a00823 	movne	r0, r3, lsr #16
	}
	vs1002SCIWrite(SCI_VOL, currentVolume);
   15590:	e1a01000 	mov	r1, r0
   15594:	e3a0000b 	mov	r0, #11	; 0xb
}
   15598:	e8bd4010 	ldmia	sp!, {r4, lr}
   1559c:	eaffff8e 	b	153dc <vs1002SCIWrite>
   155a0:	0000ffff 	streqd	pc, [r0], -pc

000155a4 <vs1002SendMusic>:

//Usage: vs1002SendMusic(bufferedSongData, BUFFERSIZE);
//Inputs: unsigned char* songData - pointer to MP3 data that is to be sent to mp3 player
//		  int buffer_size - size of song data in bytes
//Outputs: None
//Description: Sends the data in the songData buffer to the MP3 player
void vs1002SendMusic(unsigned char* songData, int buffer_size){
   155a4:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
	SELECT_MP3_SDI();
   155a8:	e59f303c 	ldr	r3, [pc, #60]	; 155ec <.text+0x55ec>
   155ac:	e3a02801 	mov	r2, #65536	; 0x10000
   155b0:	e1a06000 	mov	r6, r0
   155b4:	e1a05001 	mov	r5, r1
   155b8:	e3a04000 	mov	r4, #0	; 0x0
   155bc:	e5832000 	str	r2, [r3]
   155c0:	ea000002 	b	155d0 <vs1002SendMusic+0x2c>
	for(int i=0; i<buffer_size; i++){
		SPI0_send(*songData++);			//Send the buffered byte of data, then increment the buffer position
   155c4:	e7d40006 	ldrb	r0, [r4, r6]
   155c8:	ebfff21d 	bl	11e44 <SPI0_send>
   155cc:	e2844001 	add	r4, r4, #1	; 0x1
   155d0:	e1540005 	cmp	r4, r5
   155d4:	bafffffa 	blt	155c4 <vs1002SendMusic+0x20>
	}
	UNSELECT_MP3_SDI();
   155d8:	e59f3010 	ldr	r3, [pc, #16]	; 155f0 <.text+0x55f0>
   155dc:	e3a02801 	mov	r2, #65536	; 0x10000
   155e0:	e5832000 	str	r2, [r3]
}
   155e4:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   155e8:	e12fff1e 	bx	lr
   155ec:	e002801c 	and	r8, r2, ip, lsl r0
   155f0:	e0028014 	and	r8, r2, r4, lsl r0

000155f4 <vs1002Reset>:

//Usage: vs1002Reset();
//Inputs: None
//Outputs: None
//Description: Resets the mp3 player
void vs1002Reset(void){
	//Reset the MP3 Player and make sure the mp3 player doesn't try to boot from SPI
	IOCLR0 = MP3_GPIO0;		//Pull GPIO0 low
   155f4:	e59f302c 	ldr	r3, [pc, #44]	; 15628 <.text+0x5628>
   155f8:	e3a02802 	mov	r2, #131072	; 0x20000
   155fc:	e92d4010 	stmdb	sp!, {r4, lr}
   15600:	e5832000 	str	r2, [r3]
	IOCLR1 = MP3_XRES;		//Reset the vs1002
   15604:	e3a04401 	mov	r4, #16777216	; 0x1000000
   15608:	e2833010 	add	r3, r3, #16	; 0x10
   1560c:	e5834000 	str	r4, [r3]
	delay_ms(10);			//Hold Reset
   15610:	e3a0000a 	mov	r0, #10	; 0xa
   15614:	ebffeade 	bl	10194 <delay_ms>
	IOSET1 = MP3_XRES;		//Bring vs1002 out of reset
   15618:	e59f300c 	ldr	r3, [pc, #12]	; 1562c <.text+0x562c>
   1561c:	e5834000 	str	r4, [r3]
}
   15620:	e8bd4010 	ldmia	sp!, {r4, lr}
   15624:	e12fff1e 	bx	lr
   15628:	e002800c 	and	r8, r2, ip
   1562c:	e0028014 	and	r8, r2, r4, lsl r0

00015630 <ns73Config>:
//Inputs: None
//Outputs: None
//Description: Configures the LPC2148 for communication with the ns73 module
void ns73Config(void)
{
   15630:	e52de004 	str	lr, [sp, #-4]!
    //Setup Ports
	IODIR1 |= (FM_SCLK | FM_DIO);		//Setup FM Trans. I/O Lines
   15634:	e59f203c 	ldr	r2, [pc, #60]	; 15678 <.text+0x5678>
   15638:	e5923000 	ldr	r3, [r2]
   1563c:	e3833303 	orr	r3, r3, #201326592	; 0xc000000
   15640:	e5823000 	str	r3, [r2]
	IODIR1 |= FM_LA;					//**This has been done in the bootup() routine
   15644:	e5923000 	ldr	r3, [r2]
   15648:	e3833402 	orr	r3, r3, #33554432	; 0x2000000
   1564c:	e4023010 	str	r3, [r2], #-16
	IODIR0 &= ~FM_TEB;
   15650:	e5923000 	ldr	r3, [r2]
   15654:	e3c33801 	bic	r3, r3, #65536	; 0x10000
   15658:	e482300c 	str	r3, [r2], #12
	IOSET1 |= FM_SCLK | FM_DIO;
   1565c:	e5923000 	ldr	r3, [r2]
   15660:	e3833303 	orr	r3, r3, #201326592	; 0xc000000
	delay_ms(1);
   15664:	e3a00001 	mov	r0, #1	; 0x1
   15668:	e5823000 	str	r3, [r2]
   1566c:	ebffeac8 	bl	10194 <delay_ms>
}
   15670:	e49de004 	ldr	lr, [sp], #4
   15674:	e12fff1e 	bx	lr
   15678:	e0028018 	and	r8, r2, r8, lsl r0

0001567c <ns73Send>:

//Usage: ns73_init()
//Inputs: None
//Outputs: None
//Description: Resets the ns73 module and restores the default values to each register
void ns73Init(void){
	ns73Send(R14, R14_RESET); //Software reset
	delay_ms(1);				 //
	
    //Load register values with initial default values
    ns73Send(R1, R1_DEFAULT); 		//Register 1 defaults
    ns73Send(R2, R2_DEFAULT); 		//Register 2 defaults
    ns73Send(R3, 0x8A); 			//Set broadcast freq to 97.3
    ns73Send(R4, 0x2E);
	ns73Send(R8, R8_DEFAULT); 		//Register 8 defaults
    ns73Send(R0, MUTE); 			//Flip the power switch
    ns73Send(R14, R14_RESET); 		//Software reset
    ns73Send(R6, R6_DEFAULT); 		//Set Register 6
}

//Usage: ns73Send(R1, R1_DEFAULT);
//Inputs: unsigned char outgoing_address - address of the ns73 register to be written to
//		  unsigned char outgoing_data - data to be written to the register
//Outputs: None
//Description: Basic SPI send address and data bytes to ns73 module
unsigned char ns73Send(unsigned char outgoing_address, unsigned char outgoing_data)
{
    unsigned char incoming_byte=0, x;

    UNLATCH;
   1567c:	e59f310c 	ldr	r3, [pc, #268]	; 15790 <.text+0x5790>
   15680:	e3a02402 	mov	r2, #33554432	; 0x2000000
   15684:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15688:	e1a0c000 	mov	ip, r0
   1568c:	e5832000 	str	r2, [r3]
    delay_ms(10);
   15690:	e3a0000a 	mov	r0, #10	; 0xa
   15694:	e20c40ff 	and	r4, ip, #255	; 0xff
   15698:	e20160ff 	and	r6, r1, #255	; 0xff
   1569c:	ebffeabc 	bl	10194 <delay_ms>
   156a0:	e3a05000 	mov	r5, #0	; 0x0
    for(x = 0 ; x < 4 ; x++)
    {
        CLKDWN; //Toggle the SPI clock
   156a4:	e59f20e4 	ldr	r2, [pc, #228]	; 15790 <.text+0x5790>
   156a8:	e3a03302 	mov	r3, #134217728	; 0x8000000
   156ac:	e5823000 	str	r3, [r2]
        if((outgoing_address & 0x01)==0x01){
			IOSET1 |= FM_DIO; //Put bit on SPI data bus
   156b0:	e59f10dc 	ldr	r1, [pc, #220]	; 15794 <.text+0x5794>
   156b4:	e3140001 	tst	r4, #1	; 0x1
		}	
		else IOCLR1 |= FM_DIO;
   156b8:	05923000 	ldreq	r3, [r2]
   156bc:	15913000 	ldrne	r3, [r1]
   156c0:	03833301 	orreq	r3, r3, #67108864	; 0x4000000
   156c4:	13833301 	orrne	r3, r3, #67108864	; 0x4000000
   156c8:	05823000 	streq	r3, [r2]
   156cc:	15813000 	strne	r3, [r1]
		outgoing_address >>= 1; //Rotate 1 bit to the right
		delay_ms(1);
   156d0:	e3a00001 	mov	r0, #1	; 0x1
   156d4:	e1a04034 	mov	r4, r4, lsr r0
   156d8:	ebffeaad 	bl	10194 <delay_ms>
        CLKUP;
   156dc:	e59f20b0 	ldr	r2, [pc, #176]	; 15794 <.text+0x5794>
   156e0:	e3a03302 	mov	r3, #134217728	; 0x8000000
   156e4:	e5823000 	str	r3, [r2]
		delay_ms(1);
   156e8:	e3a00001 	mov	r0, #1	; 0x1
   156ec:	ebffeaa8 	bl	10194 <delay_ms>
   156f0:	e2853001 	add	r3, r5, #1	; 0x1
   156f4:	e20350ff 	and	r5, r3, #255	; 0xff
   156f8:	e3550004 	cmp	r5, #4	; 0x4
   156fc:	1affffe8 	bne	156a4 <ns73Send+0x28>
   15700:	e3a07008 	mov	r7, #8	; 0x8
    }

    for(x = 0 ; x < 8 ; x++)
    {
        CLKDWN; //Toggle the SPI clock
   15704:	e59f1084 	ldr	r1, [pc, #132]	; 15790 <.text+0x5790>
   15708:	e3a03302 	mov	r3, #134217728	; 0x8000000
   1570c:	e5813000 	str	r3, [r1]
		ledRedOn();
   15710:	e59f3080 	ldr	r3, [pc, #128]	; 15798 <.text+0x5798>
   15714:	e3a02101 	mov	r2, #1073741824	; 0x40000000
   15718:	e5832000 	str	r2, [r3]
        if((outgoing_data & 0x01)==0x01){
			IOSET1 |= FM_DIO; //Put bit on SPI data bus
   1571c:	e59f0070 	ldr	r0, [pc, #112]	; 15794 <.text+0x5794>
   15720:	e3160001 	tst	r6, #1	; 0x1
   15724:	15903000 	ldrne	r3, [r0]
		}
		else IOCLR1 |= FM_DIO;
   15728:	05913000 	ldreq	r3, [r1]
   1572c:	13833301 	orrne	r3, r3, #67108864	; 0x4000000
   15730:	03833301 	orreq	r3, r3, #67108864	; 0x4000000
		outgoing_data >>= 1; //Rotate 1 bit to the right
		delay_ms(1);
        CLKUP;
   15734:	e59f5058 	ldr	r5, [pc, #88]	; 15794 <.text+0x5794>
   15738:	15803000 	strne	r3, [r0]
   1573c:	05813000 	streq	r3, [r1]
   15740:	e3a00001 	mov	r0, #1	; 0x1
   15744:	e3a08302 	mov	r8, #134217728	; 0x8000000
   15748:	e1a06036 	mov	r6, r6, lsr r0
   1574c:	ebffea90 	bl	10194 <delay_ms>
		delay_ms(1);
   15750:	e3a00001 	mov	r0, #1	; 0x1
   15754:	e5858000 	str	r8, [r5]
   15758:	ebffea8d 	bl	10194 <delay_ms>
   1575c:	e2473001 	sub	r3, r7, #1	; 0x1
   15760:	e21370ff 	ands	r7, r3, #255	; 0xff
   15764:	1affffe6 	bne	15704 <ns73Send+0x88>
    }
    LATCH; //Latch this trasfer
   15768:	e3a04402 	mov	r4, #33554432	; 0x2000000
    delay_ms(10); //Minimum tLAH is 250nS
   1576c:	e3a0000a 	mov	r0, #10	; 0xa
   15770:	e5854000 	str	r4, [r5]
   15774:	ebffea86 	bl	10194 <delay_ms>
    UNLATCH;
   15778:	e59f3010 	ldr	r3, [pc, #16]	; 15790 <.text+0x5790>
	CLKDWN;
    return(incoming_byte);
}
   1577c:	e1a00007 	mov	r0, r7
   15780:	e5834000 	str	r4, [r3]
   15784:	e5838000 	str	r8, [r3]
   15788:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   1578c:	e12fff1e 	bx	lr
   15790:	e002801c 	and	r8, r2, ip, lsl r0
   15794:	e0028014 	and	r8, r2, r4, lsl r0
   15798:	e002800c 	and	r8, r2, ip

0001579c <ns73Init>:
   1579c:	e52de004 	str	lr, [sp, #-4]!
   157a0:	e3a01005 	mov	r1, #5	; 0x5
   157a4:	e3a0000e 	mov	r0, #14	; 0xe
   157a8:	ebffffb3 	bl	1567c <ns73Send>
   157ac:	e3a00001 	mov	r0, #1	; 0x1
   157b0:	ebffea77 	bl	10194 <delay_ms>
   157b4:	e3a010b4 	mov	r1, #180	; 0xb4
   157b8:	e3a00001 	mov	r0, #1	; 0x1
   157bc:	ebffffae 	bl	1567c <ns73Send>
   157c0:	e3a01006 	mov	r1, #6	; 0x6
   157c4:	e3a00002 	mov	r0, #2	; 0x2
   157c8:	ebffffab 	bl	1567c <ns73Send>
   157cc:	e3a0108a 	mov	r1, #138	; 0x8a
   157d0:	e3a00003 	mov	r0, #3	; 0x3
   157d4:	ebffffa8 	bl	1567c <ns73Send>
   157d8:	e3a0102e 	mov	r1, #46	; 0x2e
   157dc:	e3a00004 	mov	r0, #4	; 0x4
   157e0:	ebffffa5 	bl	1567c <ns73Send>
   157e4:	e3a0101a 	mov	r1, #26	; 0x1a
   157e8:	e3a00008 	mov	r0, #8	; 0x8
   157ec:	ebffffa2 	bl	1567c <ns73Send>
   157f0:	e3a01004 	mov	r1, #4	; 0x4
   157f4:	e3a00000 	mov	r0, #0	; 0x0
   157f8:	ebffff9f 	bl	1567c <ns73Send>
   157fc:	e3a01005 	mov	r1, #5	; 0x5
   15800:	e3a0000e 	mov	r0, #14	; 0xe
   15804:	ebffff9c 	bl	1567c <ns73Send>
   15808:	e3a00006 	mov	r0, #6	; 0x6
   1580c:	e3a0101e 	mov	r1, #30	; 0x1e
   15810:	e49de004 	ldr	lr, [sp], #4
   15814:	eaffff98 	b	1567c <ns73Send>

00015818 <ns73SerialReset>:

//Usage: ns73SerialReset()
//Inputs: None
//Outputs: None
//Description:  Resets the ns73 module
void ns73SerialReset(void){
   15818:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
		delay_ms(10);
		IOCLR1 |= FM_DIO;
   1581c:	e59f40f4 	ldr	r4, [pc, #244]	; 15918 <.text+0x5918>
   15820:	e3a0000a 	mov	r0, #10	; 0xa
   15824:	ebffea5a 	bl	10194 <delay_ms>
   15828:	e5943000 	ldr	r3, [r4]
   1582c:	e3833301 	orr	r3, r3, #67108864	; 0x4000000
		delay_ms(10);
   15830:	e3a0000a 	mov	r0, #10	; 0xa
   15834:	e5843000 	str	r3, [r4]
   15838:	ebffea55 	bl	10194 <delay_ms>
		IOCLR1 |= FM_SCLK;
   1583c:	e5943000 	ldr	r3, [r4]
   15840:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
   15844:	e5843000 	str	r3, [r4]
		delay_ms(10);
   15848:	e3a0000a 	mov	r0, #10	; 0xa
   1584c:	ebffea50 	bl	10194 <delay_ms>
		IOSET1 |= FM_DIO;
   15850:	e59f20c4 	ldr	r2, [pc, #196]	; 1591c <.text+0x591c>
   15854:	e5923000 	ldr	r3, [r2]
   15858:	e3833301 	orr	r3, r3, #67108864	; 0x4000000
   1585c:	e5823000 	str	r3, [r2]
   15860:	e3a06000 	mov	r6, #0	; 0x0
		for(int i=0; i<26; i++){
			IOSET1 |= FM_SCLK;
   15864:	e59f40b0 	ldr	r4, [pc, #176]	; 1591c <.text+0x591c>
   15868:	e5943000 	ldr	r3, [r4]
			delay_ms(10);
			IOCLR1 |= FM_SCLK;
   1586c:	e59f50a4 	ldr	r5, [pc, #164]	; 15918 <.text+0x5918>
   15870:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
   15874:	e3a0000a 	mov	r0, #10	; 0xa
   15878:	e5843000 	str	r3, [r4]
   1587c:	ebffea44 	bl	10194 <delay_ms>
   15880:	e5953000 	ldr	r3, [r5]
   15884:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
   15888:	e2866001 	add	r6, r6, #1	; 0x1
			delay_ms(10);
   1588c:	e3a0000a 	mov	r0, #10	; 0xa
   15890:	e5853000 	str	r3, [r5]
   15894:	ebffea3e 	bl	10194 <delay_ms>
   15898:	e356001a 	cmp	r6, #26	; 0x1a
   1589c:	1afffff0 	bne	15864 <ns73SerialReset+0x4c>
		}
		IOSET1 |= FM_SCLK;
   158a0:	e5943000 	ldr	r3, [r4]
   158a4:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
		delay_ms(10);
   158a8:	e3a0000a 	mov	r0, #10	; 0xa
   158ac:	e5843000 	str	r3, [r4]
   158b0:	ebffea37 	bl	10194 <delay_ms>
		IOCLR1 |= FM_DIO;
   158b4:	e5953000 	ldr	r3, [r5]
   158b8:	e3833301 	orr	r3, r3, #67108864	; 0x4000000
		delay_ms(10);
   158bc:	e3a0000a 	mov	r0, #10	; 0xa
   158c0:	e5853000 	str	r3, [r5]
   158c4:	ebffea32 	bl	10194 <delay_ms>
		IOCLR1 |= FM_SCLK;
   158c8:	e5953000 	ldr	r3, [r5]
   158cc:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
		delay_ms(10);
   158d0:	e3a0000a 	mov	r0, #10	; 0xa
   158d4:	e5853000 	str	r3, [r5]
   158d8:	ebffea2d 	bl	10194 <delay_ms>
		IOSET1 |= FM_SCLK;
   158dc:	e5943000 	ldr	r3, [r4]
   158e0:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
		delay_ms(10);
   158e4:	e3a0000a 	mov	r0, #10	; 0xa
   158e8:	e5843000 	str	r3, [r4]
   158ec:	ebffea28 	bl	10194 <delay_ms>
		IOSET1 |= FM_DIO;
   158f0:	e5943000 	ldr	r3, [r4]
   158f4:	e3833301 	orr	r3, r3, #67108864	; 0x4000000
   158f8:	e5843000 	str	r3, [r4]
		delay_ms(10);
   158fc:	e3a0000a 	mov	r0, #10	; 0xa
   15900:	ebffea23 	bl	10194 <delay_ms>
		IOCLR1 |= FM_SCLK;
   15904:	e5953000 	ldr	r3, [r5]
   15908:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
   1590c:	e5853000 	str	r3, [r5]
}
   15910:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   15914:	e12fff1e 	bx	lr
   15918:	e002801c 	and	r8, r2, ip, lsl r0
   1591c:	e0028014 	and	r8, r2, r4, lsl r0

00015920 <ns73SetChannel>:

//Usage: ns73SetChannel(973);
//Inputs: int radio_channel - Desired Radio Channel (should be input in MHz*10 so 97.3FM becomes 973)
//Outputs: None
//Description: Tunes the ns73 module to "radio_channel."
void ns73SetChannel(int radio_channel){
	long int channel=radio_channel*100000;
	unsigned char low_byte, high_byte;
	
	channel += 304000;
   15920:	e59f203c 	ldr	r2, [pc, #60]	; 15964 <.text+0x5964>
   15924:	e59f303c 	ldr	r3, [pc, #60]	; 15968 <.text+0x5968>
   15928:	e92d4010 	stmdb	sp!, {r4, lr}
   1592c:	e0243290 	mla	r4, r0, r2, r3
	channel /= 8192;
   15930:	e2843d7f 	add	r3, r4, #8128	; 0x1fc0
   15934:	e3540000 	cmp	r4, #0	; 0x0
   15938:	e283303f 	add	r3, r3, #63	; 0x3f
   1593c:	b1a04003 	movlt	r4, r3
	low_byte = channel & 0xFF;
	high_byte = (channel >> 8) & 0xFF;
	
	ns73Send(R3, low_byte);
   15940:	e1a016a4 	mov	r1, r4, lsr #13
   15944:	e20110ff 	and	r1, r1, #255	; 0xff
   15948:	e3a00003 	mov	r0, #3	; 0x3
   1594c:	ebffff4a 	bl	1567c <ns73Send>
	ns73Send(R4, high_byte);
   15950:	e1a04aa4 	mov	r4, r4, lsr #21
   15954:	e20410ff 	and	r1, r4, #255	; 0xff
   15958:	e3a00004 	mov	r0, #4	; 0x4
}
   1595c:	e8bd4010 	ldmia	sp!, {r4, lr}
   15960:	eaffff45 	b	1567c <ns73Send>
   15964:	000186a0 	andeq	r8, r1, r0, lsr #13
   15968:	0004a380 	andeq	sl, r4, r0, lsl #7

0001596c <HandleClassRequest>:
        Handle mass storage class request

**************************************************************************/
static BOOL HandleClassRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
   1596c:	e92d4010 	stmdb	sp!, {r4, lr}
    if (pSetup->wIndex != 0)
   15970:	e1d030b4 	ldrh	r3, [r0, #4]
   15974:	e3530000 	cmp	r3, #0	; 0x0
   15978:	e1a04001 	mov	r4, r1
   1597c:	e1a03002 	mov	r3, r2
   15980:	1a000012 	bne	159d0 <HandleClassRequest+0x64>
    {
        DBG("Invalid idx %X\n", pSetup->wIndex);
        return FALSE;
    }
    if (pSetup->wValue != 0)
   15984:	e1d0e0b2 	ldrh	lr, [r0, #2]
   15988:	e35e0000 	cmp	lr, #0	; 0x0
   1598c:	1a00000f 	bne	159d0 <HandleClassRequest+0x64>
    {
        DBG("Invalid val %X\n", pSetup->wValue);
        return FALSE;
    }

    switch (pSetup->bRequest)
   15990:	e5d0c001 	ldrb	ip, [r0, #1]
   15994:	e35c00fe 	cmp	ip, #254	; 0xfe
    {

        // get max LUN
        case 0xFE:
            *ppbData[0] = 0;        // No LUNs
   15998:	05933000 	ldreq	r3, [r3]
            *piLen = 1;
   1599c:	e3a02001 	mov	r2, #1	; 0x1
   159a0:	05c3e000 	streqb	lr, [r3]
   159a4:	e1a01002 	mov	r1, r2
   159a8:	05842000 	streq	r2, [r4]
   159ac:	0a000008 	beq	159d4 <HandleClassRequest+0x68>
   159b0:	e35c00ff 	cmp	ip, #255	; 0xff
   159b4:	1a000005 	bne	159d0 <HandleClassRequest+0x64>
            break;

        // MSC reset
        case 0xFF:
            if (pSetup->wLength > 0)
   159b8:	e1d030b6 	ldrh	r3, [r0, #6]
   159bc:	e3530000 	cmp	r3, #0	; 0x0
   159c0:	1a000002 	bne	159d0 <HandleClassRequest+0x64>
            {
                return FALSE;
            }
            MSCBotReset();
   159c4:	eb00002c 	bl	15a7c <MSCBotReset>
   159c8:	e3a01001 	mov	r1, #1	; 0x1
   159cc:	ea000000 	b	159d4 <HandleClassRequest+0x68>
            break;
   159d0:	e3a01000 	mov	r1, #0	; 0x0

        default:
            DBG("Unhandled class\n");
            return FALSE;
        }
    return TRUE;
}
   159d4:	e1a00001 	mov	r0, r1
   159d8:	e8bd4010 	ldmia	sp!, {r4, lr}
   159dc:	e12fff1e 	bx	lr

000159e0 <main_msc>:


/*************************************************************************
    msc_main
    ====
**************************************************************************/
int main_msc(void)
{
   159e0:	e52de004 	str	lr, [sp, #-4]!
    // initialise the SD card
    BlockDevInit();
   159e4:	eb000290 	bl	1642c <BlockDevInit>

    rprintf("Initialising USB stack\n");
   159e8:	e59f006c 	ldr	r0, [pc, #108]	; 15a5c <.text+0x5a5c>
   159ec:	ebfff019 	bl	11a58 <rprintf>

    // initialise stack
    USBInit();
   159f0:	eb0003d0 	bl	16938 <USBInit>

    // enable bulk-in interrupts on NAKs
    // these are required to get the BOT protocol going again after a STALL
    USBHwNakIntEnable(INACK_BI);
   159f4:	e3a00020 	mov	r0, #32	; 0x20
   159f8:	eb000444 	bl	16b10 <USBHwNakIntEnable>

    // register descriptors
    USBRegisterDescriptors(abDescriptors);
   159fc:	e59f005c 	ldr	r0, [pc, #92]	; 15a60 <.text+0x5a60>
   15a00:	eb0005eb 	bl	171b4 <USBRegisterDescriptors>

    // register class request handler
    USBRegisterRequestHandler(REQTYPE_TYPE_CLASS, HandleClassRequest, abClassReqData);
   15a04:	e59f2058 	ldr	r2, [pc, #88]	; 15a64 <.text+0x5a64>
   15a08:	e3a00001 	mov	r0, #1	; 0x1
   15a0c:	e59f1054 	ldr	r1, [pc, #84]	; 15a68 <.text+0x5a68>
   15a10:	eb0005e0 	bl	17198 <USBRegisterRequestHandler>

    // register endpoint handlers
    USBHwRegisterEPIntHandler(MSC_BULK_IN_EP, MSCBotBulkIn);
   15a14:	e3a00085 	mov	r0, #133	; 0x85
   15a18:	e59f104c 	ldr	r1, [pc, #76]	; 15a6c <.text+0x5a6c>
   15a1c:	eb0003e1 	bl	169a8 <USBHwRegisterEPIntHandler>
    USBHwRegisterEPIntHandler(MSC_BULK_OUT_EP, MSCBotBulkOut);
   15a20:	e59f1048 	ldr	r1, [pc, #72]	; 15a70 <.text+0x5a70>
   15a24:	e3a00002 	mov	r0, #2	; 0x2
   15a28:	eb0003de 	bl	169a8 <USBHwRegisterEPIntHandler>

    rprintf("Starting USB communication\n");
   15a2c:	e59f0040 	ldr	r0, [pc, #64]	; 15a74 <.text+0x5a74>
   15a30:	ebfff008 	bl	11a58 <rprintf>
	
    // connect to bus
    USBHwConnect(TRUE);
   15a34:	e3a00001 	mov	r0, #1	; 0x1
   15a38:	eb000471 	bl	16c04 <USBHwConnect>
   15a3c:	ea000000 	b	15a44 <main_msc+0x64>

    // call USB interrupt handler continuously
    while (IOPIN0 & (1<<23))
	{
		USBHwISR();
   15a40:	eb0004f9 	bl	16e2c <USBHwISR>
   15a44:	e59f302c 	ldr	r3, [pc, #44]	; 15a78 <.text+0x5a78>
   15a48:	e5933000 	ldr	r3, [r3]
   15a4c:	e2130502 	ands	r0, r3, #8388608	; 0x800000
   15a50:	1afffffa 	bne	15a40 <main_msc+0x60>
    }

    return 0;
}
   15a54:	e49de004 	ldr	lr, [sp], #4
   15a58:	e12fff1e 	bx	lr
   15a5c:	00018e34 	andeq	r8, r1, r4, lsr lr
   15a60:	40000646 	andmi	r0, r0, r6, asr #12
   15a64:	40001567 	andmi	r1, r0, r7, ror #10
   15a68:	0001596c 	andeq	r5, r1, ip, ror #18
   15a6c:	00015e30 	andeq	r5, r1, r0, lsr lr
   15a70:	00015be8 	andeq	r5, r1, r8, ror #23
   15a74:	00018e4c 	andeq	r8, r1, ip, asr #28
   15a78:	e0028000 	and	r8, r2, r0

00015a7c <MSCBotReset>:
void MSCBotReset(void)
{
    DBG("BOT reset in state %d\n", eState);
    // reset BOT state
    eState = eCBW;
   15a7c:	e59f3014 	ldr	r3, [pc, #20]	; 15a98 <.text+0x5a98>
   15a80:	e3a02000 	mov	r2, #0	; 0x0
   15a84:	e52de004 	str	lr, [sp, #-4]!
   15a88:	e5832000 	str	r2, [r3]
    // reset SCSI
    SCSIReset();
   15a8c:	eb000100 	bl	15e94 <SCSIReset>
}
   15a90:	e49de004 	ldr	lr, [sp], #4
   15a94:	e12fff1e 	bx	lr
   15a98:	40001570 	andmi	r1, r0, r0, ror r5

00015a9c <SendCSW>:


static void SendCSW(U8 bStatus)
{
    int iResidue;

    iResidue = CBW.dwCBWDataTransferLength - dwTransferSize;
   15a9c:	e59f203c 	ldr	r2, [pc, #60]	; 15ae0 <.text+0x5ae0>
   15aa0:	e59f303c 	ldr	r3, [pc, #60]	; 15ae4 <.text+0x5ae4>
   15aa4:	e5921008 	ldr	r1, [r2, #8]
   15aa8:	e5933000 	ldr	r3, [r3]

    // construct CSW
    CSW.dwCSWSignature      = CSW_SIGNATURE;
    CSW.dwCSWTag            = CBW.dwCBWTag;
   15aac:	e592c004 	ldr	ip, [r2, #4]
   15ab0:	e59f2030 	ldr	r2, [pc, #48]	; 15ae8 <.text+0x5ae8>
   15ab4:	e0631001 	rsb	r1, r3, r1
    CSW.dwCSWDataResidue    = MAX(iResidue, 0);
    CSW.bmCSWStatus         = bStatus;

    DBG("CSW: status=%x, residue=%d\n", bStatus, CSW.dwCSWDataResidue);

    // next state
    eState = eCSW;
   15ab8:	e59f302c 	ldr	r3, [pc, #44]	; 15aec <.text+0x5aec>
   15abc:	e5c2000c 	strb	r0, [r2, #12]
   15ac0:	e3a00003 	mov	r0, #3	; 0x3
   15ac4:	e5830000 	str	r0, [r3]
   15ac8:	e59f3020 	ldr	r3, [pc, #32]	; 15af0 <.text+0x5af0>
   15acc:	e3510000 	cmp	r1, #0	; 0x0
   15ad0:	b3a01000 	movlt	r1, #0	; 0x0
   15ad4:	e8821008 	stmia	r2, {r3, ip}
   15ad8:	e5821008 	str	r1, [r2, #8]
}
   15adc:	e12fff1e 	bx	lr
   15ae0:	40001584 	andmi	r1, r0, r4, lsl #11
   15ae4:	400015a8 	andmi	r1, r0, r8, lsr #11
   15ae8:	40001574 	andmi	r1, r0, r4, ror r5
   15aec:	40001570 	andmi	r1, r0, r0, ror r5
   15af0:	53425355 	cmppl	r2, #1409286145	; 0x54000001

00015af4 <BOTStall>:


/*************************************************************************
    CheckCBW
    ========
        Checks if CBW is valid and meaningful

    IN      pCBW    Command block wrapper
            iLen    Length of CBW

    Returns TRUE if valid and meaningful
**************************************************************************/
static BOOL CheckCBW(TCBW *pCBW, int iLen)
{
    // CBW valid?
    if (iLen != 31)
    {
        DBG("Invalid length (%d)\n", iLen);
        return FALSE;
    }
    if (pCBW->dwCBWSignature != CBW_SIGNATURE)
    {
        DBG("Invalid signature %x\n", pCBW->dwCBWSignature);
        return FALSE;
    }

    // CBW meaningful?
    if (pCBW->bCBWLun != 0)
    {
        DBG("Invalid LUN %d\n", pCBW->bCBWLun);
        return FALSE;
    }
    if ((pCBW->bCBWCBLength < 1) || (pCBW->bCBWCBLength > 16))
    {
        DBG("Invalid CB len %d\n", pCBW->bCBWCBLength);
        return FALSE;
    }
    return TRUE;
}


/*************************************************************************
    BOTStall
    ========
        Local function to stall ongoing transfer

    Which endpoint to stall is determined by looking at the transfer
    direction intended by the host.

**************************************************************************/
static void BOTStall(void)
{
   15af4:	e52de004 	str	lr, [sp, #-4]!
    if ((CBW.bmCBWFlags & 0x80) || (CBW.dwCBWDataTransferLength == 0))
   15af8:	e59f202c 	ldr	r2, [pc, #44]	; 15b2c <.text+0x5b2c>
   15afc:	e1d230dc 	ldrsb	r3, [r2, #12]
   15b00:	e3530000 	cmp	r3, #0	; 0x0
    {
        // stall data-in or CSW
        USBHwEPStall(MSC_BULK_IN_EP, TRUE);
   15b04:	e3a00085 	mov	r0, #133	; 0x85
   15b08:	e3a01001 	mov	r1, #1	; 0x1
   15b0c:	ba000003 	blt	15b20 <BOTStall+0x2c>
   15b10:	e5923008 	ldr	r3, [r2, #8]
   15b14:	e3530000 	cmp	r3, #0	; 0x0
    }
    else
    {
        // stall data-out
        USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
   15b18:	13a00002 	movne	r0, #2	; 0x2
   15b1c:	13a01001 	movne	r1, #1	; 0x1
   15b20:	eb0003f2 	bl	16af0 <USBHwEPStall>
    }
}
   15b24:	e49de004 	ldr	lr, [sp], #4
   15b28:	e12fff1e 	bx	lr
   15b2c:	40001584 	andmi	r1, r0, r4, lsl #11

00015b30 <HandleDataIn>:


/*************************************************************************
    HandleDataIn
    ============
        Handles data from device-to-host

**************************************************************************/
static void HandleDataIn(void)
{
   15b30:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    int iChunk;

    // process data for host in SCSI layer
    pbData = SCSIHandleData(CBW.CBWCB, CBW.bCBWCBLength, pbData, dwOffset);
   15b34:	e59f609c 	ldr	r6, [pc, #156]	; 15bd8 <.text+0x5bd8>
   15b38:	e59f409c 	ldr	r4, [pc, #156]	; 15bdc <.text+0x5bdc>
   15b3c:	e59f509c 	ldr	r5, [pc, #156]	; 15be0 <.text+0x5be0>
   15b40:	e5d6100e 	ldrb	r1, [r6, #14]
   15b44:	e5942000 	ldr	r2, [r4]
   15b48:	e5953000 	ldr	r3, [r5]
   15b4c:	e286000f 	add	r0, r6, #15	; 0xf
   15b50:	eb000124 	bl	15fe8 <SCSIHandleData>
    if (pbData == NULL)
   15b54:	e3500000 	cmp	r0, #0	; 0x0
    {
        BOTStall();
        SendCSW(STATUS_FAILED);
        return;
    }

    // send data to host?
    if (dwOffset < dwTransferSize)
   15b58:	e59f7084 	ldr	r7, [pc, #132]	; 15be4 <.text+0x5be4>
   15b5c:	e5840000 	str	r0, [r4]
   15b60:	1a000002 	bne	15b70 <HandleDataIn+0x40>
   15b64:	ebffffe2 	bl	15af4 <BOTStall>
   15b68:	e3a00001 	mov	r0, #1	; 0x1
   15b6c:	ea000015 	b	15bc8 <HandleDataIn+0x98>
   15b70:	e5952000 	ldr	r2, [r5]
   15b74:	e5973000 	ldr	r3, [r7]
   15b78:	e1520003 	cmp	r2, r3
    {
        iChunk = MIN(64, dwTransferSize - dwOffset);
        USBHwEPWrite(MSC_BULK_IN_EP, pbData, iChunk);
   15b7c:	e1a01000 	mov	r1, r0
   15b80:	e0624003 	rsb	r4, r2, r3
   15b84:	e3a00085 	mov	r0, #133	; 0x85
   15b88:	2a000006 	bcs	15ba8 <HandleDataIn+0x78>
   15b8c:	e3540040 	cmp	r4, #64	; 0x40
   15b90:	23a04040 	movcs	r4, #64	; 0x40
   15b94:	e1a02004 	mov	r2, r4
   15b98:	eb000468 	bl	16d40 <USBHwEPWrite>
        dwOffset += iChunk;
   15b9c:	e5953000 	ldr	r3, [r5]
   15ba0:	e0833004 	add	r3, r3, r4
   15ba4:	e5853000 	str	r3, [r5]
    }

    // are we done now?
    if (dwOffset == dwTransferSize)
   15ba8:	e5952000 	ldr	r2, [r5]
   15bac:	e5973000 	ldr	r3, [r7]
   15bb0:	e1520003 	cmp	r2, r3
   15bb4:	1a000005 	bne	15bd0 <HandleDataIn+0xa0>
    {
        if (dwOffset != CBW.dwCBWDataTransferLength)
   15bb8:	e5963008 	ldr	r3, [r6, #8]
   15bbc:	e1520003 	cmp	r2, r3
        {
            // stall pipe
            DBG("stalling DIN");
            BOTStall();
   15bc0:	1bffffcb 	blne	15af4 <BOTStall>
        }
        // done
        SendCSW(STATUS_PASSED);
   15bc4:	e3a00000 	mov	r0, #0	; 0x0
    }
}
   15bc8:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   15bcc:	eaffffb2 	b	15a9c <SendCSW>
   15bd0:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   15bd4:	e12fff1e 	bx	lr
   15bd8:	40001584 	andmi	r1, r0, r4, lsl #11
   15bdc:	4000156c 	andmi	r1, r0, ip, ror #10
   15be0:	400015a4 	andmi	r1, r0, r4, lsr #11
   15be4:	400015a8 	andmi	r1, r0, r8, lsr #11

00015be8 <MSCBotBulkOut>:


/*************************************************************************
    HandleDataOut
    =============
        Handles data from host-to-device

**************************************************************************/
static void HandleDataOut(void)
{
    int iChunk;

    if (dwOffset < dwTransferSize)
    {
        // get data from host
        iChunk = USBHwEPRead(MSC_BULK_OUT_EP, pbData, dwTransferSize - dwOffset);
        // process data in SCSI layer
        pbData = SCSIHandleData(CBW.CBWCB, CBW.bCBWCBLength, pbData, dwOffset);
        if (pbData == NULL)
        {
            BOTStall();
            SendCSW(STATUS_FAILED);
            return;
        }
        dwOffset += iChunk;
    }

    // are we done now?
    if (dwOffset == dwTransferSize)
    {
        if (dwOffset != CBW.dwCBWDataTransferLength)
        {
            // stall pipe
            DBG("stalling DOUT");
            BOTStall();
        }
        SendCSW(STATUS_PASSED);
    }
}


/*************************************************************************
    MSCBotBulkOut
    ===============
        Handles the BOT bulk OUT endpoint

    IN      bEP         Endpoint number
            bEPStatus   Endpoint status (indicates NAK, STALL, etc)

**************************************************************************/
void MSCBotBulkOut(U8 bEP, U8 bEPStatus)
{
   15be8:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    int     iLen, iChunk;
    BOOL    fHostIn, fDevIn;

    // ignore events on stalled EP
    if (bEPStatus & EP_STATUS_STALLED)
   15bec:	e3110002 	tst	r1, #2	; 0x2
   15bf0:	e24dd008 	sub	sp, sp, #8	; 0x8
   15bf4:	e20000ff 	and	r0, r0, #255	; 0xff
   15bf8:	1a000083 	bne	15e0c <.text+0x5e0c>
    {
        return;
    }

    switch (eState)
   15bfc:	e59f3214 	ldr	r3, [pc, #532]	; 15e18 <.text+0x5e18>
   15c00:	e5933000 	ldr	r3, [r3]
   15c04:	e3530004 	cmp	r3, #4	; 0x4
   15c08:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   15c0c:	ea00007e 	b	15e0c <.text+0x5e0c>
   15c10:	00015c24 	andeq	r5, r1, r4, lsr #24
   15c14:	00015d0c 	andeq	r5, r1, ip, lsl #26
   15c18:	00015da8 	andeq	r5, r1, r8, lsr #27
   15c1c:	00015da8 	andeq	r5, r1, r8, lsr #27
   15c20:	00015dc4 	andeq	r5, r1, r4, asr #27
    {

        case eCBW:
            iLen = USBHwEPRead(bEP, (U8 *)&CBW, sizeof(CBW));
   15c24:	e59f41f0 	ldr	r4, [pc, #496]	; 15e1c <.text+0x5e1c>
   15c28:	e3a02020 	mov	r2, #32	; 0x20
   15c2c:	e1a01004 	mov	r1, r4
   15c30:	eb000417 	bl	16c94 <USBHwEPRead>
   15c34:	e350001f 	cmp	r0, #31	; 0x1f
   15c38:	e58d0004 	str	r0, [sp, #4]
   15c3c:	1a00000a 	bne	15c6c <.text+0x5c6c>
   15c40:	e5942000 	ldr	r2, [r4]
   15c44:	e59f31d4 	ldr	r3, [pc, #468]	; 15e20 <.text+0x5e20>
   15c48:	e1520003 	cmp	r2, r3
   15c4c:	1a000006 	bne	15c6c <.text+0x5c6c>
   15c50:	e5d4e00d 	ldrb	lr, [r4, #13]
   15c54:	e35e0000 	cmp	lr, #0	; 0x0
   15c58:	1a000003 	bne	15c6c <.text+0x5c6c>
   15c5c:	e5d4100e 	ldrb	r1, [r4, #14]
   15c60:	e2413001 	sub	r3, r1, #1	; 0x1
   15c64:	e353000f 	cmp	r3, #15	; 0xf
   15c68:	9a000059 	bls	15dd4 <.text+0x5dd4>

            // check if we got a good CBW
            if (!CheckCBW(&CBW, iLen))
            {
                // see 6.6.1
                USBHwEPStall(MSC_BULK_IN_EP, TRUE);
   15c6c:	e3a00085 	mov	r0, #133	; 0x85
   15c70:	e3a01001 	mov	r1, #1	; 0x1
   15c74:	eb00039d 	bl	16af0 <USBHwEPStall>
                USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
   15c78:	e3a00002 	mov	r0, #2	; 0x2
   15c7c:	e3a01001 	mov	r1, #1	; 0x1
   15c80:	eb00039a 	bl	16af0 <USBHwEPStall>
                eState = eStalled;
   15c84:	e3a02004 	mov	r2, #4	; 0x4
   15c88:	ea00004a 	b	15db8 <.text+0x5db8>
                break;
            }

            DBG("CBW: len=%d, flags=%x, cmd=%x, cmdlen=%d\n",
                    CBW.dwCBWDataTransferLength, CBW.bmCBWFlags, CBW.CBWCB[0], CBW.bCBWCBLength);

            dwOffset = 0;
            dwTransferSize = 0;
            fHostIn = ((CBW.bmCBWFlags & 0x80) != 0);

            // verify request
            pbData = SCSIHandleCmd(CBW.CBWCB, CBW.bCBWCBLength, &iLen, &fDevIn);
            if (pbData == NULL)
            {
                // unknown command
                BOTStall();
                SendCSW(STATUS_FAILED);
                break;
            }

            // rule: if device and host disagree on direction, send CSW with status 2
            if ((iLen > 0) &&
   15c8c:	e59d2004 	ldr	r2, [sp, #4]
   15c90:	e3520000 	cmp	r2, #0	; 0x0
   15c94:	da00000b 	ble	15cc8 <.text+0x5cc8>
   15c98:	e3140080 	tst	r4, #128	; 0x80
   15c9c:	e59d3000 	ldr	r3, [sp]
   15ca0:	0a000002 	beq	15cb0 <.text+0x5cb0>
   15ca4:	e3530000 	cmp	r3, #0	; 0x0
   15ca8:	0a000002 	beq	15cb8 <.text+0x5cb8>
   15cac:	ea000005 	b	15cc8 <.text+0x5cc8>
   15cb0:	e3530000 	cmp	r3, #0	; 0x0
   15cb4:	0a000003 	beq	15cc8 <.text+0x5cc8>
                ((fHostIn && !fDevIn) ||
                (!fHostIn && fDevIn)))
            {
                DBG("Host and device disagree on direction\n");
                BOTStall();
   15cb8:	ebffff8d 	bl	15af4 <BOTStall>
                SendCSW(STATUS_PHASE_ERR);
   15cbc:	e3a00002 	mov	r0, #2	; 0x2
   15cc0:	ebffff75 	bl	15a9c <SendCSW>
   15cc4:	ea000050 	b	15e0c <.text+0x5e0c>
                break;
            }

            // rule: if D > H, send CSW with status 2
            if (iLen > CBW.dwCBWDataTransferLength)
   15cc8:	e59f314c 	ldr	r3, [pc, #332]	; 15e1c <.text+0x5e1c>
   15ccc:	e5933008 	ldr	r3, [r3, #8]
   15cd0:	e1520003 	cmp	r2, r3
   15cd4:	8afffff7 	bhi	15cb8 <.text+0x5cb8>
            {
                DBG("Negative residue\n");
                BOTStall();
                SendCSW(STATUS_PHASE_ERR);
                break;
            }

            dwTransferSize = iLen;
   15cd8:	e59f3144 	ldr	r3, [pc, #324]	; 15e24 <.text+0x5e24>
            if ((dwTransferSize == 0) || fDevIn)
   15cdc:	e3520000 	cmp	r2, #0	; 0x0
   15ce0:	e5832000 	str	r2, [r3]
   15ce4:	0a000003 	beq	15cf8 <.text+0x5cf8>
   15ce8:	e59d3000 	ldr	r3, [sp]
   15cec:	e3530000 	cmp	r3, #0	; 0x0
            {
                // data from device-to-host
                eState = eDataIn;
                HandleDataIn();
            }
            else
            {
                // data from host-to-device
                eState = eDataOut;
   15cf0:	03a02001 	moveq	r2, #1	; 0x1
   15cf4:	0a00002f 	beq	15db8 <.text+0x5db8>
   15cf8:	e59f3118 	ldr	r3, [pc, #280]	; 15e18 <.text+0x5e18>
   15cfc:	e3a02002 	mov	r2, #2	; 0x2
   15d00:	e5832000 	str	r2, [r3]
   15d04:	ebffff89 	bl	15b30 <HandleDataIn>
   15d08:	ea00003f 	b	15e0c <.text+0x5e0c>
   15d0c:	e59f5114 	ldr	r5, [pc, #276]	; 15e28 <.text+0x5e28>
   15d10:	e59f310c 	ldr	r3, [pc, #268]	; 15e24 <.text+0x5e24>
   15d14:	e5951000 	ldr	r1, [r5]
   15d18:	e5932000 	ldr	r2, [r3]
   15d1c:	e1510002 	cmp	r1, r2
   15d20:	2a000014 	bcs	15d78 <.text+0x5d78>
   15d24:	e59f4100 	ldr	r4, [pc, #256]	; 15e2c <.text+0x5e2c>
   15d28:	e0612002 	rsb	r2, r1, r2
   15d2c:	e3a00002 	mov	r0, #2	; 0x2
   15d30:	e5941000 	ldr	r1, [r4]
   15d34:	eb0003d6 	bl	16c94 <USBHwEPRead>
   15d38:	e1a06000 	mov	r6, r0
   15d3c:	e59f00d8 	ldr	r0, [pc, #216]	; 15e1c <.text+0x5e1c>
   15d40:	e5953000 	ldr	r3, [r5]
   15d44:	e5d0100e 	ldrb	r1, [r0, #14]
   15d48:	e5942000 	ldr	r2, [r4]
   15d4c:	e280000f 	add	r0, r0, #15	; 0xf
   15d50:	eb0000a4 	bl	15fe8 <SCSIHandleData>
   15d54:	e3500000 	cmp	r0, #0	; 0x0
   15d58:	15953000 	ldrne	r3, [r5]
   15d5c:	10833006 	addne	r3, r3, r6
   15d60:	e5840000 	str	r0, [r4]
   15d64:	15853000 	strne	r3, [r5]
   15d68:	1a000002 	bne	15d78 <.text+0x5d78>
   15d6c:	ebffff60 	bl	15af4 <BOTStall>
   15d70:	e3a00001 	mov	r0, #1	; 0x1
   15d74:	eaffffd1 	b	15cc0 <.text+0x5cc0>
   15d78:	e59f30a8 	ldr	r3, [pc, #168]	; 15e28 <.text+0x5e28>
   15d7c:	e5932000 	ldr	r2, [r3]
   15d80:	e59f309c 	ldr	r3, [pc, #156]	; 15e24 <.text+0x5e24>
   15d84:	e5933000 	ldr	r3, [r3]
   15d88:	e1520003 	cmp	r2, r3
   15d8c:	1a00001e 	bne	15e0c <.text+0x5e0c>
   15d90:	e59f3084 	ldr	r3, [pc, #132]	; 15e1c <.text+0x5e1c>
   15d94:	e5933008 	ldr	r3, [r3, #8]
   15d98:	e1520003 	cmp	r2, r3
   15d9c:	1bffff54 	blne	15af4 <BOTStall>
   15da0:	e3a00000 	mov	r0, #0	; 0x0
   15da4:	eaffffc5 	b	15cc0 <.text+0x5cc0>
            }
            break;

        case eDataOut:
            HandleDataOut();
            break;

        case eDataIn:
        case eCSW:
            iChunk = USBHwEPRead(bEP, NULL, 0);
   15da8:	e3a01000 	mov	r1, #0	; 0x0
   15dac:	e1a02001 	mov	r2, r1
   15db0:	eb0003b7 	bl	16c94 <USBHwEPRead>
            DBG("Phase error in state %d, %d bytes\n", eState, iChunk);
            eState = eCBW;
   15db4:	e3a02000 	mov	r2, #0	; 0x0
   15db8:	e59f3058 	ldr	r3, [pc, #88]	; 15e18 <.text+0x5e18>
   15dbc:	e5832000 	str	r2, [r3]
   15dc0:	ea000011 	b	15e0c <.text+0x5e0c>
            break;

        case eStalled:
        // keep stalling
            USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
   15dc4:	e3a00002 	mov	r0, #2	; 0x2
   15dc8:	e3a01001 	mov	r1, #1	; 0x1
   15dcc:	eb000347 	bl	16af0 <USBHwEPStall>
   15dd0:	ea00000d 	b	15e0c <.text+0x5e0c>
   15dd4:	e59fc048 	ldr	ip, [pc, #72]	; 15e24 <.text+0x5e24>
   15dd8:	e58ce000 	str	lr, [ip]
   15ddc:	e59fc044 	ldr	ip, [pc, #68]	; 15e28 <.text+0x5e28>
   15de0:	e284000f 	add	r0, r4, #15	; 0xf
   15de4:	e1a0300d 	mov	r3, sp
   15de8:	e28d2004 	add	r2, sp, #4	; 0x4
   15dec:	e58ce000 	str	lr, [ip]
   15df0:	e5d4400c 	ldrb	r4, [r4, #12]
   15df4:	eb00002b 	bl	15ea8 <SCSIHandleCmd>
   15df8:	e59f302c 	ldr	r3, [pc, #44]	; 15e2c <.text+0x5e2c>
   15dfc:	e3500000 	cmp	r0, #0	; 0x0
   15e00:	e5830000 	str	r0, [r3]
   15e04:	1affffa0 	bne	15c8c <.text+0x5c8c>
   15e08:	eaffffd7 	b	15d6c <.text+0x5d6c>
            break;

        default:
            DBG("Invalid state %d\n", eState);
//            ASSERT(FALSE);
            break;
    }
}
   15e0c:	e28dd008 	add	sp, sp, #8	; 0x8
   15e10:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   15e14:	e12fff1e 	bx	lr
   15e18:	40001570 	andmi	r1, r0, r0, ror r5
   15e1c:	40001584 	andmi	r1, r0, r4, lsl #11
   15e20:	43425355 	cmpmi	r2, #1409286145	; 0x54000001
   15e24:	400015a8 	andmi	r1, r0, r8, lsr #11
   15e28:	400015a4 	andmi	r1, r0, r4, lsr #11
   15e2c:	4000156c 	andmi	r1, r0, ip, ror #10

00015e30 <MSCBotBulkIn>:


/*************************************************************************
    MSCBotBulkIn
    ============
        Handles the BOT bulk IN endpoint

    IN      bEP         Endpoint number
            bEPStatus   Endpoint status (indicates NAK, STALL, etc)

**************************************************************************/
void MSCBotBulkIn(U8 bEP, U8 bEPStatus)
{
   15e30:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    // ignore events on stalled EP
    if (bEPStatus & EP_STATUS_STALLED)
   15e34:	e2114002 	ands	r4, r1, #2	; 0x2
    {
        return;
    }

    switch (eState)
   15e38:	e59f504c 	ldr	r5, [pc, #76]	; 15e8c <.text+0x5e8c>
   15e3c:	1a000010 	bne	15e84 <MSCBotBulkIn+0x54>
   15e40:	e5953000 	ldr	r3, [r5]
   15e44:	e3530003 	cmp	r3, #3	; 0x3
    {

        case eCBW:
        case eDataOut:
        // ignore possibly old ACKs
            break;

        case eDataIn:
            HandleDataIn();
            break;

        case eCSW:
        // wait for an IN token, then send the CSW
            USBHwEPWrite(MSC_BULK_IN_EP, (U8 *)&CSW, 13);
   15e48:	e3a00085 	mov	r0, #133	; 0x85
   15e4c:	e59f103c 	ldr	r1, [pc, #60]	; 15e90 <.text+0x5e90>
   15e50:	e3a0200d 	mov	r2, #13	; 0xd
   15e54:	0a000006 	beq	15e74 <MSCBotBulkIn+0x44>
   15e58:	e3530004 	cmp	r3, #4	; 0x4
            eState = eCBW;
            break;

        case eStalled:
        // keep stalling
            USBHwEPStall(MSC_BULK_IN_EP, TRUE);
   15e5c:	e3a01001 	mov	r1, #1	; 0x1
   15e60:	0a000006 	beq	15e80 <MSCBotBulkIn+0x50>
   15e64:	e3530002 	cmp	r3, #2	; 0x2
   15e68:	1a000005 	bne	15e84 <MSCBotBulkIn+0x54>
            break;

        default:
            DBG("Invalid state %d\n", eState);
//            ASSERT(FALSE);
            break;
    }
}
   15e6c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   15e70:	eaffff2e 	b	15b30 <HandleDataIn>
   15e74:	eb0003b1 	bl	16d40 <USBHwEPWrite>
   15e78:	e5854000 	str	r4, [r5]
   15e7c:	ea000000 	b	15e84 <MSCBotBulkIn+0x54>
   15e80:	eb00031a 	bl	16af0 <USBHwEPStall>
   15e84:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   15e88:	e12fff1e 	bx	lr
   15e8c:	40001570 	andmi	r1, r0, r0, ror r5
   15e90:	40001574 	andmi	r1, r0, r4, ror r5

00015e94 <SCSIReset>:

**************************************************************************/
void SCSIReset(void)
{
    dwSense = 0;
   15e94:	e59f3008 	ldr	r3, [pc, #8]	; 15ea4 <.text+0x5ea4>
   15e98:	e3a02000 	mov	r2, #0	; 0x0
   15e9c:	e5832000 	str	r2, [r3]
}
   15ea0:	e12fff1e 	bx	lr
   15ea4:	400017ac 	andmi	r1, r0, ip, lsr #15

00015ea8 <SCSIHandleCmd>:


/*************************************************************************
    SCSIHandleCmd
    =============
        Verifies a SCSI CDB and indicates the direction and amount of data
        that the device wants to transfer.

    If this call fails, a sense code is set in dwSense.

    IN      pbCDB       Command data block
            iCDBLen     Command data block len
    OUT     *piRspLen   Length of intended response data:
            *pfDevIn    TRUE if data is transferred from device-to-host

    Returns a pointer to the data exchange buffer if successful,
    return NULL otherwise.
**************************************************************************/
U8 * SCSIHandleCmd(U8 *pbCDB, int iCDBLen, int *piRspLen, BOOL *pfDevIn)
{
   15ea8:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15eac:	e1a04000 	mov	r4, r0
   15eb0:	e24dd008 	sub	sp, sp, #8	; 0x8
    int     i;
    TCDB6   *pCDB;
    U32     dwLen, dwLBA;

	//pCDB = (TCDB6 *)pbCDB;
	//Compiler warning fix
    TCDB6 cdb;
	pCDB = &cdb;
	memcpy(pCDB, pbCDB, sizeof(TCDB6));
   15eb4:	e3a08008 	mov	r8, #8	; 0x8
   15eb8:	e1a06001 	mov	r6, r1
   15ebc:	e1a05002 	mov	r5, r2
   15ec0:	e1a0000d 	mov	r0, sp
   15ec4:	e1a02008 	mov	r2, r8
   15ec8:	e1a01004 	mov	r1, r4
   15ecc:	e1a07003 	mov	r7, r3
   15ed0:	eb000770 	bl	17c98 <memcpy>
	
    // default direction is from device to host
    *pfDevIn = TRUE;

    switch (pCDB->bOperationCode)
   15ed4:	e5dd2000 	ldrb	r2, [sp]
   15ed8:	e3a03001 	mov	r3, #1	; 0x1
   15edc:	e3520012 	cmp	r2, #18	; 0x12
   15ee0:	e5873000 	str	r3, [r7]
   15ee4:	0a000016 	beq	15f44 <SCSIHandleCmd+0x9c>
   15ee8:	8a000006 	bhi	15f08 <SCSIHandleCmd+0x60>
   15eec:	e3520000 	cmp	r2, #0	; 0x0
    {

        // test unit ready (6)
        case SCSI_CMD_TEST_UNIT_READY:
            DBG("TEST UNIT READY\n");
            *piRspLen = 0;
   15ef0:	059f00e8 	ldreq	r0, [pc, #232]	; 15fe0 <.text+0x5fe0>
   15ef4:	05852000 	streq	r2, [r5]
   15ef8:	0a000035 	beq	15fd4 <SCSIHandleCmd+0x12c>
   15efc:	e3520003 	cmp	r2, #3	; 0x3
   15f00:	1a000008 	bne	15f28 <SCSIHandleCmd+0x80>
   15f04:	ea000009 	b	15f30 <SCSIHandleCmd+0x88>
   15f08:	e3520028 	cmp	r2, #40	; 0x28
   15f0c:	0a000012 	beq	15f5c <SCSIHandleCmd+0xb4>
   15f10:	e352002a 	cmp	r2, #42	; 0x2a
   15f14:	0a000018 	beq	15f7c <SCSIHandleCmd+0xd4>
   15f18:	e3520025 	cmp	r2, #37	; 0x25
            break;

        // request sense (6)
        case SCSI_CMD_REQUEST_SENSE:
            DBG("REQUEST SENSE (%06X)\n", dwSense);
            // check params
            *piRspLen = MIN(18, pCDB->bLength);
            break;

        // inquiry (6)
        case SCSI_CMD_INQUIRY:
            DBG("INQUIRY\n");
            // see SPC20r20, 4.3.4.6
            *piRspLen = MIN(36, pCDB->bLength);
            break;

        // read capacity (10)
        case SCSI_CMD_READ_CAPACITY:
            DBG("READ CAPACITY\n");
            *piRspLen = 8;
   15f1c:	059f00bc 	ldreq	r0, [pc, #188]	; 15fe0 <.text+0x5fe0>
   15f20:	05858000 	streq	r8, [r5]
   15f24:	0a00002a 	beq	15fd4 <SCSIHandleCmd+0x12c>
   15f28:	e3a03000 	mov	r3, #0	; 0x0
   15f2c:	ea00001e 	b	15fac <SCSIHandleCmd+0x104>
   15f30:	e5dd3004 	ldrb	r3, [sp, #4]
   15f34:	e59f00a4 	ldr	r0, [pc, #164]	; 15fe0 <.text+0x5fe0>
   15f38:	e3530012 	cmp	r3, #18	; 0x12
   15f3c:	23a03012 	movcs	r3, #18	; 0x12
   15f40:	ea000003 	b	15f54 <SCSIHandleCmd+0xac>
   15f44:	e5dd3004 	ldrb	r3, [sp, #4]
   15f48:	e59f0090 	ldr	r0, [pc, #144]	; 15fe0 <.text+0x5fe0>
   15f4c:	e3530024 	cmp	r3, #36	; 0x24
   15f50:	23a03024 	movcs	r3, #36	; 0x24
   15f54:	e5853000 	str	r3, [r5]
   15f58:	ea00001d 	b	15fd4 <SCSIHandleCmd+0x12c>
            break;

        // read (10)
        case SCSI_CMD_READ_10:
            if (iCDBLen != 10)
   15f5c:	e356000a 	cmp	r6, #10	; 0xa
   15f60:	1a00001a 	bne	15fd0 <SCSIHandleCmd+0x128>
            {
                return NULL;
            }
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);
            dwLen = (pbCDB[7] << 8) | pbCDB[8];
            DBG("READ10, LBA=%d, len=%d\n", dwLBA, dwLen);
            *piRspLen = dwLen * BLOCKSIZE;
   15f64:	e5d43008 	ldrb	r3, [r4, #8]
   15f68:	e5d42007 	ldrb	r2, [r4, #7]
   15f6c:	e59f006c 	ldr	r0, [pc, #108]	; 15fe0 <.text+0x5fe0>
   15f70:	e1833402 	orr	r3, r3, r2, lsl #8
   15f74:	e1a03483 	mov	r3, r3, lsl #9
   15f78:	eafffff5 	b	15f54 <SCSIHandleCmd+0xac>
            break;

        // write (10)
        case SCSI_CMD_WRITE_10:
            if (iCDBLen != 10)
   15f7c:	e356000a 	cmp	r6, #10	; 0xa
   15f80:	1a000012 	bne	15fd0 <SCSIHandleCmd+0x128>
            {
                return NULL;
            }
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);
            dwLen = (pbCDB[7] << 8) | pbCDB[8];
            DBG("WRITE10, LBA=%d, len=%d\n", dwLBA, dwLen);
            *piRspLen = dwLen * BLOCKSIZE;
   15f84:	e5d43008 	ldrb	r3, [r4, #8]
   15f88:	e5d42007 	ldrb	r2, [r4, #7]
   15f8c:	e1833402 	orr	r3, r3, r2, lsl #8
   15f90:	e1a03483 	mov	r3, r3, lsl #9
            *pfDevIn = FALSE;
   15f94:	e59f0044 	ldr	r0, [pc, #68]	; 15fe0 <.text+0x5fe0>
   15f98:	e5853000 	str	r3, [r5]
   15f9c:	e3a03000 	mov	r3, #0	; 0x0
   15fa0:	e5873000 	str	r3, [r7]
   15fa4:	ea00000a 	b	15fd4 <SCSIHandleCmd+0x12c>
            break;

        default:
            DBG("Unhandled SCSI: ");
            for (i = 0; i < iCDBLen; i++)
   15fa8:	e2833001 	add	r3, r3, #1	; 0x1
   15fac:	e1530006 	cmp	r3, r6
   15fb0:	bafffffc 	blt	15fa8 <SCSIHandleCmd+0x100>
            {
                DBG(" %02X", pbCDB[i]);
            }
            DBG("\n");
            // unsupported command
            dwSense = INVALID_CMD_OPCODE;
            *piRspLen = 0;
   15fb4:	e3a01000 	mov	r1, #0	; 0x0
   15fb8:	e59f3024 	ldr	r3, [pc, #36]	; 15fe4 <.text+0x5fe4>
   15fbc:	e3a02a52 	mov	r2, #335872	; 0x52000
   15fc0:	e1a00001 	mov	r0, r1
   15fc4:	e5832000 	str	r2, [r3]
   15fc8:	e5851000 	str	r1, [r5]
   15fcc:	ea000000 	b	15fd4 <SCSIHandleCmd+0x12c>
            return NULL;
   15fd0:	e3a00000 	mov	r0, #0	; 0x0
        }


    return abBlockBuf;
}
   15fd4:	e28dd008 	add	sp, sp, #8	; 0x8
   15fd8:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   15fdc:	e12fff1e 	bx	lr
   15fe0:	400015ac 	andmi	r1, r0, ip, lsr #11
   15fe4:	400017ac 	andmi	r1, r0, ip, lsr #15

00015fe8 <SCSIHandleData>:


/*************************************************************************
    SCSIHandleData
    ==============
        Handles a block of SCSI data.

    IN      pbCDB       Command data block
            iCDBLen     Command data block len
    IN/OUT  pbData      Data buffer
    IN      dwOffset    Offset in data

    Returns a pointer to the next data to be exchanged if successful,
    returns NULL otherwise.
**************************************************************************/
U8 * SCSIHandleData(U8 *pbCDB, int iCDBLen, U8 *pbData, U32 dwOffset)
{
   15fe8:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   15fec:	e1a04000 	mov	r4, r0
   15ff0:	e24dd00c 	sub	sp, sp, #12	; 0xc
   15ff4:	e1a05002 	mov	r5, r2
    TCDB6   *pCDB;
    U32     dwLBA;
    U32     dwBufPos, dwBlockNr;
    U32     dwNumBlocks, dwMaxBlock;

	//pCDB = (TCDB6 *)pbCDB;
	//Compiler warning fix
    TCDB6 cdb;
	pCDB = &cdb;
	memcpy(pCDB, pbCDB, sizeof(TCDB6));
   15ff8:	e1a0000d 	mov	r0, sp
   15ffc:	e1a01004 	mov	r1, r4
   16000:	e3a02008 	mov	r2, #8	; 0x8
   16004:	e1a06003 	mov	r6, r3
   16008:	eb000722 	bl	17c98 <memcpy>
	
    switch (pCDB->bOperationCode)
   1600c:	e5dd3000 	ldrb	r3, [sp]
   16010:	e3530012 	cmp	r3, #18	; 0x12
   16014:	0a000022 	beq	160a4 <SCSIHandleData+0xbc>
   16018:	8a000004 	bhi	16030 <SCSIHandleData+0x48>
   1601c:	e3530000 	cmp	r3, #0	; 0x0
   16020:	0a000009 	beq	1604c <SCSIHandleData+0x64>
   16024:	e3530003 	cmp	r3, #3	; 0x3
   16028:	1a000065 	bne	161c4 <SCSIHandleData+0x1dc>
   1602c:	ea00000d 	b	16068 <SCSIHandleData+0x80>
   16030:	e3530028 	cmp	r3, #40	; 0x28
   16034:	0a000034 	beq	1610c <SCSIHandleData+0x124>
   16038:	e353002a 	cmp	r3, #42	; 0x2a
   1603c:	0a000046 	beq	1615c <SCSIHandleData+0x174>
   16040:	e3530025 	cmp	r3, #37	; 0x25
   16044:	1a00005e 	bne	161c4 <SCSIHandleData+0x1dc>
   16048:	ea00001b 	b	160bc <SCSIHandleData+0xd4>
    {

        // test unit ready
        case 0x00:
            if (dwSense != 0)
   1604c:	e59f3190 	ldr	r3, [pc, #400]	; 161e4 <.text+0x61e4>
   16050:	e5932000 	ldr	r2, [r3]
   16054:	e59f318c 	ldr	r3, [pc, #396]	; 161e8 <.text+0x61e8>
   16058:	e3520000 	cmp	r2, #0	; 0x0
   1605c:	01a0e003 	moveq	lr, r3
   16060:	13a0e000 	movne	lr, #0	; 0x0
   16064:	ea00005a 	b	161d4 <SCSIHandleData+0x1ec>
            {
                return NULL;
            }
            break;

        // request sense
        case SCSI_CMD_REQUEST_SENSE:
            memcpy(pbData, abSense, 18);
   16068:	e59f117c 	ldr	r1, [pc, #380]	; 161ec <.text+0x61ec>
   1606c:	e3a02012 	mov	r2, #18	; 0x12
   16070:	e1a00005 	mov	r0, r5
   16074:	eb000707 	bl	17c98 <memcpy>
            // fill in KEY/ASC/ASCQ
            pbData[2] = (dwSense >> 16) & 0xFF;
   16078:	e59f0164 	ldr	r0, [pc, #356]	; 161e4 <.text+0x61e4>
   1607c:	e5903000 	ldr	r3, [r0]
            pbData[12] = (dwSense >> 8) & 0xFF;
            pbData[13] = (dwSense >> 0) & 0xFF;
            // reset sense data
            dwSense = 0;
   16080:	e59fe160 	ldr	lr, [pc, #352]	; 161e8 <.text+0x61e8>
   16084:	e1a02823 	mov	r2, r3, lsr #16
   16088:	e1a01423 	mov	r1, r3, lsr #8
   1608c:	e5c5300d 	strb	r3, [r5, #13]
   16090:	e3a03000 	mov	r3, #0	; 0x0
   16094:	e5c52002 	strb	r2, [r5, #2]
   16098:	e5c5100c 	strb	r1, [r5, #12]
   1609c:	e5803000 	str	r3, [r0]
   160a0:	ea00004b 	b	161d4 <SCSIHandleData+0x1ec>
            break;

        // inquiry
        case SCSI_CMD_INQUIRY:
            memcpy(pbData, abInquiry, sizeof(abInquiry));
   160a4:	e1a00005 	mov	r0, r5
   160a8:	e59f1140 	ldr	r1, [pc, #320]	; 161f0 <.text+0x61f0>
   160ac:	e3a02024 	mov	r2, #36	; 0x24
   160b0:	eb0006f8 	bl	17c98 <memcpy>
   160b4:	e59fe12c 	ldr	lr, [pc, #300]	; 161e8 <.text+0x61e8>
   160b8:	ea000045 	b	161d4 <SCSIHandleData+0x1ec>
            break;

        // read capacity
        case SCSI_CMD_READ_CAPACITY:
        // get size of drive (bytes)
            BlockDevGetSize(&dwNumBlocks);
   160bc:	e28d0008 	add	r0, sp, #8	; 0x8
   160c0:	eb00009c 	bl	16338 <BlockDevGetSize>
            // calculate highest LBA
            dwMaxBlock = (dwNumBlocks - 1) / 512;
   160c4:	e59d3008 	ldr	r3, [sp, #8]
   160c8:	e2433001 	sub	r3, r3, #1	; 0x1
   160cc:	e1a004a3 	mov	r0, r3, lsr #9

            pbData[0] = (dwMaxBlock >> 24) & 0xFF;
            pbData[1] = (dwMaxBlock >> 16) & 0xFF;
            pbData[2] = (dwMaxBlock >> 8) & 0xFF;
   160d0:	e1a0c8a3 	mov	ip, r3, lsr #17
            pbData[3] = (dwMaxBlock >> 0) & 0xFF;
            pbData[4] = (BLOCKSIZE >> 24) & 0xFF;
            pbData[5] = (BLOCKSIZE >> 16) & 0xFF;
            pbData[6] = (BLOCKSIZE >> 8) & 0xFF;
            pbData[7] = (BLOCKSIZE >> 0) & 0xFF;
   160d4:	e59fe10c 	ldr	lr, [pc, #268]	; 161e8 <.text+0x61e8>
   160d8:	e1a03ca3 	mov	r3, r3, lsr #25
   160dc:	e3a02000 	mov	r2, #0	; 0x0
   160e0:	e1a01c20 	mov	r1, r0, lsr #24
   160e4:	e5c53001 	strb	r3, [r5, #1]
   160e8:	e3a03002 	mov	r3, #2	; 0x2
   160ec:	e5c52007 	strb	r2, [r5, #7]
   160f0:	e5c51000 	strb	r1, [r5]
   160f4:	e5c5c002 	strb	ip, [r5, #2]
   160f8:	e5c50003 	strb	r0, [r5, #3]
   160fc:	e5c53006 	strb	r3, [r5, #6]
   16100:	e5c52004 	strb	r2, [r5, #4]
   16104:	e5c52005 	strb	r2, [r5, #5]
   16108:	ea000031 	b	161d4 <SCSIHandleData+0x1ec>
            break;

        // read10
        case SCSI_CMD_READ_10:
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);
   1610c:	e5d43003 	ldrb	r3, [r4, #3]
   16110:	e5d42002 	ldrb	r2, [r4, #2]
   16114:	e1a03803 	mov	r3, r3, lsl #16
   16118:	e5d41004 	ldrb	r1, [r4, #4]

            // copy data from block buffer
            dwBufPos = (dwOffset & (BLOCKSIZE - 1));
   1611c:	e1a05b86 	mov	r5, r6, lsl #23
   16120:	e1833c02 	orr	r3, r3, r2, lsl #24
   16124:	e1a05ba5 	mov	r5, r5, lsr #23
   16128:	e5d42005 	ldrb	r2, [r4, #5]
   1612c:	e1833401 	orr	r3, r3, r1, lsl #8
            if (dwBufPos == 0)
   16130:	e3550000 	cmp	r5, #0	; 0x0
   16134:	e1830002 	orr	r0, r3, r2
   16138:	1a00001e 	bne	161b8 <SCSIHandleData+0x1d0>
            {
                // read new block
                dwBlockNr = dwLBA + (dwOffset / BLOCKSIZE);
                DBG("R");
                if (BlockDevRead(dwBlockNr, abBlockBuf) < 0)
   1613c:	e08004a6 	add	r0, r0, r6, lsr #9
   16140:	e59f10a0 	ldr	r1, [pc, #160]	; 161e8 <.text+0x61e8>
   16144:	eb00014b 	bl	16678 <BlockDevRead>
   16148:	e3500000 	cmp	r0, #0	; 0x0
                {
                    dwSense = READ_ERROR;
   1614c:	b1a0e005 	movlt	lr, r5
   16150:	b59f209c 	ldrlt	r2, [pc, #156]	; 161f4 <.text+0x61f4>
   16154:	ba000014 	blt	161ac <SCSIHandleData+0x1c4>
   16158:	ea000016 	b	161b8 <SCSIHandleData+0x1d0>
                    DBG("BlockDevRead failed\n");
                    return NULL;
                }
            }
            // return pointer to data
            return abBlockBuf + dwBufPos;

            // write10
            case SCSI_CMD_WRITE_10:
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);
   1615c:	e5d43003 	ldrb	r3, [r4, #3]
   16160:	e5d41002 	ldrb	r1, [r4, #2]

            // copy data to block buffer
            dwBufPos = ((dwOffset + 64) & (BLOCKSIZE - 1));
   16164:	e2862040 	add	r2, r6, #64	; 0x40
   16168:	e1a05b82 	mov	r5, r2, lsl #23
   1616c:	e1a03803 	mov	r3, r3, lsl #16
   16170:	e5d42004 	ldrb	r2, [r4, #4]
   16174:	e1833c01 	orr	r3, r3, r1, lsl #24
   16178:	e1a05ba5 	mov	r5, r5, lsr #23
   1617c:	e5d41005 	ldrb	r1, [r4, #5]
   16180:	e1833402 	orr	r3, r3, r2, lsl #8
            if (dwBufPos == 0)
   16184:	e3550000 	cmp	r5, #0	; 0x0
   16188:	e1830001 	orr	r0, r3, r1
   1618c:	1a000009 	bne	161b8 <SCSIHandleData+0x1d0>
            {
                // write new block
                dwBlockNr = dwLBA + (dwOffset / BLOCKSIZE);
                DBG("W");
                if (BlockDevWrite(dwBlockNr, abBlockBuf) < 0)
   16190:	e08004a6 	add	r0, r0, r6, lsr #9
   16194:	e59f104c 	ldr	r1, [pc, #76]	; 161e8 <.text+0x61e8>
   16198:	eb00011d 	bl	16614 <BlockDevWrite>
   1619c:	e3500000 	cmp	r0, #0	; 0x0
   161a0:	aa000004 	bge	161b8 <SCSIHandleData+0x1d0>
                {
                    dwSense = WRITE_ERROR;
   161a4:	e1a0e005 	mov	lr, r5
   161a8:	e3a02bc3 	mov	r2, #199680	; 0x30c00
   161ac:	e59f3030 	ldr	r3, [pc, #48]	; 161e4 <.text+0x61e4>
   161b0:	e5832000 	str	r2, [r3]
   161b4:	ea000006 	b	161d4 <SCSIHandleData+0x1ec>
                    DBG("BlockDevWrite failed\n");
                    return NULL;
                }
            }
            // return pointer to next data
            return abBlockBuf + dwBufPos;
   161b8:	e59f3028 	ldr	r3, [pc, #40]	; 161e8 <.text+0x61e8>
   161bc:	e085e003 	add	lr, r5, r3
   161c0:	ea000003 	b	161d4 <SCSIHandleData+0x1ec>

            default:
            // unsupported command
            dwSense = INVALID_CMD_OPCODE;
   161c4:	e59f3018 	ldr	r3, [pc, #24]	; 161e4 <.text+0x61e4>
   161c8:	e3a02a52 	mov	r2, #335872	; 0x52000
   161cc:	e5832000 	str	r2, [r3]
   161d0:	e3a0e000 	mov	lr, #0	; 0x0
            return NULL;
        }

    // default: return pointer to start of block buffer
    return abBlockBuf;
}
   161d4:	e1a0000e 	mov	r0, lr
   161d8:	e28dd00c 	add	sp, sp, #12	; 0xc
   161dc:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   161e0:	e12fff1e 	bx	lr
   161e4:	400017ac 	andmi	r1, r0, ip, lsr #15
   161e8:	400015ac 	andmi	r1, r0, ip, lsr #11
   161ec:	00018c40 	andeq	r8, r1, r0, asr #24
   161f0:	00018c1c 	andeq	r8, r1, ip, lsl ip
   161f4:	00031100 	andeq	r1, r3, r0, lsl #2

000161f8 <Command>:
#define CMD_WRITE           24
#define CMD_WRITE_MULTIPLE  25

static void Command(U8 cmd, U32 param)
{
   161f8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   161fc:	e1a03001 	mov	r3, r1
   16200:	e24dd008 	sub	sp, sp, #8	; 0x8
    U8  abCmd[8];

    // create buffer
    abCmd[0] = 0xff;
    abCmd[1] = 0x40 | cmd;
   16204:	e3804040 	orr	r4, r0, #64	; 0x40
   16208:	e3e05000 	mvn	r5, #0	; 0x0
    abCmd[2] = (U8)(param >> 24);
   1620c:	e1a02c21 	mov	r2, r1, lsr #24
    abCmd[3] = (U8)(param >> 16);
   16210:	e1a0c821 	mov	ip, r1, lsr #16
    abCmd[4] = (U8)(param >> 8);
   16214:	e1a0e421 	mov	lr, r1, lsr #8
    abCmd[5] = (U8)(param);
   16218:	e5cd3005 	strb	r3, [sp, #5]
    abCmd[6] = 0x95;            /* Checksum (should be only valid for first command (0) */
    abCmd[7] = 0xff;            /* eat empty command - response */

    SPISendN(abCmd, 8);
   1621c:	e1a0000d 	mov	r0, sp
   16220:	e3e0306a 	mvn	r3, #106	; 0x6a
   16224:	e3a01008 	mov	r1, #8	; 0x8
   16228:	e5cd4001 	strb	r4, [sp, #1]
   1622c:	e5cd2002 	strb	r2, [sp, #2]
   16230:	e5cdc003 	strb	ip, [sp, #3]
   16234:	e5cde004 	strb	lr, [sp, #4]
   16238:	e5cd3006 	strb	r3, [sp, #6]
   1623c:	e5cd5007 	strb	r5, [sp, #7]
   16240:	e5cd5000 	strb	r5, [sp]
   16244:	eb00014d 	bl	16780 <SPISendN>
}
   16248:	e28dd008 	add	sp, sp, #8	; 0x8
   1624c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   16250:	e12fff1e 	bx	lr

00016254 <Resp8b>:

/*****************************************************************************/

static U8 Resp8b(void)
{
   16254:	e92d4010 	stmdb	sp!, {r4, lr}
   16258:	e3a04008 	mov	r4, #8	; 0x8
    U8 i;
    U8 resp;

    /* Respone will come after 1 - 8 pings */
    for (i = 0; i < 8; i++)
    {
        resp = SPISend(0xff);
   1625c:	e3a000ff 	mov	r0, #255	; 0xff
   16260:	eb000130 	bl	16728 <SPISend>
        if (resp != 0xff)
   16264:	e35000ff 	cmp	r0, #255	; 0xff
        {
            return resp;
   16268:	e2443001 	sub	r3, r4, #1	; 0x1
   1626c:	1a000001 	bne	16278 <Resp8b+0x24>
   16270:	e21340ff 	ands	r4, r3, #255	; 0xff
   16274:	1afffff8 	bne	1625c <Resp8b+0x8>
        }
    }

    return resp;
}
   16278:	e8bd4010 	ldmia	sp!, {r4, lr}
   1627c:	e12fff1e 	bx	lr

00016280 <Resp8bError>:

/*****************************************************************************/

static void Resp8bError(U8 value)
{
   16280:	e20010ff 	and	r1, r0, #255	; 0xff
    switch (value)
   16284:	e3510008 	cmp	r1, #8	; 0x8
   16288:	e52de004 	str	lr, [sp, #-4]!
   1628c:	0a000015 	beq	162e8 <Resp8bError+0x68>
   16290:	8a000006 	bhi	162b0 <Resp8bError+0x30>
   16294:	e3510002 	cmp	r1, #2	; 0x2
   16298:	0a000016 	beq	162f8 <Resp8bError+0x78>
   1629c:	e3510004 	cmp	r1, #4	; 0x4
   162a0:	0a000012 	beq	162f0 <Resp8bError+0x70>
   162a4:	e3510001 	cmp	r1, #1	; 0x1
   162a8:	1a000016 	bne	16308 <Resp8bError+0x88>
   162ac:	ea000013 	b	16300 <Resp8bError+0x80>
   162b0:	e3510020 	cmp	r1, #32	; 0x20
   162b4:	0a000006 	beq	162d4 <Resp8bError+0x54>
   162b8:	e3510040 	cmp	r1, #64	; 0x40
   162bc:	0a000002 	beq	162cc <Resp8bError+0x4c>
   162c0:	e3510010 	cmp	r1, #16	; 0x10
   162c4:	1a00000f 	bne	16308 <Resp8bError+0x88>
   162c8:	ea000004 	b	162e0 <Resp8bError+0x60>
    {
        case 0x40:  rprintf("Argument out of bounds.\n");               break;
   162cc:	e59f0044 	ldr	r0, [pc, #68]	; 16318 <.text+0x6318>
   162d0:	ea000000 	b	162d8 <Resp8bError+0x58>
        case 0x20:  rprintf("Address out of bounds.\n");                break;
   162d4:	e59f0040 	ldr	r0, [pc, #64]	; 1631c <.text+0x631c>
   162d8:	ebffedde 	bl	11a58 <rprintf>
   162dc:	ea00000b 	b	16310 <Resp8bError+0x90>
        case 0x10:  rprintf("Error during erase sequence.\n");          break;
   162e0:	e59f0038 	ldr	r0, [pc, #56]	; 16320 <.text+0x6320>
   162e4:	eafffffb 	b	162d8 <Resp8bError+0x58>
        case 0x08:  rprintf("CRC failed.\n");                           break;
   162e8:	e59f0034 	ldr	r0, [pc, #52]	; 16324 <.text+0x6324>
   162ec:	eafffff9 	b	162d8 <Resp8bError+0x58>
        case 0x04:  rprintf("Illegal command.\n");                      break;
   162f0:	e59f0030 	ldr	r0, [pc, #48]	; 16328 <.text+0x6328>
   162f4:	eafffff7 	b	162d8 <Resp8bError+0x58>
        case 0x02:  rprintf("Erase reset (see SanDisk docs p5-13).\n"); break;
   162f8:	e59f002c 	ldr	r0, [pc, #44]	; 1632c <.text+0x632c>
   162fc:	eafffff5 	b	162d8 <Resp8bError+0x58>
//        case 0x01:  rprintf("Card is initialising.\n");                 break;
        case 0x01:  rprintf(".");                 break;
   16300:	e59f0028 	ldr	r0, [pc, #40]	; 16330 <.text+0x6330>
   16304:	eafffff3 	b	162d8 <Resp8bError+0x58>
            default:
            rprintf("Unknown error 0x%x (see SanDisk docs p5-13).\n", value);
   16308:	e59f0024 	ldr	r0, [pc, #36]	; 16334 <.text+0x6334>
   1630c:	ebffedd1 	bl	11a58 <rprintf>
            break;
    }
}
   16310:	e49de004 	ldr	lr, [sp], #4
   16314:	e12fff1e 	bx	lr
   16318:	00018e68 	andeq	r8, r1, r8, ror #28
   1631c:	00018e84 	andeq	r8, r1, r4, lsl #29
   16320:	00018e9c 	muleq	r1, ip, lr
   16324:	00018ebc 	streqh	r8, [r1], -ip
   16328:	00018ecc 	andeq	r8, r1, ip, asr #29
   1632c:	00018ee0 	andeq	r8, r1, r0, ror #29
   16330:	00018f08 	andeq	r8, r1, r8, lsl #30
   16334:	00018f0c 	andeq	r8, r1, ip, lsl #30

00016338 <BlockDevGetSize>:


/* ****************************************************************************
 calculates size of card from CSD
 (extension by Martin Thomas, inspired by code from Holger Klabunde)
 */
int BlockDevGetSize(U32 *pdwDriveSize)
{
   16338:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    U8 cardresp, i, by;
    U8 iob[16];
    U16 c_size, c_size_mult, read_bl_len;

    Command(CMD_READCSD, 0);
   1633c:	e3a01000 	mov	r1, #0	; 0x0
   16340:	e1a05000 	mov	r5, r0
   16344:	e24dd010 	sub	sp, sp, #16	; 0x10
   16348:	e3a00009 	mov	r0, #9	; 0x9
   1634c:	ebffffa9 	bl	161f8 <Command>
    do
    {
        cardresp = Resp8b();
   16350:	ebffffbf 	bl	16254 <Resp8b>
    }
    while (cardresp != 0xFE);
   16354:	e35000fe 	cmp	r0, #254	; 0xfe
   16358:	1afffffc 	bne	16350 <BlockDevGetSize+0x18>

    rprintf("CSD:");
   1635c:	e59f00bc 	ldr	r0, [pc, #188]	; 16420 <.text+0x6420>
   16360:	ebffedbc 	bl	11a58 <rprintf>
   16364:	e3a04000 	mov	r4, #0	; 0x0
    for (i = 0; i < 16; i++)
    {
        iob[i] = SPISend(0xFF);
   16368:	e3a000ff 	mov	r0, #255	; 0xff
   1636c:	eb0000ed 	bl	16728 <SPISend>
   16370:	e1a0300d 	mov	r3, sp
   16374:	e7c40003 	strb	r0, [r4, r3]
   16378:	e1a01000 	mov	r1, r0
        rprintf(" %02x", iob[i]);
   1637c:	e2844001 	add	r4, r4, #1	; 0x1
   16380:	e59f009c 	ldr	r0, [pc, #156]	; 16424 <.text+0x6424>
   16384:	ebffedb3 	bl	11a58 <rprintf>
   16388:	e3540010 	cmp	r4, #16	; 0x10
   1638c:	1afffff5 	bne	16368 <BlockDevGetSize+0x30>
    }
    rprintf("\n");
   16390:	e59f0090 	ldr	r0, [pc, #144]	; 16428 <.text+0x6428>
   16394:	ebffedaf 	bl	11a58 <rprintf>

    SPISend(0xff);
   16398:	e3a000ff 	mov	r0, #255	; 0xff
   1639c:	eb0000e1 	bl	16728 <SPISend>
    SPISend(0xff);
   163a0:	e3a000ff 	mov	r0, #255	; 0xff
   163a4:	eb0000df 	bl	16728 <SPISend>

    c_size = iob[6] & 0x03;     // bits 1..0
    c_size <<= 10;
    c_size += (U16) iob[7] << 2;
    c_size += iob[8] >> 6;

    by = iob[5] & 0x0F;
    read_bl_len = 1 << by;

    by = iob[9] & 0x03;
   163a8:	e5dd3009 	ldrb	r3, [sp, #9]
    by <<= 1;
    by += iob[10] >> 7;

    c_size_mult = 1 << (2 + by);

    *pdwDriveSize = (U32) (c_size + 1) * (U32) c_size_mult *(U32) read_bl_len;
   163ac:	e5dd200a 	ldrb	r2, [sp, #10]
   163b0:	e2033003 	and	r3, r3, #3	; 0x3
   163b4:	e1a023a2 	mov	r2, r2, lsr #7
   163b8:	e0822083 	add	r2, r2, r3, lsl #1
   163bc:	e3a00001 	mov	r0, #1	; 0x1
   163c0:	e2822002 	add	r2, r2, #2	; 0x2
   163c4:	e1a02210 	mov	r2, r0, lsl r2
   163c8:	e5dd3005 	ldrb	r3, [sp, #5]
   163cc:	e203300f 	and	r3, r3, #15	; 0xf
   163d0:	e1a00310 	mov	r0, r0, lsl r3
   163d4:	e5dd1006 	ldrb	r1, [sp, #6]
   163d8:	e5dd3007 	ldrb	r3, [sp, #7]
   163dc:	e5ddc008 	ldrb	ip, [sp, #8]
   163e0:	e2011003 	and	r1, r1, #3	; 0x3
   163e4:	e1a03103 	mov	r3, r3, lsl #2
   163e8:	e0833501 	add	r3, r3, r1, lsl #10
   163ec:	e083332c 	add	r3, r3, ip, lsr #6
   163f0:	e1a02802 	mov	r2, r2, lsl #16
   163f4:	e1a02822 	mov	r2, r2, lsr #16
   163f8:	e2833001 	add	r3, r3, #1	; 0x1
   163fc:	e0030392 	mul	r3, r2, r3
   16400:	e1a00800 	mov	r0, r0, lsl #16
   16404:	e1a00820 	mov	r0, r0, lsr #16
   16408:	e0030390 	mul	r3, r0, r3

    return 0;
}
   1640c:	e3a00000 	mov	r0, #0	; 0x0
   16410:	e5853000 	str	r3, [r5]
   16414:	e28dd010 	add	sp, sp, #16	; 0x10
   16418:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   1641c:	e12fff1e 	bx	lr
   16420:	00018f3c 	andeq	r8, r1, ip, lsr pc
   16424:	00018f44 	andeq	r8, r1, r4, asr #30
   16428:	00018f38 	andeq	r8, r1, r8, lsr pc

0001642c <BlockDevInit>:

/*****************************************************************************/

static U16 Resp16b(void)
{
    U16 resp;

    resp = (Resp8b() << 8) & 0xff00;
    resp |= SPISend(0xff);

    return resp;
}

/*****************************************************************************/

static int State(void)
{
    U16 value;

    Command(CMD_SENDSTATUS, 0);
    value = Resp16b();

    switch (value)
    {
        case 0x0000: return 1;
        case 0x0001: rprintf("Card is Locked.\n");                                                  break;
        case 0x0002: rprintf("WP Erase Skip, Lock/Unlock Cmd Failed.\n");                           break;
        case 0x0004: rprintf("General / Unknown error -- card broken?.\n");                         break;
        case 0x0008: rprintf("Internal card controller error.\n");                                  break;
        case 0x0010: rprintf("Card internal ECC was applied, but failed to correct the data.\n");   break;
        case 0x0020: rprintf("Write protect violation.\n");                                         break;
        case 0x0040: rprintf("An invalid selection, sectors for erase.\n");                         break;
        case 0x0080: rprintf("Out of Range, CSD_Overwrite.\n");                                     break;
            default:
            if (value > 0x00FF)
            {
                Resp8bError((U8) (value >> 8));
            }
            else
            {
                rprintf("Unknown error: 0x%x (see SanDisk docs p5-14).\n", value);
            }
            break;
    }
    return -1;
}

/*****************************************************************************/


int BlockDevInit(void)
{
   1642c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    int i;
    U8 resp;

    SPIInit();              /* init at low speed */
   16430:	eb000107 	bl	16854 <SPIInit>
   16434:	e3a04064 	mov	r4, #100	; 0x64

    /* Try to send reset command up to 100 times */
    i = 100;
    do
    {
        Command(CMD_GOIDLESTATE, 0);
   16438:	e3a00000 	mov	r0, #0	; 0x0
   1643c:	e1a01000 	mov	r1, r0
   16440:	ebffff6c 	bl	161f8 <Command>
        resp = Resp8b();
   16444:	ebffff82 	bl	16254 <Resp8b>
    }
    while (resp != 1 && i--);
   16448:	e3500001 	cmp	r0, #1	; 0x1
   1644c:	e2444001 	sub	r4, r4, #1	; 0x1
   16450:	0a00000a 	beq	16480 <BlockDevInit+0x54>
   16454:	e3740001 	cmn	r4, #1	; 0x1
   16458:	1afffff6 	bne	16438 <BlockDevInit+0xc>

    if (resp != 1)
    {
        if (resp == 0xff)
   1645c:	e35000ff 	cmp	r0, #255	; 0xff
   16460:	1a000003 	bne	16474 <BlockDevInit+0x48>
        {
            rprintf("resp=0xff\n");
   16464:	e59f0174 	ldr	r0, [pc, #372]	; 165e0 <.text+0x65e0>
   16468:	ebffed7a 	bl	11a58 <rprintf>
   1646c:	e1a00004 	mov	r0, r4
   16470:	ea000058 	b	165d8 <BlockDevInit+0x1ac>
            return -1;
        }
        else
        {
            Resp8bError(resp);
   16474:	ebffff81 	bl	16280 <Resp8bError>
            rprintf("resp!=0xff\n");
   16478:	e59f0164 	ldr	r0, [pc, #356]	; 165e4 <.text+0x65e4>
   1647c:	ea000053 	b	165d0 <BlockDevInit+0x1a4>
            return -2;
   16480:	e3a04c7d 	mov	r4, #32000	; 0x7d00
        }
    }

    /* Wait till card is ready initialising (returns 0 on CMD_1) */
    /* Try up to 32000 times. */
    i = 32000;
    do
    {
        Command(CMD_SENDOPCOND, 0);
   16484:	e3a01000 	mov	r1, #0	; 0x0
   16488:	e3a00001 	mov	r0, #1	; 0x1
   1648c:	ebffff59 	bl	161f8 <Command>

        resp = Resp8b();
   16490:	ebffff6f 	bl	16254 <Resp8b>
        if (resp != 0)
   16494:	e2505000 	subs	r5, r0, #0	; 0x0
        {
            Resp8bError(resp);
        }
    }
    while (resp == 1 && i--);
   16498:	e2444001 	sub	r4, r4, #1	; 0x1
   1649c:	1bffff77 	blne	16280 <Resp8bError>
   164a0:	e3550001 	cmp	r5, #1	; 0x1
   164a4:	1a000002 	bne	164b4 <BlockDevInit+0x88>
   164a8:	e3740001 	cmn	r4, #1	; 0x1
   164ac:	0a000002 	beq	164bc <BlockDevInit+0x90>
   164b0:	eafffff3 	b	16484 <BlockDevInit+0x58>

    if (resp != 0)
   164b4:	e3550000 	cmp	r5, #0	; 0x0
   164b8:	0a000003 	beq	164cc <BlockDevInit+0xa0>
    {
        Resp8bError(resp);
   164bc:	e1a00005 	mov	r0, r5
   164c0:	ebffff6e 	bl	16280 <Resp8bError>
   164c4:	e3e00002 	mvn	r0, #2	; 0x2
   164c8:	ea000042 	b	165d8 <BlockDevInit+0x1ac>
        return -3;
    }

    /* increase speed after init */
    SPISetSpeed(SPI_PRESCALE_MIN);
   164cc:	e3a00008 	mov	r0, #8	; 0x8
   164d0:	eb00008d 	bl	1670c <SPISetSpeed>
   164d4:	e1a01005 	mov	r1, r5
   164d8:	e3a0000d 	mov	r0, #13	; 0xd
   164dc:	ebffff45 	bl	161f8 <Command>
   164e0:	ebffff5b 	bl	16254 <Resp8b>
   164e4:	e1a04c00 	mov	r4, r0, lsl #24
   164e8:	e3a000ff 	mov	r0, #255	; 0xff
   164ec:	eb00008d 	bl	16728 <SPISend>
   164f0:	e1a04824 	mov	r4, r4, lsr #16
   164f4:	e1844000 	orr	r4, r4, r0
   164f8:	e1a04804 	mov	r4, r4, lsl #16
   164fc:	e1a01824 	mov	r1, r4, lsr #16
   16500:	e3510008 	cmp	r1, #8	; 0x8
   16504:	0a00001a 	beq	16574 <BlockDevInit+0x148>
   16508:	8a000007 	bhi	1652c <BlockDevInit+0x100>
   1650c:	e3510001 	cmp	r1, #1	; 0x1
   16510:	0a000010 	beq	16558 <BlockDevInit+0x12c>
   16514:	3a000028 	bcc	165bc <BlockDevInit+0x190>
   16518:	e3510002 	cmp	r1, #2	; 0x2
   1651c:	0a00000f 	beq	16560 <BlockDevInit+0x134>
   16520:	e3510004 	cmp	r1, #4	; 0x4
   16524:	1a00001c 	bne	1659c <BlockDevInit+0x170>
   16528:	ea00000f 	b	1656c <BlockDevInit+0x140>
   1652c:	e3510020 	cmp	r1, #32	; 0x20
   16530:	0a000013 	beq	16584 <BlockDevInit+0x158>
   16534:	8a000002 	bhi	16544 <BlockDevInit+0x118>
   16538:	e3510010 	cmp	r1, #16	; 0x10
   1653c:	1a000016 	bne	1659c <BlockDevInit+0x170>
   16540:	ea00000d 	b	1657c <BlockDevInit+0x150>
   16544:	e3510040 	cmp	r1, #64	; 0x40
   16548:	0a00000f 	beq	1658c <BlockDevInit+0x160>
   1654c:	e3510080 	cmp	r1, #128	; 0x80
   16550:	1a000011 	bne	1659c <BlockDevInit+0x170>
   16554:	ea00000e 	b	16594 <BlockDevInit+0x168>
   16558:	e59f0088 	ldr	r0, [pc, #136]	; 165e8 <.text+0x65e8>
   1655c:	ea000000 	b	16564 <BlockDevInit+0x138>
   16560:	e59f0084 	ldr	r0, [pc, #132]	; 165ec <.text+0x65ec>
   16564:	ebffed3b 	bl	11a58 <rprintf>
   16568:	ea000017 	b	165cc <BlockDevInit+0x1a0>
   1656c:	e59f007c 	ldr	r0, [pc, #124]	; 165f0 <.text+0x65f0>
   16570:	eafffffb 	b	16564 <BlockDevInit+0x138>
   16574:	e59f0078 	ldr	r0, [pc, #120]	; 165f4 <.text+0x65f4>
   16578:	eafffff9 	b	16564 <BlockDevInit+0x138>
   1657c:	e59f0074 	ldr	r0, [pc, #116]	; 165f8 <.text+0x65f8>
   16580:	eafffff7 	b	16564 <BlockDevInit+0x138>
   16584:	e59f0070 	ldr	r0, [pc, #112]	; 165fc <.text+0x65fc>
   16588:	eafffff5 	b	16564 <BlockDevInit+0x138>
   1658c:	e59f006c 	ldr	r0, [pc, #108]	; 16600 <.text+0x6600>
   16590:	eafffff3 	b	16564 <BlockDevInit+0x138>
   16594:	e59f0068 	ldr	r0, [pc, #104]	; 16604 <.text+0x6604>
   16598:	eafffff1 	b	16564 <BlockDevInit+0x138>
   1659c:	e35100ff 	cmp	r1, #255	; 0xff
   165a0:	9a000002 	bls	165b0 <BlockDevInit+0x184>
   165a4:	e1a00421 	mov	r0, r1, lsr #8
   165a8:	ebffff34 	bl	16280 <Resp8bError>
   165ac:	ea000006 	b	165cc <BlockDevInit+0x1a0>
   165b0:	e59f0050 	ldr	r0, [pc, #80]	; 16608 <.text+0x6608>
   165b4:	ebffed27 	bl	11a58 <rprintf>
   165b8:	ea000003 	b	165cc <BlockDevInit+0x1a0>

    if (State() < 0)
    {
        rprintf("Card didn't return the ready state, breaking up...\n");
        return -2;
    }

    rprintf("SD Init done...\n");
   165bc:	e59f0048 	ldr	r0, [pc, #72]	; 1660c <.text+0x660c>
   165c0:	ebffed24 	bl	11a58 <rprintf>
   165c4:	e1a00005 	mov	r0, r5
   165c8:	ea000002 	b	165d8 <BlockDevInit+0x1ac>
   165cc:	e59f003c 	ldr	r0, [pc, #60]	; 16610 <.text+0x6610>
   165d0:	ebffed20 	bl	11a58 <rprintf>
   165d4:	e3e00001 	mvn	r0, #1	; 0x1

    return 0;
}
   165d8:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   165dc:	e12fff1e 	bx	lr
   165e0:	00018f4c 	andeq	r8, r1, ip, asr #30
   165e4:	00018f58 	andeq	r8, r1, r8, asr pc
   165e8:	00018f64 	andeq	r8, r1, r4, ror #30
   165ec:	00018f78 	andeq	r8, r1, r8, ror pc
   165f0:	00018fa0 	andeq	r8, r1, r0, lsr #31
   165f4:	00018fcc 	andeq	r8, r1, ip, asr #31
   165f8:	00018ff0 	streqd	r8, [r1], -r0
   165fc:	00019030 	andeq	r9, r1, r0, lsr r0
   16600:	0001904c 	andeq	r9, r1, ip, asr #32
   16604:	00019078 	andeq	r9, r1, r8, ror r0
   16608:	00019098 	muleq	r1, r8, r0
   1660c:	000190c8 	andeq	r9, r1, r8, asr #1
   16610:	000190dc 	ldreqd	r9, [r1], -ip

00016614 <BlockDevWrite>:

/*****************************************************************************/



/*****************************************************************************/


/*****************************************************************************/

/* ****************************************************************************
 * WAIT ?? -- FIXME
 * CMD_WRITE
 * WAIT
 * CARD RESP
 * WAIT
 * DATA BLOCK OUT
 *      START BLOCK
 *      DATA
 *      CHKS (2B)
 * BUSY...
 */

int BlockDevWrite(U32 dwAddress, U8 * pbBuf)
{
    U32 place;
    U16 t = 0;

    place = 512 * dwAddress;
    Command(CMD_WRITE, place);
   16614:	e1a00480 	mov	r0, r0, lsl #9
   16618:	e92d4010 	stmdb	sp!, {r4, lr}
   1661c:	e1a04001 	mov	r4, r1
   16620:	e1a01000 	mov	r1, r0
   16624:	e3a00018 	mov	r0, #24	; 0x18
   16628:	ebfffef2 	bl	161f8 <Command>

    Resp8b();               /* Card response */
   1662c:	ebffff08 	bl	16254 <Resp8b>

    SPISend(0xfe);          /* Start block */
   16630:	e3a000fe 	mov	r0, #254	; 0xfe
   16634:	eb00003b 	bl	16728 <SPISend>
    SPISendN(pbBuf, 512);
   16638:	e3a01c02 	mov	r1, #512	; 0x200
   1663c:	e1a00004 	mov	r0, r4
   16640:	eb00004e 	bl	16780 <SPISendN>
    SPISend(0xff);          /* Checksum part 1 */
   16644:	e3a000ff 	mov	r0, #255	; 0xff
   16648:	eb000036 	bl	16728 <SPISend>
    SPISend(0xff);          /* Checksum part 2 */
   1664c:	e3a000ff 	mov	r0, #255	; 0xff
   16650:	eb000034 	bl	16728 <SPISend>

    SPISend(0xff);
   16654:	e3a000ff 	mov	r0, #255	; 0xff
   16658:	eb000032 	bl	16728 <SPISend>

    while (SPISend(0xff) != 0xff)
   1665c:	e3a000ff 	mov	r0, #255	; 0xff
   16660:	eb000030 	bl	16728 <SPISend>
   16664:	e35000ff 	cmp	r0, #255	; 0xff
   16668:	1afffffb 	bne	1665c <BlockDevWrite+0x48>
    {
        t++;
    }

    return 0;
}
   1666c:	e3a00000 	mov	r0, #0	; 0x0
   16670:	e8bd4010 	ldmia	sp!, {r4, lr}
   16674:	e12fff1e 	bx	lr

00016678 <BlockDevRead>:

/*****************************************************************************/

/* ****************************************************************************
 * WAIT ?? -- FIXME
 * CMD_CMD_
 * WAIT
 * CARD RESP
 * WAIT
 * DATA BLOCK IN
 *      START BLOCK
 *      DATA
 *      CHKS (2B)
 */

int BlockDevRead(U32 dwAddress, U8 * pbBuf)
{
    U8 cardresp;
    U8 firstblock;
    U16 fb_timeout = 0xffff;
    U32 place;

    place = 512 * dwAddress;
    Command(CMD_READSINGLEBLOCK, place);
   16678:	e1a00480 	mov	r0, r0, lsl #9
   1667c:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   16680:	e1a06001 	mov	r6, r1
   16684:	e1a01000 	mov	r1, r0
   16688:	e3a00011 	mov	r0, #17	; 0x11
   1668c:	ebfffed9 	bl	161f8 <Command>

    cardresp = Resp8b();        /* Card response */
   16690:	ebfffeef 	bl	16254 <Resp8b>
   16694:	e59f506c 	ldr	r5, [pc, #108]	; 16708 <.text+0x6708>
   16698:	e1a04000 	mov	r4, r0

    /* Wait for startblock */
    do
    {
        firstblock = Resp8b();
   1669c:	ebfffeec 	bl	16254 <Resp8b>
    }
    while (firstblock == 0xff && fb_timeout--);
   166a0:	e2453001 	sub	r3, r5, #1	; 0x1
   166a4:	e1a03803 	mov	r3, r3, lsl #16
   166a8:	e35000ff 	cmp	r0, #255	; 0xff
   166ac:	e1a02000 	mov	r2, r0
   166b0:	e1a05823 	mov	r5, r3, lsr #16
   166b4:	1a000001 	bne	166c0 <BlockDevRead+0x48>
   166b8:	e3730801 	cmn	r3, #65536	; 0x10000
   166bc:	1afffff6 	bne	1669c <BlockDevRead+0x24>

    if (cardresp != 0x00 || firstblock != 0xfe)
   166c0:	e35200fe 	cmp	r2, #254	; 0xfe
   166c4:	03540000 	cmpeq	r4, #0	; 0x0
   166c8:	03a04000 	moveq	r4, #0	; 0x0
   166cc:	13a04001 	movne	r4, #1	; 0x1
   166d0:	0a000002 	beq	166e0 <BlockDevRead+0x68>
    {
        Resp8bError(firstblock);
   166d4:	ebfffee9 	bl	16280 <Resp8bError>
   166d8:	e3e00000 	mvn	r0, #0	; 0x0
   166dc:	ea000007 	b	16700 <BlockDevRead+0x88>
        return -1;
    }

    SPIRecvN(pbBuf, 512);
   166e0:	e3a01c02 	mov	r1, #512	; 0x200
   166e4:	e1a00006 	mov	r0, r6
   166e8:	eb00003d 	bl	167e4 <SPIRecvN>

    /* Checksum (2 byte) - ignore for now */
    SPISend(0xff);
   166ec:	e3a000ff 	mov	r0, #255	; 0xff
   166f0:	eb00000c 	bl	16728 <SPISend>
    SPISend(0xff);
   166f4:	e3a000ff 	mov	r0, #255	; 0xff
   166f8:	eb00000a 	bl	16728 <SPISend>
   166fc:	e1a00004 	mov	r0, r4

    return 0;
}
   16700:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   16704:	e12fff1e 	bx	lr
   16708:	0000ffff 	streqd	pc, [r0], -pc

0001670c <SPISetSpeed>:
/*****************************************************************************/

void SPISetSpeed(U8 speed)
{
    speed &= 0xFE;
   1670c:	e20000fe 	and	r0, r0, #254	; 0xfe
    if (speed < SPI_PRESCALE_MIN)
   16710:	e3500007 	cmp	r0, #7	; 0x7
    {
        speed = SPI_PRESCALE_MIN;
    }
    SPI_PRESCALE_REG = speed;
   16714:	e59f3008 	ldr	r3, [pc, #8]	; 16724 <.text+0x6724>
   16718:	93a00008 	movls	r0, #8	; 0x8
   1671c:	e5c30000 	strb	r0, [r3]
}
   16720:	e12fff1e 	bx	lr
   16724:	e002000c 	and	r0, r2, ip

00016728 <SPISend>:


void SPIInit(void)
{
    U8 i;
    //U32 j;

    rprintf("spiInit for SPI(0)\n");

    // setup GPIO
    PINSEL2 = 0;

	SPI_IODIR |= (1 << SPI_SCK_PIN) | (1 << SPI_MOSI_PIN);
    IODIR0 |= (1 << SPI_SS_PIN);			//Changed to Port0 for MP3 Player
    SPI_IODIR &= ~(1 << SPI_MISO_PIN);

    // reset Pin-Functions
    SPI_PINSEL &= ~((3 << SPI_SCK_FUNCBIT) | (3 << SPI_MISO_FUNCBIT) | (3 << SPI_MOSI_FUNCBIT));
    SPI_PINSEL |= ((1 << SPI_SCK_FUNCBIT) | (1 << SPI_MISO_FUNCBIT) | (1 << SPI_MOSI_FUNCBIT));

    /*        PINSEL0 &= ~(3 << (SPI_SS_FUNCBIT));*/
    /*        PINSEL0 |= (0 << (SPI_SS_FUNCBIT));*/

    // set Chip-Select high - unselect card
    UNSELECT_CARD();

    // enable SPI-Master
    S0SPCR = (1 << MSTR) | (0 << CPOL);   // TODO: check CPOL

    // low speed during init
    SPISetSpeed(254);

    /* Send 20 spi commands with card not selected */
    for (i = 0; i < 21; i++)
    {
        my_SPISend(0xff);
    }
}

/*****************************************************************************/

/*****************************************************************************/

U8 SPISend(U8 outgoing)
{
    U8 incoming;

    SELECT_CARD();
   16728:	e59f2040 	ldr	r2, [pc, #64]	; 16770 <.text+0x6770>
   1672c:	e5923000 	ldr	r3, [r2]
   16730:	e3833080 	orr	r3, r3, #128	; 0x80
   16734:	e5823000 	str	r3, [r2]
    S0SPDR = outgoing;
   16738:	e59f3034 	ldr	r3, [pc, #52]	; 16774 <.text+0x6774>
   1673c:	e20000ff 	and	r0, r0, #255	; 0xff
   16740:	e5c30000 	strb	r0, [r3]
    while (!(S0SPSR & (1 << SPIF)));
   16744:	e59f302c 	ldr	r3, [pc, #44]	; 16778 <.text+0x6778>
   16748:	e5d33000 	ldrb	r3, [r3]
   1674c:	e3130080 	tst	r3, #128	; 0x80
   16750:	0afffffb 	beq	16744 <SPISend+0x1c>
    incoming = S0SPDR;
    UNSELECT_CARD();
   16754:	e59f2020 	ldr	r2, [pc, #32]	; 1677c <.text+0x677c>
   16758:	e59f3014 	ldr	r3, [pc, #20]	; 16774 <.text+0x6774>
   1675c:	e5d30000 	ldrb	r0, [r3]
   16760:	e5923000 	ldr	r3, [r2]
   16764:	e3833080 	orr	r3, r3, #128	; 0x80
   16768:	e5823000 	str	r3, [r2]

    return incoming;
}
   1676c:	e12fff1e 	bx	lr
   16770:	e002800c 	and	r8, r2, ip
   16774:	e0020008 	and	r0, r2, r8
   16778:	e0020004 	and	r0, r2, r4
   1677c:	e0028004 	and	r8, r2, r4

00016780 <SPISendN>:

void SPISendN(U8 * pbBuf, int iLen)
{
    int i;

    SELECT_CARD();
   16780:	e59f204c 	ldr	r2, [pc, #76]	; 167d4 <.text+0x67d4>
   16784:	e5923000 	ldr	r3, [r2]
   16788:	e3a0c000 	mov	ip, #0	; 0x0
   1678c:	e3833080 	orr	r3, r3, #128	; 0x80
   16790:	e5823000 	str	r3, [r2]
   16794:	ea000007 	b	167b8 <SPISendN+0x38>
    for (i = 0; i < iLen; i++)
    {
        S0SPDR = pbBuf[i];
   16798:	e7dc2000 	ldrb	r2, [ip, r0]
   1679c:	e59f3034 	ldr	r3, [pc, #52]	; 167d8 <.text+0x67d8>
   167a0:	e5c32000 	strb	r2, [r3]
        while (!(S0SPSR & (1 << SPIF)));
   167a4:	e59f3030 	ldr	r3, [pc, #48]	; 167dc <.text+0x67dc>
   167a8:	e5d33000 	ldrb	r3, [r3]
   167ac:	e3130080 	tst	r3, #128	; 0x80
   167b0:	0afffffb 	beq	167a4 <SPISendN+0x24>
   167b4:	e28cc001 	add	ip, ip, #1	; 0x1
   167b8:	e15c0001 	cmp	ip, r1
   167bc:	bafffff5 	blt	16798 <SPISendN+0x18>
    }
    UNSELECT_CARD();
   167c0:	e59f2018 	ldr	r2, [pc, #24]	; 167e0 <.text+0x67e0>
   167c4:	e5923000 	ldr	r3, [r2]
   167c8:	e3833080 	orr	r3, r3, #128	; 0x80
   167cc:	e5823000 	str	r3, [r2]
}
   167d0:	e12fff1e 	bx	lr
   167d4:	e002800c 	and	r8, r2, ip
   167d8:	e0020008 	and	r0, r2, r8
   167dc:	e0020004 	and	r0, r2, r4
   167e0:	e0028004 	and	r8, r2, r4

000167e4 <SPIRecvN>:

void SPIRecvN(U8 * pbBuf, int iLen)
{
    int i;

    SELECT_CARD();
   167e4:	e59f2058 	ldr	r2, [pc, #88]	; 16844 <.text+0x6844>
   167e8:	e5923000 	ldr	r3, [r2]
   167ec:	e3a0c000 	mov	ip, #0	; 0x0
   167f0:	e3833080 	orr	r3, r3, #128	; 0x80
   167f4:	e5823000 	str	r3, [r2]
   167f8:	ea00000a 	b	16828 <SPIRecvN+0x44>
    for (i = 0; i < iLen; i++)
    {
        S0SPDR = 0xFF;
   167fc:	e59f3044 	ldr	r3, [pc, #68]	; 16848 <.text+0x6848>
   16800:	e3e02000 	mvn	r2, #0	; 0x0
   16804:	e5c32000 	strb	r2, [r3]
        while (!(S0SPSR & (1 << SPIF)));
   16808:	e59f303c 	ldr	r3, [pc, #60]	; 1684c <.text+0x684c>
   1680c:	e5d33000 	ldrb	r3, [r3]
   16810:	e3130080 	tst	r3, #128	; 0x80
   16814:	0afffffb 	beq	16808 <SPIRecvN+0x24>
        pbBuf[i] = S0SPDR;
   16818:	e59f3028 	ldr	r3, [pc, #40]	; 16848 <.text+0x6848>
   1681c:	e5d33000 	ldrb	r3, [r3]
   16820:	e7cc3000 	strb	r3, [ip, r0]
   16824:	e28cc001 	add	ip, ip, #1	; 0x1
   16828:	e15c0001 	cmp	ip, r1
   1682c:	bafffff2 	blt	167fc <SPIRecvN+0x18>
    }
    UNSELECT_CARD();
   16830:	e59f2018 	ldr	r2, [pc, #24]	; 16850 <.text+0x6850>
   16834:	e5923000 	ldr	r3, [r2]
   16838:	e3833080 	orr	r3, r3, #128	; 0x80
   1683c:	e5823000 	str	r3, [r2]
}
   16840:	e12fff1e 	bx	lr
   16844:	e002800c 	and	r8, r2, ip
   16848:	e0020008 	and	r0, r2, r8
   1684c:	e0020004 	and	r0, r2, r4
   16850:	e0028004 	and	r8, r2, r4

00016854 <SPIInit>:
   16854:	e52de004 	str	lr, [sp, #-4]!
   16858:	e59f00b4 	ldr	r0, [pc, #180]	; 16914 <.text+0x6914>
   1685c:	ebffec7d 	bl	11a58 <rprintf>
   16860:	e59f30b0 	ldr	r3, [pc, #176]	; 16918 <.text+0x6918>
   16864:	e3a02000 	mov	r2, #0	; 0x0
   16868:	e5832000 	str	r2, [r3]
   1686c:	e59f20a8 	ldr	r2, [pc, #168]	; 1691c <.text+0x691c>
   16870:	e5923000 	ldr	r3, [r2]
   16874:	e3833050 	orr	r3, r3, #80	; 0x50
   16878:	e5823000 	str	r3, [r2]
   1687c:	e5923000 	ldr	r3, [r2]
   16880:	e3833080 	orr	r3, r3, #128	; 0x80
   16884:	e5823000 	str	r3, [r2]
   16888:	e5923000 	ldr	r3, [r2]
   1688c:	e3c33020 	bic	r3, r3, #32	; 0x20
   16890:	e5823000 	str	r3, [r2]
   16894:	e59f2084 	ldr	r2, [pc, #132]	; 16920 <.text+0x6920>
   16898:	e5923000 	ldr	r3, [r2]
   1689c:	e3c33c3f 	bic	r3, r3, #16128	; 0x3f00
   168a0:	e5823000 	str	r3, [r2]
   168a4:	e5923000 	ldr	r3, [r2]
   168a8:	e3833c15 	orr	r3, r3, #5376	; 0x1500
   168ac:	e5823000 	str	r3, [r2]
   168b0:	e59f206c 	ldr	r2, [pc, #108]	; 16924 <.text+0x6924>
   168b4:	e5923000 	ldr	r3, [r2]
   168b8:	e3833080 	orr	r3, r3, #128	; 0x80
   168bc:	e5823000 	str	r3, [r2]
   168c0:	e59f3060 	ldr	r3, [pc, #96]	; 16928 <.text+0x6928>
   168c4:	e3a02020 	mov	r2, #32	; 0x20
   168c8:	e5c32000 	strb	r2, [r3]
   168cc:	e3e02001 	mvn	r2, #1	; 0x1
   168d0:	e283300c 	add	r3, r3, #12	; 0xc
   168d4:	e5c32000 	strb	r2, [r3]
   168d8:	e3a01015 	mov	r1, #21	; 0x15
   168dc:	e59f3048 	ldr	r3, [pc, #72]	; 1692c <.text+0x692c>
   168e0:	e3e02000 	mvn	r2, #0	; 0x0
   168e4:	e5c32000 	strb	r2, [r3]
   168e8:	e59f3040 	ldr	r3, [pc, #64]	; 16930 <.text+0x6930>
   168ec:	e5d33000 	ldrb	r3, [r3]
   168f0:	e3130080 	tst	r3, #128	; 0x80
   168f4:	0afffffb 	beq	168e8 <SPIInit+0x94>
   168f8:	e2413001 	sub	r3, r1, #1	; 0x1
   168fc:	e21310ff 	ands	r1, r3, #255	; 0xff
   16900:	e59f3024 	ldr	r3, [pc, #36]	; 1692c <.text+0x692c>
   16904:	e5d33000 	ldrb	r3, [r3]
   16908:	1afffff3 	bne	168dc <SPIInit+0x88>
   1690c:	e49de004 	ldr	lr, [sp], #4
   16910:	e12fff1e 	bx	lr
   16914:	00019110 	andeq	r9, r1, r0, lsl r1
   16918:	e002c014 	and	ip, r2, r4, lsl r0
   1691c:	e0028008 	and	r8, r2, r8
   16920:	e002c000 	and	ip, r2, r0
   16924:	e0028004 	and	r8, r2, r4
   16928:	e0020000 	and	r0, r2, r0
   1692c:	e0020008 	and	r0, r2, r8
   16930:	e0020004 	and	r0, r2, r4

00016934 <HandleUsbReset>:
{
	if (bDevStatus & DEV_STATUS_RESET) {
		DBG("\n!");
	}
}
   16934:	e12fff1e 	bx	lr

00016938 <USBInit>:


/**
	Initialises the USB hardware and sets up the USB stack by
	installing default callbacks.
	
	@return TRUE if initialisation was successful
 */
BOOL USBInit(void)
{
   16938:	e92d4010 	stmdb	sp!, {r4, lr}
	// init hardware
	USBHwInit();
	
	// register bus reset handler
	USBHwRegisterDevIntHandler(HandleUsbReset);
	
	// register control transfer handler on EP0
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
   1693c:	e59f4054 	ldr	r4, [pc, #84]	; 16998 <.text+0x6998>
   16940:	eb000075 	bl	16b1c <USBHwInit>
   16944:	e59f0050 	ldr	r0, [pc, #80]	; 1699c <.text+0x699c>
   16948:	eb00002b 	bl	169fc <USBHwRegisterDevIntHandler>
   1694c:	e1a01004 	mov	r1, r4
   16950:	e3a00000 	mov	r0, #0	; 0x0
   16954:	eb000013 	bl	169a8 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(0x80, USBHandleControlTransfer);
   16958:	e1a01004 	mov	r1, r4
   1695c:	e3a00080 	mov	r0, #128	; 0x80
   16960:	eb000010 	bl	169a8 <USBHwRegisterEPIntHandler>
	
	// setup control endpoints
	USBHwEPConfig(0x00, MAX_PACKET_SIZE0);
   16964:	e3a00000 	mov	r0, #0	; 0x0
   16968:	e3a01040 	mov	r1, #64	; 0x40
   1696c:	eb0000ac 	bl	16c24 <USBHwEPConfig>
	USBHwEPConfig(0x80, MAX_PACKET_SIZE0);
   16970:	e3a00080 	mov	r0, #128	; 0x80
   16974:	e3a01040 	mov	r1, #64	; 0x40
   16978:	eb0000a9 	bl	16c24 <USBHwEPConfig>
	
	// register standard request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_STANDARD, USBHandleStandardRequest, abStdReqData);
   1697c:	e3a00000 	mov	r0, #0	; 0x0
   16980:	e59f1018 	ldr	r1, [pc, #24]	; 169a0 <.text+0x69a0>
   16984:	e59f2018 	ldr	r2, [pc, #24]	; 169a4 <.text+0x69a4>
   16988:	eb000202 	bl	17198 <USBRegisterRequestHandler>

	return TRUE;
}
   1698c:	e3a00001 	mov	r0, #1	; 0x1
   16990:	e8bd4010 	ldmia	sp!, {r4, lr}
   16994:	e12fff1e 	bx	lr
   16998:	0001704c 	andeq	r7, r1, ip, asr #32
   1699c:	00016934 	andeq	r6, r1, r4, lsr r9
   169a0:	00017248 	andeq	r7, r1, r8, asr #4
   169a4:	400017b0 	strmih	r1, [r0], -r0

000169a8 <USBHwRegisterEPIntHandler>:
	@param [in]	bEP				Endpoint number
	@param [in]	pfnHandler		Callback function
 */
void USBHwRegisterEPIntHandler(U8 bEP, TFnEPIntHandler *pfnHandler)
{
   169a8:	e52de004 	str	lr, [sp, #-4]!
	int idx;
	
	idx = EP2IDX(bEP);

	ASSERT(idx<32);

	/* add handler to list of EP handlers */
	_apfnEPIntHandlers[idx / 2] = pfnHandler;
	
	/* enable EP interrupt */
	USBEpIntEn |= (1 << idx);
   169ac:	e59fe03c 	ldr	lr, [pc, #60]	; 169f0 <.text+0x69f0>
   169b0:	e2003080 	and	r3, r0, #128	; 0x80
   169b4:	e59ec000 	ldr	ip, [lr]
   169b8:	e200000f 	and	r0, r0, #15	; 0xf
   169bc:	e1a033c3 	mov	r3, r3, asr #7
   169c0:	e1833080 	orr	r3, r3, r0, lsl #1
   169c4:	e3a02001 	mov	r2, #1	; 0x1
   169c8:	e18cc312 	orr	ip, ip, r2, lsl r3
   169cc:	e58ec000 	str	ip, [lr]
	USBDevIntEn |= EP_SLOW;
   169d0:	e59fc01c 	ldr	ip, [pc, #28]	; 169f4 <.text+0x69f4>
   169d4:	e59c3000 	ldr	r3, [ip]
   169d8:	e59f2018 	ldr	r2, [pc, #24]	; 169f8 <.text+0x69f8>
   169dc:	e3833004 	orr	r3, r3, #4	; 0x4
   169e0:	e7821100 	str	r1, [r2, r0, lsl #2]
   169e4:	e58c3000 	str	r3, [ip]
	
	DBG("Registered handler for EP 0x%x\n", bEP);
}
   169e8:	e49de004 	ldr	lr, [sp], #4
   169ec:	e12fff1e 	bx	lr
   169f0:	e0090034 	and	r0, r9, r4, lsr r0
   169f4:	e0090004 	and	r0, r9, r4
   169f8:	400017c0 	andmi	r1, r0, r0, asr #15

000169fc <USBHwRegisterDevIntHandler>:


/**
	Registers an device status callback
		
	@param [in]	pfnHandler	Callback function
 */
void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
{
	_pfnDevIntHandler = pfnHandler;
	
	// enable device interrupt
	USBDevIntEn |= DEV_STAT;
   169fc:	e59f3014 	ldr	r3, [pc, #20]	; 16a18 <.text+0x6a18>
   16a00:	e5932000 	ldr	r2, [r3]
   16a04:	e59f1010 	ldr	r1, [pc, #16]	; 16a1c <.text+0x6a1c>
   16a08:	e3822008 	orr	r2, r2, #8	; 0x8
   16a0c:	e5810000 	str	r0, [r1]
   16a10:	e5832000 	str	r2, [r3]

	DBG("Registered handler for device status\n");
}
   16a14:	e12fff1e 	bx	lr
   16a18:	e0090004 	and	r0, r9, r4
   16a1c:	400017b8 	strmih	r1, [r0], -r8

00016a20 <USBHwRegisterFrameHandler>:


/**
	Registers the frame callback
		
	@param [in]	pfnHandler	Callback function
 */
void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
{
	_pfnFrameHandler = pfnHandler;
	
	// enable device interrupt
	USBDevIntEn |= FRAME;
   16a20:	e59f3014 	ldr	r3, [pc, #20]	; 16a3c <.text+0x6a3c>
   16a24:	e5932000 	ldr	r2, [r3]
   16a28:	e59f1010 	ldr	r1, [pc, #16]	; 16a40 <.text+0x6a40>
   16a2c:	e3822001 	orr	r2, r2, #1	; 0x1
   16a30:	e5810000 	str	r0, [r1]
   16a34:	e5832000 	str	r2, [r3]

	DBG("Registered handler for frame\n");
}
   16a38:	e12fff1e 	bx	lr
   16a3c:	e0090004 	and	r0, r9, r4
   16a40:	400017bc 	strmih	r1, [r0], -ip

00016a44 <USBHwCmd>:
   16a44:	e59f3038 	ldr	r3, [pc, #56]	; 16a84 <.text+0x6a84>
   16a48:	e1a00800 	mov	r0, r0, lsl #16
   16a4c:	e20008ff 	and	r0, r0, #16711680	; 0xff0000
   16a50:	e3a02030 	mov	r2, #48	; 0x30
   16a54:	e5832000 	str	r2, [r3]
   16a58:	e3800c05 	orr	r0, r0, #1280	; 0x500
   16a5c:	e2833008 	add	r3, r3, #8	; 0x8
   16a60:	e5830000 	str	r0, [r3]
   16a64:	e59f301c 	ldr	r3, [pc, #28]	; 16a88 <.text+0x6a88>
   16a68:	e5933000 	ldr	r3, [r3]
   16a6c:	e2032010 	and	r2, r3, #16	; 0x10
   16a70:	e3520010 	cmp	r2, #16	; 0x10
   16a74:	1afffffa 	bne	16a64 <USBHwCmd+0x20>
   16a78:	e59f3004 	ldr	r3, [pc, #4]	; 16a84 <.text+0x6a84>
   16a7c:	e5832000 	str	r2, [r3]
   16a80:	e12fff1e 	bx	lr
   16a84:	e0090008 	and	r0, r9, r8
   16a88:	e0090000 	and	r0, r9, r0

00016a8c <USBHwCmdWrite>:
   16a8c:	e92d4010 	stmdb	sp!, {r4, lr}
   16a90:	e1a04801 	mov	r4, r1, lsl #16
   16a94:	e20000ff 	and	r0, r0, #255	; 0xff
   16a98:	e1a04824 	mov	r4, r4, lsr #16
   16a9c:	ebffffe8 	bl	16a44 <USBHwCmd>
   16aa0:	e1a04804 	mov	r4, r4, lsl #16
   16aa4:	e59f3028 	ldr	r3, [pc, #40]	; 16ad4 <.text+0x6ad4>
   16aa8:	e3844c01 	orr	r4, r4, #256	; 0x100
   16aac:	e5834000 	str	r4, [r3]
   16ab0:	e59f3020 	ldr	r3, [pc, #32]	; 16ad8 <.text+0x6ad8>
   16ab4:	e5933000 	ldr	r3, [r3]
   16ab8:	e2032010 	and	r2, r3, #16	; 0x10
   16abc:	e3520010 	cmp	r2, #16	; 0x10
   16ac0:	1afffffa 	bne	16ab0 <USBHwCmdWrite+0x24>
   16ac4:	e59f3010 	ldr	r3, [pc, #16]	; 16adc <.text+0x6adc>
   16ac8:	e5832000 	str	r2, [r3]
   16acc:	e8bd4010 	ldmia	sp!, {r4, lr}
   16ad0:	e12fff1e 	bx	lr
   16ad4:	e0090010 	and	r0, r9, r0, lsl r0
   16ad8:	e0090000 	and	r0, r9, r0
   16adc:	e0090008 	and	r0, r9, r8

00016ae0 <USBHwConfigDevice>:


/**
	Sets the USB address.
		
	@param [in]	bAddr		Device address to set
 */
void USBHwSetAddress(U8 bAddr)
{
	USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
}


/**
	Connects or disconnects from the USB bus
		
	@param [in]	fConnect	If TRUE, connect, otherwise disconnect
 */
void USBHwConnect(BOOL fConnect)
{
	USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);

}


/**
	Enables interrupt on NAK condition
		
	For IN endpoints a NAK is generated when the host wants to read data
	from the device, but none is available in the endpoint buffer.
	For OUT endpoints a NAK is generated when the host wants to write data
	to the device, but the endpoint buffer is still full.
	
	The endpoint interrupt handlers can distinguish regular (ACK) interrupts
	from NAK interrupt by checking the bits in their bEPStatus argument.
	
	@param [in]	bIntBits	Bitmap indicating which NAK interrupts to enable
 */
void USBHwNakIntEnable(U8 bIntBits)
{
	USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
}


/**
	Gets the status from a specific endpoint.
		
	@param [in]	bEP		Endpoint number
	@return Endpoint status byte (containing EP_STATUS_xxx bits)
 */
U8	USBHwEPGetStatus(U8 bEP)
{
	int idx = EP2IDX(bEP);

	return USBHwCmdRead(CMD_EP_SELECT | idx);
}


/**
	Sets the stalled property of an endpoint
		
	@param [in]	bEP		Endpoint number
	@param [in]	fStall	TRUE to stall, FALSE to unstall
 */
void USBHwEPStall(U8 bEP, BOOL fStall)
{
	int idx = EP2IDX(bEP);

	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
}


/**
	Writes data to an endpoint buffer
		
	@param [in]	bEP		Endpoint number
	@param [in]	pbBuf	Endpoint data
	@param [in]	iLen	Number of bytes to write
			
	@return TRUE if the data was successfully written or <0 in case of error.
*/
int USBHwEPWrite(U8 bEP, U8 *pbBuf, int iLen)
{
	int idx;
	
	idx = EP2IDX(bEP);
	
	// set write enable for specific endpoint
	USBCtrl = WR_EN | ((bEP & 0xF) << 2);
	
	// set packet length
	USBTxPLen = iLen;
	
	// write data
	while (USBCtrl & WR_EN) {
		USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
		pbBuf += 4;
	}

	// select endpoint and validate buffer
	USBHwCmd(CMD_EP_SELECT | idx);
	USBHwCmd(CMD_EP_VALIDATE_BUFFER);
	
	return iLen;
}


/**
	Reads data from an endpoint buffer
		
	@param [in]	bEP		Endpoint number
	@param [in]	pbBuf	Endpoint data
	@param [in]	iMaxLen	Maximum number of bytes to read
			
	@return the number of bytes available in the EP (possibly more than iMaxLen),
	or <0 in case of error.
 */
int USBHwEPRead(U8 bEP, U8 *pbBuf, int iMaxLen)
{
	int i, idx;
	U32	dwData, dwLen;
	
	idx = EP2IDX(bEP);
	
	// set read enable bit for specific endpoint
	USBCtrl = RD_EN | ((bEP & 0xF) << 2);
	
	// wait for PKT_RDY
	do {
		dwLen = USBRxPLen;
	} while ((dwLen & PKT_RDY) == 0);
	
	// packet valid?
	if ((dwLen & DV) == 0) {
		return -1;
	}
	
	// get length
	dwLen &= PKT_LNGTH_MASK;
	
	// get data
	dwData = 0;
	for (i = 0; i < dwLen; i++) {
		if ((i % 4) == 0) {
			dwData = USBRxData;
		}
		if ((pbBuf != NULL) && (i < iMaxLen)) {
			pbBuf[i] = dwData & 0xFF;
		}
		dwData >>= 8;
	}

	// make sure RD_EN is clear
	USBCtrl = 0;

	// select endpoint and clear buffer
	USBHwCmd(CMD_EP_SELECT | idx);
	USBHwCmd(CMD_EP_CLEAR_BUFFER);
	
	return dwLen;
}


/**
	Sets the 'configured' state.
		
	All registered endpoints are 'realised' and enabled, and the
	'configured' bit is set in the device status register.
		
	@param [in]	fConfigured	If TRUE, configure device, else unconfigure
 */
void USBHwConfigDevice(BOOL fConfigured)
{
	// set configured bit
	USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
   16ae0:	e2501000 	subs	r1, r0, #0	; 0x0
   16ae4:	13a01001 	movne	r1, #1	; 0x1
   16ae8:	e3a000d8 	mov	r0, #216	; 0xd8
   16aec:	eaffffe6 	b	16a8c <USBHwCmdWrite>

00016af0 <USBHwEPStall>:
   16af0:	e2003080 	and	r3, r0, #128	; 0x80
   16af4:	e1a033c3 	mov	r3, r3, asr #7
   16af8:	e200000f 	and	r0, r0, #15	; 0xf
   16afc:	e1833080 	orr	r3, r3, r0, lsl #1
   16b00:	e2511000 	subs	r1, r1, #0	; 0x0
   16b04:	13a01001 	movne	r1, #1	; 0x1
   16b08:	e3830040 	orr	r0, r3, #64	; 0x40
   16b0c:	eaffffde 	b	16a8c <USBHwCmdWrite>

00016b10 <USBHwNakIntEnable>:
   16b10:	e20010ff 	and	r1, r0, #255	; 0xff
   16b14:	e3a000f3 	mov	r0, #243	; 0xf3
   16b18:	eaffffdb 	b	16a8c <USBHwCmdWrite>

00016b1c <USBHwInit>:
}


/**
	USB interrupt handler
		
	@todo Get all 11 bits of frame number instead of just 8

	Endpoint interrupts are mapped to the slow interrupt
 */
void USBHwISR(void)
{
	U32	dwStatus;
	U32 dwIntBit;
	U8	bEPStat, bDevStat, bStat;
	int i;
	U16	wFrame;

// LED9 monitors total time in interrupt routine
DEBUG_LED_ON(9);

	// handle device interrupts
	dwStatus = USBDevIntSt;
	
	// frame interrupt
	if (dwStatus & FRAME) {
		// clear int
		USBDevIntClr = FRAME;
		// call handler
		if (_pfnFrameHandler != NULL) {
			wFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);
			_pfnFrameHandler(wFrame);
		}
	}
	
	// device status interrupt
	if (dwStatus & DEV_STAT) {
		/*	Clear DEV_STAT interrupt before reading DEV_STAT register.
			This prevents corrupted device status reads, see
			LPC2148 User manual revision 2, 25 july 2006.
		*/
		USBDevIntClr = DEV_STAT;
		bDevStat = USBHwCmdRead(CMD_DEV_STATUS);
		if (bDevStat & (CON_CH | SUS_CH | RST)) {
			// convert device status into something HW independent
			bStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |
					((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |
					((bDevStat & RST) ? DEV_STATUS_RESET : 0);
			// call handler
			if (_pfnDevIntHandler != NULL) {
DEBUG_LED_ON(8);		
				_pfnDevIntHandler(bStat);
DEBUG_LED_OFF(8);		
			}
		}
	}
	
	// endpoint interrupt
	if (dwStatus & EP_SLOW) {
		// clear EP_SLOW
		USBDevIntClr = EP_SLOW;
		// check all endpoints
		for (i = 0; i < 32; i++) {
			dwIntBit = (1 << i);
			if (USBEpIntSt & dwIntBit) {
				// clear int (and retrieve status)
				USBEpIntClr = dwIntBit;
				Wait4DevInt(CDFULL);
				bEPStat = USBCmdData;
				// convert EP pipe stat into something HW independent
				bStat = ((bEPStat & EPSTAT_FE) ? EP_STATUS_DATA : 0) |
						((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
						((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
						((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
						((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
				// call handler
				if (_apfnEPIntHandlers[i / 2] != NULL) {
DEBUG_LED_ON(10);		
					_apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);
DEBUG_LED_OFF(10);
				}
			}
		}
	}
	
DEBUG_LED_OFF(9);		
}



/**
	Initialises the USB hardware
		
	This function assumes that the hardware is connected as shown in
	section 10.1 of the LPC2148 data sheet:
	* P0.31 controls a switch to connect a 1.5k pull-up to D+ if low.
	* P0.23 is connected to USB VCC.
	
	Embedded artists board: make sure to disconnect P0.23 LED as it
	acts as a pull-up and so prevents detection of USB disconnect.
		
	@return TRUE if the hardware was successfully initialised
 */
BOOL USBHwInit(void)
{
   16b1c:	e52de004 	str	lr, [sp, #-4]!
	// configure P0.23 for Vbus sense
	PINSEL1 = (PINSEL1 & ~(3 << 14)) | (1 << 14);	// P0.23
   16b20:	e59f20c4 	ldr	r2, [pc, #196]	; 16bec <.text+0x6bec>
   16b24:	e5923000 	ldr	r3, [r2]
   16b28:	e3c33903 	bic	r3, r3, #49152	; 0xc000
   16b2c:	e3833901 	orr	r3, r3, #16384	; 0x4000
   16b30:	e5823000 	str	r3, [r2]
	// configure P0.31 for CONNECT
	PINSEL1 = (PINSEL1 & ~(3 << 30)) | (2 << 30);	// P0.31
   16b34:	e5923000 	ldr	r3, [r2]
   16b38:	e3c33103 	bic	r3, r3, #-1073741824	; 0xc0000000
   16b3c:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
   16b40:	e5823000 	str	r3, [r2]

	// enable PUSB
	PCONP |= (1 << 31);		
   16b44:	e59f20a4 	ldr	r2, [pc, #164]	; 16bf0 <.text+0x6bf0>
   16b48:	e5923000 	ldr	r3, [r2]
   16b4c:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
   16b50:	e5823000 	str	r3, [r2]
	
	// initialise PLL
	PLL1CON = 1;			// enable PLL
   16b54:	e59f3098 	ldr	r3, [pc, #152]	; 16bf4 <.text+0x6bf4>
   16b58:	e3a02001 	mov	r2, #1	; 0x1
   16b5c:	e5832000 	str	r2, [r3]
	PLL1CFG = (1 << 5) | 3; // P = 2, M = 4
	PLL1FEED = 0xAA;
   16b60:	e59f1090 	ldr	r1, [pc, #144]	; 16bf8 <.text+0x6bf8>
   16b64:	e2833004 	add	r3, r3, #4	; 0x4
   16b68:	e2822022 	add	r2, r2, #34	; 0x22
   16b6c:	e5832000 	str	r2, [r3]
   16b70:	e3a030aa 	mov	r3, #170	; 0xaa
   16b74:	e5813000 	str	r3, [r1]
	PLL1FEED = 0x55;
   16b78:	e3a03055 	mov	r3, #85	; 0x55
   16b7c:	e5813000 	str	r3, [r1]
	while ((PLL1STAT & (1 << 10)) == 0);
   16b80:	e59f3074 	ldr	r3, [pc, #116]	; 16bfc <.text+0x6bfc>
   16b84:	e5933000 	ldr	r3, [r3]
   16b88:	e3130b01 	tst	r3, #1024	; 0x400
   16b8c:	0afffffb 	beq	16b80 <USBHwInit+0x64>

	PLL1CON = 3;			// enable and connect
   16b90:	e59f305c 	ldr	r3, [pc, #92]	; 16bf4 <.text+0x6bf4>
	PLL1FEED = 0xAA;
   16b94:	e59fc05c 	ldr	ip, [pc, #92]	; 16bf8 <.text+0x6bf8>
   16b98:	e3a02003 	mov	r2, #3	; 0x3
   16b9c:	e5832000 	str	r2, [r3]
   16ba0:	e3a030aa 	mov	r3, #170	; 0xaa
   16ba4:	e58c3000 	str	r3, [ip]
	PLL1FEED = 0x55;
   16ba8:	e3a03055 	mov	r3, #85	; 0x55
   16bac:	e58c3000 	str	r3, [ip]
	
	// disable/clear all interrupts for now
	USBDevIntEn = 0;
   16bb0:	e59f3048 	ldr	r3, [pc, #72]	; 16c00 <.text+0x6c00>
   16bb4:	e3a01000 	mov	r1, #0	; 0x0
   16bb8:	e5831000 	str	r1, [r3]
	USBDevIntClr = 0xFFFFFFFF;
   16bbc:	e3e0e000 	mvn	lr, #0	; 0x0
   16bc0:	e2833004 	add	r3, r3, #4	; 0x4
   16bc4:	e483e024 	str	lr, [r3], #36
	USBDevIntPri = 0;
   16bc8:	e4831008 	str	r1, [r3], #8

	USBEpIntEn = 0;
   16bcc:	e4831004 	str	r1, [r3], #4
	USBEpIntClr = 0xFFFFFFFF;
   16bd0:	e483e008 	str	lr, [r3], #8
	USBEpIntPri = 0;

	// by default, only ACKs generate interrupts
	USBHwNakIntEnable(0);
   16bd4:	e1a00001 	mov	r0, r1
   16bd8:	e5831000 	str	r1, [r3]
   16bdc:	ebffffcb 	bl	16b10 <USBHwNakIntEnable>
	
	// init debug leds
	DEBUG_LED_INIT(8);
	DEBUG_LED_INIT(9);
	DEBUG_LED_INIT(10);

	return TRUE;
}
   16be0:	e3a00001 	mov	r0, #1	; 0x1
   16be4:	e49de004 	ldr	lr, [sp], #4
   16be8:	e12fff1e 	bx	lr
   16bec:	e002c004 	and	ip, r2, r4
   16bf0:	e01fc0c4 	ands	ip, pc, r4, asr #1
   16bf4:	e01fc0a0 	ands	ip, pc, r0, lsr #1
   16bf8:	e01fc0ac 	ands	ip, pc, ip, lsr #1
   16bfc:	e01fc0a8 	ands	ip, pc, r8, lsr #1
   16c00:	e0090004 	and	r0, r9, r4

00016c04 <USBHwConnect>:
   16c04:	e2501000 	subs	r1, r0, #0	; 0x0
   16c08:	13a01001 	movne	r1, #1	; 0x1
   16c0c:	e3a000fe 	mov	r0, #254	; 0xfe
   16c10:	eaffff9d 	b	16a8c <USBHwCmdWrite>

00016c14 <USBHwSetAddress>:
   16c14:	e20010ff 	and	r1, r0, #255	; 0xff
   16c18:	e3811080 	orr	r1, r1, #128	; 0x80
   16c1c:	e3a000d0 	mov	r0, #208	; 0xd0
   16c20:	eaffff99 	b	16a8c <USBHwCmdWrite>

00016c24 <USBHwEPConfig>:
   16c24:	e59fc058 	ldr	ip, [pc, #88]	; 16c84 <.text+0x6c84>
   16c28:	e2003080 	and	r3, r0, #128	; 0x80
   16c2c:	e59c2000 	ldr	r2, [ip]
   16c30:	e1a033c3 	mov	r3, r3, asr #7
   16c34:	e200000f 	and	r0, r0, #15	; 0xf
   16c38:	e1830080 	orr	r0, r3, r0, lsl #1
   16c3c:	e3a03001 	mov	r3, #1	; 0x1
   16c40:	e1822013 	orr	r2, r2, r3, lsl r0
   16c44:	e59f303c 	ldr	r3, [pc, #60]	; 16c88 <.text+0x6c88>
   16c48:	e1a01801 	mov	r1, r1, lsl #16
   16c4c:	e58c2000 	str	r2, [ip]
   16c50:	e1a01821 	mov	r1, r1, lsr #16
   16c54:	e4830004 	str	r0, [r3], #4
   16c58:	e5831000 	str	r1, [r3]
   16c5c:	e59f3028 	ldr	r3, [pc, #40]	; 16c8c <.text+0x6c8c>
   16c60:	e5933000 	ldr	r3, [r3]
   16c64:	e2032c01 	and	r2, r3, #256	; 0x100
   16c68:	e3520c01 	cmp	r2, #256	; 0x100
   16c6c:	1afffffa 	bne	16c5c <USBHwEPConfig+0x38>
   16c70:	e59f3018 	ldr	r3, [pc, #24]	; 16c90 <.text+0x6c90>
   16c74:	e3800040 	orr	r0, r0, #64	; 0x40
   16c78:	e3a01000 	mov	r1, #0	; 0x0
   16c7c:	e5832000 	str	r2, [r3]
   16c80:	eaffff81 	b	16a8c <USBHwCmdWrite>
   16c84:	e0090044 	and	r0, r9, r4, asr #32
   16c88:	e0090048 	and	r0, r9, r8, asr #32
   16c8c:	e0090000 	and	r0, r9, r0
   16c90:	e0090008 	and	r0, r9, r8

00016c94 <USBHwEPRead>:
   16c94:	e92d4010 	stmdb	sp!, {r4, lr}
   16c98:	e200e00f 	and	lr, r0, #15	; 0xf
   16c9c:	e1a0310e 	mov	r3, lr, lsl #2
   16ca0:	e59fc08c 	ldr	ip, [pc, #140]	; 16d34 <.text+0x6d34>
   16ca4:	e2000080 	and	r0, r0, #128	; 0x80
   16ca8:	e3833001 	orr	r3, r3, #1	; 0x1
   16cac:	e1a003c0 	mov	r0, r0, asr #7
   16cb0:	e58c3000 	str	r3, [ip]
   16cb4:	e180008e 	orr	r0, r0, lr, lsl #1
   16cb8:	e59f3078 	ldr	r3, [pc, #120]	; 16d38 <.text+0x6d38>
   16cbc:	e5933000 	ldr	r3, [r3]
   16cc0:	e3130b02 	tst	r3, #2048	; 0x800
   16cc4:	0afffffb 	beq	16cb8 <USBHwEPRead+0x24>
   16cc8:	e3130b01 	tst	r3, #1024	; 0x400
   16ccc:	03e00000 	mvneq	r0, #0	; 0x0
   16cd0:	0a000015 	beq	16d2c <USBHwEPRead+0x98>
   16cd4:	e1a04b03 	mov	r4, r3, lsl #22
   16cd8:	e3a0c000 	mov	ip, #0	; 0x0
   16cdc:	e1a04b24 	mov	r4, r4, lsr #22
   16ce0:	e1a0300c 	mov	r3, ip
   16ce4:	ea000007 	b	16d08 <USBHwEPRead+0x74>
   16ce8:	e31c0003 	tst	ip, #3	; 0x3
   16cec:	059f3048 	ldreq	r3, [pc, #72]	; 16d3c <.text+0x6d3c>
   16cf0:	05933000 	ldreq	r3, [r3]
   16cf4:	e3510000 	cmp	r1, #0	; 0x0
   16cf8:	115c0002 	cmpne	ip, r2
   16cfc:	b7cc3001 	strltb	r3, [ip, r1]
   16d00:	e1a03423 	mov	r3, r3, lsr #8
   16d04:	e28cc001 	add	ip, ip, #1	; 0x1
   16d08:	e15c0004 	cmp	ip, r4
   16d0c:	3afffff5 	bcc	16ce8 <USBHwEPRead+0x54>
   16d10:	e59f301c 	ldr	r3, [pc, #28]	; 16d34 <.text+0x6d34>
   16d14:	e3a02000 	mov	r2, #0	; 0x0
   16d18:	e5832000 	str	r2, [r3]
   16d1c:	ebffff48 	bl	16a44 <USBHwCmd>
   16d20:	e3a000f2 	mov	r0, #242	; 0xf2
   16d24:	ebffff46 	bl	16a44 <USBHwCmd>
   16d28:	e1a00004 	mov	r0, r4
   16d2c:	e8bd4010 	ldmia	sp!, {r4, lr}
   16d30:	e12fff1e 	bx	lr
   16d34:	e0090028 	and	r0, r9, r8, lsr #32
   16d38:	e0090020 	and	r0, r9, r0, lsr #32
   16d3c:	e0090018 	and	r0, r9, r8, lsl r0

00016d40 <USBHwEPWrite>:
   16d40:	e92d4010 	stmdb	sp!, {r4, lr}
   16d44:	e2003080 	and	r3, r0, #128	; 0x80
   16d48:	e1a033c3 	mov	r3, r3, asr #7
   16d4c:	e200000f 	and	r0, r0, #15	; 0xf
   16d50:	e1a0c100 	mov	ip, r0, lsl #2
   16d54:	e1830080 	orr	r0, r3, r0, lsl #1
   16d58:	e59f306c 	ldr	r3, [pc, #108]	; 16dcc <.text+0x6dcc>
   16d5c:	e38cc002 	orr	ip, ip, #2	; 0x2
   16d60:	e583c000 	str	ip, [r3]
   16d64:	e1a04002 	mov	r4, r2
   16d68:	e2433004 	sub	r3, r3, #4	; 0x4
   16d6c:	e1a0e001 	mov	lr, r1
   16d70:	e5832000 	str	r2, [r3]
   16d74:	ea000009 	b	16da0 <USBHwEPWrite+0x60>
   16d78:	e55e3002 	ldrb	r3, [lr, #-2]
   16d7c:	e55e2001 	ldrb	r2, [lr, #-1]
   16d80:	e55e1003 	ldrb	r1, [lr, #-3]
   16d84:	e1a03803 	mov	r3, r3, lsl #16
   16d88:	e1833c02 	orr	r3, r3, r2, lsl #24
   16d8c:	e55e2004 	ldrb	r2, [lr, #-4]
   16d90:	e1833401 	orr	r3, r3, r1, lsl #8
   16d94:	e1833002 	orr	r3, r3, r2
   16d98:	e59f2030 	ldr	r2, [pc, #48]	; 16dd0 <.text+0x6dd0>
   16d9c:	e5823000 	str	r3, [r2]
   16da0:	e59f3024 	ldr	r3, [pc, #36]	; 16dcc <.text+0x6dcc>
   16da4:	e5933000 	ldr	r3, [r3]
   16da8:	e3130002 	tst	r3, #2	; 0x2
   16dac:	e28ee004 	add	lr, lr, #4	; 0x4
   16db0:	1afffff0 	bne	16d78 <USBHwEPWrite+0x38>
   16db4:	ebffff22 	bl	16a44 <USBHwCmd>
   16db8:	e3a000fa 	mov	r0, #250	; 0xfa
   16dbc:	ebffff20 	bl	16a44 <USBHwCmd>
   16dc0:	e1a00004 	mov	r0, r4
   16dc4:	e8bd4010 	ldmia	sp!, {r4, lr}
   16dc8:	e12fff1e 	bx	lr
   16dcc:	e0090028 	and	r0, r9, r8, lsr #32
   16dd0:	e009001c 	and	r0, r9, ip, lsl r0

00016dd4 <USBHwCmdRead>:
   16dd4:	e92d4010 	stmdb	sp!, {r4, lr}
   16dd8:	e20040ff 	and	r4, r0, #255	; 0xff
   16ddc:	e1a00004 	mov	r0, r4
   16de0:	ebffff17 	bl	16a44 <USBHwCmd>
   16de4:	e1a04804 	mov	r4, r4, lsl #16
   16de8:	e59f3030 	ldr	r3, [pc, #48]	; 16e20 <.text+0x6e20>
   16dec:	e3844c02 	orr	r4, r4, #512	; 0x200
   16df0:	e5834000 	str	r4, [r3]
   16df4:	e59f3028 	ldr	r3, [pc, #40]	; 16e24 <.text+0x6e24>
   16df8:	e5933000 	ldr	r3, [r3]
   16dfc:	e2032020 	and	r2, r3, #32	; 0x20
   16e00:	e3520020 	cmp	r2, #32	; 0x20
   16e04:	1afffffa 	bne	16df4 <USBHwCmdRead+0x20>
   16e08:	e59f3018 	ldr	r3, [pc, #24]	; 16e28 <.text+0x6e28>
   16e0c:	e483200c 	str	r2, [r3], #12
   16e10:	e5930000 	ldr	r0, [r3]
   16e14:	e20000ff 	and	r0, r0, #255	; 0xff
   16e18:	e8bd4010 	ldmia	sp!, {r4, lr}
   16e1c:	e12fff1e 	bx	lr
   16e20:	e0090010 	and	r0, r9, r0, lsl r0
   16e24:	e0090000 	and	r0, r9, r0
   16e28:	e0090008 	and	r0, r9, r8

00016e2c <USBHwISR>:
   16e2c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   16e30:	e59f311c 	ldr	r3, [pc, #284]	; 16f54 <.text+0x6f54>
   16e34:	e5934000 	ldr	r4, [r3]
   16e38:	e3140001 	tst	r4, #1	; 0x1
   16e3c:	0a00000d 	beq	16e78 <USBHwISR+0x4c>
   16e40:	e59f5110 	ldr	r5, [pc, #272]	; 16f58 <.text+0x6f58>
   16e44:	e5953000 	ldr	r3, [r5]
   16e48:	e3530000 	cmp	r3, #0	; 0x0
   16e4c:	e59f3108 	ldr	r3, [pc, #264]	; 16f5c <.text+0x6f5c>
   16e50:	e3a02001 	mov	r2, #1	; 0x1
   16e54:	e5832000 	str	r2, [r3]
   16e58:	0a000006 	beq	16e78 <USBHwISR+0x4c>
   16e5c:	e3a000f5 	mov	r0, #245	; 0xf5
   16e60:	ebffffdb 	bl	16dd4 <USBHwCmdRead>
   16e64:	e1a00800 	mov	r0, r0, lsl #16
   16e68:	e1a00820 	mov	r0, r0, lsr #16
   16e6c:	e595c000 	ldr	ip, [r5]
   16e70:	e1a0e00f 	mov	lr, pc
   16e74:	e12fff1c 	bx	ip
   16e78:	e3140008 	tst	r4, #8	; 0x8
   16e7c:	0a00000c 	beq	16eb4 <USBHwISR+0x88>
   16e80:	e59f30d4 	ldr	r3, [pc, #212]	; 16f5c <.text+0x6f5c>
   16e84:	e3a02008 	mov	r2, #8	; 0x8
   16e88:	e3a000fe 	mov	r0, #254	; 0xfe
   16e8c:	e5832000 	str	r2, [r3]
   16e90:	ebffffcf 	bl	16dd4 <USBHwCmdRead>
   16e94:	e310001a 	tst	r0, #26	; 0x1a
   16e98:	0a000005 	beq	16eb4 <USBHwISR+0x88>
   16e9c:	e59f30bc 	ldr	r3, [pc, #188]	; 16f60 <.text+0x6f60>
   16ea0:	e5933000 	ldr	r3, [r3]
   16ea4:	e3530000 	cmp	r3, #0	; 0x0
   16ea8:	e2000015 	and	r0, r0, #21	; 0x15
   16eac:	11a0e00f 	movne	lr, pc
   16eb0:	112fff13 	bxne	r3
   16eb4:	e3140004 	tst	r4, #4	; 0x4
   16eb8:	0a000023 	beq	16f4c <USBHwISR+0x120>
   16ebc:	e59f3098 	ldr	r3, [pc, #152]	; 16f5c <.text+0x6f5c>
   16ec0:	e3a02004 	mov	r2, #4	; 0x4
   16ec4:	e5832000 	str	r2, [r3]
   16ec8:	e3a04000 	mov	r4, #0	; 0x0
   16ecc:	e3a03001 	mov	r3, #1	; 0x1
   16ed0:	e1a02413 	mov	r2, r3, lsl r4
   16ed4:	e59f3088 	ldr	r3, [pc, #136]	; 16f64 <.text+0x6f64>
   16ed8:	e5933000 	ldr	r3, [r3]
   16edc:	e1130002 	tst	r3, r2
   16ee0:	0a000016 	beq	16f40 <USBHwISR+0x114>
   16ee4:	e59f307c 	ldr	r3, [pc, #124]	; 16f68 <.text+0x6f68>
   16ee8:	e5832000 	str	r2, [r3]
   16eec:	e59f3060 	ldr	r3, [pc, #96]	; 16f54 <.text+0x6f54>
   16ef0:	e5933000 	ldr	r3, [r3]
   16ef4:	e2031020 	and	r1, r3, #32	; 0x20
   16ef8:	e3510020 	cmp	r1, #32	; 0x20
   16efc:	1afffffa 	bne	16eec <USBHwISR+0xc0>
   16f00:	e59f3054 	ldr	r3, [pc, #84]	; 16f5c <.text+0x6f5c>
   16f04:	e0842fa4 	add	r2, r4, r4, lsr #31
   16f08:	e5831000 	str	r1, [r3]
   16f0c:	e59f3058 	ldr	r3, [pc, #88]	; 16f6c <.text+0x6f6c>
   16f10:	e1a020c2 	mov	r2, r2, asr #1
   16f14:	e7932102 	ldr	r2, [r3, r2, lsl #2]
   16f18:	e59f3050 	ldr	r3, [pc, #80]	; 16f70 <.text+0x6f70>
   16f1c:	e5933000 	ldr	r3, [r3]
   16f20:	e3520000 	cmp	r2, #0	; 0x0
   16f24:	e203101f 	and	r1, r3, #31	; 0x1f
   16f28:	11a000c4 	movne	r0, r4, asr #1
   16f2c:	1200000f 	andne	r0, r0, #15	; 0xf
   16f30:	11800384 	orrne	r0, r0, r4, lsl #7
   16f34:	1200008f 	andne	r0, r0, #143	; 0x8f
   16f38:	11a0e00f 	movne	lr, pc
   16f3c:	112fff12 	bxne	r2
   16f40:	e2844001 	add	r4, r4, #1	; 0x1
   16f44:	e3540020 	cmp	r4, #32	; 0x20
   16f48:	1affffdf 	bne	16ecc <USBHwISR+0xa0>
   16f4c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   16f50:	e12fff1e 	bx	lr
   16f54:	e0090000 	and	r0, r9, r0
   16f58:	400017bc 	strmih	r1, [r0], -ip
   16f5c:	e0090008 	and	r0, r9, r8
   16f60:	400017b8 	strmih	r1, [r0], -r8
   16f64:	e0090030 	and	r0, r9, r0, lsr r0
   16f68:	e0090038 	and	r0, r9, r8, lsr r0
   16f6c:	400017c0 	andmi	r1, r0, r0, asr #15
   16f70:	e0090014 	and	r0, r9, r4, lsl r0

00016f74 <USBHwEPGetStatus>:
   16f74:	e1a03000 	mov	r3, r0
   16f78:	e2000080 	and	r0, r0, #128	; 0x80
   16f7c:	e203300f 	and	r3, r3, #15	; 0xf
   16f80:	e1a003c0 	mov	r0, r0, asr #7
   16f84:	e52de004 	str	lr, [sp, #-4]!
   16f88:	e1800083 	orr	r0, r0, r3, lsl #1
   16f8c:	ebffff90 	bl	16dd4 <USBHwCmdRead>
   16f90:	e49de004 	ldr	lr, [sp], #4
   16f94:	e12fff1e 	bx	lr

00016f98 <_HandleRequest>:

	@return TRUE if the request was handles successfully
 */
static BOOL _HandleRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
   16f98:	e52de004 	str	lr, [sp, #-4]!
	TFnHandleRequest *pfnHandler;
	int iType;
	
	iType = REQTYPE_GET_TYPE(pSetup->bmRequestType);
	pfnHandler = apfnReqHandlers[iType];
   16f9c:	e5d03000 	ldrb	r3, [r0]
   16fa0:	e59fc02c 	ldr	ip, [pc, #44]	; 16fd4 <.text+0x6fd4>
   16fa4:	e1a032a3 	mov	r3, r3, lsr #5
   16fa8:	e2033003 	and	r3, r3, #3	; 0x3
   16fac:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
	if (pfnHandler == NULL) {
   16fb0:	e3530000 	cmp	r3, #0	; 0x0
   16fb4:	e1a0c003 	mov	ip, r3
   16fb8:	0a000002 	beq	16fc8 <_HandleRequest+0x30>
		DBG("No handler for reqtype %d\n", iType);
		return FALSE;
	}

	return pfnHandler(pSetup, piLen, ppbData);
   16fbc:	e1a0e00f 	mov	lr, pc
   16fc0:	e12fff13 	bx	r3
   16fc4:	e1a0c000 	mov	ip, r0
}
   16fc8:	e1a0000c 	mov	r0, ip
   16fcc:	e49de004 	ldr	lr, [sp], #4
   16fd0:	e12fff1e 	bx	lr
   16fd4:	40001810 	andmi	r1, r0, r0, lsl r8

00016fd8 <StallControlPipe>:


/**
	Local function to stall the control endpoint
	
	@param [in]	bEPStat	Endpoint status
 */
static void StallControlPipe(U8 bEPStat)
{
   16fd8:	e52de004 	str	lr, [sp, #-4]!
	U8	*pb;
	int	i;

	USBHwEPStall(0x80, TRUE);
   16fdc:	e3a00080 	mov	r0, #128	; 0x80
   16fe0:	e3a01001 	mov	r1, #1	; 0x1
   16fe4:	ebfffec1 	bl	16af0 <USBHwEPStall>
   16fe8:	e3a03008 	mov	r3, #8	; 0x8

// dump setup packet
	DBG("STALL on [");
	pb = (U8 *)&Setup;
	for (i = 0; i < 8; i++) {
   16fec:	e2533001 	subs	r3, r3, #1	; 0x1
   16ff0:	1afffffd 	bne	16fec <StallControlPipe+0x14>
		DBG(" %02x", *pb++);
	}
	DBG("] stat=%x\n", bEPStat);
}
   16ff4:	e49de004 	ldr	lr, [sp], #4
   16ff8:	e12fff1e 	bx	lr

00016ffc <DataIn>:


/**
	Sends next chunk of data (possibly 0 bytes) to host
 */
static void DataIn(void)
{
   16ffc:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
	int iChunk;

	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
   17000:	e59f603c 	ldr	r6, [pc, #60]	; 17044 <.text+0x7044>
   17004:	e5964000 	ldr	r4, [r6]
	USBHwEPWrite(0x80, pbData, iChunk);
   17008:	e59f5038 	ldr	r5, [pc, #56]	; 17048 <.text+0x7048>
   1700c:	e3540040 	cmp	r4, #64	; 0x40
   17010:	a3a04040 	movge	r4, #64	; 0x40
   17014:	e1a02004 	mov	r2, r4
   17018:	e3a00080 	mov	r0, #128	; 0x80
   1701c:	e5951000 	ldr	r1, [r5]
   17020:	ebffff46 	bl	16d40 <USBHwEPWrite>
	pbData += iChunk;
   17024:	e5953000 	ldr	r3, [r5]
	iResidue -= iChunk;
   17028:	e5962000 	ldr	r2, [r6]
   1702c:	e0833004 	add	r3, r3, r4
   17030:	e0642002 	rsb	r2, r4, r2
   17034:	e5853000 	str	r3, [r5]
   17038:	e5862000 	str	r2, [r6]
}
   1703c:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   17040:	e12fff1e 	bx	lr
   17044:	40001824 	andmi	r1, r0, r4, lsr #16
   17048:	40001828 	andmi	r1, r0, r8, lsr #16

0001704c <USBHandleControlTransfer>:


/**
 *	Handles IN/OUT transfers on EP0
 *
 *	@param [in]	bEP		Endpoint address
 *	@param [in]	bEPStat	Endpoint status
 */
void USBHandleControlTransfer(U8 bEP, U8 bEPStat)
{
	int iChunk, iType;

	if (bEP == 0x00) {
   1704c:	e21000ff 	ands	r0, r0, #255	; 0xff
   17050:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   17054:	e20170ff 	and	r7, r1, #255	; 0xff
   17058:	1a000043 	bne	1716c <USBHandleControlTransfer+0x120>
		// OUT transfer
		if (bEPStat & EP_STATUS_SETUP) {
   1705c:	e3110004 	tst	r1, #4	; 0x4
   17060:	e59f611c 	ldr	r6, [pc, #284]	; 17184 <.text+0x7184>
   17064:	0a00001d 	beq	170e0 <USBHandleControlTransfer+0x94>
			// setup packet, reset request message state machine
			USBHwEPRead(0x00, (U8 *)&Setup, sizeof(Setup));
   17068:	e59f5118 	ldr	r5, [pc, #280]	; 17188 <.text+0x7188>
   1706c:	e3a02008 	mov	r2, #8	; 0x8
   17070:	e1a01005 	mov	r1, r5
   17074:	ebffff06 	bl	16c94 <USBHwEPRead>
			DBG("S%x", Setup.bRequest);

			// defaults for data pointer and residue
			iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
   17078:	e5d50000 	ldrb	r0, [r5]
			pbData = apbDataStore[iType];
   1707c:	e59f2108 	ldr	r2, [pc, #264]	; 1718c <.text+0x718c>
   17080:	e1a032a0 	mov	r3, r0, lsr #5
			iResidue = Setup.wLength;
   17084:	e1d510b6 	ldrh	r1, [r5, #6]
   17088:	e2033003 	and	r3, r3, #3	; 0x3
   1708c:	e7923103 	ldr	r3, [r2, r3, lsl #2]
			iLen = Setup.wLength;
   17090:	e59f40f8 	ldr	r4, [pc, #248]	; 17190 <.text+0x7190>
   17094:	e59f20f8 	ldr	r2, [pc, #248]	; 17194 <.text+0x7194>

			if ((Setup.wLength == 0) ||
   17098:	e3510000 	cmp	r1, #0	; 0x0
   1709c:	e5823000 	str	r3, [r2]
   170a0:	e5861000 	str	r1, [r6]
   170a4:	e5841000 	str	r1, [r4]
   170a8:	0a000001 	beq	170b4 <USBHandleControlTransfer+0x68>
   170ac:	e1b003a0 	movs	r0, r0, lsr #7
   170b0:	0a000031 	beq	1717c <USBHandleControlTransfer+0x130>
				(REQTYPE_GET_DIR(Setup.bmRequestType) == REQTYPE_DIR_TO_HOST)) {
				// ask installed handler to process request
				if (!_HandleRequest(&Setup, &iLen, &pbData)) {
   170b4:	e1a00005 	mov	r0, r5
   170b8:	e1a01004 	mov	r1, r4
   170bc:	ebffffb5 	bl	16f98 <_HandleRequest>
   170c0:	e3500000 	cmp	r0, #0	; 0x0
   170c4:	0a000021 	beq	17150 <USBHandleControlTransfer+0x104>
					DBG("_HandleRequest1 failed\n");
					StallControlPipe(bEPStat);
					return;
				}
				// send smallest of requested and offered length
				iResidue = MIN(iLen, Setup.wLength);
   170c8:	e1d520b6 	ldrh	r2, [r5, #6]
   170cc:	e5943000 	ldr	r3, [r4]
   170d0:	e1520003 	cmp	r2, r3
   170d4:	d5862000 	strle	r2, [r6]
   170d8:	c5863000 	strgt	r3, [r6]
   170dc:	ea000024 	b	17174 <USBHandleControlTransfer+0x128>
				// send first part (possibly a zero-length status message)
				DataIn();
			}
		}
		else {		
			if (iResidue > 0) {
   170e0:	e5962000 	ldr	r2, [r6]
   170e4:	e3520000 	cmp	r2, #0	; 0x0
   170e8:	da00001b 	ble	1715c <USBHandleControlTransfer+0x110>
				// store data
				iChunk = USBHwEPRead(0x00, pbData, iResidue);
   170ec:	e59f40a0 	ldr	r4, [pc, #160]	; 17194 <.text+0x7194>
   170f0:	e5941000 	ldr	r1, [r4]
   170f4:	ebfffee6 	bl	16c94 <USBHwEPRead>
				if (iChunk < 0) {
   170f8:	e3500000 	cmp	r0, #0	; 0x0
   170fc:	ba000013 	blt	17150 <USBHandleControlTransfer+0x104>
					StallControlPipe(bEPStat);
					return;
				}
				pbData += iChunk;
				iResidue -= iChunk;
   17100:	e5962000 	ldr	r2, [r6]
   17104:	e5943000 	ldr	r3, [r4]
   17108:	e0602002 	rsb	r2, r0, r2
   1710c:	e0833000 	add	r3, r3, r0
				if (iResidue == 0) {
   17110:	e3520000 	cmp	r2, #0	; 0x0
   17114:	e5843000 	str	r3, [r4]
   17118:	e5862000 	str	r2, [r6]
   1711c:	1a000016 	bne	1717c <USBHandleControlTransfer+0x130>
					// received all, send data to handler
					iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
					pbData = apbDataStore[iType];
   17120:	e59f0060 	ldr	r0, [pc, #96]	; 17188 <.text+0x7188>
   17124:	e5d03000 	ldrb	r3, [r0]
   17128:	e59f205c 	ldr	r2, [pc, #92]	; 1718c <.text+0x718c>
   1712c:	e1a032a3 	mov	r3, r3, lsr #5
   17130:	e2033003 	and	r3, r3, #3	; 0x3
   17134:	e7923103 	ldr	r3, [r2, r3, lsl #2]
					if (!_HandleRequest(&Setup, &iLen, &pbData)) {
   17138:	e59f1050 	ldr	r1, [pc, #80]	; 17190 <.text+0x7190>
   1713c:	e1a02004 	mov	r2, r4
   17140:	e5843000 	str	r3, [r4]
   17144:	ebffff93 	bl	16f98 <_HandleRequest>
   17148:	e3500000 	cmp	r0, #0	; 0x0
   1714c:	1a000008 	bne	17174 <USBHandleControlTransfer+0x128>
						DBG("_HandleRequest2 failed\n");
						StallControlPipe(bEPStat);
   17150:	e1a00007 	mov	r0, r7
						return;
					}
					// send status to host
					DataIn();
				}
			}
			else {
				// absorb zero-length status message
				iChunk = USBHwEPRead(0x00, NULL, 0);
				DBG(iChunk > 0 ? "?" : "");
			}
		}
	}
	else if (bEP == 0x80) {
		// IN transfer
		// send more data if available (possibly a 0-length packet)
		DataIn();
	}
	else {
		ASSERT(FALSE);
	}
}
   17154:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   17158:	eaffff9e 	b	16fd8 <StallControlPipe>
   1715c:	e1a01000 	mov	r1, r0
   17160:	e1a02000 	mov	r2, r0
   17164:	ebfffeca 	bl	16c94 <USBHwEPRead>
   17168:	ea000003 	b	1717c <USBHandleControlTransfer+0x130>
   1716c:	e3500080 	cmp	r0, #128	; 0x80
   17170:	1a000001 	bne	1717c <USBHandleControlTransfer+0x130>
   17174:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   17178:	eaffff9f 	b	16ffc <DataIn>
   1717c:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   17180:	e12fff1e 	bx	lr
   17184:	40001824 	andmi	r1, r0, r4, lsr #16
   17188:	4000182c 	andmi	r1, r0, ip, lsr #16
   1718c:	40001800 	andmi	r1, r0, r0, lsl #16
   17190:	40001820 	andmi	r1, r0, r0, lsr #16
   17194:	40001828 	andmi	r1, r0, r8, lsr #16

00017198 <USBRegisterRequestHandler>:


/**
	Registers a callback for handling requests
		
	@param [in]	iType			Type of request, e.g. REQTYPE_TYPE_STANDARD
	@param [in]	*pfnHandler		Callback function pointer
	@param [in]	*pbDataStore	Data storage area for this type of request
 */
void USBRegisterRequestHandler(int iType, TFnHandleRequest *pfnHandler, U8 *pbDataStore)
{
	ASSERT(iType >= 0);
	ASSERT(iType < 4);
	apfnReqHandlers[iType] = pfnHandler;
	apbDataStore[iType] = pbDataStore;
   17198:	e59f300c 	ldr	r3, [pc, #12]	; 171ac <.text+0x71ac>
   1719c:	e7832100 	str	r2, [r3, r0, lsl #2]
   171a0:	e59f3008 	ldr	r3, [pc, #8]	; 171b0 <.text+0x71b0>
   171a4:	e7831100 	str	r1, [r3, r0, lsl #2]
}
   171a8:	e12fff1e 	bx	lr
   171ac:	40001800 	andmi	r1, r0, r0, lsl #16
   171b0:	40001810 	andmi	r1, r0, r0, lsl r8

000171b4 <USBRegisterDescriptors>:
 */
//void USBRegisterDescriptors(const U8 *pabDescriptors)
void USBRegisterDescriptors(U8 *pabDescriptors)
{
	pabDescrip = pabDescriptors;
   171b4:	e59f3004 	ldr	r3, [pc, #4]	; 171c0 <.text+0x71c0>
   171b8:	e5830000 	str	r0, [r3]
}
   171bc:	e12fff1e 	bx	lr
   171c0:	4000183c 	andmi	r1, r0, ip, lsr r8

000171c4 <USBGetDescriptor>:


/**
	Parses the list of installed USB descriptors and attempts to find
	the specified USB descriptor.
		
	@param [in]		wTypeIndex	Type and index of the descriptor
	@param [in]		wLangID		Language ID of the descriptor (currently unused)
	@param [out]	*piLen		Descriptor length
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetDescriptor(U16 wTypeIndex, U16 wLangID, int *piLen, U8 **ppbData)
{
   171c4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	U8	bType, bIndex;
	U8	*pab;
	int iCurIndex;
	
	ASSERT(pabDescrip != NULL);

	bType = GET_DESC_TYPE(wTypeIndex);
	bIndex = GET_DESC_INDEX(wTypeIndex);
	
	pab = (U8 *)pabDescrip;
   171c8:	e59f1074 	ldr	r1, [pc, #116]	; 17244 <.text+0x7244>
   171cc:	e1a00800 	mov	r0, r0, lsl #16
   171d0:	e591c000 	ldr	ip, [r1]
   171d4:	e1a01820 	mov	r1, r0, lsr #16
   171d8:	e1a05002 	mov	r5, r2
   171dc:	e1a04003 	mov	r4, r3
   171e0:	e1a0ec20 	mov	lr, r0, lsr #24
   171e4:	e20110ff 	and	r1, r1, #255	; 0xff
   171e8:	e3a02000 	mov	r2, #0	; 0x0
   171ec:	ea00000f 	b	17230 <USBGetDescriptor+0x6c>
	iCurIndex = 0;
	
	while (pab[DESC_bLength] != 0) {
		if (pab[DESC_bDescriptorType] == bType) {
   171f0:	e5dc3001 	ldrb	r3, [ip, #1]
   171f4:	e153000e 	cmp	r3, lr
   171f8:	1a00000b 	bne	1722c <USBGetDescriptor+0x68>
			if (iCurIndex == bIndex) {
   171fc:	e1520001 	cmp	r2, r1
				// set data pointer
				*ppbData = pab;
				// get length from structure
				if (bType == DESC_CONFIGURATION) {
					// configuration descriptor is an exception, length is at offset 2 and 3
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
								(pab[CONF_DESC_wTotalLength + 1] << 8);
				}
				else {
					// normally length is at offset 0
					*piLen = pab[DESC_bLength];
				}
				return TRUE;
			}
			iCurIndex++;
   17200:	e2822001 	add	r2, r2, #1	; 0x1
   17204:	1a000008 	bne	1722c <USBGetDescriptor+0x68>
   17208:	e584c000 	str	ip, [r4]
   1720c:	e35e0002 	cmp	lr, #2	; 0x2
   17210:	05dc2003 	ldreqb	r2, [ip, #3]
   17214:	05dc3002 	ldreqb	r3, [ip, #2]
   17218:	15dc3000 	ldrneb	r3, [ip]
   1721c:	01833402 	orreq	r3, r3, r2, lsl #8
   17220:	e3a00001 	mov	r0, #1	; 0x1
   17224:	e5853000 	str	r3, [r5]
   17228:	ea000003 	b	1723c <USBGetDescriptor+0x78>
		}
		// skip to next descriptor
		pab += pab[DESC_bLength];
   1722c:	e08cc000 	add	ip, ip, r0
   17230:	e5dc0000 	ldrb	r0, [ip]
   17234:	e3500000 	cmp	r0, #0	; 0x0
   17238:	1affffec 	bne	171f0 <USBGetDescriptor+0x2c>
	}
	// nothing found
	DBG("Desc %x not found!\n", wTypeIndex);
	return FALSE;
}
   1723c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   17240:	e12fff1e 	bx	lr
   17244:	4000183c 	andmi	r1, r0, ip, lsr r8

00017248 <USBHandleStandardRequest>:


/**
	Configures the device according to the specified configuration index and
	alternate setting by parsing the installed USB descriptor list.
	A configuration index of 0 unconfigures the device.
		
	@param [in]		bConfigIndex	Configuration index
	@param [in]		bAltSetting		Alternate setting number
	
	@todo function always returns TRUE, add stricter checking?
	
	@return TRUE if successfully configured, FALSE otherwise
 */
static BOOL USBSetConfiguration(U8 bConfigIndex, U8 bAltSetting)
{
	U8	*pab;
	U8	bCurConfig, bCurAltSetting;
	U8	bEP;
	U16	wMaxPktSize;
	
	ASSERT(pabDescrip != NULL);

	if (bConfigIndex == 0) {
		// unconfigure device
		USBHwConfigDevice(FALSE);
	}
	else {
		// configure endpoints for this configuration/altsetting
		pab = (U8 *)pabDescrip;
		bCurConfig = 0xFF;
		bCurAltSetting = 0xFF;

		while (pab[DESC_bLength] != 0) {

			switch (pab[DESC_bDescriptorType]) {

			case DESC_CONFIGURATION:
				// remember current configuration index
				bCurConfig = pab[CONF_DESC_bConfigurationValue];
				break;

			case DESC_INTERFACE:
				// remember current alternate setting
				bCurAltSetting = pab[INTF_DESC_bAlternateSetting];
				break;

			case DESC_ENDPOINT:
				if ((bCurConfig == bConfigIndex) &&
					(bCurAltSetting == bAltSetting)) {
					// endpoint found for desired config and alternate setting
					bEP = pab[ENDP_DESC_bEndpointAddress];
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
					// configure endpoint
					USBHwEPConfig(bEP, wMaxPktSize);
				}
				break;

			default:
				break;
			}
			// skip to next descriptor
			pab += pab[DESC_bLength];
		}
		
		// configure device
		USBHwConfigDevice(TRUE);
	}

	return TRUE;
}


/**
	Local function to handle a standard device request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in,out]	ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdDeviceReq(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
	
	case REQ_GET_STATUS:
		// bit 0: self-powered
		// bit 1: remote wakeup = not supported
		pbData[0] = 0;
		pbData[1] = 0;
		*piLen = 2;
		break;
		
	case REQ_SET_ADDRESS:
		USBHwSetAddress(pSetup->wValue);
		break;

	case REQ_GET_DESCRIPTOR:
		DBG("D%x", pSetup->wValue);
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);

	case REQ_GET_CONFIGURATION:
		// indicate if we are configured
		pbData[0] = bConfiguration;
		*piLen = 1;
		break;

	case REQ_SET_CONFIGURATION:
		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
			DBG("USBSetConfiguration failed!\n");
			return FALSE;
		}
		// configuration successful, update current configuration
		bConfiguration = pSetup->wValue & 0xFF;	
		break;

	case REQ_CLEAR_FEATURE:
	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_REMOTE_WAKEUP) {
			// put DEVICE_REMOTE_WAKEUP code here
		}
		if (pSetup->wValue == FEA_TEST_MODE) {
			// put TEST_MODE code here
		}
		return FALSE;

	case REQ_SET_DESCRIPTOR:
		DBG("Device req %d not implemented\n", pSetup->bRequest);
		return FALSE;

	default:
		DBG("Illegal device req %d\n", pSetup->bRequest);
		return FALSE;
	}
	
	return TRUE;
}


/**
	Local function to handle a standard interface request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdInterfaceReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {

	case REQ_GET_STATUS:
		// no bits specified
		pbData[0] = 0;
		pbData[1] = 0;
		*piLen = 2;
		break;

	case REQ_CLEAR_FEATURE:
	case REQ_SET_FEATURE:
		// not defined for interface
		return FALSE;
	
	case REQ_GET_INTERFACE:	// TODO use bNumInterfaces
        // there is only one interface, return n-1 (= 0)
		pbData[0] = 0;
		*piLen = 1;
		break;
	
	case REQ_SET_INTERFACE:	// TODO use bNumInterfaces
		// there is only one interface (= 0)
		if (pSetup->wValue != 0) {
			return FALSE;
		}
		*piLen = 0;
		break;

	default:
		DBG("Illegal interface req %d\n", pSetup->bRequest);
		return FALSE;
	}

	return TRUE;
}


/**
	Local function to handle a standard endpoint request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdEndPointReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
	case REQ_GET_STATUS:
		// bit 0 = endpointed halted or not
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
		pbData[1] = 0;
		*piLen = 2;
		break;
		
	case REQ_CLEAR_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
			// clear HALT by unstalling
			USBHwEPStall(pSetup->wIndex, FALSE);
			break;
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;
	
	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
			// set HALT by stalling
			USBHwEPStall(pSetup->wIndex, TRUE);
			break;
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;

	case REQ_SYNCH_FRAME:
		DBG("EP req %d not implemented\n", pSetup->bRequest);
		return FALSE;

	default:
		DBG("Illegal EP req %d\n", pSetup->bRequest);
		return FALSE;
	}
	
	return TRUE;
}


/**
	Default handler for standard ('chapter 9') requests
	
	If a custom request handler was installed, this handler is called first.
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
   17248:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
   1724c:	e59f3260 	ldr	r3, [pc, #608]	; 174b4 <.text+0x74b4>
   17250:	e5933000 	ldr	r3, [r3]
   17254:	e3530000 	cmp	r3, #0	; 0x0
   17258:	e1a05000 	mov	r5, r0
   1725c:	e1a08001 	mov	r8, r1
   17260:	e1a07002 	mov	r7, r2
   17264:	0a000003 	beq	17278 <USBHandleStandardRequest+0x30>
   17268:	e1a0e00f 	mov	lr, pc
   1726c:	e12fff13 	bx	r3
   17270:	e3500000 	cmp	r0, #0	; 0x0
   17274:	1a00001e 	bne	172f4 <.text+0x72f4>
		return TRUE;
	}
	
	switch (REQTYPE_GET_RECIP(pSetup->bmRequestType)) {
   17278:	e5d53000 	ldrb	r3, [r5]
   1727c:	e203401f 	and	r4, r3, #31	; 0x1f
   17280:	e3540001 	cmp	r4, #1	; 0x1
   17284:	0a00004e 	beq	173c4 <.text+0x73c4>
   17288:	e3540002 	cmp	r4, #2	; 0x2
   1728c:	0a000064 	beq	17424 <.text+0x7424>
   17290:	e3540000 	cmp	r4, #0	; 0x0
   17294:	1a000082 	bne	174a4 <.text+0x74a4>
   17298:	e5d53001 	ldrb	r3, [r5, #1]
   1729c:	e5971000 	ldr	r1, [r7]
   172a0:	e3530009 	cmp	r3, #9	; 0x9
   172a4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   172a8:	ea00007d 	b	174a4 <.text+0x74a4>
   172ac:	000172d4 	ldreqd	r7, [r1], -r4
   172b0:	000174a4 	andeq	r7, r1, r4, lsr #9
   172b4:	000174a4 	andeq	r7, r1, r4, lsr #9
   172b8:	000174a4 	andeq	r7, r1, r4, lsr #9
   172bc:	000174a4 	andeq	r7, r1, r4, lsr #9
   172c0:	000172ec 	andeq	r7, r1, ip, ror #5
   172c4:	000172fc 	streqd	r7, [r1], -ip
   172c8:	000174a4 	andeq	r7, r1, r4, lsr #9
   172cc:	00017314 	andeq	r7, r1, r4, lsl r3
   172d0:	00017330 	andeq	r7, r1, r0, lsr r3
   172d4:	e3a03000 	mov	r3, #0	; 0x0
   172d8:	e5c13001 	strb	r3, [r1, #1]
   172dc:	e5c13000 	strb	r3, [r1]
   172e0:	e3a0c001 	mov	ip, #1	; 0x1
   172e4:	e2833002 	add	r3, r3, #2	; 0x2
   172e8:	ea00000e 	b	17328 <.text+0x7328>
   172ec:	e5d50002 	ldrb	r0, [r5, #2]
   172f0:	ebfffe47 	bl	16c14 <USBHwSetAddress>
   172f4:	e3a0c001 	mov	ip, #1	; 0x1
   172f8:	ea00006a 	b	174a8 <.text+0x74a8>
   172fc:	e1d510b4 	ldrh	r1, [r5, #4]
   17300:	e1d500b2 	ldrh	r0, [r5, #2]
   17304:	e1a02008 	mov	r2, r8
   17308:	e1a03007 	mov	r3, r7
	case REQTYPE_RECIP_DEVICE:		return HandleStdDeviceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
	default: 						return FALSE;
	}
}
   1730c:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   17310:	eaffffab 	b	171c4 <USBGetDescriptor>
   17314:	e59f319c 	ldr	r3, [pc, #412]	; 174b8 <.text+0x74b8>
   17318:	e5d32000 	ldrb	r2, [r3]
   1731c:	e3a03001 	mov	r3, #1	; 0x1
   17320:	e5c12000 	strb	r2, [r1]
   17324:	e1a0c003 	mov	ip, r3
   17328:	e5883000 	str	r3, [r8]
   1732c:	ea00005d 	b	174a8 <.text+0x74a8>
   17330:	e5d56002 	ldrb	r6, [r5, #2]
   17334:	e3560000 	cmp	r6, #0	; 0x0
   17338:	01a00006 	moveq	r0, r6
   1733c:	0a00001a 	beq	173ac <.text+0x73ac>
   17340:	e59f3174 	ldr	r3, [pc, #372]	; 174bc <.text+0x74bc>
   17344:	e3a070ff 	mov	r7, #255	; 0xff
   17348:	e5934000 	ldr	r4, [r3]
   1734c:	e1a08007 	mov	r8, r7
   17350:	ea000011 	b	1739c <.text+0x739c>
   17354:	e5d43001 	ldrb	r3, [r4, #1]
   17358:	e3530004 	cmp	r3, #4	; 0x4
   1735c:	05d47003 	ldreqb	r7, [r4, #3]
   17360:	0a00000b 	beq	17394 <.text+0x7394>
   17364:	e3530005 	cmp	r3, #5	; 0x5
   17368:	0a000002 	beq	17378 <.text+0x7378>
   1736c:	e3530002 	cmp	r3, #2	; 0x2
   17370:	05d48005 	ldreqb	r8, [r4, #5]
   17374:	ea000006 	b	17394 <.text+0x7394>
   17378:	e1580006 	cmp	r8, r6
   1737c:	03570000 	cmpeq	r7, #0	; 0x0
   17380:	05d43004 	ldreqb	r3, [r4, #4]
   17384:	05d41005 	ldreqb	r1, [r4, #5]
   17388:	05d40002 	ldreqb	r0, [r4, #2]
   1738c:	01831401 	orreq	r1, r3, r1, lsl #8
   17390:	0bfffe23 	bleq	16c24 <USBHwEPConfig>
   17394:	e5d43000 	ldrb	r3, [r4]
   17398:	e0844003 	add	r4, r4, r3
   1739c:	e5d43000 	ldrb	r3, [r4]
   173a0:	e3530000 	cmp	r3, #0	; 0x0
   173a4:	1affffea 	bne	17354 <.text+0x7354>
   173a8:	e3a00001 	mov	r0, #1	; 0x1
   173ac:	ebfffdcb 	bl	16ae0 <USBHwConfigDevice>
   173b0:	e1d520b2 	ldrh	r2, [r5, #2]
   173b4:	e59f30fc 	ldr	r3, [pc, #252]	; 174b8 <.text+0x74b8>
   173b8:	e3a0c001 	mov	ip, #1	; 0x1
   173bc:	e5c32000 	strb	r2, [r3]
   173c0:	ea000038 	b	174a8 <.text+0x74a8>
   173c4:	e5d53001 	ldrb	r3, [r5, #1]
   173c8:	e3530000 	cmp	r3, #0	; 0x0
   173cc:	e5972000 	ldr	r2, [r7]
   173d0:	0a000004 	beq	173e8 <.text+0x73e8>
   173d4:	e353000a 	cmp	r3, #10	; 0xa
   173d8:	0a000007 	beq	173fc <.text+0x73fc>
   173dc:	e353000b 	cmp	r3, #11	; 0xb
   173e0:	1a00002f 	bne	174a4 <.text+0x74a4>
   173e4:	ea000008 	b	1740c <.text+0x740c>
   173e8:	e5c23001 	strb	r3, [r2, #1]
   173ec:	e5c23000 	strb	r3, [r2]
   173f0:	e1a0c004 	mov	ip, r4
   173f4:	e3a03002 	mov	r3, #2	; 0x2
   173f8:	eaffffca 	b	17328 <.text+0x7328>
   173fc:	e3a03000 	mov	r3, #0	; 0x0
   17400:	e1a0c004 	mov	ip, r4
   17404:	e5c23000 	strb	r3, [r2]
   17408:	ea000015 	b	17464 <.text+0x7464>
   1740c:	e1d500b2 	ldrh	r0, [r5, #2]
   17410:	e3500000 	cmp	r0, #0	; 0x0
   17414:	03a0c001 	moveq	ip, #1	; 0x1
   17418:	05880000 	streq	r0, [r8]
   1741c:	0a000021 	beq	174a8 <.text+0x74a8>
   17420:	ea00001f 	b	174a4 <.text+0x74a4>
   17424:	e5d56001 	ldrb	r6, [r5, #1]
   17428:	e3560001 	cmp	r6, #1	; 0x1
   1742c:	e5977000 	ldr	r7, [r7]
   17430:	0a00000d 	beq	1746c <.text+0x746c>
   17434:	3a000002 	bcc	17444 <.text+0x7444>
   17438:	e3560003 	cmp	r6, #3	; 0x3
   1743c:	1a000018 	bne	174a4 <.text+0x74a4>
   17440:	ea000010 	b	17488 <.text+0x7488>
   17444:	e5d50004 	ldrb	r0, [r5, #4]
   17448:	ebfffec9 	bl	16f74 <USBHwEPGetStatus>
   1744c:	e1a000a0 	mov	r0, r0, lsr #1
   17450:	e2000001 	and	r0, r0, #1	; 0x1
   17454:	e3a03000 	mov	r3, #0	; 0x0
   17458:	e5c73001 	strb	r3, [r7, #1]
   1745c:	e5c70000 	strb	r0, [r7]
   17460:	e3a0c001 	mov	ip, #1	; 0x1
   17464:	e5884000 	str	r4, [r8]
   17468:	ea00000e 	b	174a8 <.text+0x74a8>
   1746c:	e1d510b2 	ldrh	r1, [r5, #2]
   17470:	e3510000 	cmp	r1, #0	; 0x0
   17474:	1a00000a 	bne	174a4 <.text+0x74a4>
   17478:	e5d50004 	ldrb	r0, [r5, #4]
   1747c:	ebfffd9b 	bl	16af0 <USBHwEPStall>
   17480:	e1a0c006 	mov	ip, r6
   17484:	ea000007 	b	174a8 <.text+0x74a8>
   17488:	e1d530b2 	ldrh	r3, [r5, #2]
   1748c:	e3530000 	cmp	r3, #0	; 0x0
   17490:	1a000003 	bne	174a4 <.text+0x74a4>
   17494:	e5d50004 	ldrb	r0, [r5, #4]
   17498:	e3a01001 	mov	r1, #1	; 0x1
   1749c:	ebfffd93 	bl	16af0 <USBHwEPStall>
   174a0:	eaffff93 	b	172f4 <.text+0x72f4>
   174a4:	e3a0c000 	mov	ip, #0	; 0x0
   174a8:	e1a0000c 	mov	r0, ip
   174ac:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   174b0:	e12fff1e 	bx	lr
   174b4:	40001834 	andmi	r1, r0, r4, lsr r8
   174b8:	40001838 	andmi	r1, r0, r8, lsr r8
   174bc:	4000183c 	andmi	r1, r0, ip, lsr r8

000174c0 <USBRegisterCustomReqHandler>:


/**
	Registers a callback for custom device requests
	
	In USBHandleStandardRequest, the custom request handler gets a first
	chance at handling the request before it is handed over to the 'chapter 9'
	request handler.
	
	This can be used for example in HID devices, where a REQ_GET_DESCRIPTOR
	request is sent to an interface, which is not covered by the 'chapter 9'
	specification.
		
	@param [in]	pfnHandler	Callback function pointer
 */
void USBRegisterCustomReqHandler(TFnHandleRequest *pfnHandler)
{
	pfnHandleCustomReq = pfnHandler;
   174c0:	e59f3004 	ldr	r3, [pc, #4]	; 174cc <.text+0x74cc>
   174c4:	e5830000 	str	r0, [r3]
}
   174c8:	e12fff1e 	bx	lr
   174cc:	40001834 	andmi	r1, r0, r4, lsr r8

000174d0 <malloc>:
   174d0:	e52de004 	str	lr, [sp, #-4]!
   174d4:	e59f3010 	ldr	r3, [pc, #16]	; 174ec <.text+0x74ec>
   174d8:	e1a01000 	mov	r1, r0
   174dc:	e5930000 	ldr	r0, [r3]
   174e0:	eb00000a 	bl	17510 <_malloc_r>
   174e4:	e49de004 	ldr	lr, [sp], #4
   174e8:	e12fff1e 	bx	lr
   174ec:	40000ecc 	andmi	r0, r0, ip, asr #29

000174f0 <free>:
   174f0:	e52de004 	str	lr, [sp, #-4]!
   174f4:	e59f3010 	ldr	r3, [pc, #16]	; 1750c <.text+0x750c>
   174f8:	e1a01000 	mov	r1, r0
   174fc:	e5930000 	ldr	r0, [r3]
   17500:	eb0003f7 	bl	184e4 <_free_r>
   17504:	e49de004 	ldr	lr, [sp], #4
   17508:	e12fff1e 	bx	lr
   1750c:	40000ecc 	andmi	r0, r0, ip, asr #29

00017510 <_malloc_r>:
   17510:	e281300b 	add	r3, r1, #11	; 0xb
   17514:	e3530016 	cmp	r3, #22	; 0x16
   17518:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1751c:	93a05010 	movls	r5, #16	; 0x10
   17520:	83c35007 	bichi	r5, r3, #7	; 0x7
   17524:	91a02005 	movls	r2, r5
   17528:	81a02005 	movhi	r2, r5
   1752c:	e1550001 	cmp	r5, r1
   17530:	23a03000 	movcs	r3, #0	; 0x0
   17534:	33a03001 	movcc	r3, #1	; 0x1
   17538:	e1932fa2 	orrs	r2, r3, r2, lsr #31
   1753c:	e1a07000 	mov	r7, r0
   17540:	13a0300c 	movne	r3, #12	; 0xc
   17544:	e24dd004 	sub	sp, sp, #4	; 0x4
   17548:	13a00000 	movne	r0, #0	; 0x0
   1754c:	15873000 	strne	r3, [r7]
   17550:	1a000017 	bne	175b4 <_malloc_r+0xa4>
   17554:	e1a00007 	mov	r0, r7
   17558:	eb000222 	bl	17de8 <__malloc_lock>
   1755c:	e3550f7e 	cmp	r5, #504	; 0x1f8
   17560:	2a000016 	bcs	175c0 <_malloc_r+0xb0>
   17564:	e59f8710 	ldr	r8, [pc, #1808]	; 17c7c <.text+0x7c7c>
   17568:	e1a021a5 	mov	r2, r5, lsr #3
   1756c:	e0883182 	add	r3, r8, r2, lsl #3
   17570:	e593400c 	ldr	r4, [r3, #12]
   17574:	e1530004 	cmp	r3, r4
   17578:	e1a0a008 	mov	sl, r8
   1757c:	0a000077 	beq	17760 <_malloc_r+0x250>
   17580:	e5943004 	ldr	r3, [r4, #4]
   17584:	e3c33003 	bic	r3, r3, #3	; 0x3
   17588:	e0843003 	add	r3, r4, r3
   1758c:	e5932004 	ldr	r2, [r3, #4]
   17590:	e594000c 	ldr	r0, [r4, #12]
   17594:	e5941008 	ldr	r1, [r4, #8]
   17598:	e3822001 	orr	r2, r2, #1	; 0x1
   1759c:	e5801008 	str	r1, [r0, #8]
   175a0:	e581000c 	str	r0, [r1, #12]
   175a4:	e5832004 	str	r2, [r3, #4]
   175a8:	e1a00007 	mov	r0, r7
   175ac:	eb00020e 	bl	17dec <__malloc_unlock>
   175b0:	e2840008 	add	r0, r4, #8	; 0x8
   175b4:	e28dd004 	add	sp, sp, #4	; 0x4
   175b8:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   175bc:	e12fff1e 	bx	lr
   175c0:	e1b024a5 	movs	r2, r5, lsr #9
   175c4:	01a001a5 	moveq	r0, r5, lsr #3
   175c8:	01a03180 	moveq	r3, r0, lsl #3
   175cc:	1a00002f 	bne	17690 <_malloc_r+0x180>
   175d0:	e59f86a4 	ldr	r8, [pc, #1700]	; 17c7c <.text+0x7c7c>
   175d4:	e0831008 	add	r1, r3, r8
   175d8:	e591400c 	ldr	r4, [r1, #12]
   175dc:	e1510004 	cmp	r1, r4
   175e0:	e1a0a008 	mov	sl, r8
   175e4:	0a000013 	beq	17638 <_malloc_r+0x128>
   175e8:	e5943004 	ldr	r3, [r4, #4]
   175ec:	e3c33003 	bic	r3, r3, #3	; 0x3
   175f0:	e0652003 	rsb	r2, r5, r3
   175f4:	e352000f 	cmp	r2, #15	; 0xf
   175f8:	ca00000d 	bgt	17634 <_malloc_r+0x124>
   175fc:	e3520000 	cmp	r2, #0	; 0x0
   17600:	ba000045 	blt	1771c <_malloc_r+0x20c>
   17604:	e0840003 	add	r0, r4, r3
   17608:	e5903004 	ldr	r3, [r0, #4]
   1760c:	e594100c 	ldr	r1, [r4, #12]
   17610:	e5942008 	ldr	r2, [r4, #8]
   17614:	e3833001 	orr	r3, r3, #1	; 0x1
   17618:	e5803004 	str	r3, [r0, #4]
   1761c:	e5812008 	str	r2, [r1, #8]
   17620:	e1a00007 	mov	r0, r7
   17624:	e582100c 	str	r1, [r2, #12]
   17628:	eb0001ef 	bl	17dec <__malloc_unlock>
   1762c:	e2840008 	add	r0, r4, #8	; 0x8
   17630:	eaffffdf 	b	175b4 <_malloc_r+0xa4>
   17634:	e2400001 	sub	r0, r0, #1	; 0x1
   17638:	e280e001 	add	lr, r0, #1	; 0x1
   1763c:	e59f663c 	ldr	r6, [pc, #1596]	; 17c80 <.text+0x7c80>
   17640:	e5964008 	ldr	r4, [r6, #8]
   17644:	e1560004 	cmp	r6, r4
   17648:	0a00007b 	beq	1783c <_malloc_r+0x32c>
   1764c:	e5943004 	ldr	r3, [r4, #4]
   17650:	e3c32003 	bic	r2, r3, #3	; 0x3
   17654:	e0650002 	rsb	r0, r5, r2
   17658:	e350000f 	cmp	r0, #15	; 0xf
   1765c:	ca000032 	bgt	1772c <_malloc_r+0x21c>
   17660:	e3500000 	cmp	r0, #0	; 0x0
   17664:	e586600c 	str	r6, [r6, #12]
   17668:	e5866008 	str	r6, [r6, #8]
   1766c:	ba000041 	blt	17778 <_malloc_r+0x268>
   17670:	e0842002 	add	r2, r4, r2
   17674:	e5923004 	ldr	r3, [r2, #4]
   17678:	e3833001 	orr	r3, r3, #1	; 0x1
   1767c:	e1a00007 	mov	r0, r7
   17680:	e5823004 	str	r3, [r2, #4]
   17684:	eb0001d8 	bl	17dec <__malloc_unlock>
   17688:	e2840008 	add	r0, r4, #8	; 0x8
   1768c:	eaffffc8 	b	175b4 <_malloc_r+0xa4>
   17690:	e3520004 	cmp	r2, #4	; 0x4
   17694:	91a03325 	movls	r3, r5, lsr #6
   17698:	92830038 	addls	r0, r3, #56	; 0x38
   1769c:	91a03180 	movls	r3, r0, lsl #3
   176a0:	9affffca 	bls	175d0 <_malloc_r+0xc0>
   176a4:	e3520014 	cmp	r2, #20	; 0x14
   176a8:	9282005b 	addls	r0, r2, #91	; 0x5b
   176ac:	91a03180 	movls	r3, r0, lsl #3
   176b0:	9affffc6 	bls	175d0 <_malloc_r+0xc0>
   176b4:	e3520054 	cmp	r2, #84	; 0x54
   176b8:	91a03625 	movls	r3, r5, lsr #12
   176bc:	9283006e 	addls	r0, r3, #110	; 0x6e
   176c0:	91a03180 	movls	r3, r0, lsl #3
   176c4:	9affffc1 	bls	175d0 <_malloc_r+0xc0>
   176c8:	e3520f55 	cmp	r2, #340	; 0x154
   176cc:	91a037a5 	movls	r3, r5, lsr #15
   176d0:	92830077 	addls	r0, r3, #119	; 0x77
   176d4:	91a03180 	movls	r3, r0, lsl #3
   176d8:	9affffbc 	bls	175d0 <_malloc_r+0xc0>
   176dc:	e3a03e55 	mov	r3, #1360	; 0x550
   176e0:	e2833004 	add	r3, r3, #4	; 0x4
   176e4:	e1520003 	cmp	r2, r3
   176e8:	91a03925 	movls	r3, r5, lsr #18
   176ec:	9283007c 	addls	r0, r3, #124	; 0x7c
   176f0:	83a0007e 	movhi	r0, #126	; 0x7e
   176f4:	82433f59 	subhi	r3, r3, #356	; 0x164
   176f8:	91a03180 	movls	r3, r0, lsl #3
   176fc:	eaffffb3 	b	175d0 <_malloc_r+0xc0>
   17700:	e5943004 	ldr	r3, [r4, #4]
   17704:	e3c33003 	bic	r3, r3, #3	; 0x3
   17708:	e0652003 	rsb	r2, r5, r3
   1770c:	e352000f 	cmp	r2, #15	; 0xf
   17710:	caffffc7 	bgt	17634 <_malloc_r+0x124>
   17714:	e3520000 	cmp	r2, #0	; 0x0
   17718:	aaffffb9 	bge	17604 <_malloc_r+0xf4>
   1771c:	e594400c 	ldr	r4, [r4, #12]
   17720:	e1510004 	cmp	r1, r4
   17724:	1afffff5 	bne	17700 <_malloc_r+0x1f0>
   17728:	eaffffc2 	b	17638 <_malloc_r+0x128>
   1772c:	e0842005 	add	r2, r4, r5
   17730:	e3801001 	orr	r1, r0, #1	; 0x1
   17734:	e3853001 	orr	r3, r5, #1	; 0x1
   17738:	e7820000 	str	r0, [r2, r0]
   1773c:	e5843004 	str	r3, [r4, #4]
   17740:	e586200c 	str	r2, [r6, #12]
   17744:	e5862008 	str	r2, [r6, #8]
   17748:	e1a00007 	mov	r0, r7
   1774c:	e9820042 	stmib	r2, {r1, r6}
   17750:	e582600c 	str	r6, [r2, #12]
   17754:	eb0001a4 	bl	17dec <__malloc_unlock>
   17758:	e2840008 	add	r0, r4, #8	; 0x8
   1775c:	eaffff94 	b	175b4 <_malloc_r+0xa4>
   17760:	e2843008 	add	r3, r4, #8	; 0x8
   17764:	e593400c 	ldr	r4, [r3, #12]
   17768:	e1530004 	cmp	r3, r4
   1776c:	1affff83 	bne	17580 <_malloc_r+0x70>
   17770:	e282e002 	add	lr, r2, #2	; 0x2
   17774:	eaffffb0 	b	1763c <_malloc_r+0x12c>
   17778:	e3520c02 	cmp	r2, #512	; 0x200
   1777c:	3a000095 	bcc	179d8 <_malloc_r+0x4c8>
   17780:	e1b014a2 	movs	r1, r2, lsr #9
   17784:	01a011a2 	moveq	r1, r2, lsr #3
   17788:	01a03181 	moveq	r3, r1, lsl #3
   1778c:	0a00001a 	beq	177fc <_malloc_r+0x2ec>
   17790:	e3510004 	cmp	r1, #4	; 0x4
   17794:	91a03322 	movls	r3, r2, lsr #6
   17798:	92831038 	addls	r1, r3, #56	; 0x38
   1779c:	91a03181 	movls	r3, r1, lsl #3
   177a0:	9a000015 	bls	177fc <_malloc_r+0x2ec>
   177a4:	e3510014 	cmp	r1, #20	; 0x14
   177a8:	9281105b 	addls	r1, r1, #91	; 0x5b
   177ac:	91a03181 	movls	r3, r1, lsl #3
   177b0:	9a000011 	bls	177fc <_malloc_r+0x2ec>
   177b4:	e3510054 	cmp	r1, #84	; 0x54
   177b8:	91a03622 	movls	r3, r2, lsr #12
   177bc:	9283106e 	addls	r1, r3, #110	; 0x6e
   177c0:	91a03181 	movls	r3, r1, lsl #3
   177c4:	9a00000c 	bls	177fc <_malloc_r+0x2ec>
   177c8:	e3510f55 	cmp	r1, #340	; 0x154
   177cc:	91a037a2 	movls	r3, r2, lsr #15
   177d0:	92831077 	addls	r1, r3, #119	; 0x77
   177d4:	91a03181 	movls	r3, r1, lsl #3
   177d8:	9a000007 	bls	177fc <_malloc_r+0x2ec>
   177dc:	e3a03e55 	mov	r3, #1360	; 0x550
   177e0:	e2833004 	add	r3, r3, #4	; 0x4
   177e4:	e1510003 	cmp	r1, r3
   177e8:	91a03922 	movls	r3, r2, lsr #18
   177ec:	9283107c 	addls	r1, r3, #124	; 0x7c
   177f0:	83a0107e 	movhi	r1, #126	; 0x7e
   177f4:	82433f59 	subhi	r3, r3, #356	; 0x164
   177f8:	91a03181 	movls	r3, r1, lsl #3
   177fc:	e088c003 	add	ip, r8, r3
   17800:	e59c0008 	ldr	r0, [ip, #8]
   17804:	e15c0000 	cmp	ip, r0
   17808:	0a000100 	beq	17c10 <_malloc_r+0x700>
   1780c:	e5903004 	ldr	r3, [r0, #4]
   17810:	e3c33003 	bic	r3, r3, #3	; 0x3
   17814:	e1520003 	cmp	r2, r3
   17818:	2a000002 	bcs	17828 <_malloc_r+0x318>
   1781c:	e5900008 	ldr	r0, [r0, #8]
   17820:	e15c0000 	cmp	ip, r0
   17824:	1afffff8 	bne	1780c <_malloc_r+0x2fc>
   17828:	e590c00c 	ldr	ip, [r0, #12]
   1782c:	e584c00c 	str	ip, [r4, #12]
   17830:	e5840008 	str	r0, [r4, #8]
   17834:	e580400c 	str	r4, [r0, #12]
   17838:	e58c4008 	str	r4, [ip, #8]
   1783c:	e59a0004 	ldr	r0, [sl, #4]
   17840:	e35e0000 	cmp	lr, #0	; 0x0
   17844:	e28e3003 	add	r3, lr, #3	; 0x3
   17848:	a1a0300e 	movge	r3, lr
   1784c:	e1a03143 	mov	r3, r3, asr #2
   17850:	e3a02001 	mov	r2, #1	; 0x1
   17854:	e1a02312 	mov	r2, r2, lsl r3
   17858:	e1520000 	cmp	r2, r0
   1785c:	8a00001e 	bhi	178dc <_malloc_r+0x3cc>
   17860:	e1120000 	tst	r2, r0
   17864:	0a000068 	beq	17a0c <_malloc_r+0x4fc>
   17868:	e088918e 	add	r9, r8, lr, lsl #3
   1786c:	e1a0a00e 	mov	sl, lr
   17870:	e1a01009 	mov	r1, r9
   17874:	e591400c 	ldr	r4, [r1, #12]
   17878:	e1510004 	cmp	r1, r4
   1787c:	1a000003 	bne	17890 <_malloc_r+0x380>
   17880:	ea00006b 	b	17a34 <_malloc_r+0x524>
   17884:	e594400c 	ldr	r4, [r4, #12]
   17888:	e1510004 	cmp	r1, r4
   1788c:	0a000068 	beq	17a34 <_malloc_r+0x524>
   17890:	e5943004 	ldr	r3, [r4, #4]
   17894:	e3c33003 	bic	r3, r3, #3	; 0x3
   17898:	e065c003 	rsb	ip, r5, r3
   1789c:	e35c000f 	cmp	ip, #15	; 0xf
   178a0:	ca0000c6 	bgt	17bc0 <_malloc_r+0x6b0>
   178a4:	e35c0000 	cmp	ip, #0	; 0x0
   178a8:	bafffff5 	blt	17884 <_malloc_r+0x374>
   178ac:	e0841003 	add	r1, r4, r3
   178b0:	e5913004 	ldr	r3, [r1, #4]
   178b4:	e594000c 	ldr	r0, [r4, #12]
   178b8:	e5b42008 	ldr	r2, [r4, #8]!
   178bc:	e3833001 	orr	r3, r3, #1	; 0x1
   178c0:	e5802008 	str	r2, [r0, #8]
   178c4:	e582000c 	str	r0, [r2, #12]
   178c8:	e5813004 	str	r3, [r1, #4]
   178cc:	e1a00007 	mov	r0, r7
   178d0:	eb000145 	bl	17dec <__malloc_unlock>
   178d4:	e1a00004 	mov	r0, r4
   178d8:	eaffff35 	b	175b4 <_malloc_r+0xa4>
   178dc:	e59f2398 	ldr	r2, [pc, #920]	; 17c7c <.text+0x7c7c>
   178e0:	e5924008 	ldr	r4, [r2, #8]
   178e4:	e5943004 	ldr	r3, [r4, #4]
   178e8:	e3c39003 	bic	r9, r3, #3	; 0x3
   178ec:	e0650009 	rsb	r0, r5, r9
   178f0:	e350000f 	cmp	r0, #15	; 0xf
   178f4:	c3a03000 	movgt	r3, #0	; 0x0
   178f8:	d3a03001 	movle	r3, #1	; 0x1
   178fc:	e1550009 	cmp	r5, r9
   17900:	83833001 	orrhi	r3, r3, #1	; 0x1
   17904:	e3530000 	cmp	r3, #0	; 0x0
   17908:	e58d4000 	str	r4, [sp]
   1790c:	0a000026 	beq	179ac <_malloc_r+0x49c>
   17910:	e59f336c 	ldr	r3, [pc, #876]	; 17c84 <.text+0x7c84>
   17914:	e59fb36c 	ldr	fp, [pc, #876]	; 17c88 <.text+0x7c88>
   17918:	e5931000 	ldr	r1, [r3]
   1791c:	e59b2000 	ldr	r2, [fp]
   17920:	e0853001 	add	r3, r5, r1
   17924:	e3720001 	cmn	r2, #1	; 0x1
   17928:	e2836010 	add	r6, r3, #16	; 0x10
   1792c:	12833a01 	addne	r3, r3, #4096	; 0x1000
   17930:	1283300f 	addne	r3, r3, #15	; 0xf
   17934:	13c36eff 	bicne	r6, r3, #4080	; 0xff0
   17938:	13c6600f 	bicne	r6, r6, #15	; 0xf
   1793c:	e1a00007 	mov	r0, r7
   17940:	e1a01006 	mov	r1, r6
   17944:	ebffe824 	bl	119dc <_sbrk_r>
   17948:	e3700001 	cmn	r0, #1	; 0x1
   1794c:	e084a009 	add	sl, r4, r9
   17950:	e1a08000 	mov	r8, r0
   17954:	0a0000aa 	beq	17c04 <_malloc_r+0x6f4>
   17958:	e15a0000 	cmp	sl, r0
   1795c:	9a00004f 	bls	17aa0 <_malloc_r+0x590>
   17960:	e59f3314 	ldr	r3, [pc, #788]	; 17c7c <.text+0x7c7c>
   17964:	e1540003 	cmp	r4, r3
   17968:	0a00004c 	beq	17aa0 <_malloc_r+0x590>
   1796c:	e59f1308 	ldr	r1, [pc, #776]	; 17c7c <.text+0x7c7c>
   17970:	e5914008 	ldr	r4, [r1, #8]
   17974:	e5942004 	ldr	r2, [r4, #4]
   17978:	e3c22003 	bic	r2, r2, #3	; 0x3
   1797c:	e0650002 	rsb	r0, r5, r2
   17980:	e350000f 	cmp	r0, #15	; 0xf
   17984:	c3a03000 	movgt	r3, #0	; 0x0
   17988:	d3a03001 	movle	r3, #1	; 0x1
   1798c:	e1550002 	cmp	r5, r2
   17990:	83833001 	orrhi	r3, r3, #1	; 0x1
   17994:	e3530000 	cmp	r3, #0	; 0x0
   17998:	0a000003 	beq	179ac <_malloc_r+0x49c>
   1799c:	e1a00007 	mov	r0, r7
   179a0:	eb000111 	bl	17dec <__malloc_unlock>
   179a4:	e3a00000 	mov	r0, #0	; 0x0
   179a8:	eaffff01 	b	175b4 <_malloc_r+0xa4>
   179ac:	e0841005 	add	r1, r4, r5
   179b0:	e3802001 	orr	r2, r0, #1	; 0x1
   179b4:	e3853001 	orr	r3, r5, #1	; 0x1
   179b8:	e5843004 	str	r3, [r4, #4]
   179bc:	e5812004 	str	r2, [r1, #4]
   179c0:	e59f22b4 	ldr	r2, [pc, #692]	; 17c7c <.text+0x7c7c>
   179c4:	e1a00007 	mov	r0, r7
   179c8:	e5821008 	str	r1, [r2, #8]
   179cc:	eb000106 	bl	17dec <__malloc_unlock>
   179d0:	e2840008 	add	r0, r4, #8	; 0x8
   179d4:	eafffef6 	b	175b4 <_malloc_r+0xa4>
   179d8:	e1a021a2 	mov	r2, r2, lsr #3
   179dc:	e59a0004 	ldr	r0, [sl, #4]
   179e0:	e1a01122 	mov	r1, r2, lsr #2
   179e4:	e3a03001 	mov	r3, #1	; 0x1
   179e8:	e1800113 	orr	r0, r0, r3, lsl r1
   179ec:	e0882182 	add	r2, r8, r2, lsl #3
   179f0:	e5923008 	ldr	r3, [r2, #8]
   179f4:	e584200c 	str	r2, [r4, #12]
   179f8:	e5843008 	str	r3, [r4, #8]
   179fc:	e58a0004 	str	r0, [sl, #4]
   17a00:	e583400c 	str	r4, [r3, #12]
   17a04:	e5824008 	str	r4, [r2, #8]
   17a08:	eaffff8c 	b	17840 <_malloc_r+0x330>
   17a0c:	e1a02082 	mov	r2, r2, lsl #1
   17a10:	e3ce3003 	bic	r3, lr, #3	; 0x3
   17a14:	e1100002 	tst	r0, r2
   17a18:	e283e004 	add	lr, r3, #4	; 0x4
   17a1c:	1affff91 	bne	17868 <_malloc_r+0x358>
   17a20:	e1a02082 	mov	r2, r2, lsl #1
   17a24:	e1100002 	tst	r0, r2
   17a28:	e28ee004 	add	lr, lr, #4	; 0x4
   17a2c:	0afffffb 	beq	17a20 <_malloc_r+0x510>
   17a30:	eaffff8c 	b	17868 <_malloc_r+0x358>
   17a34:	e28aa001 	add	sl, sl, #1	; 0x1
   17a38:	e31a0003 	tst	sl, #3	; 0x3
   17a3c:	e2841008 	add	r1, r4, #8	; 0x8
   17a40:	1affff8b 	bne	17874 <_malloc_r+0x364>
   17a44:	e1a04009 	mov	r4, r9
   17a48:	e1a0c00e 	mov	ip, lr
   17a4c:	e1a01009 	mov	r1, r9
   17a50:	e31c0003 	tst	ip, #3	; 0x3
   17a54:	e2444008 	sub	r4, r4, #8	; 0x8
   17a58:	e24cc001 	sub	ip, ip, #1	; 0x1
   17a5c:	0a000081 	beq	17c68 <_malloc_r+0x758>
   17a60:	e4113008 	ldr	r3, [r1], #-8
   17a64:	e1540003 	cmp	r4, r3
   17a68:	0afffff8 	beq	17a50 <_malloc_r+0x540>
   17a6c:	e1a02082 	mov	r2, r2, lsl #1
   17a70:	e1520000 	cmp	r2, r0
   17a74:	8affff98 	bhi	178dc <_malloc_r+0x3cc>
   17a78:	e3520000 	cmp	r2, #0	; 0x0
   17a7c:	0affff96 	beq	178dc <_malloc_r+0x3cc>
   17a80:	e1120000 	tst	r2, r0
   17a84:	1a000003 	bne	17a98 <_malloc_r+0x588>
   17a88:	e1a02082 	mov	r2, r2, lsl #1
   17a8c:	e1100002 	tst	r0, r2
   17a90:	e28aa004 	add	sl, sl, #4	; 0x4
   17a94:	0afffffb 	beq	17a88 <_malloc_r+0x578>
   17a98:	e1a0e00a 	mov	lr, sl
   17a9c:	eaffff71 	b	17868 <_malloc_r+0x358>
   17aa0:	e59f01e4 	ldr	r0, [pc, #484]	; 17c8c <.text+0x7c8c>
   17aa4:	e5903000 	ldr	r3, [r0]
   17aa8:	e15a0008 	cmp	sl, r8
   17aac:	e0862003 	add	r2, r6, r3
   17ab0:	e5802000 	str	r2, [r0]
   17ab4:	0a00005b 	beq	17c28 <_malloc_r+0x718>
   17ab8:	e59b3000 	ldr	r3, [fp]
   17abc:	e3730001 	cmn	r3, #1	; 0x1
   17ac0:	106a3008 	rsbne	r3, sl, r8
   17ac4:	10823003 	addne	r3, r2, r3
   17ac8:	159f21bc 	ldrne	r2, [pc, #444]	; 17c8c <.text+0x7c8c>
   17acc:	058b8000 	streq	r8, [fp]
   17ad0:	15823000 	strne	r3, [r2]
   17ad4:	e2183007 	ands	r3, r8, #7	; 0x7
   17ad8:	12631008 	rsbne	r1, r3, #8	; 0x8
   17adc:	10888001 	addne	r8, r8, r1
   17ae0:	01a01003 	moveq	r1, r3
   17ae4:	e0883006 	add	r3, r8, r6
   17ae8:	e1a03a03 	mov	r3, r3, lsl #20
   17aec:	e1a03a23 	mov	r3, r3, lsr #20
   17af0:	e2633a01 	rsb	r3, r3, #4096	; 0x1000
   17af4:	e0816003 	add	r6, r1, r3
   17af8:	e1a01006 	mov	r1, r6
   17afc:	e1a00007 	mov	r0, r7
   17b00:	ebffe7b5 	bl	119dc <_sbrk_r>
   17b04:	e3700001 	cmn	r0, #1	; 0x1
   17b08:	03a06000 	moveq	r6, #0	; 0x0
   17b0c:	e59f1178 	ldr	r1, [pc, #376]	; 17c8c <.text+0x7c8c>
   17b10:	01a00006 	moveq	r0, r6
   17b14:	10680000 	rsbne	r0, r8, r0
   17b18:	e5913000 	ldr	r3, [r1]
   17b1c:	e0862000 	add	r2, r6, r0
   17b20:	e59f1154 	ldr	r1, [pc, #340]	; 17c7c <.text+0x7c7c>
   17b24:	e59d0000 	ldr	r0, [sp]
   17b28:	e1500001 	cmp	r0, r1
   17b2c:	e59f0158 	ldr	r0, [pc, #344]	; 17c8c <.text+0x7c8c>
   17b30:	e0863003 	add	r3, r6, r3
   17b34:	e3822001 	orr	r2, r2, #1	; 0x1
   17b38:	e1a04008 	mov	r4, r8
   17b3c:	e5803000 	str	r3, [r0]
   17b40:	e5882004 	str	r2, [r8, #4]
   17b44:	e5818008 	str	r8, [r1, #8]
   17b48:	0a000011 	beq	17b94 <_malloc_r+0x684>
   17b4c:	e359000f 	cmp	r9, #15	; 0xf
   17b50:	93a03001 	movls	r3, #1	; 0x1
   17b54:	95883004 	strls	r3, [r8, #4]
   17b58:	9affff85 	bls	17974 <_malloc_r+0x464>
   17b5c:	e59d1000 	ldr	r1, [sp]
   17b60:	e5913004 	ldr	r3, [r1, #4]
   17b64:	e249200c 	sub	r2, r9, #12	; 0xc
   17b68:	e3c22007 	bic	r2, r2, #7	; 0x7
   17b6c:	e2033001 	and	r3, r3, #1	; 0x1
   17b70:	e59d0000 	ldr	r0, [sp]
   17b74:	e1823003 	orr	r3, r2, r3
   17b78:	e352000f 	cmp	r2, #15	; 0xf
   17b7c:	e0812002 	add	r2, r1, r2
   17b80:	e3a01005 	mov	r1, #5	; 0x5
   17b84:	e5803004 	str	r3, [r0, #4]
   17b88:	e5821008 	str	r1, [r2, #8]
   17b8c:	e5821004 	str	r1, [r2, #4]
   17b90:	8a00002e 	bhi	17c50 <_malloc_r+0x740>
   17b94:	e59f10f4 	ldr	r1, [pc, #244]	; 17c90 <.text+0x7c90>
   17b98:	e59f30ec 	ldr	r3, [pc, #236]	; 17c8c <.text+0x7c8c>
   17b9c:	e5932000 	ldr	r2, [r3]
   17ba0:	e5913000 	ldr	r3, [r1]
   17ba4:	e1520003 	cmp	r2, r3
   17ba8:	85812000 	strhi	r2, [r1]
   17bac:	e59f10e0 	ldr	r1, [pc, #224]	; 17c94 <.text+0x7c94>
   17bb0:	e5913000 	ldr	r3, [r1]
   17bb4:	e1520003 	cmp	r2, r3
   17bb8:	85812000 	strhi	r2, [r1]
   17bbc:	eaffff6c 	b	17974 <_malloc_r+0x464>
   17bc0:	e3853001 	orr	r3, r5, #1	; 0x1
   17bc4:	e0842005 	add	r2, r4, r5
   17bc8:	e594000c 	ldr	r0, [r4, #12]
   17bcc:	e5843004 	str	r3, [r4, #4]
   17bd0:	e5b41008 	ldr	r1, [r4, #8]!
   17bd4:	e38c3001 	orr	r3, ip, #1	; 0x1
   17bd8:	e5801008 	str	r1, [r0, #8]
   17bdc:	e581000c 	str	r0, [r1, #12]
   17be0:	e5862008 	str	r2, [r6, #8]
   17be4:	e586200c 	str	r2, [r6, #12]
   17be8:	e1a00007 	mov	r0, r7
   17bec:	e782c00c 	str	ip, [r2, ip]
   17bf0:	e9820048 	stmib	r2, {r3, r6}
   17bf4:	e582600c 	str	r6, [r2, #12]
   17bf8:	eb00007b 	bl	17dec <__malloc_unlock>
   17bfc:	e1a00004 	mov	r0, r4
   17c00:	eafffe6b 	b	175b4 <_malloc_r+0xa4>
   17c04:	e59f0070 	ldr	r0, [pc, #112]	; 17c7c <.text+0x7c7c>
   17c08:	e5904008 	ldr	r4, [r0, #8]
   17c0c:	eaffff58 	b	17974 <_malloc_r+0x464>
   17c10:	e59a3004 	ldr	r3, [sl, #4]
   17c14:	e1a01121 	mov	r1, r1, lsr #2
   17c18:	e3a02001 	mov	r2, #1	; 0x1
   17c1c:	e1833112 	orr	r3, r3, r2, lsl r1
   17c20:	e58a3004 	str	r3, [sl, #4]
   17c24:	eaffff00 	b	1782c <_malloc_r+0x31c>
   17c28:	e1a03a08 	mov	r3, r8, lsl #20
   17c2c:	e1a03a23 	mov	r3, r3, lsr #20
   17c30:	e3530000 	cmp	r3, #0	; 0x0
   17c34:	1affff9f 	bne	17ab8 <_malloc_r+0x5a8>
   17c38:	e59f103c 	ldr	r1, [pc, #60]	; 17c7c <.text+0x7c7c>
   17c3c:	e0863009 	add	r3, r6, r9
   17c40:	e5914008 	ldr	r4, [r1, #8]
   17c44:	e3833001 	orr	r3, r3, #1	; 0x1
   17c48:	e5843004 	str	r3, [r4, #4]
   17c4c:	eaffffd0 	b	17b94 <_malloc_r+0x684>
   17c50:	e2801008 	add	r1, r0, #8	; 0x8
   17c54:	e1a00007 	mov	r0, r7
   17c58:	eb000221 	bl	184e4 <_free_r>
   17c5c:	e59f1018 	ldr	r1, [pc, #24]	; 17c7c <.text+0x7c7c>
   17c60:	e5914008 	ldr	r4, [r1, #8]
   17c64:	eaffffca 	b	17b94 <_malloc_r+0x684>
   17c68:	e1e03002 	mvn	r3, r2
   17c6c:	e59f1008 	ldr	r1, [pc, #8]	; 17c7c <.text+0x7c7c>
   17c70:	e0000003 	and	r0, r0, r3
   17c74:	e5810004 	str	r0, [r1, #4]
   17c78:	eaffff7b 	b	17a6c <_malloc_r+0x55c>
   17c7c:	400006c4 	andmi	r0, r0, r4, asr #13
   17c80:	400006cc 	andmi	r0, r0, ip, asr #13
   17c84:	40001870 	andmi	r1, r0, r0, ror r8
   17c88:	400006bc 	strmih	r0, [r0], -ip
   17c8c:	40001840 	andmi	r1, r0, r0, asr #16
   17c90:	4000186c 	andmi	r1, r0, ip, ror #16
   17c94:	40001868 	andmi	r1, r0, r8, ror #16

00017c98 <memcpy>:
   17c98:	e352000f 	cmp	r2, #15	; 0xf
   17c9c:	e92d4010 	stmdb	sp!, {r4, lr}
   17ca0:	e1a0c000 	mov	ip, r0
   17ca4:	e1a04000 	mov	r4, r0
   17ca8:	e1a0e002 	mov	lr, r2
   17cac:	e1a00002 	mov	r0, r2
   17cb0:	9a000002 	bls	17cc0 <memcpy+0x28>
   17cb4:	e1813004 	orr	r3, r1, r4
   17cb8:	e3130003 	tst	r3, #3	; 0x3
   17cbc:	0a00000a 	beq	17cec <memcpy+0x54>
   17cc0:	e3500000 	cmp	r0, #0	; 0x0
   17cc4:	0a000005 	beq	17ce0 <memcpy+0x48>
   17cc8:	e3a02000 	mov	r2, #0	; 0x0
   17ccc:	e4d13001 	ldrb	r3, [r1], #1
   17cd0:	e7c2300c 	strb	r3, [r2, ip]
   17cd4:	e2822001 	add	r2, r2, #1	; 0x1
   17cd8:	e1500002 	cmp	r0, r2
   17cdc:	1afffffa 	bne	17ccc <memcpy+0x34>
   17ce0:	e1a00004 	mov	r0, r4
   17ce4:	e8bd4010 	ldmia	sp!, {r4, lr}
   17ce8:	e12fff1e 	bx	lr
   17cec:	e5913000 	ldr	r3, [r1]
   17cf0:	e58c3000 	str	r3, [ip]
   17cf4:	e5912004 	ldr	r2, [r1, #4]
   17cf8:	e58c2004 	str	r2, [ip, #4]
   17cfc:	e5913008 	ldr	r3, [r1, #8]
   17d00:	e58c3008 	str	r3, [ip, #8]
   17d04:	e24ee010 	sub	lr, lr, #16	; 0x10
   17d08:	e591300c 	ldr	r3, [r1, #12]
   17d0c:	e35e000f 	cmp	lr, #15	; 0xf
   17d10:	e58c300c 	str	r3, [ip, #12]
   17d14:	e2811010 	add	r1, r1, #16	; 0x10
   17d18:	e28cc010 	add	ip, ip, #16	; 0x10
   17d1c:	8afffff2 	bhi	17cec <memcpy+0x54>
   17d20:	e35e0003 	cmp	lr, #3	; 0x3
   17d24:	e1a0000e 	mov	r0, lr
   17d28:	9affffe4 	bls	17cc0 <memcpy+0x28>
   17d2c:	e24ee004 	sub	lr, lr, #4	; 0x4
   17d30:	e4913004 	ldr	r3, [r1], #4
   17d34:	e35e0003 	cmp	lr, #3	; 0x3
   17d38:	e48c3004 	str	r3, [ip], #4
   17d3c:	8afffffa 	bhi	17d2c <memcpy+0x94>
   17d40:	e1a0000e 	mov	r0, lr
   17d44:	eaffffdd 	b	17cc0 <memcpy+0x28>

00017d48 <memset>:
   17d48:	e3520003 	cmp	r2, #3	; 0x3
   17d4c:	e20110ff 	and	r1, r1, #255	; 0xff
   17d50:	e1a0c000 	mov	ip, r0
   17d54:	9a000001 	bls	17d60 <memset+0x18>
   17d58:	e3100003 	tst	r0, #3	; 0x3
   17d5c:	0a000008 	beq	17d84 <memset+0x3c>
   17d60:	e3520000 	cmp	r2, #0	; 0x0
   17d64:	012fff1e 	bxeq	lr
   17d68:	e20110ff 	and	r1, r1, #255	; 0xff
   17d6c:	e3a03000 	mov	r3, #0	; 0x0
   17d70:	e7c3100c 	strb	r1, [r3, ip]
   17d74:	e2833001 	add	r3, r3, #1	; 0x1
   17d78:	e1530002 	cmp	r3, r2
   17d7c:	1afffffb 	bne	17d70 <memset+0x28>
   17d80:	e12fff1e 	bx	lr
   17d84:	e1813401 	orr	r3, r1, r1, lsl #8
   17d88:	e352000f 	cmp	r2, #15	; 0xf
   17d8c:	e183c803 	orr	ip, r3, r3, lsl #16
   17d90:	e1a03000 	mov	r3, r0
   17d94:	8a000007 	bhi	17db8 <memset+0x70>
   17d98:	e2422004 	sub	r2, r2, #4	; 0x4
   17d9c:	e3520003 	cmp	r2, #3	; 0x3
   17da0:	e483c004 	str	ip, [r3], #4
   17da4:	8afffffb 	bhi	17d98 <memset+0x50>
   17da8:	e1a0c003 	mov	ip, r3
   17dac:	e3520000 	cmp	r2, #0	; 0x0
   17db0:	1affffec 	bne	17d68 <memset+0x20>
   17db4:	e12fff1e 	bx	lr
   17db8:	e2422010 	sub	r2, r2, #16	; 0x10
   17dbc:	e352000f 	cmp	r2, #15	; 0xf
   17dc0:	e583c000 	str	ip, [r3]
   17dc4:	e583c004 	str	ip, [r3, #4]
   17dc8:	e583c008 	str	ip, [r3, #8]
   17dcc:	e583c00c 	str	ip, [r3, #12]
   17dd0:	e2833010 	add	r3, r3, #16	; 0x10
   17dd4:	8afffff7 	bhi	17db8 <memset+0x70>
   17dd8:	e3520003 	cmp	r2, #3	; 0x3
   17ddc:	8affffed 	bhi	17d98 <memset+0x50>
   17de0:	e1a0c003 	mov	ip, r3
   17de4:	eafffff0 	b	17dac <memset+0x64>

00017de8 <__malloc_lock>:
   17de8:	e12fff1e 	bx	lr

00017dec <__malloc_unlock>:
   17dec:	e12fff1e 	bx	lr

00017df0 <strchr>:
   17df0:	e2102003 	ands	r2, r0, #3	; 0x3
   17df4:	e92d4010 	stmdb	sp!, {r4, lr}
   17df8:	e1a0c000 	mov	ip, r0
   17dfc:	e201e0ff 	and	lr, r1, #255	; 0xff
   17e00:	1a000013 	bne	17e54 <strchr+0x64>
   17e04:	e1a04002 	mov	r4, r2
   17e08:	e1a03002 	mov	r3, r2
   17e0c:	e2833001 	add	r3, r3, #1	; 0x1
   17e10:	e3530004 	cmp	r3, #4	; 0x4
   17e14:	e18e4404 	orr	r4, lr, r4, lsl #8
   17e18:	1afffffb 	bne	17e0c <strchr+0x1c>
   17e1c:	e59c1000 	ldr	r1, [ip]
   17e20:	e28134ff 	add	r3, r1, #-16777216	; 0xff000000
   17e24:	e2433801 	sub	r3, r3, #65536	; 0x10000
   17e28:	e2433c01 	sub	r3, r3, #256	; 0x100
   17e2c:	e2433001 	sub	r3, r3, #1	; 0x1
   17e30:	e1e02001 	mvn	r2, r1
   17e34:	e0033002 	and	r3, r3, r2
   17e38:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
   17e3c:	e3c3387f 	bic	r3, r3, #8323072	; 0x7f0000
   17e40:	e3c33c7f 	bic	r3, r3, #32512	; 0x7f00
   17e44:	e3c3307f 	bic	r3, r3, #127	; 0x7f
   17e48:	e3530000 	cmp	r3, #0	; 0x0
   17e4c:	e1a0000c 	mov	r0, ip
   17e50:	0a00000c 	beq	17e88 <strchr+0x98>
   17e54:	e5d03000 	ldrb	r3, [r0]
   17e58:	e3530000 	cmp	r3, #0	; 0x0
   17e5c:	1a000006 	bne	17e7c <strchr+0x8c>
   17e60:	e15e0003 	cmp	lr, r3
   17e64:	13a00000 	movne	r0, #0	; 0x0
   17e68:	e8bd4010 	ldmia	sp!, {r4, lr}
   17e6c:	e12fff1e 	bx	lr
   17e70:	e5f03001 	ldrb	r3, [r0, #1]!
   17e74:	e3530000 	cmp	r3, #0	; 0x0
   17e78:	0afffff8 	beq	17e60 <strchr+0x70>
   17e7c:	e15e0003 	cmp	lr, r3
   17e80:	1afffffa 	bne	17e70 <strchr+0x80>
   17e84:	eafffff7 	b	17e68 <strchr+0x78>
   17e88:	e0242001 	eor	r2, r4, r1
   17e8c:	e28234ff 	add	r3, r2, #-16777216	; 0xff000000
   17e90:	e2433801 	sub	r3, r3, #65536	; 0x10000
   17e94:	e2433c01 	sub	r3, r3, #256	; 0x100
   17e98:	e2433001 	sub	r3, r3, #1	; 0x1
   17e9c:	e1e02002 	mvn	r2, r2
   17ea0:	e0033002 	and	r3, r3, r2
   17ea4:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
   17ea8:	e3c3387f 	bic	r3, r3, #8323072	; 0x7f0000
   17eac:	e3c33c7f 	bic	r3, r3, #32512	; 0x7f00
   17eb0:	e3c3307f 	bic	r3, r3, #127	; 0x7f
   17eb4:	e3530000 	cmp	r3, #0	; 0x0
   17eb8:	1affffe5 	bne	17e54 <strchr+0x64>
   17ebc:	e5b02004 	ldr	r2, [r0, #4]!
   17ec0:	e0241002 	eor	r1, r4, r2
   17ec4:	e28134ff 	add	r3, r1, #-16777216	; 0xff000000
   17ec8:	e2433801 	sub	r3, r3, #65536	; 0x10000
   17ecc:	e2433c01 	sub	r3, r3, #256	; 0x100
   17ed0:	e2433001 	sub	r3, r3, #1	; 0x1
   17ed4:	e1e01001 	mvn	r1, r1
   17ed8:	e0011003 	and	r1, r1, r3
   17edc:	e28234ff 	add	r3, r2, #-16777216	; 0xff000000
   17ee0:	e2433801 	sub	r3, r3, #65536	; 0x10000
   17ee4:	e2433c01 	sub	r3, r3, #256	; 0x100
   17ee8:	e2433001 	sub	r3, r3, #1	; 0x1
   17eec:	e1e02002 	mvn	r2, r2
   17ef0:	e0022003 	and	r2, r2, r3
   17ef4:	e3c2247f 	bic	r2, r2, #2130706432	; 0x7f000000
   17ef8:	e3c2287f 	bic	r2, r2, #8323072	; 0x7f0000
   17efc:	e3c1147f 	bic	r1, r1, #2130706432	; 0x7f000000
   17f00:	e3c22c7f 	bic	r2, r2, #32512	; 0x7f00
   17f04:	e3c1187f 	bic	r1, r1, #8323072	; 0x7f0000
   17f08:	e3c2207f 	bic	r2, r2, #127	; 0x7f
   17f0c:	e3c11c7f 	bic	r1, r1, #32512	; 0x7f00
   17f10:	e3520000 	cmp	r2, #0	; 0x0
   17f14:	e3c1107f 	bic	r1, r1, #127	; 0x7f
   17f18:	1affffcd 	bne	17e54 <strchr+0x64>
   17f1c:	e3510000 	cmp	r1, #0	; 0x0
   17f20:	0affffe5 	beq	17ebc <strchr+0xcc>
   17f24:	eaffffca 	b	17e54 <strchr+0x64>

00017f28 <strcmp>:
   17f28:	e1803001 	orr	r3, r0, r1
   17f2c:	e3130003 	tst	r3, #3	; 0x3
   17f30:	e52de004 	str	lr, [sp, #-4]!
   17f34:	e1a0c000 	mov	ip, r0
   17f38:	1a000006 	bne	17f58 <strcmp+0x30>
   17f3c:	e5902000 	ldr	r2, [r0]
   17f40:	e5913000 	ldr	r3, [r1]
   17f44:	e1520003 	cmp	r2, r3
   17f48:	e1a0e001 	mov	lr, r1
   17f4c:	0a000015 	beq	17fa8 <strcmp+0x80>
   17f50:	e1a0c000 	mov	ip, r0
   17f54:	e1a0100e 	mov	r1, lr
   17f58:	e5dc3000 	ldrb	r3, [ip]
   17f5c:	e20320ff 	and	r2, r3, #255	; 0xff
   17f60:	e3520000 	cmp	r2, #0	; 0x0
   17f64:	1a000003 	bne	17f78 <strcmp+0x50>
   17f68:	e5d10000 	ldrb	r0, [r1]
   17f6c:	e0600003 	rsb	r0, r0, r3
   17f70:	e49de004 	ldr	lr, [sp], #4
   17f74:	e12fff1e 	bx	lr
   17f78:	e5d10000 	ldrb	r0, [r1]
   17f7c:	e1500002 	cmp	r0, r2
   17f80:	1afffff9 	bne	17f6c <strcmp+0x44>
   17f84:	e5fc3001 	ldrb	r3, [ip, #1]!
   17f88:	e20320ff 	and	r2, r3, #255	; 0xff
   17f8c:	e3520000 	cmp	r2, #0	; 0x0
   17f90:	e2811001 	add	r1, r1, #1	; 0x1
   17f94:	0afffff3 	beq	17f68 <strcmp+0x40>
   17f98:	e5d10000 	ldrb	r0, [r1]
   17f9c:	e1500002 	cmp	r0, r2
   17fa0:	0afffff7 	beq	17f84 <strcmp+0x5c>
   17fa4:	eafffff0 	b	17f6c <strcmp+0x44>
   17fa8:	e28234ff 	add	r3, r2, #-16777216	; 0xff000000
   17fac:	e2433801 	sub	r3, r3, #65536	; 0x10000
   17fb0:	e2433c01 	sub	r3, r3, #256	; 0x100
   17fb4:	e2433001 	sub	r3, r3, #1	; 0x1
   17fb8:	e1e02002 	mvn	r2, r2
   17fbc:	e0033002 	and	r3, r3, r2
   17fc0:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
   17fc4:	e3c3387f 	bic	r3, r3, #8323072	; 0x7f0000
   17fc8:	e3c33c7f 	bic	r3, r3, #32512	; 0x7f00
   17fcc:	e3c3307f 	bic	r3, r3, #127	; 0x7f
   17fd0:	e3530000 	cmp	r3, #0	; 0x0
   17fd4:	1a00000f 	bne	18018 <strcmp+0xf0>
   17fd8:	e5be1004 	ldr	r1, [lr, #4]!
   17fdc:	e28134ff 	add	r3, r1, #-16777216	; 0xff000000
   17fe0:	e2433801 	sub	r3, r3, #65536	; 0x10000
   17fe4:	e2433c01 	sub	r3, r3, #256	; 0x100
   17fe8:	e2433001 	sub	r3, r3, #1	; 0x1
   17fec:	e1e02001 	mvn	r2, r1
   17ff0:	e0022003 	and	r2, r2, r3
   17ff4:	e3c2247f 	bic	r2, r2, #2130706432	; 0x7f000000
   17ff8:	e5b03004 	ldr	r3, [r0, #4]!
   17ffc:	e3c2287f 	bic	r2, r2, #8323072	; 0x7f0000
   18000:	e3c22c7f 	bic	r2, r2, #32512	; 0x7f00
   18004:	e1510003 	cmp	r1, r3
   18008:	e3c2207f 	bic	r2, r2, #127	; 0x7f
   1800c:	1affffcf 	bne	17f50 <strcmp+0x28>
   18010:	e3520000 	cmp	r2, #0	; 0x0
   18014:	0affffef 	beq	17fd8 <strcmp+0xb0>
   18018:	e3a00000 	mov	r0, #0	; 0x0
   1801c:	eaffffd3 	b	17f70 <strcmp+0x48>

00018020 <strlen>:
   18020:	e3100003 	tst	r0, #3	; 0x3
   18024:	e1a01000 	mov	r1, r0
   18028:	1a00000e 	bne	18068 <strlen+0x48>
   1802c:	e5902000 	ldr	r2, [r0]
   18030:	e28234ff 	add	r3, r2, #-16777216	; 0xff000000
   18034:	e2433801 	sub	r3, r3, #65536	; 0x10000
   18038:	e2433c01 	sub	r3, r3, #256	; 0x100
   1803c:	e1e02002 	mvn	r2, r2
   18040:	e2433001 	sub	r3, r3, #1	; 0x1
   18044:	e0033002 	and	r3, r3, r2
   18048:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
   1804c:	e3c3387f 	bic	r3, r3, #8323072	; 0x7f0000
   18050:	e3c33c7f 	bic	r3, r3, #32512	; 0x7f00
   18054:	e3c3307f 	bic	r3, r3, #127	; 0x7f
   18058:	e3530000 	cmp	r3, #0	; 0x0
   1805c:	e1a02000 	mov	r2, r0
   18060:	0a000008 	beq	18088 <strlen+0x68>
   18064:	e1a00002 	mov	r0, r2
   18068:	e5d03000 	ldrb	r3, [r0]
   1806c:	e3530000 	cmp	r3, #0	; 0x0
   18070:	0a000002 	beq	18080 <strlen+0x60>
   18074:	e5f03001 	ldrb	r3, [r0, #1]!
   18078:	e3530000 	cmp	r3, #0	; 0x0
   1807c:	1afffffc 	bne	18074 <strlen+0x54>
   18080:	e0610000 	rsb	r0, r1, r0
   18084:	e12fff1e 	bx	lr
   18088:	e5b02004 	ldr	r2, [r0, #4]!
   1808c:	e28234ff 	add	r3, r2, #-16777216	; 0xff000000
   18090:	e2433801 	sub	r3, r3, #65536	; 0x10000
   18094:	e2433c01 	sub	r3, r3, #256	; 0x100
   18098:	e2433001 	sub	r3, r3, #1	; 0x1
   1809c:	e1e02002 	mvn	r2, r2
   180a0:	e0033002 	and	r3, r3, r2
   180a4:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
   180a8:	e3c3387f 	bic	r3, r3, #8323072	; 0x7f0000
   180ac:	e3c33c7f 	bic	r3, r3, #32512	; 0x7f00
   180b0:	e3c3307f 	bic	r3, r3, #127	; 0x7f
   180b4:	e3530000 	cmp	r3, #0	; 0x0
   180b8:	0afffff2 	beq	18088 <strlen+0x68>
   180bc:	e1a02000 	mov	r2, r0
   180c0:	eaffffe7 	b	18064 <strlen+0x44>

000180c4 <strncmp>:
   180c4:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   180c8:	e2525000 	subs	r5, r2, #0	; 0x0
   180cc:	e1a02000 	mov	r2, r0
   180d0:	0a00001a 	beq	18140 <strncmp+0x7c>
   180d4:	e1803001 	orr	r3, r0, r1
   180d8:	e3130003 	tst	r3, #3	; 0x3
   180dc:	0a000009 	beq	18108 <strncmp+0x44>
   180e0:	e255e001 	subs	lr, r5, #1	; 0x1
   180e4:	3a000017 	bcc	18148 <strncmp+0x84>
   180e8:	e5d13000 	ldrb	r3, [r1]
   180ec:	e5d20000 	ldrb	r0, [r2]
   180f0:	e203c0ff 	and	ip, r3, #255	; 0xff
   180f4:	e15c0000 	cmp	ip, r0
   180f8:	0a00000b 	beq	1812c <strncmp+0x68>
   180fc:	e0630000 	rsb	r0, r3, r0
   18100:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   18104:	e12fff1e 	bx	lr
   18108:	e3550003 	cmp	r5, #3	; 0x3
   1810c:	e1a0e000 	mov	lr, r0
   18110:	e1a0c001 	mov	ip, r1
   18114:	8a00000e 	bhi	18154 <strncmp+0x90>
   18118:	e1a0200e 	mov	r2, lr
   1811c:	e255e001 	subs	lr, r5, #1	; 0x1
   18120:	e1a0100c 	mov	r1, ip
   18124:	2affffef 	bcs	180e8 <strncmp+0x24>
   18128:	ea000006 	b	18148 <strncmp+0x84>
   1812c:	e35e0000 	cmp	lr, #0	; 0x0
   18130:	0a000002 	beq	18140 <strncmp+0x7c>
   18134:	e35c0000 	cmp	ip, #0	; 0x0
   18138:	13a0c000 	movne	ip, #0	; 0x0
   1813c:	1a00002e 	bne	181fc <strncmp+0x138>
   18140:	e3a00000 	mov	r0, #0	; 0x0
   18144:	eaffffed 	b	18100 <strncmp+0x3c>
   18148:	e5d20000 	ldrb	r0, [r2]
   1814c:	e5d13000 	ldrb	r3, [r1]
   18150:	eaffffe9 	b	180fc <strncmp+0x38>
   18154:	e5900000 	ldr	r0, [r0]
   18158:	e5913000 	ldr	r3, [r1]
   1815c:	e1500003 	cmp	r0, r3
   18160:	1affffec 	bne	18118 <strncmp+0x54>
   18164:	e2555004 	subs	r5, r5, #4	; 0x4
   18168:	0afffff4 	beq	18140 <strncmp+0x7c>
   1816c:	e28034ff 	add	r3, r0, #-16777216	; 0xff000000
   18170:	e2433801 	sub	r3, r3, #65536	; 0x10000
   18174:	e2433c01 	sub	r3, r3, #256	; 0x100
   18178:	e2433001 	sub	r3, r3, #1	; 0x1
   1817c:	e1e02000 	mvn	r2, r0
   18180:	e0033002 	and	r3, r3, r2
   18184:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
   18188:	e3c3387f 	bic	r3, r3, #8323072	; 0x7f0000
   1818c:	e3c33c7f 	bic	r3, r3, #32512	; 0x7f00
   18190:	e3c3307f 	bic	r3, r3, #127	; 0x7f
   18194:	e3530000 	cmp	r3, #0	; 0x0
   18198:	1affffe8 	bne	18140 <strncmp+0x7c>
   1819c:	e3550003 	cmp	r5, #3	; 0x3
   181a0:	e28ee004 	add	lr, lr, #4	; 0x4
   181a4:	e28cc004 	add	ip, ip, #4	; 0x4
   181a8:	9affffda 	bls	18118 <strncmp+0x54>
   181ac:	e59c1000 	ldr	r1, [ip]
   181b0:	e28134ff 	add	r3, r1, #-16777216	; 0xff000000
   181b4:	e2433801 	sub	r3, r3, #65536	; 0x10000
   181b8:	e2433c01 	sub	r3, r3, #256	; 0x100
   181bc:	e2433001 	sub	r3, r3, #1	; 0x1
   181c0:	e1e02001 	mvn	r2, r1
   181c4:	e0022003 	and	r2, r2, r3
   181c8:	e3c2247f 	bic	r2, r2, #2130706432	; 0x7f000000
   181cc:	e59e3000 	ldr	r3, [lr]
   181d0:	e3c2287f 	bic	r2, r2, #8323072	; 0x7f0000
   181d4:	e3c22c7f 	bic	r2, r2, #32512	; 0x7f00
   181d8:	e1510003 	cmp	r1, r3
   181dc:	e3c2207f 	bic	r2, r2, #127	; 0x7f
   181e0:	1affffcc 	bne	18118 <strncmp+0x54>
   181e4:	e2555004 	subs	r5, r5, #4	; 0x4
   181e8:	0affffd4 	beq	18140 <strncmp+0x7c>
   181ec:	e3520000 	cmp	r2, #0	; 0x0
   181f0:	0affffe9 	beq	1819c <strncmp+0xd8>
   181f4:	e3a00000 	mov	r0, #0	; 0x0
   181f8:	eaffffc0 	b	18100 <strncmp+0x3c>
   181fc:	e15c000e 	cmp	ip, lr
   18200:	e2456002 	sub	r6, r5, #2	; 0x2
   18204:	e2822001 	add	r2, r2, #1	; 0x1
   18208:	e2811001 	add	r1, r1, #1	; 0x1
   1820c:	0affffcd 	beq	18148 <strncmp+0x84>
   18210:	e5d13000 	ldrb	r3, [r1]
   18214:	e5d20000 	ldrb	r0, [r2]
   18218:	e20340ff 	and	r4, r3, #255	; 0xff
   1821c:	e1540000 	cmp	r4, r0
   18220:	1affffb5 	bne	180fc <strncmp+0x38>
   18224:	e156000c 	cmp	r6, ip
   18228:	e28cc001 	add	ip, ip, #1	; 0x1
   1822c:	0affffc3 	beq	18140 <strncmp+0x7c>
   18230:	e3540000 	cmp	r4, #0	; 0x0
   18234:	1afffff0 	bne	181fc <strncmp+0x138>
   18238:	e3a00000 	mov	r0, #0	; 0x0
   1823c:	eaffffaf 	b	18100 <strncmp+0x3c>

00018240 <strncpy>:
   18240:	e1a0c001 	mov	ip, r1
   18244:	e1811000 	orr	r1, r1, r0
   18248:	e3110003 	tst	r1, #3	; 0x3
   1824c:	13a03000 	movne	r3, #0	; 0x0
   18250:	03a03001 	moveq	r3, #1	; 0x1
   18254:	e3520003 	cmp	r2, #3	; 0x3
   18258:	93a03000 	movls	r3, #0	; 0x0
   1825c:	82033001 	andhi	r3, r3, #1	; 0x1
   18260:	e3530000 	cmp	r3, #0	; 0x0
   18264:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   18268:	01a0100c 	moveq	r1, ip
   1826c:	e1a05000 	mov	r5, r0
   18270:	e1a0e002 	mov	lr, r2
   18274:	01a0c000 	moveq	ip, r0
   18278:	0a000024 	beq	18310 <strncpy+0xd0>
   1827c:	e3520003 	cmp	r2, #3	; 0x3
   18280:	e1a04000 	mov	r4, r0
   18284:	e1a0000c 	mov	r0, ip
   18288:	9a00001e 	bls	18308 <strncpy+0xc8>
   1828c:	e59c1000 	ldr	r1, [ip]
   18290:	e28134ff 	add	r3, r1, #-16777216	; 0xff000000
   18294:	e2433801 	sub	r3, r3, #65536	; 0x10000
   18298:	e2433c01 	sub	r3, r3, #256	; 0x100
   1829c:	e2433001 	sub	r3, r3, #1	; 0x1
   182a0:	e1e02001 	mvn	r2, r1
   182a4:	e0033002 	and	r3, r3, r2
   182a8:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
   182ac:	e3c3387f 	bic	r3, r3, #8323072	; 0x7f0000
   182b0:	e3c33c7f 	bic	r3, r3, #32512	; 0x7f00
   182b4:	e3c3307f 	bic	r3, r3, #127	; 0x7f
   182b8:	e3530000 	cmp	r3, #0	; 0x0
   182bc:	1a000011 	bne	18308 <strncpy+0xc8>
   182c0:	e24ee004 	sub	lr, lr, #4	; 0x4
   182c4:	e35e0003 	cmp	lr, #3	; 0x3
   182c8:	e4841004 	str	r1, [r4], #4
   182cc:	e2800004 	add	r0, r0, #4	; 0x4
   182d0:	9a00000c 	bls	18308 <strncpy+0xc8>
   182d4:	e5901000 	ldr	r1, [r0]
   182d8:	e28124ff 	add	r2, r1, #-16777216	; 0xff000000
   182dc:	e2422801 	sub	r2, r2, #65536	; 0x10000
   182e0:	e2422c01 	sub	r2, r2, #256	; 0x100
   182e4:	e2422001 	sub	r2, r2, #1	; 0x1
   182e8:	e1e03001 	mvn	r3, r1
   182ec:	e0033002 	and	r3, r3, r2
   182f0:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
   182f4:	e3c3387f 	bic	r3, r3, #8323072	; 0x7f0000
   182f8:	e3c33c7f 	bic	r3, r3, #32512	; 0x7f00
   182fc:	e3c3307f 	bic	r3, r3, #127	; 0x7f
   18300:	e3530000 	cmp	r3, #0	; 0x0
   18304:	0affffed 	beq	182c0 <strncpy+0x80>
   18308:	e1a0c004 	mov	ip, r4
   1830c:	e1a01000 	mov	r1, r0
   18310:	e35e0000 	cmp	lr, #0	; 0x0
   18314:	0a000011 	beq	18360 <strncpy+0x120>
   18318:	e4d13001 	ldrb	r3, [r1], #1
   1831c:	e4cc3001 	strb	r3, [ip], #1
   18320:	e3530000 	cmp	r3, #0	; 0x0
   18324:	e24e0001 	sub	r0, lr, #1	; 0x1
   18328:	e1a04001 	mov	r4, r1
   1832c:	01a0e000 	moveq	lr, r0
   18330:	11a0e000 	movne	lr, r0
   18334:	11a0100c 	movne	r1, ip
   18338:	13a02000 	movne	r2, #0	; 0x0
   1833c:	1a00000a 	bne	1836c <strncpy+0x12c>
   18340:	e35e0000 	cmp	lr, #0	; 0x0
   18344:	0a000005 	beq	18360 <strncpy+0x120>
   18348:	e3a03000 	mov	r3, #0	; 0x0
   1834c:	e1a02003 	mov	r2, r3
   18350:	e7cc2003 	strb	r2, [ip, r3]
   18354:	e2833001 	add	r3, r3, #1	; 0x1
   18358:	e15e0003 	cmp	lr, r3
   1835c:	1afffffb 	bne	18350 <strncpy+0x110>
   18360:	e1a00005 	mov	r0, r5
   18364:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   18368:	e12fff1e 	bx	lr
   1836c:	e1520000 	cmp	r2, r0
   18370:	0a000006 	beq	18390 <strncpy+0x150>
   18374:	e7d23004 	ldrb	r3, [r2, r4]
   18378:	e3530000 	cmp	r3, #0	; 0x0
   1837c:	e7c2300c 	strb	r3, [r2, ip]
   18380:	e24ee001 	sub	lr, lr, #1	; 0x1
   18384:	e2811001 	add	r1, r1, #1	; 0x1
   18388:	e2822001 	add	r2, r2, #1	; 0x1
   1838c:	1afffff6 	bne	1836c <strncpy+0x12c>
   18390:	e1a0c001 	mov	ip, r1
   18394:	eaffffe9 	b	18340 <strncpy+0x100>

00018398 <strrchr>:
   18398:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   1839c:	e2515000 	subs	r5, r1, #0	; 0x0
   183a0:	e1a03000 	mov	r3, r0
   183a4:	13a04000 	movne	r4, #0	; 0x0
   183a8:	1a000002 	bne	183b8 <strrchr+0x20>
   183ac:	ea000009 	b	183d8 <strrchr+0x40>
   183b0:	e1a04000 	mov	r4, r0
   183b4:	e2803001 	add	r3, r0, #1	; 0x1
   183b8:	e1a00003 	mov	r0, r3
   183bc:	e1a01005 	mov	r1, r5
   183c0:	ebfffe8a 	bl	17df0 <strchr>
   183c4:	e3500000 	cmp	r0, #0	; 0x0
   183c8:	1afffff8 	bne	183b0 <strrchr+0x18>
   183cc:	e1a00004 	mov	r0, r4
   183d0:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   183d4:	e12fff1e 	bx	lr
   183d8:	ebfffe84 	bl	17df0 <strchr>
   183dc:	e1a04000 	mov	r4, r0
   183e0:	eafffff9 	b	183cc <strrchr+0x34>

000183e4 <_malloc_trim_r>:
   183e4:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   183e8:	e59f70e8 	ldr	r7, [pc, #232]	; 184d8 <.text+0x84d8>
   183ec:	e1a04001 	mov	r4, r1
   183f0:	e1a05000 	mov	r5, r0
   183f4:	ebfffe7b 	bl	17de8 <__malloc_lock>
   183f8:	e5973008 	ldr	r3, [r7, #8]
   183fc:	e5932004 	ldr	r2, [r3, #4]
   18400:	e3c26003 	bic	r6, r2, #3	; 0x3
   18404:	e0644006 	rsb	r4, r4, r6
   18408:	e2844efe 	add	r4, r4, #4064	; 0xfe0
   1840c:	e284400f 	add	r4, r4, #15	; 0xf
   18410:	e1a04624 	mov	r4, r4, lsr #12
   18414:	e2444001 	sub	r4, r4, #1	; 0x1
   18418:	e1a04604 	mov	r4, r4, lsl #12
   1841c:	e3540a01 	cmp	r4, #4096	; 0x1000
   18420:	e3a01000 	mov	r1, #0	; 0x0
   18424:	e1a00005 	mov	r0, r5
   18428:	ba000006 	blt	18448 <_malloc_trim_r+0x64>
   1842c:	ebffe56a 	bl	119dc <_sbrk_r>
   18430:	e5973008 	ldr	r3, [r7, #8]
   18434:	e0833006 	add	r3, r3, r6
   18438:	e1500003 	cmp	r0, r3
   1843c:	e2641000 	rsb	r1, r4, #0	; 0x0
   18440:	e1a00005 	mov	r0, r5
   18444:	0a000003 	beq	18458 <_malloc_trim_r+0x74>
   18448:	ebfffe67 	bl	17dec <__malloc_unlock>
   1844c:	e3a00000 	mov	r0, #0	; 0x0
   18450:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   18454:	e12fff1e 	bx	lr
   18458:	ebffe55f 	bl	119dc <_sbrk_r>
   1845c:	e0643006 	rsb	r3, r4, r6
   18460:	e3700001 	cmn	r0, #1	; 0x1
   18464:	e3a01000 	mov	r1, #0	; 0x0
   18468:	e59fe06c 	ldr	lr, [pc, #108]	; 184dc <.text+0x84dc>
   1846c:	e383c001 	orr	ip, r3, #1	; 0x1
   18470:	e1a00005 	mov	r0, r5
   18474:	0a000008 	beq	1849c <_malloc_trim_r+0xb8>
   18478:	e59e3000 	ldr	r3, [lr]
   1847c:	e5972008 	ldr	r2, [r7, #8]
   18480:	e0643003 	rsb	r3, r4, r3
   18484:	e1a00005 	mov	r0, r5
   18488:	e582c004 	str	ip, [r2, #4]
   1848c:	e58e3000 	str	r3, [lr]
   18490:	ebfffe55 	bl	17dec <__malloc_unlock>
   18494:	e3a00001 	mov	r0, #1	; 0x1
   18498:	eaffffec 	b	18450 <_malloc_trim_r+0x6c>
   1849c:	ebffe54e 	bl	119dc <_sbrk_r>
   184a0:	e5971008 	ldr	r1, [r7, #8]
   184a4:	e1a0e000 	mov	lr, r0
   184a8:	e061300e 	rsb	r3, r1, lr
   184ac:	e353000f 	cmp	r3, #15	; 0xf
   184b0:	e1a00005 	mov	r0, r5
   184b4:	e383c001 	orr	ip, r3, #1	; 0x1
   184b8:	daffffe2 	ble	18448 <_malloc_trim_r+0x64>
   184bc:	e59f301c 	ldr	r3, [pc, #28]	; 184e0 <.text+0x84e0>
   184c0:	e5932000 	ldr	r2, [r3]
   184c4:	e59f3010 	ldr	r3, [pc, #16]	; 184dc <.text+0x84dc>
   184c8:	e062200e 	rsb	r2, r2, lr
   184cc:	e5832000 	str	r2, [r3]
   184d0:	e581c004 	str	ip, [r1, #4]
   184d4:	eaffffdb 	b	18448 <_malloc_trim_r+0x64>
   184d8:	400006c4 	andmi	r0, r0, r4, asr #13
   184dc:	40001840 	andmi	r1, r0, r0, asr #16
   184e0:	400006bc 	strmih	r0, [r0], -ip

000184e4 <_free_r>:
   184e4:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
   184e8:	e2514000 	subs	r4, r1, #0	; 0x0
   184ec:	e1a08000 	mov	r8, r0
   184f0:	0a00001a 	beq	18560 <_free_r+0x7c>
   184f4:	ebfffe3b 	bl	17de8 <__malloc_lock>
   184f8:	e244e008 	sub	lr, r4, #8	; 0x8
   184fc:	e59e0004 	ldr	r0, [lr, #4]
   18500:	e59f7274 	ldr	r7, [pc, #628]	; 1877c <.text+0x877c>
   18504:	e3c01001 	bic	r1, r0, #1	; 0x1
   18508:	e08ec001 	add	ip, lr, r1
   1850c:	e5973008 	ldr	r3, [r7, #8]
   18510:	e59c2004 	ldr	r2, [ip, #4]
   18514:	e15c0003 	cmp	ip, r3
   18518:	e3c25003 	bic	r5, r2, #3	; 0x3
   1851c:	e1a0a007 	mov	sl, r7
   18520:	0a000076 	beq	18700 <_free_r+0x21c>
   18524:	e2106001 	ands	r6, r0, #1	; 0x1
   18528:	e58c5004 	str	r5, [ip, #4]
   1852c:	13a00000 	movne	r0, #0	; 0x0
   18530:	0a00004b 	beq	18664 <_free_r+0x180>
   18534:	e08c3005 	add	r3, ip, r5
   18538:	e5932004 	ldr	r2, [r3, #4]
   1853c:	e3120001 	tst	r2, #1	; 0x1
   18540:	0a00003a 	beq	18630 <_free_r+0x14c>
   18544:	e3813001 	orr	r3, r1, #1	; 0x1
   18548:	e3500000 	cmp	r0, #0	; 0x0
   1854c:	e58e3004 	str	r3, [lr, #4]
   18550:	e78e1001 	str	r1, [lr, r1]
   18554:	0a000003 	beq	18568 <_free_r+0x84>
   18558:	e1a00008 	mov	r0, r8
   1855c:	ebfffe22 	bl	17dec <__malloc_unlock>
   18560:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
   18564:	e12fff1e 	bx	lr
   18568:	e3510c02 	cmp	r1, #512	; 0x200
   1856c:	3a000056 	bcc	186cc <_free_r+0x1e8>
   18570:	e1b024a1 	movs	r2, r1, lsr #9
   18574:	01a021a1 	moveq	r2, r1, lsr #3
   18578:	01a03182 	moveq	r3, r2, lsl #3
   1857c:	0a00001a 	beq	185ec <_free_r+0x108>
   18580:	e3520004 	cmp	r2, #4	; 0x4
   18584:	91a03321 	movls	r3, r1, lsr #6
   18588:	92832038 	addls	r2, r3, #56	; 0x38
   1858c:	91a03182 	movls	r3, r2, lsl #3
   18590:	9a000015 	bls	185ec <_free_r+0x108>
   18594:	e3520014 	cmp	r2, #20	; 0x14
   18598:	9282205b 	addls	r2, r2, #91	; 0x5b
   1859c:	91a03182 	movls	r3, r2, lsl #3
   185a0:	9a000011 	bls	185ec <_free_r+0x108>
   185a4:	e3520054 	cmp	r2, #84	; 0x54
   185a8:	91a03621 	movls	r3, r1, lsr #12
   185ac:	9283206e 	addls	r2, r3, #110	; 0x6e
   185b0:	91a03182 	movls	r3, r2, lsl #3
   185b4:	9a00000c 	bls	185ec <_free_r+0x108>
   185b8:	e3520f55 	cmp	r2, #340	; 0x154
   185bc:	91a037a1 	movls	r3, r1, lsr #15
   185c0:	92832077 	addls	r2, r3, #119	; 0x77
   185c4:	91a03182 	movls	r3, r2, lsl #3
   185c8:	9a000007 	bls	185ec <_free_r+0x108>
   185cc:	e3a03e55 	mov	r3, #1360	; 0x550
   185d0:	e2833004 	add	r3, r3, #4	; 0x4
   185d4:	e1520003 	cmp	r2, r3
   185d8:	91a03921 	movls	r3, r1, lsr #18
   185dc:	9283207c 	addls	r2, r3, #124	; 0x7c
   185e0:	83a0207e 	movhi	r2, #126	; 0x7e
   185e4:	82433f59 	subhi	r3, r3, #356	; 0x164
   185e8:	91a03182 	movls	r3, r2, lsl #3
   185ec:	e083c00a 	add	ip, r3, sl
   185f0:	e59c0008 	ldr	r0, [ip, #8]
   185f4:	e15c0000 	cmp	ip, r0
   185f8:	0a000056 	beq	18758 <_free_r+0x274>
   185fc:	e5903004 	ldr	r3, [r0, #4]
   18600:	e3c33003 	bic	r3, r3, #3	; 0x3
   18604:	e1510003 	cmp	r1, r3
   18608:	2a000002 	bcs	18618 <_free_r+0x134>
   1860c:	e5900008 	ldr	r0, [r0, #8]
   18610:	e15c0000 	cmp	ip, r0
   18614:	1afffff8 	bne	185fc <_free_r+0x118>
   18618:	e590c00c 	ldr	ip, [r0, #12]
   1861c:	e58ec00c 	str	ip, [lr, #12]
   18620:	e58e0008 	str	r0, [lr, #8]
   18624:	e580e00c 	str	lr, [r0, #12]
   18628:	e58ce008 	str	lr, [ip, #8]
   1862c:	eaffffc9 	b	18558 <_free_r+0x74>
   18630:	e3500000 	cmp	r0, #0	; 0x0
   18634:	e0811005 	add	r1, r1, r5
   18638:	159c2008 	ldrne	r2, [ip, #8]
   1863c:	0a000018 	beq	186a4 <_free_r+0x1c0>
   18640:	e59c300c 	ldr	r3, [ip, #12]
   18644:	e3500000 	cmp	r0, #0	; 0x0
   18648:	e5832008 	str	r2, [r3, #8]
   1864c:	e582300c 	str	r3, [r2, #12]
   18650:	e3813001 	orr	r3, r1, #1	; 0x1
   18654:	e58e3004 	str	r3, [lr, #4]
   18658:	e78e1001 	str	r1, [lr, r1]
   1865c:	1affffbd 	bne	18558 <_free_r+0x74>
   18660:	eaffffc0 	b	18568 <_free_r+0x84>
   18664:	e5142008 	ldr	r2, [r4, #-8]
   18668:	e062e00e 	rsb	lr, r2, lr
   1866c:	e59e0008 	ldr	r0, [lr, #8]
   18670:	e2873008 	add	r3, r7, #8	; 0x8
   18674:	e1500003 	cmp	r0, r3
   18678:	159e300c 	ldrne	r3, [lr, #12]
   1867c:	15830008 	strne	r0, [r3, #8]
   18680:	1580300c 	strne	r3, [r0, #12]
   18684:	e08c3005 	add	r3, ip, r5
   18688:	e0811002 	add	r1, r1, r2
   1868c:	e5932004 	ldr	r2, [r3, #4]
   18690:	03a00001 	moveq	r0, #1	; 0x1
   18694:	11a00006 	movne	r0, r6
   18698:	e3120001 	tst	r2, #1	; 0x1
   1869c:	1affffa8 	bne	18544 <_free_r+0x60>
   186a0:	eaffffe2 	b	18630 <_free_r+0x14c>
   186a4:	e59c2008 	ldr	r2, [ip, #8]
   186a8:	e59f30d0 	ldr	r3, [pc, #208]	; 18780 <.text+0x8780>
   186ac:	e1520003 	cmp	r2, r3
   186b0:	1affffe2 	bne	18640 <_free_r+0x15c>
   186b4:	e2800001 	add	r0, r0, #1	; 0x1
   186b8:	e582e00c 	str	lr, [r2, #12]
   186bc:	e582e008 	str	lr, [r2, #8]
   186c0:	e58e200c 	str	r2, [lr, #12]
   186c4:	e58e2008 	str	r2, [lr, #8]
   186c8:	eaffff9d 	b	18544 <_free_r+0x60>
   186cc:	e1a011a1 	mov	r1, r1, lsr #3
   186d0:	e5972004 	ldr	r2, [r7, #4]
   186d4:	e1a00121 	mov	r0, r1, lsr #2
   186d8:	e3a03001 	mov	r3, #1	; 0x1
   186dc:	e1822013 	orr	r2, r2, r3, lsl r0
   186e0:	e08a1181 	add	r1, sl, r1, lsl #3
   186e4:	e5913008 	ldr	r3, [r1, #8]
   186e8:	e58e100c 	str	r1, [lr, #12]
   186ec:	e58e3008 	str	r3, [lr, #8]
   186f0:	e5872004 	str	r2, [r7, #4]
   186f4:	e583e00c 	str	lr, [r3, #12]
   186f8:	e581e008 	str	lr, [r1, #8]
   186fc:	eaffff95 	b	18558 <_free_r+0x74>
   18700:	e3100001 	tst	r0, #1	; 0x1
   18704:	e0810005 	add	r0, r1, r5
   18708:	1a000006 	bne	18728 <_free_r+0x244>
   1870c:	e5141008 	ldr	r1, [r4, #-8]
   18710:	e061e00e 	rsb	lr, r1, lr
   18714:	e59e200c 	ldr	r2, [lr, #12]
   18718:	e59e3008 	ldr	r3, [lr, #8]
   1871c:	e5823008 	str	r3, [r2, #8]
   18720:	e583200c 	str	r2, [r3, #12]
   18724:	e0800001 	add	r0, r0, r1
   18728:	e59f3054 	ldr	r3, [pc, #84]	; 18784 <.text+0x8784>
   1872c:	e5932000 	ldr	r2, [r3]
   18730:	e3803001 	orr	r3, r0, #1	; 0x1
   18734:	e1500002 	cmp	r0, r2
   18738:	e587e008 	str	lr, [r7, #8]
   1873c:	e58e3004 	str	r3, [lr, #4]
   18740:	3affff84 	bcc	18558 <_free_r+0x74>
   18744:	e59f303c 	ldr	r3, [pc, #60]	; 18788 <.text+0x8788>
   18748:	e1a00008 	mov	r0, r8
   1874c:	e5931000 	ldr	r1, [r3]
   18750:	ebffff23 	bl	183e4 <_malloc_trim_r>
   18754:	eaffff7f 	b	18558 <_free_r+0x74>
   18758:	e3520000 	cmp	r2, #0	; 0x0
   1875c:	e2823003 	add	r3, r2, #3	; 0x3
   18760:	a1a03002 	movge	r3, r2
   18764:	e5972004 	ldr	r2, [r7, #4]
   18768:	e1a03143 	mov	r3, r3, asr #2
   1876c:	e3a01001 	mov	r1, #1	; 0x1
   18770:	e1822311 	orr	r2, r2, r1, lsl r3
   18774:	e5872004 	str	r2, [r7, #4]
   18778:	eaffffa7 	b	1861c <_free_r+0x138>
   1877c:	400006c4 	andmi	r0, r0, r4, asr #13
   18780:	400006cc 	andmi	r0, r0, ip, asr #13
   18784:	400006c0 	andmi	r0, r0, r0, asr #13
   18788:	40001870 	andmi	r1, r0, r0, ror r8

0001878c <__udivsi3>:
   1878c:	e2512001 	subs	r2, r1, #1	; 0x1
   18790:	012fff1e 	bxeq	lr
   18794:	3a000036 	bcc	18874 <__udivsi3+0xe8>
   18798:	e1500001 	cmp	r0, r1
   1879c:	9a000022 	bls	1882c <__udivsi3+0xa0>
   187a0:	e1110002 	tst	r1, r2
   187a4:	0a000023 	beq	18838 <__udivsi3+0xac>
   187a8:	e311020e 	tst	r1, #-536870912	; 0xe0000000
   187ac:	01a01181 	moveq	r1, r1, lsl #3
   187b0:	03a03008 	moveq	r3, #8	; 0x8
   187b4:	13a03001 	movne	r3, #1	; 0x1
   187b8:	e3510201 	cmp	r1, #268435456	; 0x10000000
   187bc:	31510000 	cmpcc	r1, r0
   187c0:	31a01201 	movcc	r1, r1, lsl #4
   187c4:	31a03203 	movcc	r3, r3, lsl #4
   187c8:	3afffffa 	bcc	187b8 <__udivsi3+0x2c>
   187cc:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   187d0:	31510000 	cmpcc	r1, r0
   187d4:	31a01081 	movcc	r1, r1, lsl #1
   187d8:	31a03083 	movcc	r3, r3, lsl #1
   187dc:	3afffffa 	bcc	187cc <__udivsi3+0x40>
   187e0:	e3a02000 	mov	r2, #0	; 0x0
   187e4:	e1500001 	cmp	r0, r1
   187e8:	20400001 	subcs	r0, r0, r1
   187ec:	21822003 	orrcs	r2, r2, r3
   187f0:	e15000a1 	cmp	r0, r1, lsr #1
   187f4:	204000a1 	subcs	r0, r0, r1, lsr #1
   187f8:	218220a3 	orrcs	r2, r2, r3, lsr #1
   187fc:	e1500121 	cmp	r0, r1, lsr #2
   18800:	20400121 	subcs	r0, r0, r1, lsr #2
   18804:	21822123 	orrcs	r2, r2, r3, lsr #2
   18808:	e15001a1 	cmp	r0, r1, lsr #3
   1880c:	204001a1 	subcs	r0, r0, r1, lsr #3
   18810:	218221a3 	orrcs	r2, r2, r3, lsr #3
   18814:	e3500000 	cmp	r0, #0	; 0x0
   18818:	11b03223 	movnes	r3, r3, lsr #4
   1881c:	11a01221 	movne	r1, r1, lsr #4
   18820:	1affffef 	bne	187e4 <__udivsi3+0x58>
   18824:	e1a00002 	mov	r0, r2
   18828:	e12fff1e 	bx	lr
   1882c:	03a00001 	moveq	r0, #1	; 0x1
   18830:	13a00000 	movne	r0, #0	; 0x0
   18834:	e12fff1e 	bx	lr
   18838:	e3510801 	cmp	r1, #65536	; 0x10000
   1883c:	21a01821 	movcs	r1, r1, lsr #16
   18840:	23a02010 	movcs	r2, #16	; 0x10
   18844:	33a02000 	movcc	r2, #0	; 0x0
   18848:	e3510c01 	cmp	r1, #256	; 0x100
   1884c:	21a01421 	movcs	r1, r1, lsr #8
   18850:	22822008 	addcs	r2, r2, #8	; 0x8
   18854:	e3510010 	cmp	r1, #16	; 0x10
   18858:	21a01221 	movcs	r1, r1, lsr #4
   1885c:	22822004 	addcs	r2, r2, #4	; 0x4
   18860:	e3510004 	cmp	r1, #4	; 0x4
   18864:	82822003 	addhi	r2, r2, #3	; 0x3
   18868:	908220a1 	addls	r2, r2, r1, lsr #1
   1886c:	e1a00230 	mov	r0, r0, lsr r2
   18870:	e12fff1e 	bx	lr
   18874:	e52de004 	str	lr, [sp, #-4]!
   18878:	eb0000c7 	bl	18b9c <__aeabi_idiv0>
   1887c:	e3a00000 	mov	r0, #0	; 0x0
   18880:	e49de004 	ldr	lr, [sp], #4
   18884:	e12fff1e 	bx	lr

00018888 <__aeabi_uidivmod>:
   18888:	e92d4003 	stmdb	sp!, {r0, r1, lr}
   1888c:	ebffffbe 	bl	1878c <__udivsi3>
   18890:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
   18894:	e0030092 	mul	r3, r2, r0
   18898:	e0411003 	sub	r1, r1, r3
   1889c:	e12fff1e 	bx	lr

000188a0 <__divsi3>:
   188a0:	e3510000 	cmp	r1, #0	; 0x0
   188a4:	e020c001 	eor	ip, r0, r1
   188a8:	0a000042 	beq	189b8 <__divsi3+0x118>
   188ac:	42611000 	rsbmi	r1, r1, #0	; 0x0
   188b0:	e2512001 	subs	r2, r1, #1	; 0x1
   188b4:	0a000027 	beq	18958 <__divsi3+0xb8>
   188b8:	e1b03000 	movs	r3, r0
   188bc:	42603000 	rsbmi	r3, r0, #0	; 0x0
   188c0:	e1530001 	cmp	r3, r1
   188c4:	9a000026 	bls	18964 <__divsi3+0xc4>
   188c8:	e1110002 	tst	r1, r2
   188cc:	0a000028 	beq	18974 <__divsi3+0xd4>
   188d0:	e311020e 	tst	r1, #-536870912	; 0xe0000000
   188d4:	01a01181 	moveq	r1, r1, lsl #3
   188d8:	03a02008 	moveq	r2, #8	; 0x8
   188dc:	13a02001 	movne	r2, #1	; 0x1
   188e0:	e3510201 	cmp	r1, #268435456	; 0x10000000
   188e4:	31510003 	cmpcc	r1, r3
   188e8:	31a01201 	movcc	r1, r1, lsl #4
   188ec:	31a02202 	movcc	r2, r2, lsl #4
   188f0:	3afffffa 	bcc	188e0 <__divsi3+0x40>
   188f4:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   188f8:	31510003 	cmpcc	r1, r3
   188fc:	31a01081 	movcc	r1, r1, lsl #1
   18900:	31a02082 	movcc	r2, r2, lsl #1
   18904:	3afffffa 	bcc	188f4 <__divsi3+0x54>
   18908:	e3a00000 	mov	r0, #0	; 0x0
   1890c:	e1530001 	cmp	r3, r1
   18910:	20433001 	subcs	r3, r3, r1
   18914:	21800002 	orrcs	r0, r0, r2
   18918:	e15300a1 	cmp	r3, r1, lsr #1
   1891c:	204330a1 	subcs	r3, r3, r1, lsr #1
   18920:	218000a2 	orrcs	r0, r0, r2, lsr #1
   18924:	e1530121 	cmp	r3, r1, lsr #2
   18928:	20433121 	subcs	r3, r3, r1, lsr #2
   1892c:	21800122 	orrcs	r0, r0, r2, lsr #2
   18930:	e15301a1 	cmp	r3, r1, lsr #3
   18934:	204331a1 	subcs	r3, r3, r1, lsr #3
   18938:	218001a2 	orrcs	r0, r0, r2, lsr #3
   1893c:	e3530000 	cmp	r3, #0	; 0x0
   18940:	11b02222 	movnes	r2, r2, lsr #4
   18944:	11a01221 	movne	r1, r1, lsr #4
   18948:	1affffef 	bne	1890c <__divsi3+0x6c>
   1894c:	e35c0000 	cmp	ip, #0	; 0x0
   18950:	42600000 	rsbmi	r0, r0, #0	; 0x0
   18954:	e12fff1e 	bx	lr
   18958:	e13c0000 	teq	ip, r0
   1895c:	42600000 	rsbmi	r0, r0, #0	; 0x0
   18960:	e12fff1e 	bx	lr
   18964:	33a00000 	movcc	r0, #0	; 0x0
   18968:	01a00fcc 	moveq	r0, ip, asr #31
   1896c:	03800001 	orreq	r0, r0, #1	; 0x1
   18970:	e12fff1e 	bx	lr
   18974:	e3510801 	cmp	r1, #65536	; 0x10000
   18978:	21a01821 	movcs	r1, r1, lsr #16
   1897c:	23a02010 	movcs	r2, #16	; 0x10
   18980:	33a02000 	movcc	r2, #0	; 0x0
   18984:	e3510c01 	cmp	r1, #256	; 0x100
   18988:	21a01421 	movcs	r1, r1, lsr #8
   1898c:	22822008 	addcs	r2, r2, #8	; 0x8
   18990:	e3510010 	cmp	r1, #16	; 0x10
   18994:	21a01221 	movcs	r1, r1, lsr #4
   18998:	22822004 	addcs	r2, r2, #4	; 0x4
   1899c:	e3510004 	cmp	r1, #4	; 0x4
   189a0:	82822003 	addhi	r2, r2, #3	; 0x3
   189a4:	908220a1 	addls	r2, r2, r1, lsr #1
   189a8:	e35c0000 	cmp	ip, #0	; 0x0
   189ac:	e1a00233 	mov	r0, r3, lsr r2
   189b0:	42600000 	rsbmi	r0, r0, #0	; 0x0
   189b4:	e12fff1e 	bx	lr
   189b8:	e52de004 	str	lr, [sp, #-4]!
   189bc:	eb000076 	bl	18b9c <__aeabi_idiv0>
   189c0:	e3a00000 	mov	r0, #0	; 0x0
   189c4:	e49de004 	ldr	lr, [sp], #4
   189c8:	e12fff1e 	bx	lr

000189cc <__aeabi_idivmod>:
   189cc:	e92d4003 	stmdb	sp!, {r0, r1, lr}
   189d0:	ebffffb2 	bl	188a0 <__divsi3>
   189d4:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
   189d8:	e0030092 	mul	r3, r2, r0
   189dc:	e0411003 	sub	r1, r1, r3
   189e0:	e12fff1e 	bx	lr

000189e4 <__umodsi3>:
   189e4:	e2512001 	subs	r2, r1, #1	; 0x1
   189e8:	3a00002c 	bcc	18aa0 <__umodsi3+0xbc>
   189ec:	11500001 	cmpne	r0, r1
   189f0:	03a00000 	moveq	r0, #0	; 0x0
   189f4:	81110002 	tsthi	r1, r2
   189f8:	00000002 	andeq	r0, r0, r2
   189fc:	912fff1e 	bxls	lr
   18a00:	e3a02000 	mov	r2, #0	; 0x0
   18a04:	e3510201 	cmp	r1, #268435456	; 0x10000000
   18a08:	31510000 	cmpcc	r1, r0
   18a0c:	31a01201 	movcc	r1, r1, lsl #4
   18a10:	32822004 	addcc	r2, r2, #4	; 0x4
   18a14:	3afffffa 	bcc	18a04 <__umodsi3+0x20>
   18a18:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   18a1c:	31510000 	cmpcc	r1, r0
   18a20:	31a01081 	movcc	r1, r1, lsl #1
   18a24:	32822001 	addcc	r2, r2, #1	; 0x1
   18a28:	3afffffa 	bcc	18a18 <__umodsi3+0x34>
   18a2c:	e2522003 	subs	r2, r2, #3	; 0x3
   18a30:	ba00000e 	blt	18a70 <__umodsi3+0x8c>
   18a34:	e1500001 	cmp	r0, r1
   18a38:	20400001 	subcs	r0, r0, r1
   18a3c:	e15000a1 	cmp	r0, r1, lsr #1
   18a40:	204000a1 	subcs	r0, r0, r1, lsr #1
   18a44:	e1500121 	cmp	r0, r1, lsr #2
   18a48:	20400121 	subcs	r0, r0, r1, lsr #2
   18a4c:	e15001a1 	cmp	r0, r1, lsr #3
   18a50:	204001a1 	subcs	r0, r0, r1, lsr #3
   18a54:	e3500001 	cmp	r0, #1	; 0x1
   18a58:	e1a01221 	mov	r1, r1, lsr #4
   18a5c:	a2522004 	subges	r2, r2, #4	; 0x4
   18a60:	aafffff3 	bge	18a34 <__umodsi3+0x50>
   18a64:	e3120003 	tst	r2, #3	; 0x3
   18a68:	13300000 	teqne	r0, #0	; 0x0
   18a6c:	0a00000a 	beq	18a9c <__umodsi3+0xb8>
   18a70:	e3720002 	cmn	r2, #2	; 0x2
   18a74:	ba000006 	blt	18a94 <__umodsi3+0xb0>
   18a78:	0a000002 	beq	18a88 <__umodsi3+0xa4>
   18a7c:	e1500001 	cmp	r0, r1
   18a80:	20400001 	subcs	r0, r0, r1
   18a84:	e1a010a1 	mov	r1, r1, lsr #1
   18a88:	e1500001 	cmp	r0, r1
   18a8c:	20400001 	subcs	r0, r0, r1
   18a90:	e1a010a1 	mov	r1, r1, lsr #1
   18a94:	e1500001 	cmp	r0, r1
   18a98:	20400001 	subcs	r0, r0, r1
   18a9c:	e12fff1e 	bx	lr
   18aa0:	e52de004 	str	lr, [sp, #-4]!
   18aa4:	eb00003c 	bl	18b9c <__aeabi_idiv0>
   18aa8:	e3a00000 	mov	r0, #0	; 0x0
   18aac:	e49de004 	ldr	lr, [sp], #4
   18ab0:	e12fff1e 	bx	lr

00018ab4 <__modsi3>:
   18ab4:	e3510000 	cmp	r1, #0	; 0x0
   18ab8:	0a000032 	beq	18b88 <__modsi3+0xd4>
   18abc:	42611000 	rsbmi	r1, r1, #0	; 0x0
   18ac0:	e1b0c000 	movs	ip, r0
   18ac4:	42600000 	rsbmi	r0, r0, #0	; 0x0
   18ac8:	e2512001 	subs	r2, r1, #1	; 0x1
   18acc:	11500001 	cmpne	r0, r1
   18ad0:	03a00000 	moveq	r0, #0	; 0x0
   18ad4:	81110002 	tsthi	r1, r2
   18ad8:	00000002 	andeq	r0, r0, r2
   18adc:	9a000026 	bls	18b7c <__modsi3+0xc8>
   18ae0:	e3a02000 	mov	r2, #0	; 0x0
   18ae4:	e3510201 	cmp	r1, #268435456	; 0x10000000
   18ae8:	31510000 	cmpcc	r1, r0
   18aec:	31a01201 	movcc	r1, r1, lsl #4
   18af0:	32822004 	addcc	r2, r2, #4	; 0x4
   18af4:	3afffffa 	bcc	18ae4 <__modsi3+0x30>
   18af8:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   18afc:	31510000 	cmpcc	r1, r0
   18b00:	31a01081 	movcc	r1, r1, lsl #1
   18b04:	32822001 	addcc	r2, r2, #1	; 0x1
   18b08:	3afffffa 	bcc	18af8 <__modsi3+0x44>
   18b0c:	e2522003 	subs	r2, r2, #3	; 0x3
   18b10:	ba00000e 	blt	18b50 <__modsi3+0x9c>
   18b14:	e1500001 	cmp	r0, r1
   18b18:	20400001 	subcs	r0, r0, r1
   18b1c:	e15000a1 	cmp	r0, r1, lsr #1
   18b20:	204000a1 	subcs	r0, r0, r1, lsr #1
   18b24:	e1500121 	cmp	r0, r1, lsr #2
   18b28:	20400121 	subcs	r0, r0, r1, lsr #2
   18b2c:	e15001a1 	cmp	r0, r1, lsr #3
   18b30:	204001a1 	subcs	r0, r0, r1, lsr #3
   18b34:	e3500001 	cmp	r0, #1	; 0x1
   18b38:	e1a01221 	mov	r1, r1, lsr #4
   18b3c:	a2522004 	subges	r2, r2, #4	; 0x4
   18b40:	aafffff3 	bge	18b14 <__modsi3+0x60>
   18b44:	e3120003 	tst	r2, #3	; 0x3
   18b48:	13300000 	teqne	r0, #0	; 0x0
   18b4c:	0a00000a 	beq	18b7c <__modsi3+0xc8>
   18b50:	e3720002 	cmn	r2, #2	; 0x2
   18b54:	ba000006 	blt	18b74 <__modsi3+0xc0>
   18b58:	0a000002 	beq	18b68 <__modsi3+0xb4>
   18b5c:	e1500001 	cmp	r0, r1
   18b60:	20400001 	subcs	r0, r0, r1
   18b64:	e1a010a1 	mov	r1, r1, lsr #1
   18b68:	e1500001 	cmp	r0, r1
   18b6c:	20400001 	subcs	r0, r0, r1
   18b70:	e1a010a1 	mov	r1, r1, lsr #1
   18b74:	e1500001 	cmp	r0, r1
   18b78:	20400001 	subcs	r0, r0, r1
   18b7c:	e35c0000 	cmp	ip, #0	; 0x0
   18b80:	42600000 	rsbmi	r0, r0, #0	; 0x0
   18b84:	e12fff1e 	bx	lr
   18b88:	e52de004 	str	lr, [sp, #-4]!
   18b8c:	eb000002 	bl	18b9c <__aeabi_idiv0>
   18b90:	e3a00000 	mov	r0, #0	; 0x0
   18b94:	e49de004 	ldr	lr, [sp], #4
   18b98:	e12fff1e 	bx	lr

00018b9c <__aeabi_idiv0>:
   18b9c:	e12fff1e 	bx	lr

00018ba0 <settings>:
   18ba0:	74746553 73676e69 0000003a              Settings:...

00018bac <radio_channel_menu>:
   18bac:	69646152 6843206f 656e6e61 0000006c     Radio Channel...

00018bbc <radio_power>:
   18bbc:	69646152 6f50206f 00726577              Radio Power.

00018bc8 <contrast>:
   18bc8:	746e6f43 74736172 00000000              Contrast....

00018bd4 <volume>:
   18bd4:	6c706d41 64757469 00000065              Amplitude...

00018be0 <newline>:
   18be0:	0000000a                                ....

00018be4 <USB>:
   18be4:	20425355 6e6e6f43 65746365 00002164     USB Connected!..

00018bf4 <NotFound>:
   18bf4:	656c6946 746f4e20 756f4620 0021646e     File Not Found!.

00018c04 <welcome>:
   18c04:	68636574 616d6f6e 6d206567 63697375     technomage music
   18c14:	3a786f62 00000d0a                       box:....

00018c1c <abInquiry>:
   18c1c:	02048000 0000001f 5543504c 20204253     ........LPCUSB  
   18c2c:	7373614d 6f747320 65676172 20202020     Mass storage    
   18c3c:	20312e30                                0.1 

00018c40 <abSense>:
   18c40:	00ff0070 0a000000 00000000 0000ffff     p...............
   18c50:	00000000                                ....

00018c54 <_global_impure_ptr>:
   18c54:	40000acc 49204453 2074696e 6f727245     ...@SD Init Erro
   18c64:	00000a72 4f204453 526e6570 20746f6f     r...SD OpenRoot 
   18c74:	6f727245 00000a72 00006425 00006e4f     Error...%d..On..
   18c84:	0066664f 6e65706f 20676e69 74726170     Off.opening part
   18c94:	6f697469 6166206e 64656c69 00000d0a     ition failed....
   18ca4:	6e65706f 20676e69 656c6966 74737973     opening filesyst
   18cb4:	66206d65 656c6961 000d0a64 0000002f     em failed.../...
   18cc4:	6e65706f 20676e69 746f6f72 72696420     opening root dir
   18cd4:	6f746365 66207972 656c6961 000d0a64     ectory failed...
   18ce4:	756e616d 20203a66 30257830 0d0a7832     manuf:  0x%02x..
   18cf4:	00000000 3a6d656f 20202020 0d0a7325     ....oem:    %s..
   18d04:	00000000 646f7270 2020203a 0d0a7325     ....prod:   %s..
   18d14:	00000000 3a766572 20202020 78323025     ....rev:    %02x
   18d24:	00000d0a 69726573 203a6c61 30257830     ....serial: 0x%0
   18d34:	0a786c38 0000000d 65746164 2020203a     8lx.....date:   
   18d44:	64323025 3230252f 000d0a64 657a6973     %02d/%02d...size
   18d54:	2020203a 0a646c25 0000000d 79706f63     :   %ld.....copy
   18d64:	2020203a 0d0a6425 00000000 702e7277     :   %d......wr.p
   18d74:	203a2e72 252f6425 000d0a64 6d726f66     r.: %d/%d...form
   18d84:	203a7461 0d0a6425 00000000 65657266     at: %d......free
   18d94:	2020203a 2f646c25 0a646c25 0000000d     :   %ld/%ld.....
   18da4:	52204453 4e205741 4120544f 4c494156     SD RAW NOT AVAIL
   18db4:	454c4241 00000d0a 65720d0a 6e6f7073     ABLE......respon
   18dc4:	203a6573 0d0a6425 00000000 203d2069     se: %d......i = 
   18dd4:	66377830 0d0a6666 00000000 434f4c42     0x7fff......BLOC
   18de4:	4953204b 5320455a 45205445 0a205252     K SIZE SET ERR .
   18df4:	0000000d 725f6473 725f7761 20646165     ....sd_raw_read 
   18e04:	6b726f62 000d0a73 4c4c414d 4620434f     borks...MALLOC F
   18e14:	534c4941 00000d0a 6c696146 52206465     AILS....Failed R
   18e24:	69646165 4820676e 65646165 000d0a72     eading Header...
   18e34:	74696e49 696c6169 676e6973 42535520     Initialising USB
   18e44:	61747320 000a6b63 72617453 676e6974      stack..Starting
   18e54:	42535520 6d6f6320 696e756d 69746163      USB communicati
   18e64:	000a6e6f 75677241 746e656d 74756f20     on..Argument out
   18e74:	20666f20 6e756f62 0a2e7364 00000000      of bounds......
   18e84:	72646441 20737365 2074756f 6220666f     Address out of b
   18e94:	646e756f 000a2e73 6f727245 75642072     ounds...Error du
   18ea4:	676e6972 61726520 73206573 65757165     ring erase seque
   18eb4:	2e65636e 0000000a 20435243 6c696166     nce.....CRC fail
   18ec4:	0a2e6465 00000000 656c6c49 206c6167     ed......Illegal 
   18ed4:	6d6d6f63 2e646e61 0000000a 73617245     command.....Eras
   18ee4:	65722065 20746573 65657328 6e615320     e reset (see San
   18ef4:	6b736944 636f6420 35702073 2933312d     Disk docs p5-13)
   18f04:	00000a2e 0000002e 6e6b6e55 206e776f     ........Unknown 
   18f14:	6f727265 78302072 28207825 20656573     error 0x%x (see 
   18f24:	446e6153 206b7369 73636f64 2d357020     SanDisk docs p5-
   18f34:	2e293331 0000000a 3a445343 00000000     13).....CSD:....
   18f44:	32302520 00000078 70736572 6678303d      %02x...resp=0xf
   18f54:	00000a66 70736572 78303d21 000a6666     f...resp!=0xff..
   18f64:	64726143 20736920 6b636f4c 0a2e6465     Card is Locked..
   18f74:	00000000 45205057 65736172 696b5320     ....WP Erase Ski
   18f84:	4c202c70 2f6b636f 6f6c6e55 43206b63     p, Lock/Unlock C
   18f94:	4620646d 656c6961 000a2e64 656e6547     md Failed...Gene
   18fa4:	206c6172 6e55202f 776f6e6b 7265206e     ral / Unknown er
   18fb4:	20726f72 63202d2d 20647261 6b6f7262     ror -- card brok
   18fc4:	2e3f6e65 0000000a 65746e49 6c616e72     en?.....Internal
   18fd4:	72616320 6f632064 6f72746e 72656c6c      card controller
   18fe4:	72726520 0a2e726f 00000000 64726143      error......Card
   18ff4:	746e6920 616e7265 4345206c 61772043      internal ECC wa
   19004:	70612073 65696c70 62202c64 66207475     s applied, but f
   19014:	656c6961 6f742064 726f6320 74636572     ailed to correct
   19024:	65687420 74616420 000a2e61 74697257      the data...Writ
   19034:	72702065 6365746f 69762074 74616c6f     e protect violat
   19044:	2e6e6f69 0000000a 69206e41 6c61766e     ion.....An inval
   19054:	73206469 63656c65 6e6f6974 6573202c     id selection, se
   19064:	726f7463 6f662073 72652072 2e657361     ctors for erase.
   19074:	0000000a 2074754f 5220666f 65676e61     ....Out of Range
   19084:	5343202c 764f5f44 72777265 2e657469     , CSD_Overwrite.
   19094:	0000000a 6e6b6e55 206e776f 6f727265     ....Unknown erro
   190a4:	30203a72 20782578 65657328 6e615320     r: 0x%x (see San
   190b4:	6b736944 636f6420 35702073 2934312d     Disk docs p5-14)
   190c4:	00000a2e 49204453 2074696e 656e6f64     ....SD Init done
   190d4:	0a2e2e2e 00000000 64726143 64696420     ........Card did
   190e4:	2074276e 75746572 74206e72 72206568     n't return the r
   190f4:	79646165 61747320 202c6574 61657262     eady state, brea
   19104:	676e696b 2e707520 000a2e2e 49697073     king up.....spiI
   19114:	2074696e 20726f66 28495053 000a2930     nit for SPI(0)..
   19124:	00000043                                C...
