   1              		.file	"fat16.c"
   9              	.Ltext0:
  10              		.section	.rodata.str1.4,"aMS",%progbits,1
  11              		.align	2
  12              	.LC0:
  13 0000 4D414C4C 		.ascii	"MALLOC FAILS\012\015\000"
  13      4F432046 
  13      41494C53 
  13      0A0D00
  14              		.global	__divsi3
  15              		.global	__udivsi3
  16 000f 00       		.align	2
  17              	.LC1:
  18 0010 4661696C 		.ascii	"Failed Reading Header\012\015\000"
  18      65642052 
  18      65616469 
  18      6E672048 
  18      65616465 
  19              		.text
  20              		.align	2
  21              		.global	fat16_open
  23              	fat16_open:
  24              	.LFB2:
  25              		.file 1 "../lib/fat16.c"
   1:../lib/fat16.c **** /* This program is free software; you can redistribute it and/or modify
   2:../lib/fat16.c ****  * it under the terms of the GNU General Public License version 2 as
   3:../lib/fat16.c ****  * published by the Free Software Foundation.
   4:../lib/fat16.c ****  */
   5:../lib/fat16.c **** 
   6:../lib/fat16.c **** #include <stdio.h>
   7:../lib/fat16.c **** 
   8:../lib/fat16.c **** //Debug
   9:../lib/fat16.c **** #include "rprintf.h"
  10:../lib/fat16.c **** 
  11:../lib/fat16.c **** #include "partition.h"
  12:../lib/fat16.c **** #include "fat16.h"
  13:../lib/fat16.c **** #include "fat16_config.h"
  14:../lib/fat16.c **** #include "sd_raw.h"
  15:../lib/fat16.c **** #include <stdlib.h>
  16:../lib/fat16.c **** #include <string.h>
  17:../lib/fat16.c **** 
  18:../lib/fat16.c **** //System level settings and defines
  19:../lib/fat16.c **** //#include "system_settings.h"
  20:../lib/fat16.c **** 
  21:../lib/fat16.c **** /**
  22:../lib/fat16.c ****  * \addtogroup fat16 FAT16 support
  23:../lib/fat16.c ****  *
  24:../lib/fat16.c ****  * This module implements FAT16 read and write access.
  25:../lib/fat16.c ****  *
  26:../lib/fat16.c ****  * The following features are supported:
  27:../lib/fat16.c ****  * - File names up to 31 characters long.
  28:../lib/fat16.c ****  * - Unlimited depth of subdirectories.
  29:../lib/fat16.c ****  * - Short 8.3 and long filenames.
  30:../lib/fat16.c ****  * - Creating and deleting files.
  31:../lib/fat16.c ****  * - Reading and writing from and to files.
  32:../lib/fat16.c ****  * - File resizing.
  33:../lib/fat16.c ****  * - File sizes of up to 4 gigabytes.
  34:../lib/fat16.c ****  *
  35:../lib/fat16.c ****  * @{
  36:../lib/fat16.c ****  */
  37:../lib/fat16.c **** /**
  38:../lib/fat16.c ****  * \file
  39:../lib/fat16.c ****  * FAT16 implementation.
  40:../lib/fat16.c ****  *
  41:../lib/fat16.c ****  * \author Roland Riegel
  42:../lib/fat16.c ****  */
  43:../lib/fat16.c **** 
  44:../lib/fat16.c **** /**
  45:../lib/fat16.c ****  * \addtogroup fat16_config FAT16 configuration
  46:../lib/fat16.c ****  * Preprocessor defines to configure the FAT16 implementation.
  47:../lib/fat16.c ****  */
  48:../lib/fat16.c **** 
  49:../lib/fat16.c **** /**
  50:../lib/fat16.c ****  * \addtogroup fat16_fs FAT16 access
  51:../lib/fat16.c ****  * Basic functions for handling a FAT16 filesystem.
  52:../lib/fat16.c ****  */
  53:../lib/fat16.c **** 
  54:../lib/fat16.c **** /**
  55:../lib/fat16.c ****  * \addtogroup fat16_file FAT16 file functions
  56:../lib/fat16.c ****  * Functions for managing files.
  57:../lib/fat16.c ****  */
  58:../lib/fat16.c **** 
  59:../lib/fat16.c **** /**
  60:../lib/fat16.c ****  * \addtogroup fat16_dir FAT16 directory functions
  61:../lib/fat16.c ****  * Functions for managing directories.
  62:../lib/fat16.c ****  */
  63:../lib/fat16.c **** 
  64:../lib/fat16.c **** /**
  65:../lib/fat16.c ****  * @}
  66:../lib/fat16.c ****  */
  67:../lib/fat16.c **** 
  68:../lib/fat16.c **** #define FAT16_CLUSTER_FREE 0x0000
  69:../lib/fat16.c **** #define FAT16_CLUSTER_RESERVED_MIN (uint16_t)0xfff0
  70:../lib/fat16.c **** #define FAT16_CLUSTER_RESERVED_MAX (uint16_t)0xfff6
  71:../lib/fat16.c **** #define FAT16_CLUSTER_BAD (uint16_t)0xfff7
  72:../lib/fat16.c **** #define FAT16_CLUSTER_LAST_MIN (uint16_t)0xfff8
  73:../lib/fat16.c **** #define FAT16_CLUSTER_LAST_MAX (uint16_t)0xffff
  74:../lib/fat16.c **** 
  75:../lib/fat16.c **** #define FAT16_DIRENTRY_DELETED 0xe5
  76:../lib/fat16.c **** #define FAT16_DIRENTRY_LFNLAST (1 << 6)
  77:../lib/fat16.c **** #define FAT16_DIRENTRY_LFNSEQMASK ((1 << 6) - 1)
  78:../lib/fat16.c **** 
  79:../lib/fat16.c **** /* Each entry within the directory table has a size of 32 bytes
  80:../lib/fat16.c ****  * and either contains a 8.3 DOS-style file name or a part of a
  81:../lib/fat16.c ****  * long file name, which may consist of several directory table
  82:../lib/fat16.c ****  * entries at once.
  83:../lib/fat16.c ****  *
  84:../lib/fat16.c ****  * multi-byte integer values are stored little-endian!
  85:../lib/fat16.c ****  *
  86:../lib/fat16.c ****  * 8.3 file name entry:
  87:../lib/fat16.c ****  * ====================
  88:../lib/fat16.c ****  * offset  length  description
  89:../lib/fat16.c ****  *      0       8  name (space padded)
  90:../lib/fat16.c ****  *      8       3  extension (space padded)
  91:../lib/fat16.c ****  *     11       1  attributes (FAT16_ATTRIB_*)
  92:../lib/fat16.c ****  
  93:../lib/fat16.c ****  *     0x0E     2  Creation Time
  94:../lib/fat16.c ****  *     0x10     2  Creation Date
  95:../lib/fat16.c ****  
  96:../lib/fat16.c ****  *
  97:../lib/fat16.c ****  * long file name (lfn) entry ordering for a single file name:
  98:../lib/fat16.c ****  * ===========================================================
  99:../lib/fat16.c ****  * LFN entry n
 100:../lib/fat16.c ****  *     ...
 101:../lib/fat16.c ****  * LFN entry 2
 102:../lib/fat16.c ****  * LFN entry 1
 103:../lib/fat16.c ****  * 8.3 entry (see above)
 104:../lib/fat16.c ****  *
 105:../lib/fat16.c ****  * lfn entry:
 106:../lib/fat16.c ****  * ==========
 107:../lib/fat16.c ****  * offset  length  description
 108:../lib/fat16.c ****  *      0       1  ordinal field
 109:../lib/fat16.c ****  *      1       2  unicode character 1
 110:../lib/fat16.c ****  *      3       3  unicode character 2
 111:../lib/fat16.c ****  *      5       3  unicode character 3
 112:../lib/fat16.c ****  *      7       3  unicode character 4
 113:../lib/fat16.c ****  *      9       3  unicode character 5
 114:../lib/fat16.c ****  *     11       1  attribute (always 0x0f)
 115:../lib/fat16.c ****  *     12       1  type (reserved, always 0)
 116:../lib/fat16.c ****  *     13       1  checksum
 117:../lib/fat16.c ****  *     14       2  unicode character 6
 118:../lib/fat16.c ****  *     16       2  unicode character 7
 119:../lib/fat16.c ****  *     18       2  unicode character 8
 120:../lib/fat16.c ****  *     20       2  unicode character 9
 121:../lib/fat16.c ****  *     22       2  unicode character 10
 122:../lib/fat16.c ****  *     24       2  unicode character 11
 123:../lib/fat16.c ****  *     26       2  cluster (unused, always 0)
 124:../lib/fat16.c ****  *     28       2  unicode character 12
 125:../lib/fat16.c ****  *     30       2  unicode character 13
 126:../lib/fat16.c ****  *
 127:../lib/fat16.c ****  * The ordinal field contains a descending number, from n to 1.
 128:../lib/fat16.c ****  * For the n'th lfn entry the ordinal field is or'ed with 0x40.
 129:../lib/fat16.c ****  * For deleted lfn entries, the ordinal field is set to 0xe5.
 130:../lib/fat16.c ****  */
 131:../lib/fat16.c **** 
 132:../lib/fat16.c **** struct fat16_header_struct
 133:../lib/fat16.c **** {
 134:../lib/fat16.c ****     uint32_t size;
 135:../lib/fat16.c **** 
 136:../lib/fat16.c ****     uint32_t fat_offset;
 137:../lib/fat16.c ****     uint32_t fat_size;
 138:../lib/fat16.c **** 
 139:../lib/fat16.c ****     uint16_t sector_size;
 140:../lib/fat16.c ****     uint16_t cluster_size;
 141:../lib/fat16.c **** 
 142:../lib/fat16.c ****     uint32_t root_dir_offset;
 143:../lib/fat16.c **** 
 144:../lib/fat16.c ****     uint32_t cluster_zero_offset;
 145:../lib/fat16.c **** };
 146:../lib/fat16.c **** 
 147:../lib/fat16.c **** struct fat16_fs_struct
 148:../lib/fat16.c **** {
 149:../lib/fat16.c ****     struct partition_struct* partition;
 150:../lib/fat16.c ****     struct fat16_header_struct header;
 151:../lib/fat16.c **** };
 152:../lib/fat16.c **** 
 153:../lib/fat16.c **** struct fat16_file_struct
 154:../lib/fat16.c **** {
 155:../lib/fat16.c ****     struct fat16_fs_struct* fs;
 156:../lib/fat16.c ****     struct fat16_dir_entry_struct dir_entry;
 157:../lib/fat16.c ****     uint32_t pos;
 158:../lib/fat16.c ****     uint16_t pos_cluster;
 159:../lib/fat16.c **** };
 160:../lib/fat16.c **** 
 161:../lib/fat16.c **** struct fat16_dir_struct
 162:../lib/fat16.c **** {
 163:../lib/fat16.c ****     struct fat16_fs_struct* fs;
 164:../lib/fat16.c ****     struct fat16_dir_entry_struct dir_entry;
 165:../lib/fat16.c ****     uint16_t entry_next;
 166:../lib/fat16.c **** };
 167:../lib/fat16.c **** 
 168:../lib/fat16.c **** struct fat16_read_callback_arg
 169:../lib/fat16.c **** {
 170:../lib/fat16.c ****     uint16_t entry_cur;
 171:../lib/fat16.c ****     uint16_t entry_num;
 172:../lib/fat16.c ****     uint32_t entry_offset;
 173:../lib/fat16.c ****     uint8_t byte_count;
 174:../lib/fat16.c **** };
 175:../lib/fat16.c **** 
 176:../lib/fat16.c **** struct fat16_usage_count_callback_arg
 177:../lib/fat16.c **** {
 178:../lib/fat16.c ****     uint16_t cluster_count;
 179:../lib/fat16.c ****     uint8_t buffer_size;
 180:../lib/fat16.c **** };
 181:../lib/fat16.c **** 
 182:../lib/fat16.c **** static uint8_t fat16_read_header(struct fat16_fs_struct* fs);
 183:../lib/fat16.c **** static uint8_t fat16_read_root_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, stru
 184:../lib/fat16.c **** static uint8_t fat16_read_sub_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, const
 185:../lib/fat16.c **** static uint8_t fat16_dir_entry_seek_callback(uint8_t* buffer, uint32_t offset, void* p);
 186:../lib/fat16.c **** static uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p);
 187:../lib/fat16.c **** static uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* r
 188:../lib/fat16.c **** static uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 189:../lib/fat16.c **** static uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint1
 190:../lib/fat16.c **** static uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 191:../lib/fat16.c **** static uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 192:../lib/fat16.c **** static uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry
 193:../lib/fat16.c **** 
 194:../lib/fat16.c **** static uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p);
 195:../lib/fat16.c **** 
 196:../lib/fat16.c **** /**
 197:../lib/fat16.c ****  * \ingroup fat16_fs
 198:../lib/fat16.c ****  * Opens a FAT16 filesystem.
 199:../lib/fat16.c ****  *
 200:../lib/fat16.c ****  * \param[in] partition Discriptor of partition on which the filesystem resides.
 201:../lib/fat16.c ****  * \returns 0 on error, a FAT16 filesystem descriptor on success.
 202:../lib/fat16.c ****  * \see fat16_open
 203:../lib/fat16.c ****  */
 204:../lib/fat16.c **** struct fat16_fs_struct* fat16_open(struct partition_struct* partition)
 205:../lib/fat16.c **** {
  26              		.loc 1 205 0
  27              		@ Function supports interworking.
  28              		@ args = 0, pretend = 0, frame = 40
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  32              	.LCFI0:
 206:../lib/fat16.c ****     if(!partition ||
  33              		.loc 1 206 0
  34 0004 009050E2 		subs	r9, r0, #0
  35              		.loc 1 205 0
  36 0008 28D04DE2 		sub	sp, sp, #40
  37              	.LCFI1:
  38              	.LVL1:
  39              		.loc 1 206 0
  40 000c 7200000A 		beq	.L2
  41              	.LVL2:
  42 0010 083099E5 		ldr	r3, [r9, #8]
  43 0014 000053E3 		cmp	r3, #0
  44 0018 7200000A 		beq	.L2
 207:../lib/fat16.c ****         #if FAT16_WRITE_SUPPORT
 208:../lib/fat16.c ****         !partition->device_write
 209:../lib/fat16.c ****        #else
 210:../lib/fat16.c ****         0
 211:../lib/fat16.c ****        #endif
 212:../lib/fat16.c ****        )
 213:../lib/fat16.c ****     return 0;
 214:../lib/fat16.c **** 
 215:../lib/fat16.c ****     struct fat16_fs_struct* fs = malloc(sizeof(*fs));
  45              		.loc 1 215 0
  46 001c 1C00A0E3 		mov	r0, #28
  47 0020 FEFFFFEB 		bl	malloc
 216:../lib/fat16.c ****     if(!fs)
  48              		.loc 1 216 0
  49 0024 00A050E2 		subs	sl, r0, #0
  50              	.LVL3:
  51 0028 0C00001A 		bne	.L5
 217:../lib/fat16.c ****     {
 218:../lib/fat16.c ****         rprintf("MALLOC FAILS\n\r");
  52              		.loc 1 218 0
  53 002c B0019FE5 		ldr	r0, .L18
  54 0030 FEFFFFEB 		bl	rprintf
  55 0034 730000EA 		b	.L7
  56              	.L5:
 219:../lib/fat16.c ****         return 0;
 220:../lib/fat16.c ****     }
 221:../lib/fat16.c ****     memset(fs, 0, sizeof(*fs));
  57              		.loc 1 221 0
  58 0038 0010A0E3 		mov	r1, #0
  59 003c 1C20A0E3 		mov	r2, #28
  60 0040 FEFFFFEB 		bl	memset
  61              	.LBB2:
  62              	.LBB3:
 222:../lib/fat16.c **** 
 223:../lib/fat16.c ****     fs->partition = partition;
 224:../lib/fat16.c ****     if(!fat16_read_header(fs))
 225:../lib/fat16.c ****     {
 226:../lib/fat16.c ****         rprintf("Failed Reading Header\n\r");
 227:../lib/fat16.c ****         free(fs);
 228:../lib/fat16.c ****         return 0;
 229:../lib/fat16.c ****     }
 230:../lib/fat16.c **** 
 231:../lib/fat16.c ****     return fs;
 232:../lib/fat16.c **** }
 233:../lib/fat16.c **** 
 234:../lib/fat16.c **** /**
 235:../lib/fat16.c ****  * \ingroup fat16_fs
 236:../lib/fat16.c ****  * Closes a FAT16 filesystem.
 237:../lib/fat16.c ****  *
 238:../lib/fat16.c ****  * When this function returns, the given filesystem descriptor
 239:../lib/fat16.c ****  * will be invalid.
 240:../lib/fat16.c ****  *
 241:../lib/fat16.c ****  * \param[in] fs The filesystem to close.
 242:../lib/fat16.c ****  * \see fat16_open
 243:../lib/fat16.c ****  */
 244:../lib/fat16.c **** void fat16_close(struct fat16_fs_struct* fs)
 245:../lib/fat16.c **** {
 246:../lib/fat16.c ****     if(!fs)
 247:../lib/fat16.c ****         return;
 248:../lib/fat16.c **** 
 249:../lib/fat16.c ****     free(fs);
 250:../lib/fat16.c **** }
 251:../lib/fat16.c **** 
 252:../lib/fat16.c **** /**
 253:../lib/fat16.c ****  * \ingroup fat16_fs
 254:../lib/fat16.c ****  * Reads and parses the header of a FAT16 filesystem.
 255:../lib/fat16.c ****  *
 256:../lib/fat16.c ****  * \param[inout] fs The filesystem for which to parse the header.
 257:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
 258:../lib/fat16.c ****  */
 259:../lib/fat16.c **** uint8_t fat16_read_header(struct fat16_fs_struct* fs)
 260:../lib/fat16.c **** {
 261:../lib/fat16.c ****     if(!fs)
 262:../lib/fat16.c ****         return 0;
 263:../lib/fat16.c **** 
 264:../lib/fat16.c ****     struct partition_struct* partition = fs->partition;
 265:../lib/fat16.c ****     if(!partition)
 266:../lib/fat16.c ****     {
 267:../lib/fat16.c ****         rprintf("Partition = 0\n\r");
 268:../lib/fat16.c ****         return 0;
 269:../lib/fat16.c ****     }
 270:../lib/fat16.c **** 
 271:../lib/fat16.c ****     /* read fat parameters */
 272:../lib/fat16.c ****     uint8_t buffer[25];
 273:../lib/fat16.c ****     uint32_t partition_offset = partition->offset * 512;
  63              		.loc 1 273 0
  64 0044 103099E5 		ldr	r3, [r9, #16]
  65 0048 8334A0E1 		mov	r3, r3, asl #9
  66 004c 00308DE5 		str	r3, [sp, #0]
  67              	.LVL4:
  68              	.LBE3:
  69              	.LBE2:
  70              		.loc 1 223 0
  71 0050 00908AE5 		str	r9, [sl, #0]
  72              	.LBB4:
  73              	.LBB5:
 274:../lib/fat16.c **** 
 275:../lib/fat16.c ****     if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
  74              		.loc 1 275 0
  75 0054 0B0083E2 		add	r0, r3, #11
  76 0058 0F108DE2 		add	r1, sp, #15
  77 005c 1920A0E3 		mov	r2, #25
  78 0060 00C099E5 		ldr	ip, [r9, #0]
  79 0064 0FE0A0E1 		mov	lr, pc
  80 0068 1CFF2FE1 		bx	ip
  81 006c 000050E3 		cmp	r0, #0
  82 0070 6800000A 		beq	.L8
 276:../lib/fat16.c ****         return 0;
 277:../lib/fat16.c **** 
 278:../lib/fat16.c ****     uint16_t bytes_per_sector = ((uint16_t) buffer[0x00]) |
 279:../lib/fat16.c ****     ((uint16_t) buffer[0x01] << 8);
 280:../lib/fat16.c ****     uint8_t sectors_per_cluster = buffer[0x02];
 281:../lib/fat16.c ****     uint16_t reserved_sectors = ((uint16_t) buffer[0x03]) |
 282:../lib/fat16.c ****     ((uint16_t) buffer[0x04] << 8);
 283:../lib/fat16.c ****     uint8_t fat_copies = buffer[0x05];
 284:../lib/fat16.c ****     uint16_t max_root_entries = ((uint16_t) buffer[0x06]) |
 285:../lib/fat16.c ****     ((uint16_t) buffer[0x07] << 8);
 286:../lib/fat16.c ****     uint16_t sector_count_16 = ((uint16_t) buffer[0x08]) |
 287:../lib/fat16.c ****     ((uint16_t) buffer[0x09] << 8);
 288:../lib/fat16.c ****     uint16_t sectors_per_fat = ((uint16_t) buffer[0x0b]) |
 289:../lib/fat16.c ****     ((uint16_t) buffer[0x0c] << 8);
  83              		.loc 1 289 0
  84 0074 1B20DDE5 		ldrb	r2, [sp, #27]	@ zero_extendqisi2
 290:../lib/fat16.c ****     uint32_t sector_count = ((uint32_t) buffer[0x15]) |
 291:../lib/fat16.c ****     ((uint32_t) buffer[0x16] << 8) |
 292:../lib/fat16.c ****     ((uint32_t) buffer[0x17] << 16) |
 293:../lib/fat16.c ****     ((uint32_t) buffer[0x18] << 24);
  85              		.loc 1 293 0
  86 0078 2500DDE5 		ldrb	r0, [sp, #37]	@ zero_extendqisi2
  87              		.loc 1 289 0
  88 007c 1A30DDE5 		ldrb	r3, [sp, #26]	@ zero_extendqisi2
  89              		.loc 1 293 0
  90 0080 2410DDE5 		ldrb	r1, [sp, #36]	@ zero_extendqisi2
  91              		.loc 1 289 0
  92 0084 023483E1 		orr	r3, r3, r2, asl #8
  93              		.loc 1 293 0
  94 0088 001481E1 		orr	r1, r1, r0, asl #8
  95              		.loc 1 282 0
  96 008c 1240DDE5 		ldrb	r4, [sp, #18]	@ zero_extendqisi2
  97 0090 1300DDE5 		ldrb	r0, [sp, #19]	@ zero_extendqisi2
  98              		.loc 1 289 0
  99 0094 03B0A0E1 		mov	fp, r3
 100              	.LVL5:
 101              		.loc 1 285 0
 102 0098 15C0DDE5 		ldrb	ip, [sp, #21]	@ zero_extendqisi2
 103 009c 1630DDE5 		ldrb	r3, [sp, #22]	@ zero_extendqisi2
 104              		.loc 1 282 0
 105 00a0 000484E1 		orr	r0, r4, r0, asl #8
 106              		.loc 1 293 0
 107 00a4 2670DDE5 		ldrb	r7, [sp, #38]	@ zero_extendqisi2
 108              		.loc 1 287 0
 109 00a8 1860DDE5 		ldrb	r6, [sp, #24]	@ zero_extendqisi2
 110              		.loc 1 293 0
 111 00ac 2720DDE5 		ldrb	r2, [sp, #39]	@ zero_extendqisi2
 112              		.loc 1 287 0
 113 00b0 1780DDE5 		ldrb	r8, [sp, #23]	@ zero_extendqisi2
 114              		.loc 1 279 0
 115 00b4 0F50DDE5 		ldrb	r5, [sp, #15]	@ zero_extendqisi2
 116 00b8 10E0DDE5 		ldrb	lr, [sp, #16]	@ zero_extendqisi2
 117              		.loc 1 282 0
 118 00bc 08008DE5 		str	r0, [sp, #8]
 119              	.LVL6:
 120              		.loc 1 285 0
 121 00c0 03048CE1 		orr	r0, ip, r3, asl #8
 122              	.LVL7:
 123              		.loc 1 280 0
 124 00c4 1130DDE5 		ldrb	r3, [sp, #17]	@ zero_extendqisi2
 125              		.loc 1 293 0
 126 00c8 071881E1 		orr	r1, r1, r7, asl #16
 294:../lib/fat16.c **** 
 295:../lib/fat16.c ****     if(sectors_per_fat == 0)
 127              		.loc 1 295 0
 128 00cc 00005BE3 		cmp	fp, #0
 129              		.loc 1 287 0
 130 00d0 068488E1 		orr	r8, r8, r6, asl #8
 131              		.loc 1 279 0
 132 00d4 0E5485E1 		orr	r5, r5, lr, asl #8
 133              	.LVL8:
 134              		.loc 1 293 0
 135 00d8 026C81E1 		orr	r6, r1, r2, asl #24
 136              	.LVL9:
 137              		.loc 1 280 0
 138 00dc 04308DE5 		str	r3, [sp, #4]
 139              	.LVL10:
 140              		.loc 1 283 0
 141 00e0 1420DDE5 		ldrb	r2, [sp, #20]	@ zero_extendqisi2
 142              	.LVL11:
 143              		.loc 1 295 0
 144 00e4 6800000A 		beq	.L8
 296:../lib/fat16.c ****     /* this is not a FAT16 */
 297:../lib/fat16.c ****         return 0;
 298:../lib/fat16.c **** 
 299:../lib/fat16.c ****     if(sector_count == 0)
 145              		.loc 1 299 0
 146 00e8 000056E3 		cmp	r6, #0
 147 00ec 3D00001A 		bne	.L11
 300:../lib/fat16.c ****     {
 301:../lib/fat16.c ****         if(sector_count_16 == 0)
 148              		.loc 1 301 0
 149 00f0 000058E3 		cmp	r8, #0
 150 00f4 6800000A 		beq	.L8
 151              	.LVL12:
 302:../lib/fat16.c ****     /* illegal volume size */
 303:../lib/fat16.c ****             return 0;
 304:../lib/fat16.c ****         else
 305:../lib/fat16.c ****             sector_count = sector_count_16;
 152              		.loc 1 305 0
 153 00f8 0860A0E1 		mov	r6, r8
 154              	.L11:
 306:../lib/fat16.c ****     }
 307:../lib/fat16.c **** 
 308:../lib/fat16.c ****     /* ensure we really have a FAT16 fs here */
 309:../lib/fat16.c ****     uint32_t data_sector_count = sector_count
 310:../lib/fat16.c ****     - reserved_sectors
 311:../lib/fat16.c ****     - (uint32_t) sectors_per_fat * fat_copies
 312:../lib/fat16.c ****     - ((max_root_entries * 32 + bytes_per_sector - 1) / bytes_per_sector);
 155              		.loc 1 312 0
 156 00fc 920B08E0 		mul	r8, r2, fp
 157              	.LVL13:
 313:../lib/fat16.c ****     uint32_t data_cluster_count = data_sector_count / sectors_per_cluster;
 158              		.loc 1 313 0
 159 0100 80B2A0E1 		mov	fp, r0, asl #5
 160              	.LVL14:
 161 0104 08309DE5 		ldr	r3, [sp, #8]
 162 0108 05008BE0 		add	r0, fp, r5
 163              	.LVL15:
 164 010c 0510A0E1 		mov	r1, r5
 165 0110 010040E2 		sub	r0, r0, #1
 166 0114 064063E0 		rsb	r4, r3, r6
 167 0118 FEFFFFEB 		bl	__divsi3
 168              	.LVL16:
 169 011c 044068E0 		rsb	r4, r8, r4
 170 0120 040060E0 		rsb	r0, r0, r4
 171 0124 04109DE5 		ldr	r1, [sp, #4]
 172 0128 FEFFFFEB 		bl	__udivsi3
 314:../lib/fat16.c ****     if(data_cluster_count < 4085 || data_cluster_count >= 65525)
 173              		.loc 1 314 0
 174 012c FF3E40E2 		sub	r3, r0, #4080
 175 0130 053043E2 		sub	r3, r3, #5
 176 0134 0F0A53E3 		cmp	r3, #61440
 177              		.loc 1 313 0
 178 0138 0070A0E1 		mov	r7, r0
 179              		.loc 1 314 0
 180 013c 6800002A 		bcs	.L8
 315:../lib/fat16.c ****     /* this is not a FAT16 */
 316:../lib/fat16.c ****         return 0;
 317:../lib/fat16.c **** 
 318:../lib/fat16.c ****     partition->type = PARTITION_TYPE_FAT16;
 319:../lib/fat16.c **** 
 320:../lib/fat16.c ****     /* fill header information */
 321:../lib/fat16.c ****     struct fat16_header_struct* header = &fs->header;
 181              		.loc 1 321 0
 182 0140 04408AE2 		add	r4, sl, #4
 183              	.LVL17:
 184              		.loc 1 318 0
 185 0144 0630A0E3 		mov	r3, #6
 186 0148 0C30C9E5 		strb	r3, [r9, #12]
 322:../lib/fat16.c ****     memset(header, 0, sizeof(*header));
 187              		.loc 1 322 0
 188 014c 0010A0E3 		mov	r1, #0
 189 0150 1820A0E3 		mov	r2, #24
 190 0154 0400A0E1 		mov	r0, r4
 191 0158 FEFFFFEB 		bl	memset
 323:../lib/fat16.c **** 
 324:../lib/fat16.c ****     header->size = sector_count * bytes_per_sector;
 325:../lib/fat16.c **** 
 326:../lib/fat16.c ****     header->fat_offset = /* jump to partition */
 192              		.loc 1 326 0
 193 015c 00309DE5 		ldr	r3, [sp, #0]
 194 0160 08009DE5 		ldr	r0, [sp, #8]
 195 0164 953020E0 		mla	r0, r5, r0, r3
 327:../lib/fat16.c ****     partition_offset +
 328:../lib/fat16.c ****     /* jump to fat */
 329:../lib/fat16.c ****     (uint32_t) reserved_sectors * bytes_per_sector;
 330:../lib/fat16.c ****     header->fat_size = (data_cluster_count + 2) * 2;
 331:../lib/fat16.c **** 
 332:../lib/fat16.c ****     header->sector_size = bytes_per_sector;
 333:../lib/fat16.c ****     header->cluster_size = (uint32_t) bytes_per_sector * sectors_per_cluster;
 196              		.loc 1 333 0
 197 0168 04C09DE5 		ldr	ip, [sp, #4]
 334:../lib/fat16.c **** 
 335:../lib/fat16.c ****     header->root_dir_offset = /* jump to fats */
 198              		.loc 1 335 0
 199 016c 95082EE0 		mla	lr, r5, r8, r0
 200              		.loc 1 324 0
 201 0170 950601E0 		mul	r1, r5, r6
 202              		.loc 1 333 0
 203 0174 950C0CE0 		mul	ip, r5, ip
 204              		.loc 1 330 0
 205 0178 8730A0E1 		mov	r3, r7, asl #1
 336:../lib/fat16.c ****     header->fat_offset +
 337:../lib/fat16.c ****     /* jump to root directory entries */
 338:../lib/fat16.c ****     (uint32_t) fat_copies * sectors_per_fat * bytes_per_sector;
 339:../lib/fat16.c **** 
 340:../lib/fat16.c ****     header->cluster_zero_offset = /* jump to root directory entries */
 206              		.loc 1 340 0
 207 017c 0B208EE0 		add	r2, lr, fp
 208              		.loc 1 330 0
 209 0180 043083E2 		add	r3, r3, #4
 210              		.loc 1 340 0
 211 0184 0160A0E3 		mov	r6, #1
 212              	.LVL18:
 213 0188 142084E5 		str	r2, [r4, #20]
 214              		.loc 1 324 0
 215 018c 04108AE5 		str	r1, [sl, #4]
 216              		.loc 1 330 0
 217 0190 083084E5 		str	r3, [r4, #8]
 218              		.loc 1 333 0
 219 0194 BEC0C4E1 		strh	ip, [r4, #14]	@ movhi
 220              		.loc 1 326 0
 221 0198 040084E5 		str	r0, [r4, #4]
 222              		.loc 1 332 0
 223 019c BC50C4E1 		strh	r5, [r4, #12]	@ movhi
 224              		.loc 1 335 0
 225 01a0 10E084E5 		str	lr, [r4, #16]
 226 01a4 690000EA 		b	.L15
 227              	.LVL19:
 228              	.L8:
 229              		.loc 1 340 0
 230 01a8 0060A0E3 		mov	r6, #0
 231              	.LVL20:
 232              	.L15:
 233              	.LBE5:
 234              	.LBE4:
 235              		.loc 1 224 0
 236 01ac FF4006E2 		and	r4, r6, #255
 237              	.LVL21:
 238 01b0 000054E3 		cmp	r4, #0
 239 01b4 7300001A 		bne	.L7
 240              		.loc 1 226 0
 241 01b8 28009FE5 		ldr	r0, .L18+4
 242              	.LVL22:
 243 01bc FEFFFFEB 		bl	rprintf
 244              	.LVL23:
 245              		.loc 1 227 0
 246 01c0 0A00A0E1 		mov	r0, sl
 247 01c4 FEFFFFEB 		bl	free
 248 01c8 04A0A0E1 		mov	sl, r4
 249 01cc 730000EA 		b	.L7
 250              	.LVL24:
 251              	.L2:
 252              		.loc 1 228 0
 253 01d0 00A0A0E3 		mov	sl, #0
 254              	.LVL25:
 255              	.L7:
 256              		.loc 1 232 0
 257 01d4 0A00A0E1 		mov	r0, sl
 258              	.LVL26:
 259 01d8 28D08DE2 		add	sp, sp, #40
 260 01dc F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 261 01e0 1EFF2FE1 		bx	lr
 262              	.L19:
 263              		.align	2
 264              	.L18:
 265 01e4 00000000 		.word	.LC0
 266 01e8 10000000 		.word	.LC1
 267              	.LFE2:
 269              		.align	2
 270              		.global	fat16_close
 272              	fat16_close:
 273              	.LFB3:
 274              		.loc 1 245 0
 275              		@ Function supports interworking.
 276              		@ args = 0, pretend = 0, frame = 0
 277              		@ frame_needed = 0, uses_anonymous_args = 0
 278              	.LVL27:
 279              		.loc 1 246 0
 280 01ec 000050E3 		cmp	r0, #0
 281              		.loc 1 245 0
 282 01f0 04E02DE5 		str	lr, [sp, #-4]!
 283              	.LCFI2:
 284              		.loc 1 246 0
 285              		.loc 1 249 0
 286 01f4 FEFFFF1B 		blne	free
 287              	.LVL28:
 288              	.LVL29:
 289              	.L23:
 290              		.loc 1 250 0
 291 01f8 04E09DE4 		ldr	lr, [sp], #4
 292 01fc 1EFF2FE1 		bx	lr
 293              	.LFE3:
 295              		.align	2
 297              	fat16_get_next_cluster:
 298              	.LFB11:
 341:../lib/fat16.c ****     header->root_dir_offset +
 342:../lib/fat16.c ****     /* skip root directory entries */
 343:../lib/fat16.c ****     (uint32_t) max_root_entries * 32;
 344:../lib/fat16.c **** 
 345:../lib/fat16.c ****     return 1;
 346:../lib/fat16.c **** }
 347:../lib/fat16.c **** 
 348:../lib/fat16.c **** /**
 349:../lib/fat16.c ****  * \ingroup fat16_fs
 350:../lib/fat16.c ****  * Reads a directory entry of the root directory.
 351:../lib/fat16.c ****  *
 352:../lib/fat16.c ****  * \param[in] fs Descriptor of file system to use.
 353:../lib/fat16.c ****  * \param[in] entry_num The index of the directory entry to read.
 354:../lib/fat16.c ****  * \param[out] dir_entry Directory entry descriptor which will get filled.
 355:../lib/fat16.c ****  * \returns 0 on failure, 1 on success
 356:../lib/fat16.c ****  * \see fat16_read_sub_dir_entry, fat16_read_dir_entry_by_path
 357:../lib/fat16.c ****  */
 358:../lib/fat16.c **** uint8_t fat16_read_root_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, struct fat1
 359:../lib/fat16.c **** {
 360:../lib/fat16.c ****     if(!fs || !dir_entry)
 361:../lib/fat16.c ****         return 0;
 362:../lib/fat16.c **** 
 363:../lib/fat16.c ****     /* we read from the root directory entry */
 364:../lib/fat16.c ****     const struct fat16_header_struct* header = &fs->header;
 365:../lib/fat16.c ****     device_read_interval_t device_read_interval = fs->partition->device_read_interval;
 366:../lib/fat16.c ****     uint8_t buffer[32];
 367:../lib/fat16.c **** 
 368:../lib/fat16.c ****     /* seek to the n-th entry */
 369:../lib/fat16.c ****     struct fat16_read_callback_arg arg;
 370:../lib/fat16.c ****     memset(&arg, 0, sizeof(arg));
 371:../lib/fat16.c ****     arg.entry_num = entry_num;
 372:../lib/fat16.c ****     if(!device_read_interval(header->root_dir_offset,
 373:../lib/fat16.c ****         buffer,
 374:../lib/fat16.c ****        sizeof(buffer),
 375:../lib/fat16.c ****        header->cluster_zero_offset - header->root_dir_offset,
 376:../lib/fat16.c ****        fat16_dir_entry_seek_callback,
 377:../lib/fat16.c ****        &arg) ||
 378:../lib/fat16.c ****        arg.entry_offset == 0
 379:../lib/fat16.c ****        )
 380:../lib/fat16.c ****     return 0;
 381:../lib/fat16.c **** 
 382:../lib/fat16.c ****     /* read entry */
 383:../lib/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 384:../lib/fat16.c ****     if(!device_read_interval(arg.entry_offset,
 385:../lib/fat16.c ****         buffer,
 386:../lib/fat16.c ****        sizeof(buffer),
 387:../lib/fat16.c ****        arg.byte_count,
 388:../lib/fat16.c ****        fat16_dir_entry_read_callback,
 389:../lib/fat16.c ****        dir_entry))
 390:../lib/fat16.c ****     return 0;
 391:../lib/fat16.c **** 
 392:../lib/fat16.c ****     return dir_entry->long_name[0] != '\0' ? 1 : 0;
 393:../lib/fat16.c **** }
 394:../lib/fat16.c **** 
 395:../lib/fat16.c **** /**
 396:../lib/fat16.c ****  * \ingroup fat16_fs
 397:../lib/fat16.c ****  * Reads a directory entry of a given parent directory.
 398:../lib/fat16.c ****  *
 399:../lib/fat16.c ****  * \param[in] fs Descriptor of file system to use.
 400:../lib/fat16.c ****  * \param[in] entry_num The index of the directory entry to read.
 401:../lib/fat16.c ****  * \param[in] parent Directory entry descriptor in which to read directory entry.
 402:../lib/fat16.c ****  * \param[out] dir_entry Directory entry descriptor which will get filled.
 403:../lib/fat16.c ****  * \returns 0 on failure, 1 on success
 404:../lib/fat16.c ****  * \see fat16_read_root_dir_entry, fat16_read_dir_entry_by_path
 405:../lib/fat16.c ****  */
 406:../lib/fat16.c **** uint8_t fat16_read_sub_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, const struct
 407:../lib/fat16.c **** {
 408:../lib/fat16.c ****     if(!fs || !parent || !dir_entry)
 409:../lib/fat16.c ****         return 0;
 410:../lib/fat16.c **** 
 411:../lib/fat16.c ****     /* we are in a parent directory and want to search within its directory entry table */
 412:../lib/fat16.c ****     if(!(parent->attributes & FAT16_ATTRIB_DIR))
 413:../lib/fat16.c ****         return 0;
 414:../lib/fat16.c **** 
 415:../lib/fat16.c ****     /* loop through all clusters of the directory */
 416:../lib/fat16.c ****     uint8_t buffer[32];
 417:../lib/fat16.c ****     uint32_t cluster_offset;
 418:../lib/fat16.c ****     uint16_t cluster_size = fs->header.cluster_size;
 419:../lib/fat16.c ****     uint16_t cluster_num = parent->cluster;
 420:../lib/fat16.c ****     struct fat16_read_callback_arg arg;
 421:../lib/fat16.c **** 
 422:../lib/fat16.c ****     while(1)
 423:../lib/fat16.c ****     {
 424:../lib/fat16.c ****         /* calculate new cluster offset */
 425:../lib/fat16.c ****         cluster_offset = fs->header.cluster_zero_offset + (uint32_t) (cluster_num - 2) * cluster_si
 426:../lib/fat16.c **** 
 427:../lib/fat16.c ****         /* seek to the n-th entry */
 428:../lib/fat16.c ****         memset(&arg, 0, sizeof(arg));
 429:../lib/fat16.c ****         arg.entry_num = entry_num;
 430:../lib/fat16.c ****         if(!fs->partition->device_read_interval(cluster_offset,
 431:../lib/fat16.c ****             buffer,
 432:../lib/fat16.c ****            sizeof(buffer),
 433:../lib/fat16.c ****            cluster_size,
 434:../lib/fat16.c ****            fat16_dir_entry_seek_callback,
 435:../lib/fat16.c ****            &arg)
 436:../lib/fat16.c ****            )
 437:../lib/fat16.c ****         return 0;
 438:../lib/fat16.c **** 
 439:../lib/fat16.c ****         /* check if we found the entry */
 440:../lib/fat16.c ****         if(arg.entry_offset)
 441:../lib/fat16.c ****             break;
 442:../lib/fat16.c **** 
 443:../lib/fat16.c ****         /* get number of next cluster */
 444:../lib/fat16.c ****         if(!(cluster_num = fat16_get_next_cluster(fs, cluster_num)))
 445:../lib/fat16.c ****             return 0; /* directory entry not found */
 446:../lib/fat16.c ****     }
 447:../lib/fat16.c **** 
 448:../lib/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 449:../lib/fat16.c **** 
 450:../lib/fat16.c ****     /* read entry */
 451:../lib/fat16.c ****     if(!fs->partition->device_read_interval(arg.entry_offset,
 452:../lib/fat16.c ****         buffer,
 453:../lib/fat16.c ****        sizeof(buffer),
 454:../lib/fat16.c ****        arg.byte_count,
 455:../lib/fat16.c ****        fat16_dir_entry_read_callback,
 456:../lib/fat16.c ****        dir_entry))
 457:../lib/fat16.c ****     return 0;
 458:../lib/fat16.c **** 
 459:../lib/fat16.c ****     return dir_entry->long_name[0] != '\0' ? 1 : 0;
 460:../lib/fat16.c **** }
 461:../lib/fat16.c **** 
 462:../lib/fat16.c **** /**
 463:../lib/fat16.c ****  * \ingroup fat16_fs
 464:../lib/fat16.c ****  * Callback function for seeking through subdirectory entries.
 465:../lib/fat16.c ****  */
 466:../lib/fat16.c **** uint8_t fat16_dir_entry_seek_callback(uint8_t* buffer, uint32_t offset, void* p)
 467:../lib/fat16.c **** {
 468:../lib/fat16.c ****     struct fat16_read_callback_arg* arg = p;
 469:../lib/fat16.c **** 
 470:../lib/fat16.c ****     /* skip deleted or empty entries */
 471:../lib/fat16.c ****     if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
 472:../lib/fat16.c ****         return 1;
 473:../lib/fat16.c **** 
 474:../lib/fat16.c ****     if(arg->entry_cur == arg->entry_num)
 475:../lib/fat16.c ****     {
 476:../lib/fat16.c ****         arg->entry_offset = offset;
 477:../lib/fat16.c ****         arg->byte_count = buffer[11] == 0x0f ?
 478:../lib/fat16.c ****         ((buffer[0] & FAT16_DIRENTRY_LFNSEQMASK) + 1) * 32 :
 479:../lib/fat16.c ****         32;
 480:../lib/fat16.c ****         return 0;
 481:../lib/fat16.c ****     }
 482:../lib/fat16.c **** 
 483:../lib/fat16.c ****     /* if we read a 8.3 entry, we reached a new directory entry */
 484:../lib/fat16.c ****     if(buffer[11] != 0x0f)
 485:../lib/fat16.c ****         ++arg->entry_cur;
 486:../lib/fat16.c **** 
 487:../lib/fat16.c ****     return 1;
 488:../lib/fat16.c **** }
 489:../lib/fat16.c **** 
 490:../lib/fat16.c **** /**
 491:../lib/fat16.c ****  * \ingroup fat16_fs
 492:../lib/fat16.c ****  * Callback function for reading a directory entry.
 493:../lib/fat16.c ****  */
 494:../lib/fat16.c **** uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p)
 495:../lib/fat16.c **** {
 496:../lib/fat16.c ****     struct fat16_dir_entry_struct* dir_entry = p;
 497:../lib/fat16.c **** 
 498:../lib/fat16.c ****     /* there should not be any deleted or empty entries */
 499:../lib/fat16.c ****     if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
 500:../lib/fat16.c ****         return 0;
 501:../lib/fat16.c **** 
 502:../lib/fat16.c ****     if(!dir_entry->entry_offset)
 503:../lib/fat16.c ****         dir_entry->entry_offset = offset;
 504:../lib/fat16.c **** 
 505:../lib/fat16.c ****     switch(fat16_interpret_dir_entry(dir_entry, buffer))
 506:../lib/fat16.c ****     {
 507:../lib/fat16.c ****         case 0: /* failure */
 508:../lib/fat16.c ****             return 0;
 509:../lib/fat16.c ****             case 1: /* buffer successfully parsed, continue */
 510:../lib/fat16.c ****             return 1;
 511:../lib/fat16.c ****             case 2: /* directory entry complete, finish */
 512:../lib/fat16.c ****             return 0;
 513:../lib/fat16.c ****         }
 514:../lib/fat16.c **** 
 515:../lib/fat16.c ****     return 0;
 516:../lib/fat16.c **** }
 517:../lib/fat16.c **** 
 518:../lib/fat16.c **** /**
 519:../lib/fat16.c ****  * \ingroup fat16_fs
 520:../lib/fat16.c ****  * Interprets a raw directory entry and puts the contained
 521:../lib/fat16.c ****  * information into the directory entry.
 522:../lib/fat16.c ****  *
 523:../lib/fat16.c ****  * For a single file there may exist multiple directory
 524:../lib/fat16.c ****  * entries. All except the last one are lfn entries, which
 525:../lib/fat16.c ****  * contain parts of the long filename. The last directory
 526:../lib/fat16.c ****  * entry is a traditional 8.3 style one. It contains all
 527:../lib/fat16.c ****  * other information like size, cluster, date and time.
 528:../lib/fat16.c ****  *
 529:../lib/fat16.c ****  * \param[in,out] dir_entry The directory entry to fill.
 530:../lib/fat16.c ****  * \param[in] raw_entry A pointer to 32 bytes of raw data.
 531:../lib/fat16.c ****  * \returns 0 on failure, 1 on success and 2 if the
 532:../lib/fat16.c ****  *          directory entry is complete.
 533:../lib/fat16.c ****  */
 534:../lib/fat16.c **** uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* raw_entr
 535:../lib/fat16.c **** {
 536:../lib/fat16.c ****     if(!dir_entry || !raw_entry || !raw_entry[0])
 537:../lib/fat16.c ****         return 0;
 538:../lib/fat16.c **** 
 539:../lib/fat16.c ****     char* long_name = dir_entry->long_name;
 540:../lib/fat16.c ****     if(raw_entry[11] == 0x0f)
 541:../lib/fat16.c ****     {
 542:../lib/fat16.c ****         uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
 543:../lib/fat16.c **** 
 544:../lib/fat16.c ****         if(char_offset + 12 < sizeof(dir_entry->long_name))
 545:../lib/fat16.c ****         {
 546:../lib/fat16.c ****             /* Lfn supports unicode, but we do not, for now.
 547:../lib/fat16.c ****                                                  * So we assume pure ascii and read only every
 548:../lib/fat16.c ****                                                  * second byte.
 549:../lib/fat16.c ****                                                  */
 550:../lib/fat16.c ****             long_name[char_offset + 0] = raw_entry[1];
 551:../lib/fat16.c ****             long_name[char_offset + 1] = raw_entry[3];
 552:../lib/fat16.c ****             long_name[char_offset + 2] = raw_entry[5];
 553:../lib/fat16.c ****             long_name[char_offset + 3] = raw_entry[7];
 554:../lib/fat16.c ****             long_name[char_offset + 4] = raw_entry[9];
 555:../lib/fat16.c ****             long_name[char_offset + 5] = raw_entry[14];
 556:../lib/fat16.c ****             long_name[char_offset + 6] = raw_entry[16];
 557:../lib/fat16.c ****             long_name[char_offset + 7] = raw_entry[18];
 558:../lib/fat16.c ****             long_name[char_offset + 8] = raw_entry[20];
 559:../lib/fat16.c ****             long_name[char_offset + 9] = raw_entry[22];
 560:../lib/fat16.c ****             long_name[char_offset + 10] = raw_entry[24];
 561:../lib/fat16.c ****             long_name[char_offset + 11] = raw_entry[28];
 562:../lib/fat16.c ****             long_name[char_offset + 12] = raw_entry[30];
 563:../lib/fat16.c ****         }
 564:../lib/fat16.c **** 
 565:../lib/fat16.c ****         return 1;
 566:../lib/fat16.c ****     }
 567:../lib/fat16.c ****     else
 568:../lib/fat16.c ****     {
 569:../lib/fat16.c ****         /* if we do not have a long name, take the short one */
 570:../lib/fat16.c ****         if(long_name[0] == '\0')
 571:../lib/fat16.c ****         {
 572:../lib/fat16.c ****             uint8_t i;
 573:../lib/fat16.c ****             for(i = 0; i < 8; ++i)
 574:../lib/fat16.c ****             {
 575:../lib/fat16.c ****                 if(raw_entry[i] == ' ')
 576:../lib/fat16.c ****                     break;
 577:../lib/fat16.c ****                 long_name[i] = raw_entry[i];
 578:../lib/fat16.c ****             }
 579:../lib/fat16.c ****             if(raw_entry[8] != ' ')
 580:../lib/fat16.c ****             {
 581:../lib/fat16.c ****                 long_name[i++] = '.';
 582:../lib/fat16.c **** 
 583:../lib/fat16.c ****                 uint8_t j = 8;
 584:../lib/fat16.c ****                 for(; j < 11; ++j)
 585:../lib/fat16.c ****                 {
 586:../lib/fat16.c ****                     if(raw_entry[j] != ' ')
 587:../lib/fat16.c ****                     {
 588:../lib/fat16.c ****                         long_name[i++] = raw_entry[j];
 589:../lib/fat16.c ****                     }
 590:../lib/fat16.c ****                     else
 591:../lib/fat16.c ****                     {
 592:../lib/fat16.c ****                         break;
 593:../lib/fat16.c ****                     }
 594:../lib/fat16.c ****                 }
 595:../lib/fat16.c ****             }
 596:../lib/fat16.c **** 
 597:../lib/fat16.c ****             long_name[i] = '\0';
 598:../lib/fat16.c ****         }
 599:../lib/fat16.c **** 
 600:../lib/fat16.c ****         /* extract properties of file and store them within the structure */
 601:../lib/fat16.c ****         dir_entry->attributes = raw_entry[11];
 602:../lib/fat16.c ****         dir_entry->cluster = ((uint16_t) raw_entry[26]) |
 603:../lib/fat16.c ****         ((uint16_t) raw_entry[27] << 8);
 604:../lib/fat16.c ****         dir_entry->file_size = ((uint32_t) raw_entry[28]) |
 605:../lib/fat16.c ****         ((uint32_t) raw_entry[29] << 8) |
 606:../lib/fat16.c ****         ((uint32_t) raw_entry[30] << 16) |
 607:../lib/fat16.c ****         ((uint32_t) raw_entry[31] << 24);
 608:../lib/fat16.c **** 
 609:../lib/fat16.c ****         return 2;
 610:../lib/fat16.c ****     }
 611:../lib/fat16.c **** }
 612:../lib/fat16.c **** 
 613:../lib/fat16.c **** /**
 614:../lib/fat16.c ****  * \ingroup fat16_file
 615:../lib/fat16.c ****  * Retrieves the directory entry of a path.
 616:../lib/fat16.c ****  *
 617:../lib/fat16.c ****  * The given path may both describe a file or a directory.
 618:../lib/fat16.c ****  *
 619:../lib/fat16.c ****  * \param[in] fs The FAT16 filesystem on which to search.
 620:../lib/fat16.c ****  * \param[in] path The path of which to read the directory entry.
 621:../lib/fat16.c ****  * \param[out] dir_entry The directory entry to fill.
 622:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
 623:../lib/fat16.c ****  * \see fat16_read_dir
 624:../lib/fat16.c ****  */
 625:../lib/fat16.c **** uint8_t fat16_get_dir_entry_of_path(struct fat16_fs_struct* fs, const char* path, struct fat16_dir_
 626:../lib/fat16.c **** {
 627:../lib/fat16.c ****     if(!fs || !path || path[0] == '\0' || !dir_entry)
 628:../lib/fat16.c ****         return 0;
 629:../lib/fat16.c **** 
 630:../lib/fat16.c ****     if(path[0] == '/')
 631:../lib/fat16.c ****         ++path;
 632:../lib/fat16.c **** 
 633:../lib/fat16.c ****     /* begin with the root directory */
 634:../lib/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 635:../lib/fat16.c ****     dir_entry->attributes = FAT16_ATTRIB_DIR;
 636:../lib/fat16.c **** 
 637:../lib/fat16.c ****     if(path[0] == '\0')
 638:../lib/fat16.c ****         return 1;
 639:../lib/fat16.c **** 
 640:../lib/fat16.c ****     while(1)
 641:../lib/fat16.c ****     {
 642:../lib/fat16.c ****         struct fat16_dir_struct* dd = fat16_open_dir(fs, dir_entry);
 643:../lib/fat16.c ****         if(!dd)
 644:../lib/fat16.c ****             break;
 645:../lib/fat16.c **** 
 646:../lib/fat16.c ****         /* extract the next hierarchy we will search for */
 647:../lib/fat16.c ****         const char* sep_pos = strchr(path, '/');
 648:../lib/fat16.c ****         if(!sep_pos)
 649:../lib/fat16.c ****             sep_pos = path + strlen(path);
 650:../lib/fat16.c ****         uint8_t length_to_sep = sep_pos - path;
 651:../lib/fat16.c **** 
 652:../lib/fat16.c ****         /* read directory entries */
 653:../lib/fat16.c ****         while(fat16_read_dir(dd, dir_entry))
 654:../lib/fat16.c ****         {
 655:../lib/fat16.c ****             /* check if we have found the next hierarchy */
 656:../lib/fat16.c ****             if((strlen(dir_entry->long_name) != length_to_sep ||
 657:../lib/fat16.c ****                 strncmp(path, dir_entry->long_name, length_to_sep) != 0))
 658:../lib/fat16.c ****             continue;
 659:../lib/fat16.c **** 
 660:../lib/fat16.c ****             fat16_close_dir(dd);
 661:../lib/fat16.c ****             dd = 0;
 662:../lib/fat16.c **** 
 663:../lib/fat16.c ****             if(path[length_to_sep] == '\0')
 664:../lib/fat16.c ****     /* we iterated through the whole path and have found the file */
 665:../lib/fat16.c ****                 return 1;
 666:../lib/fat16.c **** 
 667:../lib/fat16.c ****             if(dir_entry->attributes & FAT16_ATTRIB_DIR)
 668:../lib/fat16.c ****             {
 669:../lib/fat16.c ****                 /* we found a parent directory of the file we are searching for */
 670:../lib/fat16.c ****                 path = sep_pos + 1;
 671:../lib/fat16.c ****                 break;
 672:../lib/fat16.c ****             }
 673:../lib/fat16.c **** 
 674:../lib/fat16.c ****             /* a parent of the file exists, but not the file itself */
 675:../lib/fat16.c ****             return 0;
 676:../lib/fat16.c ****         }
 677:../lib/fat16.c **** 
 678:../lib/fat16.c ****         fat16_close_dir(dd);
 679:../lib/fat16.c ****     }
 680:../lib/fat16.c **** 
 681:../lib/fat16.c ****     return 0;
 682:../lib/fat16.c **** }
 683:../lib/fat16.c **** 
 684:../lib/fat16.c **** /**
 685:../lib/fat16.c ****  * \ingroup fat16_fs
 686:../lib/fat16.c ****  * Retrieves the next following cluster of a given cluster.
 687:../lib/fat16.c ****  *
 688:../lib/fat16.c ****  * Using the filesystem file allocation table, this function returns
 689:../lib/fat16.c ****  * the number of the cluster containing the data directly following
 690:../lib/fat16.c ****  * the data within the cluster with the given number.
 691:../lib/fat16.c ****  *
 692:../lib/fat16.c ****  * \param[in] fs The filesystem for which to determine the next cluster.
 693:../lib/fat16.c ****  * \param[in] cluster_num The number of the cluster for which to determine its successor.
 694:../lib/fat16.c ****  * \returns The wanted cluster number, or 0 on error.
 695:../lib/fat16.c ****  */
 696:../lib/fat16.c **** uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 697:../lib/fat16.c **** {
 299              		.loc 1 697 0
 300              		@ Function supports interworking.
 301              		@ args = 0, pretend = 0, frame = 4
 302              		@ frame_needed = 0, uses_anonymous_args = 0
 303              	.LVL30:
 304 0200 04E02DE5 		str	lr, [sp, #-4]!
 305              	.LCFI3:
 306 0204 0138A0E1 		mov	r3, r1, asl #16
 307 0208 2338A0E1 		mov	r3, r3, lsr #16
 308 020c 04D04DE2 		sub	sp, sp, #4
 309              	.LCFI4:
 310              	.LVL31:
 698:../lib/fat16.c ****     if(!fs || cluster_num < 2)
 699:../lib/fat16.c ****         return 0;
 700:../lib/fat16.c **** 
 701:../lib/fat16.c ****     /* read appropriate fat entry */
 702:../lib/fat16.c ****     uint8_t fat_entry[2];
 703:../lib/fat16.c ****     if(!fs->partition->device_read(fs->header.fat_offset + 2 * cluster_num, fat_entry, 2))
 311              		.loc 1 703 0
 312 0210 0220A0E3 		mov	r2, #2
 313              		.loc 1 698 0
 314 0214 000050E3 		cmp	r0, #0
 315 0218 01005313 		cmpne	r3, #1
 316              		.loc 1 703 0
 317 021c 02108DE0 		add	r1, sp, r2
 318              	.LVL32:
 319              		.loc 1 698 0
 320 0220 00C0A0E1 		mov	ip, r0
 321 0224 A300009A 		bls	.L25
 322              	.LVL33:
 323              		.loc 1 703 0
 324 0228 080090E5 		ldr	r0, [r0, #8]
 325 022c 930220E0 		mla	r0, r3, r2, r0
 326 0230 00309CE5 		ldr	r3, [ip, #0]
 327              	.LVL34:
 328 0234 00C093E5 		ldr	ip, [r3, #0]
 329 0238 0FE0A0E1 		mov	lr, pc
 330 023c 1CFF2FE1 		bx	ip
 331              	.LVL35:
 332 0240 000050E3 		cmp	r0, #0
 704:../lib/fat16.c ****         return 0;
 705:../lib/fat16.c **** 
 706:../lib/fat16.c ****     /* determine next cluster from fat */
 707:../lib/fat16.c ****     cluster_num = ((uint16_t) fat_entry[0]) |
 708:../lib/fat16.c ****     ((uint16_t) fat_entry[1] << 8);
 709:../lib/fat16.c **** 	///*
 710:../lib/fat16.c ****     if(cluster_num == FAT16_CLUSTER_FREE ||
 333              		.loc 1 710 0
 334 0244 58109FE5 		ldr	r1, .L32
 335              		.loc 1 703 0
 336 0248 A300000A 		beq	.L25
 337              		.loc 1 707 0
 338 024c 0220DDE5 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
 339 0250 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 340              		.loc 1 710 0
 341 0254 030492E1 		orrs	r0, r2, r3, asl #8
 342              	.LVL36:
 343 0258 0030A013 		movne	r3, #0
 344 025c 0130A003 		moveq	r3, #1
 345 0260 010050E1 		cmp	r0, r1
 346 0264 01308303 		orreq	r3, r3, #1
 347 0268 102080E2 		add	r2, r0, #16
 348 026c 000053E3 		cmp	r3, #0
 349 0270 0228A0E1 		mov	r2, r2, asl #16
 350 0274 A300001A 		bne	.L25
 351 0278 010050E1 		cmp	r0, r1
 352 027c 0030A093 		movls	r3, #0
 353 0280 0130A083 		movhi	r3, #1
 354 0284 060852E3 		cmp	r2, #393216
 355 0288 01308393 		orrls	r3, r3, #1
 356 028c 000053E3 		cmp	r3, #0
 357 0290 A400000A 		beq	.L30
 358              	.LVL37:
 359              	.L25:
 711:../lib/fat16.c ****         cluster_num == FAT16_CLUSTER_BAD ||
 712:../lib/fat16.c ****        (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX) ||
 713:../lib/fat16.c **** 	   //********************************************************************************
 714:../lib/fat16.c ****        //(cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
 715:../lib/fat16.c **** 	   (cluster_num >= FAT16_CLUSTER_LAST_MIN))
 716:../lib/fat16.c **** 	   //********************************************************************************
 717:../lib/fat16.c ****     //*/
 718:../lib/fat16.c **** 	return 0;
 719:../lib/fat16.c **** 
 720:../lib/fat16.c ****     return cluster_num;
 360              		.loc 1 720 0
 361 0294 0000A0E3 		mov	r0, #0
 362              	.LVL38:
 363              	.L30:
 364              	.LVL39:
 721:../lib/fat16.c **** }
 365              		.loc 1 721 0
 366 0298 04D08DE2 		add	sp, sp, #4
 367 029c 04E09DE4 		ldr	lr, [sp], #4
 368 02a0 1EFF2FE1 		bx	lr
 369              	.L33:
 370              		.align	2
 371              	.L32:
 372 02a4 F7FF0000 		.word	65527
 373              	.LFE11:
 375              		.align	2
 377              	fat16_dir_entry_seek_callback:
 378              	.LFB7:
 379              		.loc 1 467 0
 380              		@ Function supports interworking.
 381              		@ args = 0, pretend = 0, frame = 0
 382              		@ frame_needed = 0, uses_anonymous_args = 0
 383              		@ link register save eliminated.
 384              	.LVL40:
 385              		.loc 1 471 0
 386 02a8 0030D0E5 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 387 02ac 000053E3 		cmp	r3, #0
 388 02b0 E5005313 		cmpne	r3, #229
 389              		.loc 1 467 0
 390              		@ lr needed for prologue
 391              		.loc 1 471 0
 392 02b4 C200000A 		beq	.L35
 393              	.LVL41:
 394              		.loc 1 474 0
 395 02b8 B0C0D2E1 		ldrh	ip, [r2, #0]
 396 02bc B230D2E1 		ldrh	r3, [r2, #2]
 397 02c0 0C0053E1 		cmp	r3, ip
 398 02c4 BC00001A 		bne	.L37
 399              		.loc 1 476 0
 400 02c8 041082E5 		str	r1, [r2, #4]
 401              		.loc 1 477 0
 402 02cc 0B30D0E5 		ldrb	r3, [r0, #11]	@ zero_extendqisi2
 403 02d0 0F0053E3 		cmp	r3, #15
 404 02d4 0030D005 		ldreqb	r3, [r0, #0]	@ zero_extendqisi2
 405 02d8 3F300302 		andeq	r3, r3, #63
 406 02dc 8332A001 		moveq	r3, r3, asl #5
 407 02e0 20308302 		addeq	r3, r3, #32
 408 02e4 2010A0E3 		mov	r1, #32
 409              	.LVL42:
 410 02e8 0000A0E3 		mov	r0, #0
 411              	.LVL43:
 412 02ec FF100302 		andeq	r1, r3, #255
 413 02f0 0810C2E5 		strb	r1, [r2, #8]
 414 02f4 1EFF2FE1 		bx	lr
 415              	.LVL44:
 416              	.L37:
 417              		.loc 1 484 0
 418 02f8 0B30D0E5 		ldrb	r3, [r0, #11]	@ zero_extendqisi2
 419              		.loc 1 485 0
 420 02fc 01108CE2 		add	r1, ip, #1
 421              	.LVL45:
 422              		.loc 1 484 0
 423 0300 0F0053E3 		cmp	r3, #15
 424              		.loc 1 485 0
 425 0304 0100A0E3 		mov	r0, #1
 426              	.LVL46:
 427 0308 B010C211 		strneh	r1, [r2, #0]	@ movhi
 428              		.loc 1 484 0
 429 030c 1EFF2F11 		bxne	lr
 430              	.LVL47:
 431              	.L35:
 432              		.loc 1 485 0
 433 0310 0100A0E3 		mov	r0, #1
 434              	.LVL48:
 435              		.loc 1 488 0
 436 0314 1EFF2FE1 		bx	lr
 437              	.LFE7:
 439              		.align	2
 441              	fat16_dir_entry_read_callback:
 442              	.LFB8:
 443              		.loc 1 495 0
 444              		@ Function supports interworking.
 445              		@ args = 0, pretend = 0, frame = 0
 446              		@ frame_needed = 0, uses_anonymous_args = 0
 447              	.LVL49:
 448 0318 30402DE9 		stmfd	sp!, {r4, r5, lr}
 449              	.LCFI5:
 450              		.loc 1 499 0
 451 031c 0030D0E5 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 452 0320 000053E3 		cmp	r3, #0
 453 0324 E5005313 		cmpne	r3, #229
 454              		.loc 1 495 0
 455 0328 02C0A0E1 		mov	ip, r2
 456              	.LVL50:
 457              		.loc 1 499 0
 458 032c 3301000A 		beq	.L46
 459              	.LVL51:
 460              		.loc 1 502 0
 461 0330 283092E5 		ldr	r3, [r2, #40]
 462 0334 000053E3 		cmp	r3, #0
 463              		.loc 1 503 0
 464 0338 28108205 		streq	r1, [r2, #40]
 465              	.LBB6:
 466              	.LBB7:
 467              		.loc 1 536 0
 468 033c 000050E3 		cmp	r0, #0
 469 0340 2F01000A 		beq	.L50
 470              	.LVL52:
 471 0344 0020D0E5 		ldrb	r2, [r0, #0]	@ zero_extendqisi2
 472              	.LVL53:
 473 0348 000052E3 		cmp	r2, #0
 474 034c 2F01000A 		beq	.L50
 475              		.loc 1 540 0
 476 0350 0B30D0E5 		ldrb	r3, [r0, #11]	@ zero_extendqisi2
 477 0354 0F0053E3 		cmp	r3, #15
 478 0358 0B5080E2 		add	r5, r0, #11
 479 035c FD00001A 		bne	.L53
 480              	.LBB8:
 481              		.loc 1 542 0
 482 0360 3F2002E2 		and	r2, r2, #63
 483 0364 0D30A0E3 		mov	r3, #13
 484 0368 920303E0 		mul	r3, r2, r3
 485 036c 0D3043E2 		sub	r3, r3, #13
 486 0370 0338A0E1 		mov	r3, r3, asl #16
 487 0374 2328A0E1 		mov	r2, r3, lsr #16
 488              	.LVL54:
 489              		.loc 1 544 0
 490 0378 0C3082E2 		add	r3, r2, #12
 491 037c 1F0053E3 		cmp	r3, #31
 492 0380 0110A083 		movhi	r1, #1
 493              	.LVL55:
 494 0384 3001008A 		bhi	.L57
 495              		.loc 1 550 0
 496 0388 0130D0E5 		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 497 038c 0230CCE7 		strb	r3, [ip, r2]
 498              		.loc 1 551 0
 499 0390 0330D0E5 		ldrb	r3, [r0, #3]	@ zero_extendqisi2
 500 0394 02208CE0 		add	r2, ip, r2
 501              	.LVL56:
 502 0398 0130C2E5 		strb	r3, [r2, #1]
 503              		.loc 1 552 0
 504 039c 0530D0E5 		ldrb	r3, [r0, #5]	@ zero_extendqisi2
 505 03a0 0230C2E5 		strb	r3, [r2, #2]
 506              		.loc 1 553 0
 507 03a4 0730D0E5 		ldrb	r3, [r0, #7]	@ zero_extendqisi2
 508 03a8 0330C2E5 		strb	r3, [r2, #3]
 509              		.loc 1 554 0
 510 03ac 0930D0E5 		ldrb	r3, [r0, #9]	@ zero_extendqisi2
 511 03b0 0430C2E5 		strb	r3, [r2, #4]
 512              		.loc 1 555 0
 513 03b4 0E30D0E5 		ldrb	r3, [r0, #14]	@ zero_extendqisi2
 514 03b8 0530C2E5 		strb	r3, [r2, #5]
 515              		.loc 1 556 0
 516 03bc 1030D0E5 		ldrb	r3, [r0, #16]	@ zero_extendqisi2
 517 03c0 0630C2E5 		strb	r3, [r2, #6]
 518              		.loc 1 557 0
 519 03c4 1230D0E5 		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 520 03c8 0730C2E5 		strb	r3, [r2, #7]
 521              		.loc 1 558 0
 522 03cc 1430D0E5 		ldrb	r3, [r0, #20]	@ zero_extendqisi2
 523 03d0 0830C2E5 		strb	r3, [r2, #8]
 524              		.loc 1 559 0
 525 03d4 1630D0E5 		ldrb	r3, [r0, #22]	@ zero_extendqisi2
 526 03d8 0930C2E5 		strb	r3, [r2, #9]
 527              		.loc 1 560 0
 528 03dc 1830D0E5 		ldrb	r3, [r0, #24]	@ zero_extendqisi2
 529 03e0 0A30C2E5 		strb	r3, [r2, #10]
 530              		.loc 1 561 0
 531 03e4 1C30D0E5 		ldrb	r3, [r0, #28]	@ zero_extendqisi2
 532 03e8 0B30C2E5 		strb	r3, [r2, #11]
 533              		.loc 1 562 0
 534 03ec 1E30D0E5 		ldrb	r3, [r0, #30]	@ zero_extendqisi2
 535 03f0 0110A0E3 		mov	r1, #1
 536 03f4 0C30C2E5 		strb	r3, [r2, #12]
 537 03f8 300100EA 		b	.L57
 538              	.LVL57:
 539              	.L53:
 540              	.LBE8:
 541              		.loc 1 570 0
 542 03fc 0020DCE5 		ldrb	r2, [ip, #0]	@ zero_extendqisi2
 543 0400 000052E3 		cmp	r2, #0
 544 0404 1F01001A 		bne	.L58
 545 0408 0210A0E1 		mov	r1, r2
 546              	.LVL58:
 547              	.L60:
 548              	.LBB9:
 549              		.loc 1 575 0
 550 040c 0030D2E7 		ldrb	r3, [r2, r0]	@ zero_extendqisi2
 551 0410 200053E3 		cmp	r3, #32
 552              		.loc 1 573 0
 553 0414 01E081E2 		add	lr, r1, #1
 554              		.loc 1 575 0
 555 0418 0A01000A 		beq	.L61
 556              		.loc 1 573 0
 557 041c FF100EE2 		and	r1, lr, #255
 558 0420 080051E3 		cmp	r1, #8
 559              		.loc 1 577 0
 560 0424 0C30C2E7 		strb	r3, [r2, ip]
 561              		.loc 1 573 0
 562 0428 012082E2 		add	r2, r2, #1
 563 042c 0101001A 		bne	.L60
 564              	.L61:
 565              		.loc 1 579 0
 566 0430 0830D0E5 		ldrb	r3, [r0, #8]	@ zero_extendqisi2
 567 0434 200053E3 		cmp	r3, #32
 568 0438 1D01000A 		beq	.L63
 569              	.LBB10:
 570              		.loc 1 581 0
 571 043c 2E30A0E3 		mov	r3, #46
 572 0440 012081E2 		add	r2, r1, #1
 573 0444 0130CCE7 		strb	r3, [ip, r1]
 574 0448 03E0A0E3 		mov	lr, #3
 575 044c FF1002E2 		and	r1, r2, #255
 576 0450 0030A0E1 		mov	r3, r0
 577              	.L65:
 578              		.loc 1 586 0
 579 0454 0820D3E5 		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 580 0458 200052E3 		cmp	r2, #32
 581              		.loc 1 588 0
 582 045c 01E04EE2 		sub	lr, lr, #1
 583 0460 014081E2 		add	r4, r1, #1
 584 0464 013083E2 		add	r3, r3, #1
 585              		.loc 1 586 0
 586 0468 1D01000A 		beq	.L63
 587              		.loc 1 584 0
 588 046c FFE01EE2 		ands	lr, lr, #255
 589              		.loc 1 588 0
 590 0470 0120CCE7 		strb	r2, [ip, r1]
 591 0474 FF1004E2 		and	r1, r4, #255
 592              		.loc 1 584 0
 593 0478 1301001A 		bne	.L65
 594              	.L63:
 595              	.LBE10:
 596              		.loc 1 597 0
 597 047c 0030A0E3 		mov	r3, #0
 598 0480 0130CCE7 		strb	r3, [ip, r1]
 599              	.LVL59:
 600              	.L58:
 601              	.LBE9:
 602              		.loc 1 601 0
 603 0484 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 604 0488 2030CCE5 		strb	r3, [ip, #32]
 605              		.loc 1 602 0
 606 048c 1B20D0E5 		ldrb	r2, [r0, #27]	@ zero_extendqisi2
 607 0490 1A30D0E5 		ldrb	r3, [r0, #26]	@ zero_extendqisi2
 608 0494 023483E1 		orr	r3, r3, r2, asl #8
 609 0498 B232CCE1 		strh	r3, [ip, #34]	@ movhi
 610              		.loc 1 604 0
 611 049c 1D20D0E5 		ldrb	r2, [r0, #29]	@ zero_extendqisi2
 612 04a0 1C30D0E5 		ldrb	r3, [r0, #28]	@ zero_extendqisi2
 613 04a4 1E10D0E5 		ldrb	r1, [r0, #30]	@ zero_extendqisi2
 614              	.LVL60:
 615 04a8 023483E1 		orr	r3, r3, r2, asl #8
 616 04ac 1F20D0E5 		ldrb	r2, [r0, #31]	@ zero_extendqisi2
 617 04b0 013883E1 		orr	r3, r3, r1, asl #16
 618 04b4 023C83E1 		orr	r3, r3, r2, asl #24
 619 04b8 0210A0E3 		mov	r1, #2
 620 04bc 24308CE5 		str	r3, [ip, #36]
 621 04c0 300100EA 		b	.L57
 622              	.LVL61:
 623              	.L50:
 624 04c4 0010A0E3 		mov	r1, #0
 625              	.LVL62:
 626              	.L57:
 627              	.LBE7:
 628              	.LBE6:
 629              		.loc 1 505 0
 630 04c8 FF0001E2 		and	r0, r1, #255
 631              	.LVL63:
 632 04cc 010050E3 		cmp	r0, #1
 633 04d0 3401000A 		beq	.L68
 634              	.LVL64:
 635              	.L46:
 636 04d4 0000A0E3 		mov	r0, #0
 637              	.LVL65:
 638              	.L68:
 639              		.loc 1 516 0
 640 04d8 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 641 04dc 1EFF2FE1 		bx	lr
 642              	.LFE8:
 644              		.align	2
 645              		.global	fat16_read_dir
 647              	fat16_read_dir:
 648              	.LFB23:
 722:../lib/fat16.c **** 
 723:../lib/fat16.c **** /**
 724:../lib/fat16.c ****  * \ingroup fat16_fs
 725:../lib/fat16.c ****  * Appends a new cluster chain to an existing one.
 726:../lib/fat16.c ****  *
 727:../lib/fat16.c ****  * Set cluster_num to zero to create a completely new one.
 728:../lib/fat16.c ****  *
 729:../lib/fat16.c ****  * \param[in] fs The file system on which to operate.
 730:../lib/fat16.c ****  * \param[in] cluster_num The cluster to which to append the new chain.
 731:../lib/fat16.c ****  * \param[in] count The number of clusters to allocate.
 732:../lib/fat16.c ****  * \returns 0 on failure, the number of the first new cluster on success.
 733:../lib/fat16.c ****  */
 734:../lib/fat16.c **** uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint16_t cou
 735:../lib/fat16.c **** {
 736:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
 737:../lib/fat16.c ****         if(!fs)
 738:../lib/fat16.c ****             return 0;
 739:../lib/fat16.c ****     
 740:../lib/fat16.c ****         device_read_t device_read = fs->partition->device_read;
 741:../lib/fat16.c ****         device_write_t device_write = fs->partition->device_write;
 742:../lib/fat16.c ****         uint32_t fat_offset = fs->header.fat_offset;
 743:../lib/fat16.c ****         uint16_t cluster_max = fs->header.fat_size / 2;
 744:../lib/fat16.c ****         uint16_t cluster_next = 0;
 745:../lib/fat16.c ****         uint16_t count_left = count;
 746:../lib/fat16.c ****         uint8_t buffer[2];
 747:../lib/fat16.c ****         uint16_t cluster_new;
 748:../lib/fat16.c ****         for(cluster_new = 0; cluster_new < cluster_max; ++cluster_new)
 749:../lib/fat16.c ****         {
 750:../lib/fat16.c ****             if(!device_read(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
 751:../lib/fat16.c ****                 return 0;
 752:../lib/fat16.c ****     
 753:../lib/fat16.c ****             /* check if this is a free cluster */
 754:../lib/fat16.c ****             if(buffer[0] == (FAT16_CLUSTER_FREE & 0xff) &&
 755:../lib/fat16.c ****                 buffer[1] == ((FAT16_CLUSTER_FREE >> 8) & 0xff))
 756:../lib/fat16.c ****             {
 757:../lib/fat16.c ****                 /* allocate cluster */
 758:../lib/fat16.c ****                 if(count_left == count)
 759:../lib/fat16.c ****                 {
 760:../lib/fat16.c ****                     buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
 761:../lib/fat16.c ****                     buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
 762:../lib/fat16.c ****                 }
 763:../lib/fat16.c ****                 else
 764:../lib/fat16.c ****                 {
 765:../lib/fat16.c ****                     buffer[0] = cluster_next & 0xff;
 766:../lib/fat16.c ****                     buffer[1] = (cluster_next >> 8) & 0xff;
 767:../lib/fat16.c ****                 }
 768:../lib/fat16.c ****     
 769:../lib/fat16.c ****                 if(!device_write(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
 770:../lib/fat16.c ****                     break;
 771:../lib/fat16.c ****     
 772:../lib/fat16.c ****                 cluster_next = cluster_new;
 773:../lib/fat16.c ****                 if(--count_left == 0)
 774:../lib/fat16.c ****                     break;
 775:../lib/fat16.c ****             }
 776:../lib/fat16.c ****         }
 777:../lib/fat16.c ****     
 778:../lib/fat16.c ****         do
 779:../lib/fat16.c ****         {
 780:../lib/fat16.c ****             if(count_left > 0)
 781:../lib/fat16.c ****                 break;
 782:../lib/fat16.c ****     
 783:../lib/fat16.c ****             /* We allocated a new cluster chain. Now join
 784:../lib/fat16.c ****                                              * it with the existing one.
 785:../lib/fat16.c ****                                              */
 786:../lib/fat16.c ****             if(cluster_num >= 2)
 787:../lib/fat16.c ****             {
 788:../lib/fat16.c ****                 buffer[0] = cluster_next & 0xff;
 789:../lib/fat16.c ****                 buffer[1] = (cluster_next >> 8) & 0xff;
 790:../lib/fat16.c ****                 if(!device_write(fat_offset + 2 * cluster_num, buffer, sizeof(buffer)))
 791:../lib/fat16.c ****                     break;
 792:../lib/fat16.c ****             }
 793:../lib/fat16.c ****     
 794:../lib/fat16.c ****             return cluster_next;
 795:../lib/fat16.c ****     
 796:../lib/fat16.c ****         }
 797:../lib/fat16.c ****         while(0);
 798:../lib/fat16.c ****     
 799:../lib/fat16.c ****         /* No space left on device or writing error.
 800:../lib/fat16.c ****                              * Free up all clusters already allocated.
 801:../lib/fat16.c ****                              */
 802:../lib/fat16.c ****         fat16_free_clusters(fs, cluster_next);
 803:../lib/fat16.c ****     
 804:../lib/fat16.c ****         return 0;
 805:../lib/fat16.c ****     #else
 806:../lib/fat16.c ****         return 0;
 807:../lib/fat16.c ****     #endif
 808:../lib/fat16.c **** }
 809:../lib/fat16.c **** 
 810:../lib/fat16.c **** /**
 811:../lib/fat16.c ****  * \ingroup fat16_fs
 812:../lib/fat16.c ****  * Frees a cluster chain, or a part thereof.
 813:../lib/fat16.c ****  *
 814:../lib/fat16.c ****  * Marks the specified cluster and all clusters which are sequentially
 815:../lib/fat16.c ****  * referenced by it as free. They may then be used again for future
 816:../lib/fat16.c ****  * file allocations.
 817:../lib/fat16.c ****  *
 818:../lib/fat16.c ****  * \note If this function is used for freeing just a part of a cluster
 819:../lib/fat16.c ****  *       chain, the new end of the chain is not correctly terminated
 820:../lib/fat16.c ****  *       within the FAT. Use fat16_terminate_clusters() instead.
 821:../lib/fat16.c ****  *
 822:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
 823:../lib/fat16.c ****  * \param[in] cluster_num The starting cluster of the chain which to free.
 824:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
 825:../lib/fat16.c ****  * \see fat16_terminate_clusters
 826:../lib/fat16.c ****  */
 827:../lib/fat16.c **** uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 828:../lib/fat16.c **** {
 829:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
 830:../lib/fat16.c ****         if(!fs || cluster_num < 2)
 831:../lib/fat16.c ****             return 0;
 832:../lib/fat16.c ****     
 833:../lib/fat16.c ****         uint32_t fat_offset = fs->header.fat_offset;
 834:../lib/fat16.c ****         uint8_t buffer[2];
 835:../lib/fat16.c ****         while(cluster_num)
 836:../lib/fat16.c ****         {
 837:../lib/fat16.c ****             if(!fs->partition->device_read(fat_offset + 2 * cluster_num, buffer, 2))
 838:../lib/fat16.c ****                 return 0;
 839:../lib/fat16.c ****     
 840:../lib/fat16.c ****             /* get next cluster of current cluster before freeing current cluster */
 841:../lib/fat16.c ****             uint16_t cluster_num_next = ((uint16_t) buffer[0]) |
 842:../lib/fat16.c ****             ((uint16_t) buffer[1] << 8);
 843:../lib/fat16.c ****     
 844:../lib/fat16.c ****             if(cluster_num_next == FAT16_CLUSTER_FREE)
 845:../lib/fat16.c ****                 return 1;
 846:../lib/fat16.c ****             if(cluster_num_next == FAT16_CLUSTER_BAD ||
 847:../lib/fat16.c ****                 (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
 848:../lib/fat16.c ****                cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
 849:../lib/fat16.c ****                )
 850:../lib/fat16.c ****                )
 851:../lib/fat16.c ****             return 0;
 852:../lib/fat16.c **** 			///*
 853:../lib/fat16.c **** 			//**********************************************************
 854:../lib/fat16.c ****             //if((cluster_num_next >= FAT16_CLUSTER_LAST_MIN) &&
 855:../lib/fat16.c ****             //    (cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
 856:../lib/fat16.c ****             //   )
 857:../lib/fat16.c **** 			if(cluster_num_next >= FAT16_CLUSTER_LAST_MIN)
 858:../lib/fat16.c **** 			//***********************************************************
 859:../lib/fat16.c **** 			//*/
 860:../lib/fat16.c ****             cluster_num_next = 0;
 861:../lib/fat16.c ****     
 862:../lib/fat16.c ****             /* free cluster */
 863:../lib/fat16.c ****             buffer[0] = FAT16_CLUSTER_FREE & 0xff;
 864:../lib/fat16.c ****             buffer[1] = (FAT16_CLUSTER_FREE >> 8) & 0xff;
 865:../lib/fat16.c ****             fs->partition->device_write(fat_offset + 2 * cluster_num, buffer, 2);
 866:../lib/fat16.c ****     
 867:../lib/fat16.c ****             /* We continue in any case here, even if freeing the cluster failed.
 868:../lib/fat16.c ****                                              * The cluster is lost, but maybe we can still free up 
 869:../lib/fat16.c ****                                              */
 870:../lib/fat16.c ****     
 871:../lib/fat16.c ****             cluster_num = cluster_num_next;
 872:../lib/fat16.c ****         }
 873:../lib/fat16.c ****     
 874:../lib/fat16.c ****         return 1;
 875:../lib/fat16.c ****     #else
 876:../lib/fat16.c ****         return 0;
 877:../lib/fat16.c ****     #endif
 878:../lib/fat16.c **** }
 879:../lib/fat16.c **** 
 880:../lib/fat16.c **** /**
 881:../lib/fat16.c ****  * \ingroup fat16_fs
 882:../lib/fat16.c ****  * Frees a part of a cluster chain and correctly terminates the rest.
 883:../lib/fat16.c ****  *
 884:../lib/fat16.c ****  * Marks the specified cluster as the new end of a cluster chain and
 885:../lib/fat16.c ****  * frees all following clusters.
 886:../lib/fat16.c ****  *
 887:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
 888:../lib/fat16.c ****  * \param[in] cluster_num The new end of the cluster chain.
 889:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
 890:../lib/fat16.c ****  * \see fat16_free_clusters
 891:../lib/fat16.c ****  */
 892:../lib/fat16.c **** uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 893:../lib/fat16.c **** {
 894:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
 895:../lib/fat16.c ****         if(!fs || cluster_num < 2)
 896:../lib/fat16.c ****             return 0;
 897:../lib/fat16.c ****     
 898:../lib/fat16.c ****         /* fetch next cluster before overwriting the cluster entry */
 899:../lib/fat16.c ****         uint16_t cluster_num_next = fat16_get_next_cluster(fs, cluster_num);
 900:../lib/fat16.c ****     
 901:../lib/fat16.c ****         /* mark cluster as the last one */
 902:../lib/fat16.c ****         uint8_t buffer[2];
 903:../lib/fat16.c ****         buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
 904:../lib/fat16.c ****         buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
 905:../lib/fat16.c ****         if(!fs->partition->device_write(fs->header.fat_offset + 2 * cluster_num, buffer, 2))
 906:../lib/fat16.c ****             return 0;
 907:../lib/fat16.c ****     
 908:../lib/fat16.c ****         /* free remaining clusters */
 909:../lib/fat16.c ****         if(cluster_num_next)
 910:../lib/fat16.c ****             return fat16_free_clusters(fs, cluster_num_next);
 911:../lib/fat16.c ****         else
 912:../lib/fat16.c ****             return 1;
 913:../lib/fat16.c ****     #else
 914:../lib/fat16.c ****         return 0;
 915:../lib/fat16.c ****     #endif
 916:../lib/fat16.c **** }
 917:../lib/fat16.c **** 
 918:../lib/fat16.c **** /**
 919:../lib/fat16.c ****  * \ingroup fat16_file
 920:../lib/fat16.c ****  * Opens a file on a FAT16 filesystem.
 921:../lib/fat16.c ****  *
 922:../lib/fat16.c ****  * \param[in] fs The filesystem on which the file to open lies.
 923:../lib/fat16.c ****  * \param[in] dir_entry The directory entry of the file to open.
 924:../lib/fat16.c ****  * \returns The file handle, or 0 on failure.
 925:../lib/fat16.c ****  * \see fat16_close_file
 926:../lib/fat16.c ****  */
 927:../lib/fat16.c **** struct fat16_file_struct* fat16_open_file(struct fat16_fs_struct* fs, const struct fat16_dir_entry_
 928:../lib/fat16.c **** {
 929:../lib/fat16.c ****     if(!fs || !dir_entry || (dir_entry->attributes & FAT16_ATTRIB_DIR))
 930:../lib/fat16.c ****         return 0;
 931:../lib/fat16.c **** 
 932:../lib/fat16.c ****     struct fat16_file_struct* fd = malloc(sizeof(*fd));
 933:../lib/fat16.c ****     if(!fd)
 934:../lib/fat16.c ****         return 0;
 935:../lib/fat16.c **** 
 936:../lib/fat16.c ****     memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
 937:../lib/fat16.c ****     fd->fs = fs;
 938:../lib/fat16.c ****     fd->pos = 0;
 939:../lib/fat16.c ****     fd->pos_cluster = dir_entry->cluster;
 940:../lib/fat16.c **** 
 941:../lib/fat16.c ****     return fd;
 942:../lib/fat16.c **** }
 943:../lib/fat16.c **** 
 944:../lib/fat16.c **** /**
 945:../lib/fat16.c ****  * \ingroup fat16_file
 946:../lib/fat16.c ****  * Closes a file.
 947:../lib/fat16.c ****  *
 948:../lib/fat16.c ****  * \param[in] fd The file handle of the file to close.
 949:../lib/fat16.c ****  * \see fat16_open_file
 950:../lib/fat16.c ****  */
 951:../lib/fat16.c **** void fat16_close_file(struct fat16_file_struct* fd)
 952:../lib/fat16.c **** {
 953:../lib/fat16.c ****     if(fd)
 954:../lib/fat16.c ****         free(fd);
 955:../lib/fat16.c **** }
 956:../lib/fat16.c **** 
 957:../lib/fat16.c **** /**
 958:../lib/fat16.c ****  * \ingroup fat16_file
 959:../lib/fat16.c ****  * Reads data from a file.
 960:../lib/fat16.c ****  *
 961:../lib/fat16.c ****  * The data requested is read from the current file location.
 962:../lib/fat16.c ****  *
 963:../lib/fat16.c ****  * \param[in] fd The file handle of the file from which to read.
 964:../lib/fat16.c ****  * \param[out] buffer The buffer into which to write.
 965:../lib/fat16.c ****  * \param[in] buffer_len The amount of data to read.
 966:../lib/fat16.c ****  * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 967:../lib/fat16.c ****  * \see fat16_write_file
 968:../lib/fat16.c ****  */
 969:../lib/fat16.c **** int16_t fat16_read_file(struct fat16_file_struct* fd, uint8_t* buffer, uint16_t buffer_len)
 970:../lib/fat16.c **** {
 971:../lib/fat16.c ****     /* check arguments */
 972:../lib/fat16.c ****     if(!fd || !buffer || buffer_len < 1)
 973:../lib/fat16.c ****         return -1;
 974:../lib/fat16.c **** 
 975:../lib/fat16.c ****     /* determine number of bytes to read */
 976:../lib/fat16.c ****     if(fd->pos + buffer_len > fd->dir_entry.file_size)
 977:../lib/fat16.c ****         buffer_len = fd->dir_entry.file_size - fd->pos;
 978:../lib/fat16.c ****     if(buffer_len == 0)
 979:../lib/fat16.c ****         return 0;
 980:../lib/fat16.c **** 
 981:../lib/fat16.c ****     uint16_t cluster_size = fd->fs->header.cluster_size;
 982:../lib/fat16.c ****     uint16_t cluster_num = fd->pos_cluster;
 983:../lib/fat16.c ****     uint16_t buffer_left = buffer_len;
 984:../lib/fat16.c ****     uint16_t first_cluster_offset = fd->pos % cluster_size;
 985:../lib/fat16.c **** 
 986:../lib/fat16.c ****     /* find cluster in which to start reading */
 987:../lib/fat16.c ****     if(!cluster_num)
 988:../lib/fat16.c ****     {
 989:../lib/fat16.c ****         cluster_num = fd->dir_entry.cluster;
 990:../lib/fat16.c **** 
 991:../lib/fat16.c ****         if(!cluster_num)
 992:../lib/fat16.c ****         {
 993:../lib/fat16.c ****             if(!fd->pos)
 994:../lib/fat16.c ****                 return 0;
 995:../lib/fat16.c ****             else
 996:../lib/fat16.c ****                 return -1;
 997:../lib/fat16.c ****         }
 998:../lib/fat16.c **** 
 999:../lib/fat16.c ****         if(fd->pos)
1000:../lib/fat16.c ****         {
1001:../lib/fat16.c ****             uint32_t pos = fd->pos;
1002:../lib/fat16.c ****             while(pos >= cluster_size)
1003:../lib/fat16.c ****             {
1004:../lib/fat16.c ****                 pos -= cluster_size;
1005:../lib/fat16.c ****                 cluster_num = fat16_get_next_cluster(fd->fs, cluster_num);
1006:../lib/fat16.c ****                 if(!cluster_num)
1007:../lib/fat16.c ****                     return -1;
1008:../lib/fat16.c ****             }
1009:../lib/fat16.c ****         }
1010:../lib/fat16.c ****     }
1011:../lib/fat16.c **** 
1012:../lib/fat16.c ****     /* read data */
1013:../lib/fat16.c ****     do
1014:../lib/fat16.c ****     {
1015:../lib/fat16.c ****         /* calculate data size to copy from cluster */
1016:../lib/fat16.c ****         uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
1017:../lib/fat16.c ****         (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
1018:../lib/fat16.c ****         uint16_t copy_length = cluster_size - first_cluster_offset;
1019:../lib/fat16.c ****         if(copy_length > buffer_left)
1020:../lib/fat16.c ****             copy_length = buffer_left;
1021:../lib/fat16.c **** 
1022:../lib/fat16.c ****         /* read data */
1023:../lib/fat16.c ****         if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
1024:../lib/fat16.c ****             return buffer_len - buffer_left;
1025:../lib/fat16.c **** 
1026:../lib/fat16.c ****         /* calculate new file position */
1027:../lib/fat16.c ****         buffer += copy_length;
1028:../lib/fat16.c ****         buffer_left -= copy_length;
1029:../lib/fat16.c ****         fd->pos += copy_length;
1030:../lib/fat16.c **** 
1031:../lib/fat16.c ****         if(first_cluster_offset + copy_length >= cluster_size)
1032:../lib/fat16.c ****         {
1033:../lib/fat16.c ****             /* we are on a cluster boundary, so get the next cluster */
1034:../lib/fat16.c ****             if((cluster_num = fat16_get_next_cluster(fd->fs, cluster_num)))
1035:../lib/fat16.c ****             {
1036:../lib/fat16.c ****                 first_cluster_offset = 0;
1037:../lib/fat16.c ****             }
1038:../lib/fat16.c ****             else
1039:../lib/fat16.c ****             {
1040:../lib/fat16.c ****                 fd->pos_cluster = 0;
1041:../lib/fat16.c ****                 return buffer_len - buffer_left;
1042:../lib/fat16.c ****             }
1043:../lib/fat16.c ****         }
1044:../lib/fat16.c **** 
1045:../lib/fat16.c ****         fd->pos_cluster = cluster_num;
1046:../lib/fat16.c **** 
1047:../lib/fat16.c ****     }
1048:../lib/fat16.c ****     while(buffer_left > 0); /* check if we are done */
1049:../lib/fat16.c **** 
1050:../lib/fat16.c ****     return buffer_len;
1051:../lib/fat16.c **** }
1052:../lib/fat16.c **** 
1053:../lib/fat16.c **** /**
1054:../lib/fat16.c ****  * \ingroup fat16_file
1055:../lib/fat16.c ****  * Writes data to a file.
1056:../lib/fat16.c ****  *
1057:../lib/fat16.c ****  * The data is written to the current file location.
1058:../lib/fat16.c ****  *
1059:../lib/fat16.c ****  * \param[in] fd The file handle of the file to which to write.
1060:../lib/fat16.c ****  * \param[in] buffer The buffer from which to read the data to be written.
1061:../lib/fat16.c ****  * \param[in] buffer_len The amount of data to write.
1062:../lib/fat16.c ****  * \returns The number of bytes written, 0 on disk full, or -1 on failure.
1063:../lib/fat16.c ****  * \see fat16_read_file
1064:../lib/fat16.c ****  */
1065:../lib/fat16.c **** int16_t fat16_write_file(struct fat16_file_struct* fd, const uint8_t* buffer, uint16_t buffer_len)
1066:../lib/fat16.c **** {
1067:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
1068:../lib/fat16.c ****         /* check arguments */
1069:../lib/fat16.c ****         if(!fd || !buffer || buffer_len < 1)
1070:../lib/fat16.c ****             return -1;
1071:../lib/fat16.c ****         if(fd->pos > fd->dir_entry.file_size)
1072:../lib/fat16.c ****             return -1;
1073:../lib/fat16.c ****     
1074:../lib/fat16.c ****         uint16_t cluster_size = fd->fs->header.cluster_size;
1075:../lib/fat16.c ****         uint16_t cluster_num = fd->pos_cluster;
1076:../lib/fat16.c ****         uint16_t buffer_left = buffer_len;
1077:../lib/fat16.c ****         uint16_t first_cluster_offset = fd->pos % cluster_size;
1078:../lib/fat16.c ****     
1079:../lib/fat16.c ****         /* find cluster in which to start writing */
1080:../lib/fat16.c ****         if(!cluster_num)
1081:../lib/fat16.c ****         {
1082:../lib/fat16.c ****             cluster_num = fd->dir_entry.cluster;
1083:../lib/fat16.c ****     
1084:../lib/fat16.c ****             if(!cluster_num)
1085:../lib/fat16.c ****             {
1086:../lib/fat16.c ****                 if(!fd->pos)
1087:../lib/fat16.c ****                 {
1088:../lib/fat16.c ****                     /* empty file */
1089:../lib/fat16.c ****                     fd->dir_entry.cluster = cluster_num = fat16_append_clusters(fd->fs, 0, 1);
1090:../lib/fat16.c ****                     if(!cluster_num)
1091:../lib/fat16.c ****                         return -1;
1092:../lib/fat16.c ****                 }
1093:../lib/fat16.c ****                 else
1094:../lib/fat16.c ****                 {
1095:../lib/fat16.c ****                     return -1;
1096:../lib/fat16.c ****                 }
1097:../lib/fat16.c ****             }
1098:../lib/fat16.c ****     
1099:../lib/fat16.c ****             if(fd->pos)
1100:../lib/fat16.c ****             {
1101:../lib/fat16.c ****                 uint32_t pos = fd->pos;
1102:../lib/fat16.c ****                 uint16_t cluster_num_next;
1103:../lib/fat16.c ****                 while(pos >= cluster_size)
1104:../lib/fat16.c ****                 {
1105:../lib/fat16.c ****                     pos -= cluster_size;
1106:../lib/fat16.c ****                     cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1107:../lib/fat16.c ****                     if(!cluster_num_next && pos == 0)
1108:../lib/fat16.c ****         /* the file exactly ends on a cluster boundary, and we append to it */
1109:../lib/fat16.c ****                         cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
1110:../lib/fat16.c ****                     if(!cluster_num_next)
1111:../lib/fat16.c ****                         return -1;
1112:../lib/fat16.c ****     
1113:../lib/fat16.c ****                     cluster_num = cluster_num_next;
1114:../lib/fat16.c ****                 }
1115:../lib/fat16.c ****             }
1116:../lib/fat16.c ****         }
1117:../lib/fat16.c ****     
1118:../lib/fat16.c ****         /* write data */
1119:../lib/fat16.c ****         do
1120:../lib/fat16.c ****         {
1121:../lib/fat16.c ****             /* calculate data size to write to cluster */
1122:../lib/fat16.c ****             uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
1123:../lib/fat16.c ****             (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
1124:../lib/fat16.c ****             uint16_t write_length = cluster_size - first_cluster_offset;
1125:../lib/fat16.c ****             if(write_length > buffer_left)
1126:../lib/fat16.c ****                 write_length = buffer_left;
1127:../lib/fat16.c ****     
1128:../lib/fat16.c ****             /* write data which fits into the current cluster */
1129:../lib/fat16.c ****             if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
1130:../lib/fat16.c ****                 break;
1131:../lib/fat16.c ****     
1132:../lib/fat16.c ****             /* calculate new file position */
1133:../lib/fat16.c ****             buffer += write_length;
1134:../lib/fat16.c ****             buffer_left -= write_length;
1135:../lib/fat16.c ****             fd->pos += write_length;
1136:../lib/fat16.c ****     
1137:../lib/fat16.c ****             if(first_cluster_offset + write_length >= cluster_size)
1138:../lib/fat16.c ****             {
1139:../lib/fat16.c ****                 /* we are on a cluster boundary, so get the next cluster */
1140:../lib/fat16.c ****                 uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1141:../lib/fat16.c ****                 if(!cluster_num_next && buffer_left > 0)
1142:../lib/fat16.c ****         /* we reached the last cluster, append a new one */
1143:../lib/fat16.c ****                     cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
1144:../lib/fat16.c ****                 if(!cluster_num_next)
1145:../lib/fat16.c ****                 {
1146:../lib/fat16.c ****                     fd->pos_cluster = 0;
1147:../lib/fat16.c ****                     break;
1148:../lib/fat16.c ****                 }
1149:../lib/fat16.c ****     
1150:../lib/fat16.c ****                 cluster_num = cluster_num_next;
1151:../lib/fat16.c ****                 first_cluster_offset = 0;
1152:../lib/fat16.c ****             }
1153:../lib/fat16.c ****     
1154:../lib/fat16.c ****             fd->pos_cluster = cluster_num;
1155:../lib/fat16.c ****     
1156:../lib/fat16.c ****         }
1157:../lib/fat16.c ****         while(buffer_left > 0); /* check if we are done */
1158:../lib/fat16.c ****     
1159:../lib/fat16.c ****         /* update directory entry */
1160:../lib/fat16.c ****         if(fd->pos > fd->dir_entry.file_size)
1161:../lib/fat16.c ****         {
1162:../lib/fat16.c ****             uint32_t size_old = fd->dir_entry.file_size;
1163:../lib/fat16.c ****     
1164:../lib/fat16.c ****             /* update file size */
1165:../lib/fat16.c ****             fd->dir_entry.file_size = fd->pos;
1166:../lib/fat16.c ****             /* write directory entry */
1167:../lib/fat16.c ****             if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
1168:../lib/fat16.c ****             {
1169:../lib/fat16.c ****                 /* We do not return an error here since we actually wrote
1170:../lib/fat16.c ****                                                              * some data to disk. So we calculate t
1171:../lib/fat16.c ****                                                              * we wrote to disk and which lies with
1172:../lib/fat16.c ****                                                              */
1173:../lib/fat16.c ****                 buffer_left = fd->pos - size_old;
1174:../lib/fat16.c ****                 fd->pos = size_old;
1175:../lib/fat16.c ****             }
1176:../lib/fat16.c ****         }
1177:../lib/fat16.c ****     
1178:../lib/fat16.c ****         return buffer_len - buffer_left;
1179:../lib/fat16.c ****     
1180:../lib/fat16.c ****     #else
1181:../lib/fat16.c ****         return -1;
1182:../lib/fat16.c ****     #endif
1183:../lib/fat16.c **** }
1184:../lib/fat16.c **** 
1185:../lib/fat16.c **** /**
1186:../lib/fat16.c ****  * \ingroup fat16_file
1187:../lib/fat16.c ****  * Repositions the read/write file offset.
1188:../lib/fat16.c ****  *
1189:../lib/fat16.c ****  * Changes the file offset where the next call to fat16_read_file()
1190:../lib/fat16.c ****  * or fat16_write_file() starts reading/writing.
1191:../lib/fat16.c ****  *
1192:../lib/fat16.c ****  * If the new offset is beyond the end of the file, fat16_resize_file()
1193:../lib/fat16.c ****  * is implicitly called, i.e. the file is expanded.
1194:../lib/fat16.c ****  *
1195:../lib/fat16.c ****  * The new offset can be given in different ways determined by
1196:../lib/fat16.c ****  * the \c whence parameter:
1197:../lib/fat16.c ****  * - \b FAT16_SEEK_SET: \c *offset is relative to the beginning of the file.
1198:../lib/fat16.c ****  * - \b FAT16_SEEK_CUR: \c *offset is relative to the current file position.
1199:../lib/fat16.c ****  * - \b FAT16_SEEK_END: \c *offset is relative to the end of the file.
1200:../lib/fat16.c ****  *
1201:../lib/fat16.c ****  * The resulting absolute offset is written to the location the \c offset
1202:../lib/fat16.c ****  * parameter points to.
1203:../lib/fat16.c ****  *
1204:../lib/fat16.c ****  * \param[in] fd The file decriptor of the file on which to seek.
1205:../lib/fat16.c ****  * \param[in,out] offset A pointer to the new offset, as affected by the \c whence
1206:../lib/fat16.c ****  *                   parameter. The function writes the new absolute offset
1207:../lib/fat16.c ****  *                   to this location before it returns.
1208:../lib/fat16.c ****  * \param[in] whence Affects the way \c offset is interpreted, see above.
1209:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1210:../lib/fat16.c ****  */
1211:../lib/fat16.c **** uint8_t fat16_seek_file(struct fat16_file_struct* fd, int32_t* offset, uint8_t whence)
1212:../lib/fat16.c **** {
1213:../lib/fat16.c ****     if(!fd || !offset)
1214:../lib/fat16.c ****         return 0;
1215:../lib/fat16.c **** 
1216:../lib/fat16.c ****     uint32_t new_pos = fd->pos;
1217:../lib/fat16.c ****     switch(whence)
1218:../lib/fat16.c ****     {
1219:../lib/fat16.c ****         case FAT16_SEEK_SET:
1220:../lib/fat16.c ****             new_pos = *offset;
1221:../lib/fat16.c ****             break;
1222:../lib/fat16.c ****         case FAT16_SEEK_CUR:
1223:../lib/fat16.c ****             new_pos += *offset;
1224:../lib/fat16.c ****             break;
1225:../lib/fat16.c ****         case FAT16_SEEK_END:
1226:../lib/fat16.c ****             new_pos = fd->dir_entry.file_size + *offset;
1227:../lib/fat16.c ****             break;
1228:../lib/fat16.c ****         default:
1229:../lib/fat16.c ****             return 0;
1230:../lib/fat16.c ****     }
1231:../lib/fat16.c **** 
1232:../lib/fat16.c ****     if(new_pos > fd->dir_entry.file_size && !fat16_resize_file(fd, new_pos))
1233:../lib/fat16.c ****         return 0;
1234:../lib/fat16.c **** 
1235:../lib/fat16.c ****     fd->pos = new_pos;
1236:../lib/fat16.c ****     fd->pos_cluster = 0;
1237:../lib/fat16.c **** 
1238:../lib/fat16.c ****     *offset = new_pos;
1239:../lib/fat16.c ****     return 1;
1240:../lib/fat16.c **** }
1241:../lib/fat16.c **** 
1242:../lib/fat16.c **** /**
1243:../lib/fat16.c ****  * \ingroup fat16_file
1244:../lib/fat16.c ****  * Resizes a file to have a specific size.
1245:../lib/fat16.c ****  *
1246:../lib/fat16.c ****  * Enlarges or shrinks the file pointed to by the file descriptor to have
1247:../lib/fat16.c ****  * exactly the specified size.
1248:../lib/fat16.c ****  *
1249:../lib/fat16.c ****  * If the file is truncated, all bytes having an equal or larger offset
1250:../lib/fat16.c ****  * than the given size are lost. If the file is expanded, the additional
1251:../lib/fat16.c ****  * bytes are allocated.
1252:../lib/fat16.c ****  *
1253:../lib/fat16.c ****  * \note Please be aware that this function just allocates or deallocates disk
1254:../lib/fat16.c ****  * space, it does not explicitely clear it. To avoid data leakage, this
1255:../lib/fat16.c ****  * must be done manually.
1256:../lib/fat16.c ****  *
1257:../lib/fat16.c ****  * \param[in] fd The file decriptor of the file which to resize.
1258:../lib/fat16.c ****  * \param[in] size The new size of the file.
1259:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1260:../lib/fat16.c ****  */
1261:../lib/fat16.c **** uint8_t fat16_resize_file(struct fat16_file_struct* fd, uint32_t size)
1262:../lib/fat16.c **** {
1263:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
1264:../lib/fat16.c ****         if(!fd)
1265:../lib/fat16.c ****             return 0;
1266:../lib/fat16.c ****     
1267:../lib/fat16.c ****         uint16_t cluster_num = fd->dir_entry.cluster;
1268:../lib/fat16.c ****         uint16_t cluster_size = fd->fs->header.cluster_size;
1269:../lib/fat16.c ****         uint32_t size_new = size;
1270:../lib/fat16.c ****     
1271:../lib/fat16.c ****         do
1272:../lib/fat16.c ****         {
1273:../lib/fat16.c ****             if(cluster_num == 0 && size_new == 0)
1274:../lib/fat16.c ****         /* the file stays empty */
1275:../lib/fat16.c ****                 break;
1276:../lib/fat16.c ****     
1277:../lib/fat16.c ****             /* seek to the next cluster as long as we need the space */
1278:../lib/fat16.c ****             while(size_new > cluster_size)
1279:../lib/fat16.c ****             {
1280:../lib/fat16.c ****                 /* get next cluster of file */
1281:../lib/fat16.c ****                 uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1282:../lib/fat16.c ****                 if(cluster_num_next)
1283:../lib/fat16.c ****                 {
1284:../lib/fat16.c ****                     cluster_num = cluster_num_next;
1285:../lib/fat16.c ****                     size_new -= cluster_size;
1286:../lib/fat16.c ****                 }
1287:../lib/fat16.c ****                 else
1288:../lib/fat16.c ****                 {
1289:../lib/fat16.c ****                     break;
1290:../lib/fat16.c ****                 }
1291:../lib/fat16.c ****             }
1292:../lib/fat16.c ****     
1293:../lib/fat16.c ****             if(size_new > cluster_size || cluster_num == 0)
1294:../lib/fat16.c ****             {
1295:../lib/fat16.c ****                 /* Allocate new cluster chain and append
1296:../lib/fat16.c ****                                                              * it to the existing one, if available
1297:../lib/fat16.c ****                                                              */
1298:../lib/fat16.c ****                 uint16_t cluster_count = size_new / cluster_size;
1299:../lib/fat16.c ****                 if((uint32_t) cluster_count * cluster_size < size_new)
1300:../lib/fat16.c ****                     ++cluster_count;
1301:../lib/fat16.c ****                 uint16_t cluster_new_chain = fat16_append_clusters(fd->fs, cluster_num, cluster_cou
1302:../lib/fat16.c ****                 if(!cluster_new_chain)
1303:../lib/fat16.c ****                     return 0;
1304:../lib/fat16.c ****     
1305:../lib/fat16.c ****                 if(!cluster_num)
1306:../lib/fat16.c ****                 {
1307:../lib/fat16.c ****                     cluster_num = cluster_new_chain;
1308:../lib/fat16.c ****                     fd->dir_entry.cluster = cluster_num;
1309:../lib/fat16.c ****                 }
1310:../lib/fat16.c ****             }
1311:../lib/fat16.c ****     
1312:../lib/fat16.c ****             /* write new directory entry */
1313:../lib/fat16.c ****             fd->dir_entry.file_size = size;
1314:../lib/fat16.c ****             if(size == 0)
1315:../lib/fat16.c ****                 fd->dir_entry.cluster = 0;
1316:../lib/fat16.c ****             if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
1317:../lib/fat16.c ****                 return 0;
1318:../lib/fat16.c ****     
1319:../lib/fat16.c ****             if(size == 0)
1320:../lib/fat16.c ****             {
1321:../lib/fat16.c ****                 /* free all clusters of file */
1322:../lib/fat16.c ****                 fat16_free_clusters(fd->fs, cluster_num);
1323:../lib/fat16.c ****             }
1324:../lib/fat16.c ****             else if(size_new <= cluster_size)
1325:../lib/fat16.c ****             {
1326:../lib/fat16.c ****                 /* free all clusters no longer needed */
1327:../lib/fat16.c ****                 fat16_terminate_clusters(fd->fs, cluster_num);
1328:../lib/fat16.c ****             }
1329:../lib/fat16.c ****     
1330:../lib/fat16.c ****         }
1331:../lib/fat16.c ****         while(0);
1332:../lib/fat16.c ****     
1333:../lib/fat16.c ****         /* correct file position */
1334:../lib/fat16.c ****         if(size < fd->pos)
1335:../lib/fat16.c ****         {
1336:../lib/fat16.c ****             fd->pos = size;
1337:../lib/fat16.c ****             fd->pos_cluster = 0;
1338:../lib/fat16.c ****         }
1339:../lib/fat16.c ****     
1340:../lib/fat16.c ****         return 1;
1341:../lib/fat16.c ****     #else
1342:../lib/fat16.c ****         return 0;
1343:../lib/fat16.c ****     #endif
1344:../lib/fat16.c **** }
1345:../lib/fat16.c **** 
1346:../lib/fat16.c **** /**
1347:../lib/fat16.c ****  * \ingroup fat16_dir
1348:../lib/fat16.c ****  * Opens a directory.
1349:../lib/fat16.c ****  *
1350:../lib/fat16.c ****  * \param[in] fs The filesystem on which the directory to open resides.
1351:../lib/fat16.c ****  * \param[in] dir_entry The directory entry which stands for the directory to open.
1352:../lib/fat16.c ****  * \returns An opaque directory descriptor on success, 0 on failure.
1353:../lib/fat16.c ****  * \see fat16_close_dir
1354:../lib/fat16.c ****  */
1355:../lib/fat16.c **** struct fat16_dir_struct* fat16_open_dir(struct fat16_fs_struct* fs, const struct fat16_dir_entry_st
1356:../lib/fat16.c **** {
1357:../lib/fat16.c ****     if(!fs || !dir_entry || !(dir_entry->attributes & FAT16_ATTRIB_DIR))
1358:../lib/fat16.c ****         return 0;
1359:../lib/fat16.c **** 
1360:../lib/fat16.c ****     struct fat16_dir_struct* dd = malloc(sizeof(*dd));
1361:../lib/fat16.c ****     if(!dd)
1362:../lib/fat16.c ****         return 0;
1363:../lib/fat16.c **** 
1364:../lib/fat16.c ****     memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
1365:../lib/fat16.c ****     dd->fs = fs;
1366:../lib/fat16.c ****     dd->entry_next = 0;
1367:../lib/fat16.c **** 
1368:../lib/fat16.c ****     return dd;
1369:../lib/fat16.c **** }
1370:../lib/fat16.c **** 
1371:../lib/fat16.c **** /**
1372:../lib/fat16.c ****  * \ingroup fat16_dir
1373:../lib/fat16.c ****  * Closes a directory descriptor.
1374:../lib/fat16.c ****  *
1375:../lib/fat16.c ****  * This function destroys a directory descriptor which was
1376:../lib/fat16.c ****  * previously obtained by calling fat16_open_dir(). When this
1377:../lib/fat16.c ****  * function returns, the given descriptor will be invalid.
1378:../lib/fat16.c ****  *
1379:../lib/fat16.c ****  * \param[in] dd The directory descriptor to close.
1380:../lib/fat16.c ****  * \see fat16_open_dir
1381:../lib/fat16.c ****  */
1382:../lib/fat16.c **** void fat16_close_dir(struct fat16_dir_struct* dd)
1383:../lib/fat16.c **** {
1384:../lib/fat16.c ****     if(dd)
1385:../lib/fat16.c ****         free(dd);
1386:../lib/fat16.c **** }
1387:../lib/fat16.c **** 
1388:../lib/fat16.c **** /**
1389:../lib/fat16.c ****  * \ingroup fat16_dir
1390:../lib/fat16.c ****  * Reads the next directory entry contained within a parent directory.
1391:../lib/fat16.c ****  *
1392:../lib/fat16.c ****  * \param[in] dd The descriptor of the parent directory from which to read the entry.
1393:../lib/fat16.c ****  * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
1394:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1395:../lib/fat16.c ****  * \see fat16_reset_dir
1396:../lib/fat16.c ****  */
1397:../lib/fat16.c **** uint8_t fat16_read_dir(struct fat16_dir_struct* dd, struct fat16_dir_entry_struct* dir_entry)
1398:../lib/fat16.c **** {
 649              		.loc 1 1398 0
 650              		@ Function supports interworking.
 651              		@ args = 0, pretend = 0, frame = 48
 652              		@ frame_needed = 0, uses_anonymous_args = 0
 653              	.LVL66:
 654 04e0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 655              	.LCFI6:
1399:../lib/fat16.c ****     if(!dd || !dir_entry)
 656              		.loc 1 1399 0
 657 04e4 01A0A0E1 		mov	sl, r1
 658 04e8 011071E2 		rsbs	r1, r1, #1
 659 04ec 0010A033 		movcc	r1, #0
 660              	.LVL67:
 661 04f0 00005AE3 		cmp	sl, #0
 662 04f4 00005013 		cmpne	r0, #0
 663              		.loc 1 1398 0
 664 04f8 38D04DE2 		sub	sp, sp, #56
 665              	.LCFI7:
 666              	.LVL68:
 667              		.loc 1 1399 0
 668 04fc 0080A0E1 		mov	r8, r0
 669 0500 BC01000A 		beq	.L98
 670              	.LVL69:
1400:../lib/fat16.c ****         return 0;
1401:../lib/fat16.c **** 
1402:../lib/fat16.c ****     if(dd->dir_entry.cluster == 0)
 671              		.loc 1 1402 0
 672 0504 B632D0E1 		ldrh	r3, [r0, #38]
 673 0508 000053E3 		cmp	r3, #0
 674 050c 006090E5 		ldr	r6, [r0, #0]
 675 0510 B033D0E1 		ldrh	r3, [r0, #48]
 676 0514 7201001A 		bne	.L76
 677              	.LVL70:
 678              	.LBB11:
 679              	.LBB12:
 680              		.loc 1 360 0
 681 0518 000056E3 		cmp	r6, #0
 682 051c 0170A011 		movne	r7, r1
 683 0520 01708103 		orreq	r7, r1, #1
 684 0524 000057E3 		cmp	r7, #0
 685              	.LBE12:
 686              	.LBE11:
 687              		.loc 1 1402 0
 688 0528 0390A0E1 		mov	r9, r3
 689              	.LVL71:
 690              	.LBB13:
 691              	.LBB14:
 692              		.loc 1 360 0
 693 052c B301001A 		bne	.L86
 694              		.loc 1 365 0
 695 0530 003096E5 		ldr	r3, [r6, #0]
 696              		.loc 1 370 0
 697 0534 2C508DE2 		add	r5, sp, #44
 698              		.loc 1 364 0
 699 0538 044086E2 		add	r4, r6, #4
 700              	.LVL72:
 701              		.loc 1 370 0
 702 053c 0710A0E1 		mov	r1, r7
 703 0540 0C20A0E3 		mov	r2, #12
 704 0544 0500A0E1 		mov	r0, r5
 705              	.LVL73:
 706              		.loc 1 365 0
 707 0548 046093E5 		ldr	r6, [r3, #4]
 708              	.LVL74:
 709              		.loc 1 370 0
 710 054c FEFFFFEB 		bl	memset
 711              		.loc 1 372 0
 712 0550 100084E2 		add	r0, r4, #16
 713 0554 090090E8 		ldmia	r0, {r0, r3}	@ phole ldm
 714 0558 A8219FE5 		ldr	r2, .L102
 715 055c 033060E0 		rsb	r3, r0, r3
 716 0560 0338A0E1 		mov	r3, r3, asl #16
 717 0564 0C408DE2 		add	r4, sp, #12
 718              	.LVL75:
 719 0568 00208DE5 		str	r2, [sp, #0]
 720              		.loc 1 371 0
 721 056c BE92CDE1 		strh	r9, [sp, #46]	@ movhi
 722              		.loc 1 372 0
 723 0570 04508DE5 		str	r5, [sp, #4]
 724 0574 2338A0E1 		mov	r3, r3, lsr #16
 725 0578 0410A0E1 		mov	r1, r4
 726 057c 2020A0E3 		mov	r2, #32
 727 0580 0FE0A0E1 		mov	lr, pc
 728 0584 16FF2FE1 		bx	r6
 729 0588 000050E3 		cmp	r0, #0
 730 058c B301000A 		beq	.L86
 731 0590 30309DE5 		ldr	r3, [sp, #48]
 732 0594 000053E3 		cmp	r3, #0
 733 0598 B301000A 		beq	.L86
 734              		.loc 1 383 0
 735 059c 0710A0E1 		mov	r1, r7
 736 05a0 2C20A0E3 		mov	r2, #44
 737 05a4 0A00A0E1 		mov	r0, sl
 738 05a8 FEFFFFEB 		bl	memset
 739              		.loc 1 384 0
 740 05ac 58219FE5 		ldr	r2, .L102+4
 741 05b0 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 742 05b4 04048DE8 		stmia	sp, {r2, sl}	@ phole stm
 743 05b8 0410A0E1 		mov	r1, r4
 744 05bc 30009DE5 		ldr	r0, [sp, #48]
 745 05c0 2020A0E3 		mov	r2, #32
 746 05c4 0FE0A0E1 		mov	lr, pc
 747 05c8 16FF2FE1 		bx	r6
 748 05cc AD0100EA 		b	.L101
 749              	.LVL76:
 750              	.L76:
 751              	.LBE14:
 752              	.LBE13:
 753              	.LBB15:
 754              	.LBB16:
 755              		.loc 1 408 0
 756 05d0 040070E3 		cmn	r0, #4
 757 05d4 00005613 		cmpne	r6, #0
 758              	.LBE16:
 759              	.LBE15:
1403:../lib/fat16.c ****     {
1404:../lib/fat16.c ****         /* read entry from root directory */
1405:../lib/fat16.c ****         if(fat16_read_root_dir_entry(dd->fs, dd->entry_next, dir_entry))
1406:../lib/fat16.c ****         {
1407:../lib/fat16.c ****             ++dd->entry_next;
1408:../lib/fat16.c ****             return 1;
 760              		.loc 1 1408 0
 761 05d8 08308DE5 		str	r3, [sp, #8]
 762              	.LVL77:
 763              	.LBB17:
 764              	.LBB18:
 765              		.loc 1 408 0
 766 05dc 040080E2 		add	r0, r0, #4
 767              	.LVL78:
 768 05e0 B301000A 		beq	.L86
 769 05e4 000051E3 		cmp	r1, #0
 770 05e8 B301001A 		bne	.L86
 771              		.loc 1 412 0
 772 05ec 2030D0E5 		ldrb	r3, [r0, #32]	@ zero_extendqisi2
 773 05f0 100013E3 		tst	r3, #16
 774 05f4 B301000A 		beq	.L86
 775              		.loc 1 419 0
 776 05f8 B272D0E1 		ldrh	r7, [r0, #34]
 777              	.LVL79:
 778              		.loc 1 418 0
 779 05fc B291D6E1 		ldrh	r9, [r6, #18]
 780              	.LVL80:
 781              	.LVL81:
 782              	.L90:
 783              		.loc 1 425 0
 784 0600 182096E5 		ldr	r2, [r6, #24]
 785 0604 023047E2 		sub	r3, r7, #2
 786 0608 992325E0 		mla	r5, r9, r3, r2
 787              		.loc 1 428 0
 788 060c 2C408DE2 		add	r4, sp, #44
 789 0610 0010A0E3 		mov	r1, #0
 790 0614 0C20A0E3 		mov	r2, #12
 791 0618 0400A0E1 		mov	r0, r4
 792              	.LVL82:
 793 061c FEFFFFEB 		bl	memset
 794              		.loc 1 429 0
 795 0620 08309DE5 		ldr	r3, [sp, #8]
 796 0624 BE32CDE1 		strh	r3, [sp, #46]	@ movhi
 797              		.loc 1 430 0
 798 0628 D8309FE5 		ldr	r3, .L102
 799 062c 0CB08DE2 		add	fp, sp, #12
 800 0630 00C096E5 		ldr	ip, [r6, #0]
 801 0634 0B10A0E1 		mov	r1, fp
 802 0638 00308DE5 		str	r3, [sp, #0]
 803 063c 0500A0E1 		mov	r0, r5
 804 0640 04408DE5 		str	r4, [sp, #4]
 805 0644 2020A0E3 		mov	r2, #32
 806 0648 0930A0E1 		mov	r3, r9
 807 064c 04C09CE5 		ldr	ip, [ip, #4]
 808 0650 0FE0A0E1 		mov	lr, pc
 809 0654 1CFF2FE1 		bx	ip
 810 0658 000050E3 		cmp	r0, #0
 811              		.loc 1 444 0
 812 065c 0710A0E1 		mov	r1, r7
 813 0660 0600A0E1 		mov	r0, r6
 814              	.LVL83:
 815              		.loc 1 430 0
 816 0664 B301000A 		beq	.L86
 817              		.loc 1 440 0
 818 0668 30309DE5 		ldr	r3, [sp, #48]
 819 066c 000053E3 		cmp	r3, #0
 820 0670 9F01001A 		bne	.L92
 821              		.loc 1 444 0
 822 0674 7E0000EB 		bl	fat16_get_next_cluster
 823              	.LVL84:
 824 0678 007050E2 		subs	r7, r0, #0
 825 067c B301000A 		beq	.L86
 826 0680 7E0100EA 		b	.L90
 827              	.LVL85:
 828              	.L92:
 829              		.loc 1 448 0
 830 0684 0010A0E3 		mov	r1, #0
 831 0688 2C20A0E3 		mov	r2, #44
 832 068c 0A00A0E1 		mov	r0, sl
 833              	.LVL86:
 834 0690 FEFFFFEB 		bl	memset
 835              		.loc 1 451 0
 836 0694 70209FE5 		ldr	r2, .L102+4
 837 0698 00C096E5 		ldr	ip, [r6, #0]
 838 069c 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 839 06a0 04048DE8 		stmia	sp, {r2, sl}	@ phole stm
 840 06a4 0B10A0E1 		mov	r1, fp
 841 06a8 30009DE5 		ldr	r0, [sp, #48]
 842 06ac 2020A0E3 		mov	r2, #32
 843 06b0 04C09CE5 		ldr	ip, [ip, #4]
 844 06b4 0FE0A0E1 		mov	lr, pc
 845 06b8 1CFF2FE1 		bx	ip
 846              	.LVL87:
 847              	.L101:
 848 06bc 000050E3 		cmp	r0, #0
 849 06c0 B301000A 		beq	.L86
 850              		.loc 1 459 0
 851 06c4 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 852 06c8 000053E2 		subs	r0, r3, #0
 853 06cc 0100A013 		movne	r0, #1
 854 06d0 B40100EA 		b	.L95
 855              	.LVL88:
 856              	.L86:
 857 06d4 0000A0E3 		mov	r0, #0
 858              	.LVL89:
 859              	.L95:
 860              	.LBE18:
 861              	.LBE17:
1409:../lib/fat16.c ****         }
1410:../lib/fat16.c ****     }
1411:../lib/fat16.c ****     else
1412:../lib/fat16.c ****     {
1413:../lib/fat16.c ****         /* read entry from a subdirectory */
1414:../lib/fat16.c ****         if(fat16_read_sub_dir_entry(dd->fs, dd->entry_next, &dd->dir_entry, dir_entry))
 862              		.loc 1 1414 0
 863 06d8 000050E3 		cmp	r0, #0
1415:../lib/fat16.c ****         {
1416:../lib/fat16.c ****             ++dd->entry_next;
1417:../lib/fat16.c ****             return 1;
1418:../lib/fat16.c ****         }
1419:../lib/fat16.c ****     }
1420:../lib/fat16.c **** 
1421:../lib/fat16.c ****     /* restart reading */
1422:../lib/fat16.c ****     dd->entry_next = 0;
 864              		.loc 1 1422 0
 865 06dc 0030A003 		moveq	r3, #0	@ movhi
 866 06e0 B033C801 		streqh	r3, [r8, #48]	@ movhi
 867              		.loc 1 1414 0
 868              		.loc 1 1416 0
 869 06e4 B033D811 		ldrneh	r3, [r8, #48]
 870 06e8 0100A013 		movne	r0, #1
 871 06ec 01308312 		addne	r3, r3, #1
 872 06f0 B033C811 		strneh	r3, [r8, #48]	@ movhi
 873 06f4 BD01001A 		bne	.L75
 874              	.LVL90:
 875              	.L98:
 876              		.loc 1 1422 0
 877 06f8 0000A0E3 		mov	r0, #0
 878              	.L75:
1423:../lib/fat16.c **** 
1424:../lib/fat16.c ****     return 0;
1425:../lib/fat16.c **** }
 879              		.loc 1 1425 0
 880 06fc 38D08DE2 		add	sp, sp, #56
 881 0700 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 882 0704 1EFF2FE1 		bx	lr
 883              	.L103:
 884              		.align	2
 885              	.L102:
 886 0708 A8020000 		.word	fat16_dir_entry_seek_callback
 887 070c 18030000 		.word	fat16_dir_entry_read_callback
 888              	.LFE23:
 890              		.align	2
 891              		.global	fat16_close_dir
 893              	fat16_close_dir:
 894              	.LFB22:
 895              		.loc 1 1383 0
 896              		@ Function supports interworking.
 897              		@ args = 0, pretend = 0, frame = 0
 898              		@ frame_needed = 0, uses_anonymous_args = 0
 899              	.LVL91:
 900              		.loc 1 1384 0
 901 0710 000050E3 		cmp	r0, #0
 902              		.loc 1 1383 0
 903 0714 04E02DE5 		str	lr, [sp, #-4]!
 904              	.LCFI8:
 905              		.loc 1 1384 0
 906              		.loc 1 1385 0
 907 0718 FEFFFF1B 		blne	free
 908              	.LVL92:
 909              	.LVL93:
 910              	.L107:
 911              		.loc 1 1386 0
 912 071c 04E09DE4 		ldr	lr, [sp], #4
 913 0720 1EFF2FE1 		bx	lr
 914              	.LFE22:
 916              		.align	2
 918              	fat16_free_clusters:
 919              	.LFB13:
 920              		.loc 1 828 0
 921              		@ Function supports interworking.
 922              		@ args = 0, pretend = 0, frame = 4
 923              		@ frame_needed = 0, uses_anonymous_args = 0
 924              	.LVL94:
 925 0724 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 926              	.LCFI9:
 927 0728 0118A0E1 		mov	r1, r1, asl #16
 928              	.LVL95:
 929 072c 2138A0E1 		mov	r3, r1, lsr #16
 930              	.LVL96:
 931              		.loc 1 830 0
 932 0730 000050E3 		cmp	r0, #0
 933 0734 01005313 		cmpne	r3, #1
 934              		.loc 1 828 0
 935 0738 04D04DE2 		sub	sp, sp, #4
 936              	.LCFI10:
 937              	.LVL97:
 938              		.loc 1 830 0
 939 073c 0050A0E1 		mov	r5, r0
 940              		.loc 1 833 0
 941 0740 08709085 		ldrhi	r7, [r0, #8]
 942              	.LVL98:
 943              		.loc 1 830 0
 944 0744 EF01008A 		bhi	.L111
 945 0748 F70100EA 		b	.L109
 946              	.LVL99:
 947              	.L112:
 948              	.LBB19:
 949              		.loc 1 837 0
 950 074c 003095E5 		ldr	r3, [r5, #0]
 951              	.LVL100:
 952 0750 00C093E5 		ldr	ip, [r3, #0]
 953 0754 0FE0A0E1 		mov	lr, pc
 954 0758 1CFF2FE1 		bx	ip
 955              		.loc 1 863 0
 956 075c 00E0A0E3 		mov	lr, #0
 957              		.loc 1 837 0
 958 0760 0E0050E1 		cmp	r0, lr
 959              		.loc 1 865 0
 960 0764 0610A0E1 		mov	r1, r6
 961 0768 0220A0E3 		mov	r2, #2
 962 076c 0400A0E1 		mov	r0, r4
 963              		.loc 1 837 0
 964 0770 F701000A 		beq	.L109
 965              		.loc 1 842 0
 966 0774 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 967 0778 03C0DDE5 		ldrb	ip, [sp, #3]	@ zero_extendqisi2
 968 077c 0C3483E1 		orr	r3, r3, ip, asl #8
 969 0780 0340A0E1 		mov	r4, r3
 970              	.LVL101:
 971              		.loc 1 844 0
 972 0784 0E0054E1 		cmp	r4, lr
 973              		.loc 1 846 0
 974 0788 103083E2 		add	r3, r3, #16
 975 078c 0338A0E1 		mov	r3, r3, asl #16
 976              		.loc 1 844 0
 977 0790 F901000A 		beq	.L114
 978              		.loc 1 846 0
 979 0794 070853E3 		cmp	r3, #458752
 980 0798 F701009A 		bls	.L109
 981              		.loc 1 857 0
 982 079c 58309FE5 		ldr	r3, .L121
 983              		.loc 1 864 0
 984 07a0 03E0CDE5 		strb	lr, [sp, #3]
 985              		.loc 1 863 0
 986 07a4 02E0CDE5 		strb	lr, [sp, #2]
 987              		.loc 1 857 0
 988 07a8 030054E1 		cmp	r4, r3
 989 07ac 0E40A081 		movhi	r4, lr
 990              		.loc 1 865 0
 991 07b0 003095E5 		ldr	r3, [r5, #0]
 992 07b4 08C093E5 		ldr	ip, [r3, #8]
 993 07b8 0FE0A0E1 		mov	lr, pc
 994 07bc 1CFF2FE1 		bx	ip
 995 07c0 0430A0E1 		mov	r3, r4
 996              	.LVL102:
 997              	.L111:
 998              		.loc 1 837 0
 999 07c4 834087E0 		add	r4, r7, r3, asl #1
 1000              	.LVL103:
 1001 07c8 02608DE2 		add	r6, sp, #2
 1002              	.LBE19:
 1003              		.loc 1 835 0
 1004 07cc 000053E3 		cmp	r3, #0
 1005              	.LBB20:
 1006              		.loc 1 837 0
 1007 07d0 0610A0E1 		mov	r1, r6
 1008 07d4 0220A0E3 		mov	r2, #2
 1009 07d8 0400A0E1 		mov	r0, r4
 1010              	.LBE20:
 1011              		.loc 1 835 0
 1012 07dc D101001A 		bne	.L112
 1013 07e0 F90100EA 		b	.L114
 1014              	.LVL104:
 1015              	.L109:
 1016 07e4 0000A0E3 		mov	r0, #0
 1017 07e8 FA0100EA 		b	.L119
 1018              	.L114:
 1019 07ec 0100A0E3 		mov	r0, #1
 1020              	.L119:
 1021              		.loc 1 878 0
 1022 07f0 04D08DE2 		add	sp, sp, #4
 1023 07f4 F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 1024 07f8 1EFF2FE1 		bx	lr
 1025              	.L122:
 1026              		.align	2
 1027              	.L121:
 1028 07fc F7FF0000 		.word	65527
 1029              	.LFE13:
 1031              		.align	2
 1033              	fat16_append_clusters:
 1034              	.LFB12:
 1035              		.loc 1 735 0
 1036              		@ Function supports interworking.
 1037              		@ args = 0, pretend = 0, frame = 20
 1038              		@ frame_needed = 0, uses_anonymous_args = 0
 1039              	.LVL105:
 1040 0800 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1041              	.LCFI11:
 1042 0804 0118A0E1 		mov	r1, r1, asl #16
 1043              	.LVL106:
 1044 0808 14D04DE2 		sub	sp, sp, #20
 1045              	.LCFI12:
 1046              	.LVL107:
 1047              		.loc 1 735 0
 1048 080c 0228A0E1 		mov	r2, r2, asl #16
 1049              	.LVL108:
 1050 0810 2118A0E1 		mov	r1, r1, lsr #16
 1051              		.loc 1 737 0
 1052 0814 007050E2 		subs	r7, r0, #0
 1053              		.loc 1 735 0
 1054 0818 00108DE5 		str	r1, [sp, #0]
 1055              	.LVL109:
 1056 081c 2298A0E1 		mov	r9, r2, lsr #16
 1057              	.LVL110:
 1058              		.loc 1 737 0
 1059 0820 5602000A 		beq	.L124
 1060              	.LVL111:
 1061              		.loc 1 740 0
 1062 0824 002097E5 		ldr	r2, [r7, #0]
 1063              		.loc 1 743 0
 1064 0828 0C3097E5 		ldr	r3, [r7, #12]
 1065              		.loc 1 741 0
 1066 082c 081092E5 		ldr	r1, [r2, #8]
 1067              		.loc 1 743 0
 1068 0830 8337A0E1 		mov	r3, r3, asl #15
 1069 0834 0050A0E3 		mov	r5, #0
 1070              	.LVL112:
 1071              		.loc 1 740 0
 1072 0838 002092E5 		ldr	r2, [r2, #0]
 1073              		.loc 1 742 0
 1074 083c 08B097E5 		ldr	fp, [r7, #8]
 1075              	.LVL113:
 1076              		.loc 1 743 0
 1077 0840 2338A0E1 		mov	r3, r3, lsr #16
 1078 0844 0960A0E1 		mov	r6, r9
 1079              	.LVL114:
 1080 0848 05A0A0E1 		mov	sl, r5
 1081              		.loc 1 741 0
 1082 084c 08108DE5 		str	r1, [sp, #8]
 1083              	.LVL115:
 1084              		.loc 1 740 0
 1085 0850 04208DE5 		str	r2, [sp, #4]
 1086              	.LVL116:
 1087              		.loc 1 743 0
 1088 0854 0C308DE5 		str	r3, [sp, #12]
 1089              	.LVL117:
 1090 0858 390200EA 		b	.L126
 1091              	.LVL118:
 1092              	.L127:
 1093              		.loc 1 750 0
 1094 085c 84808BE0 		add	r8, fp, r4, asl #1
 1095 0860 0800A0E1 		mov	r0, r8
 1096 0864 12108DE2 		add	r1, sp, #18
 1097 0868 0220A0E3 		mov	r2, #2
 1098 086c 04309DE5 		ldr	r3, [sp, #4]
 1099 0870 0FE0A0E1 		mov	lr, pc
 1100 0874 13FF2FE1 		bx	r3
 1101 0878 000050E3 		cmp	r0, #0
 1102 087c 5602000A 		beq	.L124
 1103              		.loc 1 754 0
 1104 0880 1230DDE5 		ldrb	r3, [sp, #18]	@ zero_extendqisi2
 1105 0884 000053E3 		cmp	r3, #0
 1106 0888 3802001A 		bne	.L129
 1107 088c 1330DDE5 		ldrb	r3, [sp, #19]	@ zero_extendqisi2
 1108 0890 000053E3 		cmp	r3, #0
 1109 0894 3802001A 		bne	.L129
 1110              		.loc 1 758 0
 1111 0898 090056E1 		cmp	r6, r9
 1112              		.loc 1 760 0
 1113 089c 0030E003 		mvneq	r3, #0
 1114              		.loc 1 766 0
 1115 08a0 2534A011 		movne	r3, r5, lsr #8
 1116              		.loc 1 761 0
 1117 08a4 1330CD05 		streqb	r3, [sp, #19]
 1118              		.loc 1 760 0
 1119 08a8 1230CD05 		streqb	r3, [sp, #18]
 1120              		.loc 1 766 0
 1121 08ac 1330CD15 		strneb	r3, [sp, #19]
 1122              		.loc 1 765 0
 1123 08b0 1250CD15 		strneb	r5, [sp, #18]
 1124              		.loc 1 769 0
 1125 08b4 0800A0E1 		mov	r0, r8
 1126 08b8 12108DE2 		add	r1, sp, #18
 1127 08bc 0220A0E3 		mov	r2, #2
 1128 08c0 08309DE5 		ldr	r3, [sp, #8]
 1129 08c4 0FE0A0E1 		mov	lr, pc
 1130 08c8 13FF2FE1 		bx	r3
 1131 08cc 000050E3 		cmp	r0, #0
 1132 08d0 3E02000A 		beq	.L135
 1133              		.loc 1 773 0
 1134 08d4 013046E2 		sub	r3, r6, #1
 1135 08d8 0338A0E1 		mov	r3, r3, asl #16
 1136 08dc 2368B0E1 		movs	r6, r3, lsr #16
 1137 08e0 5102000A 		beq	.L145
 1138 08e4 0450A0E1 		mov	r5, r4
 1139              	.L129:
 1140 08e8 01A08AE2 		add	sl, sl, #1
 1141              	.LVL119:
 1142              	.L126:
 1143 08ec 0A38A0E1 		mov	r3, sl, asl #16
 1144              		.loc 1 748 0
 1145 08f0 0C109DE5 		ldr	r1, [sp, #12]
 1146              		.loc 1 773 0
 1147 08f4 2348A0E1 		mov	r4, r3, lsr #16
 1148              		.loc 1 748 0
 1149 08f8 010054E1 		cmp	r4, r1
 1150 08fc 1502003A 		bcc	.L127
 1151              	.L135:
 1152              		.loc 1 780 0
 1153 0900 000056E3 		cmp	r6, #0
 1154 0904 5302001A 		bne	.L140
 1155              	.L139:
 1156              		.loc 1 786 0
 1157 0908 00309DE5 		ldr	r3, [sp, #0]
 1158 090c 010053E3 		cmp	r3, #1
 1159 0910 4F02009A 		bls	.L141
 1160              		.loc 1 790 0
 1161 0914 00109DE5 		ldr	r1, [sp, #0]
 1162              		.loc 1 789 0
 1163 0918 2534A0E1 		mov	r3, r5, lsr #8
 1164 091c 1330CDE5 		strb	r3, [sp, #19]
 1165              		.loc 1 790 0
 1166 0920 81008BE0 		add	r0, fp, r1, asl #1
 1167              		.loc 1 788 0
 1168 0924 1250CDE5 		strb	r5, [sp, #18]
 1169              		.loc 1 790 0
 1170 0928 12108DE2 		add	r1, sp, #18
 1171 092c 0220A0E3 		mov	r2, #2
 1172 0930 08309DE5 		ldr	r3, [sp, #8]
 1173 0934 0FE0A0E1 		mov	lr, pc
 1174 0938 13FF2FE1 		bx	r3
 1175 093c 000050E3 		cmp	r0, #0
 1176 0940 5302000A 		beq	.L140
 1177              	.LVL120:
 1178              	.L141:
 1179              		.loc 1 794 0
 1180 0944 0500A0E1 		mov	r0, r5
 1181 0948 570200EA 		b	.L143
 1182              	.L145:
 1183              		.loc 1 773 0
 1184 094c 0450A0E1 		mov	r5, r4
 1185 0950 400200EA 		b	.L139
 1186              	.LVL121:
 1187              	.L140:
 1188              		.loc 1 802 0
 1189 0954 0700A0E1 		mov	r0, r7
 1190 0958 0510A0E1 		mov	r1, r5
 1191 095c C70100EB 		bl	fat16_free_clusters
 1192              	.LVL122:
 1193              	.L124:
 1194              		.loc 1 804 0
 1195 0960 0000A0E3 		mov	r0, #0
 1196              	.L143:
 1197              		.loc 1 808 0
 1198 0964 14D08DE2 		add	sp, sp, #20
 1199 0968 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1200 096c 1EFF2FE1 		bx	lr
 1201              	.LFE12:
 1203              		.align	2
 1204              		.global	fat16_open_dir
 1206              	fat16_open_dir:
 1207              	.LFB21:
 1208              		.loc 1 1356 0
 1209              		@ Function supports interworking.
 1210              		@ args = 0, pretend = 0, frame = 0
 1211              		@ frame_needed = 0, uses_anonymous_args = 0
 1212              	.LVL123:
 1213              		.loc 1 1357 0
 1214 0970 000051E3 		cmp	r1, #0
 1215 0974 00005013 		cmpne	r0, #0
 1216              		.loc 1 1356 0
 1217 0978 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 1218              	.LCFI13:
 1219              		.loc 1 1357 0
 1220 097c 0070A0E1 		mov	r7, r0
 1221 0980 0150A0E1 		mov	r5, r1
 1222 0984 0080A013 		movne	r8, #0
 1223 0988 0180A003 		moveq	r8, #1
 1224 098c 7502000A 		beq	.L147
 1225              	.LVL124:
 1226 0990 2030D1E5 		ldrb	r3, [r1, #32]	@ zero_extendqisi2
 1227 0994 100013E3 		tst	r3, #16
 1228              		.loc 1 1360 0
 1229 0998 3400A0E3 		mov	r0, #52
 1230              		.loc 1 1357 0
 1231 099c 7502000A 		beq	.L147
 1232              	.LVL125:
 1233              		.loc 1 1360 0
 1234 09a0 FEFFFFEB 		bl	malloc
 1235              	.LVL126:
 1236              		.loc 1 1361 0
 1237 09a4 006050E2 		subs	r6, r0, #0
 1238              	.LVL127:
 1239              		.loc 1 1364 0
 1240 09a8 044086E2 		add	r4, r6, #4
 1241              		.loc 1 1361 0
 1242 09ac 7502000A 		beq	.L147
 1243              		.loc 1 1364 0
 1244 09b0 05C0A0E1 		mov	ip, r5
 1245 09b4 0F00BCE8 		ldmia	ip!, {r0, r1, r2, r3}
 1246 09b8 04E0A0E1 		mov	lr, r4
 1247 09bc 0F00AEE8 		stmia	lr!, {r0, r1, r2, r3}
 1248 09c0 0F00BCE8 		ldmia	ip!, {r0, r1, r2, r3}
 1249 09c4 0F00AEE8 		stmia	lr!, {r0, r1, r2, r3}
 1250 09c8 07009CE8 		ldmia	ip, {r0, r1, r2}
 1251              		.loc 1 1365 0
 1252 09cc 007086E5 		str	r7, [r6, #0]
 1253              		.loc 1 1364 0
 1254 09d0 07008EE8 		stmia	lr, {r0, r1, r2}
 1255              		.loc 1 1366 0
 1256 09d4 B083C6E1 		strh	r8, [r6, #48]	@ movhi
 1257 09d8 760200EA 		b	.L151
 1258              	.LVL128:
 1259              	.L147:
 1260              		.loc 1 1368 0
 1261 09dc 0060A0E3 		mov	r6, #0
 1262              	.LVL129:
 1263              	.L151:
 1264              		.loc 1 1369 0
 1265 09e0 0600A0E1 		mov	r0, r6
 1266 09e4 F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 1267 09e8 1EFF2FE1 		bx	lr
 1268              	.LFE21:
 1270              		.align	2
 1271              		.global	fat16_get_dir_entry_of_path
 1273              	fat16_get_dir_entry_of_path:
 1274              	.LFB10:
 1275              		.loc 1 626 0
 1276              		@ Function supports interworking.
 1277              		@ args = 0, pretend = 0, frame = 0
 1278              		@ frame_needed = 0, uses_anonymous_args = 0
 1279              	.LVL130:
 1280              		.loc 1 627 0
 1281 09ec 000051E3 		cmp	r1, #0
 1282 09f0 00005013 		cmpne	r0, #0
 1283              		.loc 1 626 0
 1284 09f4 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1285              	.LCFI14:
 1286              		.loc 1 627 0
 1287 09f8 0090A0E1 		mov	r9, r0
 1288 09fc 0140A0E1 		mov	r4, r1
 1289              		.loc 1 626 0
 1290 0a00 0250A0E1 		mov	r5, r2
 1291              		.loc 1 627 0
 1292 0a04 BD02000A 		beq	.L154
 1293              	.LVL131:
 1294 0a08 0030D1E5 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 1295 0a0c 000052E3 		cmp	r2, #0
 1296 0a10 00005313 		cmpne	r3, #0
 1297 0a14 0010A013 		movne	r1, #0
 1298 0a18 0110A003 		moveq	r1, #1
 1299 0a1c BD02000A 		beq	.L154
 1300              	.LVL132:
 1301              		.loc 1 630 0
 1302 0a20 2F0053E3 		cmp	r3, #47
 1303              		.loc 1 634 0
 1304 0a24 0200A0E1 		mov	r0, r2
 1305 0a28 2C20A0E3 		mov	r2, #44
 1306              	.LVL133:
 1307              		.loc 1 631 0
 1308 0a2c 01408402 		addeq	r4, r4, #1
 1309              		.loc 1 634 0
 1310 0a30 FEFFFFEB 		bl	memset
 1311              	.LVL134:
 1312              		.loc 1 635 0
 1313 0a34 1030A0E3 		mov	r3, #16
 1314 0a38 2030C5E5 		strb	r3, [r5, #32]
 1315              		.loc 1 637 0
 1316 0a3c 0030D4E5 		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 1317 0a40 000053E3 		cmp	r3, #0
 1318 0a44 BF02000A 		beq	.L159
 1319              	.LVL135:
 1320              	.L177:
 1321              	.LBB21:
 1322              		.loc 1 642 0
 1323 0a48 0900A0E1 		mov	r0, r9
 1324 0a4c 0510A0E1 		mov	r1, r5
 1325 0a50 FEFFFFEB 		bl	fat16_open_dir
 1326              		.loc 1 643 0
 1327 0a54 007050E2 		subs	r7, r0, #0
 1328 0a58 BD02000A 		beq	.L154
 1329              		.loc 1 647 0
 1330 0a5c 0400A0E1 		mov	r0, r4
 1331 0a60 2F10A0E3 		mov	r1, #47
 1332 0a64 FEFFFFEB 		bl	strchr
 1333              		.loc 1 648 0
 1334 0a68 008050E2 		subs	r8, r0, #0
 1335 0a6c 9D02001A 		bne	.L162
 1336              		.loc 1 649 0
 1337 0a70 0400A0E1 		mov	r0, r4
 1338 0a74 FEFFFFEB 		bl	strlen
 1339 0a78 008084E0 		add	r8, r4, r0
 1340              	.L162:
 1341              		.loc 1 650 0
 1342 0a7c 083064E0 		rsb	r3, r4, r8
 1343 0a80 FF6003E2 		and	r6, r3, #255
 1344 0a84 B40200EA 		b	.L179
 1345              	.L165:
 1346              		.loc 1 656 0
 1347 0a88 FEFFFFEB 		bl	strlen
 1348 0a8c 060050E1 		cmp	r0, r6
 1349 0a90 0510A0E1 		mov	r1, r5
 1350 0a94 0620A0E1 		mov	r2, r6
 1351 0a98 0400A0E1 		mov	r0, r4
 1352 0a9c B402001A 		bne	.L179
 1353              	.LVL136:
 1354 0aa0 FEFFFFEB 		bl	strncmp
 1355              	.LVL137:
 1356 0aa4 00A050E2 		subs	sl, r0, #0
 1357 0aa8 B402001A 		bne	.L179
 1358              		.loc 1 660 0
 1359 0aac 0700A0E1 		mov	r0, r7
 1360 0ab0 FEFFFFEB 		bl	fat16_close_dir
 1361              		.loc 1 663 0
 1362 0ab4 0630D4E7 		ldrb	r3, [r4, r6]	@ zero_extendqisi2
 1363 0ab8 000053E3 		cmp	r3, #0
 1364 0abc BF02000A 		beq	.L159
 1365              		.loc 1 667 0
 1366 0ac0 2030D5E5 		ldrb	r3, [r5, #32]	@ zero_extendqisi2
 1367 0ac4 100013E3 		tst	r3, #16
 1368 0ac8 BD02000A 		beq	.L154
 1369              		.loc 1 670 0
 1370 0acc 014088E2 		add	r4, r8, #1
 1371 0ad0 0A70A0E1 		mov	r7, sl
 1372 0ad4 BA0200EA 		b	.L170
 1373              	.LVL138:
 1374              	.L179:
 1375              		.loc 1 653 0
 1376 0ad8 0510A0E1 		mov	r1, r5
 1377 0adc 0700A0E1 		mov	r0, r7
 1378 0ae0 FEFFFFEB 		bl	fat16_read_dir
 1379 0ae4 000050E3 		cmp	r0, #0
 1380              		.loc 1 656 0
 1381 0ae8 0500A0E1 		mov	r0, r5
 1382              		.loc 1 653 0
 1383 0aec A002001A 		bne	.L165
 1384              	.L170:
 1385              		.loc 1 678 0
 1386 0af0 0700A0E1 		mov	r0, r7
 1387 0af4 FEFFFFEB 		bl	fat16_close_dir
 1388 0af8 900200EA 		b	.L177
 1389              	.LVL139:
 1390              	.L154:
 1391              		.loc 1 679 0
 1392 0afc 0000A0E3 		mov	r0, #0
 1393 0b00 C00200EA 		b	.L171
 1394              	.LVL140:
 1395              	.L159:
 1396 0b04 0100A0E3 		mov	r0, #1
 1397              	.LVL141:
 1398              	.L171:
 1399              	.LBE21:
 1400              		.loc 1 682 0
 1401 0b08 F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1402 0b0c 1EFF2FE1 		bx	lr
 1403              	.LFE10:
 1405              		.align	2
 1406              		.global	fat16_open_file
 1408              	fat16_open_file:
 1409              	.LFB15:
 1410              		.loc 1 928 0
 1411              		@ Function supports interworking.
 1412              		@ args = 0, pretend = 0, frame = 0
 1413              		@ frame_needed = 0, uses_anonymous_args = 0
 1414              	.LVL142:
 1415              		.loc 1 929 0
 1416 0b10 000051E3 		cmp	r1, #0
 1417 0b14 00005013 		cmpne	r0, #0
 1418              		.loc 1 928 0
 1419 0b18 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 1420              	.LCFI15:
 1421              		.loc 1 929 0
 1422 0b1c 0150A0E1 		mov	r5, r1
 1423 0b20 0070A0E1 		mov	r7, r0
 1424 0b24 DD02000A 		beq	.L181
 1425              	.LVL143:
 1426 0b28 2030D1E5 		ldrb	r3, [r1, #32]	@ zero_extendqisi2
 1427 0b2c 108013E2 		ands	r8, r3, #16
 1428              		.loc 1 932 0
 1429 0b30 3800A0E3 		mov	r0, #56
 1430              		.loc 1 929 0
 1431 0b34 DD02001A 		bne	.L181
 1432              	.LVL144:
 1433              		.loc 1 932 0
 1434 0b38 FEFFFFEB 		bl	malloc
 1435              	.LVL145:
 1436              		.loc 1 933 0
 1437 0b3c 006050E2 		subs	r6, r0, #0
 1438              	.LVL146:
 1439              		.loc 1 936 0
 1440 0b40 044086E2 		add	r4, r6, #4
 1441              		.loc 1 933 0
 1442 0b44 DD02000A 		beq	.L181
 1443              		.loc 1 936 0
 1444 0b48 05C0A0E1 		mov	ip, r5
 1445 0b4c 0F00BCE8 		ldmia	ip!, {r0, r1, r2, r3}
 1446 0b50 04E0A0E1 		mov	lr, r4
 1447 0b54 0F00AEE8 		stmia	lr!, {r0, r1, r2, r3}
 1448 0b58 0F00BCE8 		ldmia	ip!, {r0, r1, r2, r3}
 1449 0b5c 0F00AEE8 		stmia	lr!, {r0, r1, r2, r3}
 1450 0b60 07009CE8 		ldmia	ip, {r0, r1, r2}
 1451 0b64 07008EE8 		stmia	lr, {r0, r1, r2}
 1452              		.loc 1 939 0
 1453 0b68 B252D5E1 		ldrh	r5, [r5, #34]
 1454              	.LVL147:
 1455              		.loc 1 937 0
 1456 0b6c 007086E5 		str	r7, [r6, #0]
 1457              		.loc 1 938 0
 1458 0b70 308086E5 		str	r8, [r6, #48]
 1459              		.loc 1 939 0
 1460 0b74 B453C6E1 		strh	r5, [r6, #52]	@ movhi
 1461 0b78 DE0200EA 		b	.L185
 1462              	.LVL148:
 1463              	.L181:
 1464              		.loc 1 941 0
 1465 0b7c 0060A0E3 		mov	r6, #0
 1466              	.LVL149:
 1467              	.L185:
 1468              		.loc 1 942 0
 1469 0b80 0600A0E1 		mov	r0, r6
 1470 0b84 F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 1471 0b88 1EFF2FE1 		bx	lr
 1472              	.LFE15:
 1474              		.align	2
 1475              		.global	fat16_close_file
 1477              	fat16_close_file:
 1478              	.LFB16:
 1479              		.loc 1 952 0
 1480              		@ Function supports interworking.
 1481              		@ args = 0, pretend = 0, frame = 0
 1482              		@ frame_needed = 0, uses_anonymous_args = 0
 1483              	.LVL150:
 1484              		.loc 1 953 0
 1485 0b8c 000050E3 		cmp	r0, #0
 1486              		.loc 1 952 0
 1487 0b90 04E02DE5 		str	lr, [sp, #-4]!
 1488              	.LCFI16:
 1489              		.loc 1 953 0
 1490              		.loc 1 954 0
 1491 0b94 FEFFFF1B 		blne	free
 1492              	.LVL151:
 1493              	.LVL152:
 1494              	.L190:
 1495              		.loc 1 955 0
 1496 0b98 04E09DE4 		ldr	lr, [sp], #4
 1497 0b9c 1EFF2FE1 		bx	lr
 1498              	.LFE16:
 1500              		.global	__umodsi3
 1501              		.align	2
 1502              		.global	fat16_read_file
 1504              	fat16_read_file:
 1505              	.LFB17:
 1506              		.loc 1 970 0
 1507              		@ Function supports interworking.
 1508              		@ args = 0, pretend = 0, frame = 0
 1509              		@ frame_needed = 0, uses_anonymous_args = 0
 1510              	.LVL153:
 1511 0ba0 0228A0E1 		mov	r2, r2, asl #16
 1512              	.LVL154:
 1513              		.loc 1 972 0
 1514 0ba4 000051E3 		cmp	r1, #0
 1515 0ba8 00005013 		cmpne	r0, #0
 1516              		.loc 1 970 0
 1517 0bac F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1518              	.LCFI17:
 1519              		.loc 1 972 0
 1520 0bb0 0060A0E1 		mov	r6, r0
 1521 0bb4 01B0A0E1 		mov	fp, r1
 1522              		.loc 1 970 0
 1523 0bb8 2288A0E1 		mov	r8, r2, lsr #16
 1524              	.LVL155:
 1525              		.loc 1 972 0
 1526 0bbc 3C03000A 		beq	.L192
 1527              	.LVL156:
 1528 0bc0 000058E3 		cmp	r8, #0
 1529 0bc4 3C03000A 		beq	.L192
 1530              		.loc 1 976 0
 1531 0bc8 304090E5 		ldr	r4, [r0, #48]
 1532              	.LVL157:
 1533 0bcc 282090E5 		ldr	r2, [r0, #40]
 1534 0bd0 083084E0 		add	r3, r4, r8
 1535 0bd4 020053E1 		cmp	r3, r2
 1536 0bd8 F902009A 		bls	.L195
 1537              	.LVL158:
 1538              		.loc 1 977 0
 1539 0bdc 023064E0 		rsb	r3, r4, r2
 1540 0be0 0338A0E1 		mov	r3, r3, asl #16
 1541              		.loc 1 978 0
 1542 0be4 2388B0E1 		movs	r8, r3, lsr #16
 1543 0be8 4703000A 		beq	.L197
 1544              	.L195:
 1545              		.loc 1 981 0
 1546 0bec 003096E5 		ldr	r3, [r6, #0]
 1547 0bf0 B2A1D3E1 		ldrh	sl, [r3, #18]
 1548              	.LVL159:
 1549              		.loc 1 984 0
 1550 0bf4 0400A0E1 		mov	r0, r4
 1551              	.LVL160:
 1552 0bf8 0A10A0E1 		mov	r1, sl
 1553 0bfc FEFFFFEB 		bl	__umodsi3
 1554              		.loc 1 982 0
 1555 0c00 B453D6E1 		ldrh	r5, [r6, #52]
 1556              	.LVL161:
 1557              		.loc 1 984 0
 1558 0c04 0008A0E1 		mov	r0, r0, asl #16
 1559              		.loc 1 987 0
 1560 0c08 000055E3 		cmp	r5, #0
 1561              		.loc 1 984 0
 1562 0c0c 2098A0E1 		mov	r9, r0, lsr #16
 1563              	.LVL162:
 1564              		.loc 1 987 0
 1565 0c10 1403001A 		bne	.L198
 1566              		.loc 1 989 0
 1567 0c14 B652D6E1 		ldrh	r5, [r6, #38]
 1568              		.loc 1 991 0
 1569 0c18 000055E3 		cmp	r5, #0
 1570 0c1c 0903001A 		bne	.L200
 1571              		.loc 1 993 0
 1572 0c20 000054E3 		cmp	r4, #0
 1573 0c24 4703000A 		beq	.L197
 1574 0c28 3C0300EA 		b	.L192
 1575              	.L200:
 1576              		.loc 1 999 0
 1577 0c2c 000054E3 		cmp	r4, #0
 1578 0c30 1003001A 		bne	.L219
 1579 0c34 140300EA 		b	.L198
 1580              	.LVL163:
 1581              	.L203:
 1582              	.LBB22:
 1583              		.loc 1 1005 0
 1584 0c38 000096E5 		ldr	r0, [r6, #0]
 1585 0c3c 7E0000EB 		bl	fat16_get_next_cluster
 1586              	.LVL164:
 1587              		.loc 1 1006 0
 1588 0c40 005050E2 		subs	r5, r0, #0
 1589 0c44 3C03000A 		beq	.L192
 1590              	.L219:
 1591              		.loc 1 1002 0
 1592 0c48 0A0054E1 		cmp	r4, sl
 1593              		.loc 1 1005 0
 1594 0c4c 0510A0E1 		mov	r1, r5
 1595              		.loc 1 1004 0
 1596 0c50 04406AE0 		rsb	r4, sl, r4
 1597              		.loc 1 1002 0
 1598 0c54 0C03002A 		bcs	.L203
 1599              	.L198:
 1600 0c58 0870A0E1 		mov	r7, r8
 1601              	.LVL165:
 1602              	.LVL166:
 1603              	.L204:
 1604              	.LBE22:
 1605              	.LBB23:
 1606              		.loc 1 1017 0
 1607 0c5c 001096E5 		ldr	r1, [r6, #0]
 1608 0c60 182091E5 		ldr	r2, [r1, #24]
 1609 0c64 023045E2 		sub	r3, r5, #2
 1610 0c68 9A2320E0 		mla	r0, sl, r3, r2
 1611              		.loc 1 1018 0
 1612 0c6c 0A3069E0 		rsb	r3, r9, sl
 1613 0c70 0338A0E1 		mov	r3, r3, asl #16
 1614 0c74 2348A0E1 		mov	r4, r3, lsr #16
 1615              	.LVL167:
 1616              		.loc 1 1019 0
 1617 0c78 070054E1 		cmp	r4, r7
 1618 0c7c 0740A021 		movcs	r4, r7
 1619              		.loc 1 1023 0
 1620 0c80 003091E5 		ldr	r3, [r1, #0]
 1621 0c84 0420A0E1 		mov	r2, r4
 1622 0c88 0B10A0E1 		mov	r1, fp
 1623 0c8c 090080E0 		add	r0, r0, r9
 1624              	.LVL168:
 1625 0c90 00C093E5 		ldr	ip, [r3, #0]
 1626 0c94 0FE0A0E1 		mov	lr, pc
 1627 0c98 1CFF2FE1 		bx	ip
 1628              	.LVL169:
 1629              		.loc 1 1028 0
 1630 0c9c 073064E0 		rsb	r3, r4, r7
 1631              		.loc 1 1023 0
 1632 0ca0 000050E3 		cmp	r0, #0
 1633              		.loc 1 1034 0
 1634 0ca4 0510A0E1 		mov	r1, r5
 1635              		.loc 1 1031 0
 1636 0ca8 042089E0 		add	r2, r9, r4
 1637              		.loc 1 1028 0
 1638 0cac 0308A0E1 		mov	r0, r3, asl #16
 1639              		.loc 1 1023 0
 1640 0cb0 3E03000A 		beq	.L216
 1641              		.loc 1 1029 0
 1642 0cb4 303096E5 		ldr	r3, [r6, #48]
 1643              		.loc 1 1031 0
 1644 0cb8 0A0052E1 		cmp	r2, sl
 1645              		.loc 1 1029 0
 1646 0cbc 043083E0 		add	r3, r3, r4
 1647 0cc0 303086E5 		str	r3, [r6, #48]
 1648              		.loc 1 1028 0
 1649 0cc4 2078A0E1 		mov	r7, r0, lsr #16
 1650              		.loc 1 1027 0
 1651 0cc8 04B08BE0 		add	fp, fp, r4
 1652              		.loc 1 1031 0
 1653 0ccc 370300BA 		blt	.L210
 1654              		.loc 1 1034 0
 1655 0cd0 000096E5 		ldr	r0, [r6, #0]
 1656 0cd4 7E0000EB 		bl	fat16_get_next_cluster
 1657 0cd8 005050E2 		subs	r5, r0, #0
 1658              		.loc 1 1041 0
 1659 0cdc 0090A0E3 		mov	r9, #0
 1660              		.loc 1 1034 0
 1661 0ce0 4203000A 		beq	.L217
 1662              	.L210:
 1663              	.LBE23:
 1664              		.loc 1 1048 0
 1665 0ce4 000057E3 		cmp	r7, #0
 1666              	.LBB24:
 1667              		.loc 1 1045 0
 1668 0ce8 B453C6E1 		strh	r5, [r6, #52]	@ movhi
 1669              	.LBE24:
 1670              		.loc 1 1048 0
 1671 0cec 1503001A 		bne	.L204
 1672              		.loc 1 1050 0
 1673 0cf0 0838A0E1 		mov	r3, r8, asl #16
 1674 0cf4 400300EA 		b	.L221
 1675              	.LVL170:
 1676              	.L192:
 1677 0cf8 0000E0E3 		mvn	r0, #0
 1678 0cfc 480300EA 		b	.L209
 1679              	.LVL171:
 1680              	.L216:
 1681              	.LBB25:
 1682              		.loc 1 1024 0
 1683 0d00 083067E0 		rsb	r3, r7, r8
 1684 0d04 0338A0E1 		mov	r3, r3, asl #16
 1685              	.L221:
 1686 0d08 4308A0E1 		mov	r0, r3, asr #16
 1687 0d0c 480300EA 		b	.L209
 1688              	.L217:
 1689              		.loc 1 1041 0
 1690 0d10 083067E0 		rsb	r3, r7, r8
 1691 0d14 0338A0E1 		mov	r3, r3, asl #16
 1692 0d18 4308A0E1 		mov	r0, r3, asr #16
 1693              		.loc 1 1040 0
 1694 0d1c B453C6E1 		strh	r5, [r6, #52]	@ movhi
 1695 0d20 480300EA 		b	.L209
 1696              	.LVL172:
 1697              	.L197:
 1698              	.LBE25:
 1699              		.loc 1 1050 0
 1700 0d24 0000A0E3 		mov	r0, #0
 1701              	.LVL173:
 1702              	.L209:
 1703              		.loc 1 1051 0
 1704 0d28 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1705 0d2c 1EFF2FE1 		bx	lr
 1706              	.LFE17:
 1708              		.align	2
 1709              		.global	fat16_reset_dir
 1711              	fat16_reset_dir:
 1712              	.LFB24:
1426:../lib/fat16.c **** 
1427:../lib/fat16.c **** /**
1428:../lib/fat16.c ****  * \ingroup fat16_dir
1429:../lib/fat16.c ****  * Resets a directory handle.
1430:../lib/fat16.c ****  *
1431:../lib/fat16.c ****  * Resets the directory handle such that reading restarts
1432:../lib/fat16.c ****  * with the first directory entry.
1433:../lib/fat16.c ****  *
1434:../lib/fat16.c ****  * \param[in] dd The directory handle to reset.
1435:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1436:../lib/fat16.c ****  * \see fat16_read_dir
1437:../lib/fat16.c ****  */
1438:../lib/fat16.c **** uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
1439:../lib/fat16.c **** {
 1713              		.loc 1 1439 0
 1714              		@ Function supports interworking.
 1715              		@ args = 0, pretend = 0, frame = 0
 1716              		@ frame_needed = 0, uses_anonymous_args = 0
 1717              		@ link register save eliminated.
 1718              	.LVL174:
1440:../lib/fat16.c ****     if(!dd)
 1719              		.loc 1 1440 0
 1720 0d30 000050E3 		cmp	r0, #0
 1721 0d34 0030A0E1 		mov	r3, r0
1441:../lib/fat16.c ****         return 0;
1442:../lib/fat16.c **** 
1443:../lib/fat16.c ****     dd->entry_next = 0;
 1722              		.loc 1 1443 0
 1723 0d38 0030A013 		movne	r3, #0	@ movhi
 1724 0d3c B033C011 		strneh	r3, [r0, #48]	@ movhi
 1725 0d40 0130A013 		movne	r3, #1
1444:../lib/fat16.c ****     return 1;
1445:../lib/fat16.c **** }
 1726              		.loc 1 1445 0
 1727 0d44 0300A0E1 		mov	r0, r3
 1728              	.LVL175:
 1729              		.loc 1 1439 0
 1730              		@ lr needed for prologue
 1731              		.loc 1 1445 0
 1732 0d48 1EFF2FE1 		bx	lr
 1733              	.LFE24:
 1735              		.align	2
 1737              	fat16_write_dir_entry:
 1738              	.LFB25:
1446:../lib/fat16.c **** 
1447:../lib/fat16.c **** /**
1448:../lib/fat16.c ****  * \ingroup fat16_fs
1449:../lib/fat16.c ****  * Writes a directory entry to disk.
1450:../lib/fat16.c ****  *
1451:../lib/fat16.c ****  * \note The file name is not checked for invalid characters.
1452:../lib/fat16.c ****  *
1453:../lib/fat16.c ****  * \note The generation of the short 8.3 file name is quite
1454:../lib/fat16.c ****  * simple. The first eight characters are used for the filename.
1455:../lib/fat16.c ****  * The extension, if any, is made up of the first three characters
1456:../lib/fat16.c ****  * following the last dot within the long filename. If the
1457:../lib/fat16.c ****  * filename (without the extension) is longer than eight characters,
1458:../lib/fat16.c ****  * the lower byte of the cluster number replaces the last two
1459:../lib/fat16.c ****  * characters to avoid name clashes. In any other case, it is your
1460:../lib/fat16.c ****  * responsibility to avoid name clashes.
1461:../lib/fat16.c ****  *
1462:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1463:../lib/fat16.c ****  * \param[in] dir_entry The directory entry to write.
1464:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1465:../lib/fat16.c ****  */
1466:../lib/fat16.c **** uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct
1467:../lib/fat16.c **** {
 1739              		.loc 1 1467 0
 1740              		@ Function supports interworking.
 1741              		@ args = 0, pretend = 0, frame = 32
 1742              		@ frame_needed = 0, uses_anonymous_args = 0
 1743              	.LVL176:
 1744 0d4c F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1745              	.LCFI18:
1468:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
1469:../lib/fat16.c ****         if(!fs || !dir_entry)
 1746              		.loc 1 1469 0
 1747 0d50 000051E3 		cmp	r1, #0
 1748 0d54 00005013 		cmpne	r0, #0
 1749              		.loc 1 1467 0
 1750 0d58 20D04DE2 		sub	sp, sp, #32
 1751              	.LCFI19:
 1752              	.LVL177:
 1753              		.loc 1 1469 0
 1754 0d5c 0160A0E1 		mov	r6, r1
 1755 0d60 F003000A 		beq	.L228
 1756              	.LVL178:
1470:../lib/fat16.c ****             return 0;
1471:../lib/fat16.c ****     
1472:../lib/fat16.c ****         device_write_t device_write = fs->partition->device_write;
 1757              		.loc 1 1472 0
 1758 0d64 003090E5 		ldr	r3, [r0, #0]
1473:../lib/fat16.c ****         uint32_t offset = dir_entry->entry_offset;
1474:../lib/fat16.c ****         uint8_t name_len = strlen(dir_entry->long_name);
 1759              		.loc 1 1474 0
 1760 0d68 0100A0E1 		mov	r0, r1
 1761              	.LVL179:
 1762              		.loc 1 1472 0
 1763 0d6c 089093E5 		ldr	r9, [r3, #8]
 1764              	.LVL180:
 1765              		.loc 1 1474 0
 1766 0d70 FEFFFFEB 		bl	strlen
 1767 0d74 FF5000E2 		and	r5, r0, #255
 1768              	.LVL181:
1475:../lib/fat16.c ****         uint8_t lfn_entry_count = (name_len + 12) / 13;
 1769              		.loc 1 1475 0
 1770 0d78 0D10A0E3 		mov	r1, #13
 1771 0d7c 0C0085E2 		add	r0, r5, #12
 1772 0d80 FEFFFFEB 		bl	__divsi3
1476:../lib/fat16.c ****         uint8_t buffer[32];
1477:../lib/fat16.c ****     
1478:../lib/fat16.c ****         /* write 8.3 entry */
1479:../lib/fat16.c ****     
1480:../lib/fat16.c ****         /* generate 8.3 file name */
1481:../lib/fat16.c ****         memset(&buffer[0], ' ', 11);
 1773              		.loc 1 1481 0
 1774 0d84 2010A0E3 		mov	r1, #32
 1775              		.loc 1 1475 0
 1776 0d88 0030A0E1 		mov	r3, r0
 1777              		.loc 1 1481 0
 1778 0d8c 0B20A0E3 		mov	r2, #11
 1779 0d90 0D00A0E1 		mov	r0, sp
 1780              		.loc 1 1475 0
 1781 0d94 FFA003E2 		and	sl, r3, #255
 1782              	.LVL182:
 1783              		.loc 1 1473 0
 1784 0d98 288096E5 		ldr	r8, [r6, #40]
 1785              	.LVL183:
 1786              		.loc 1 1481 0
 1787 0d9c FEFFFFEB 		bl	memset
1482:../lib/fat16.c ****         char* name_ext = strrchr(dir_entry->long_name, '.');
 1788              		.loc 1 1482 0
 1789 0da0 0600A0E1 		mov	r0, r6
 1790 0da4 2E10A0E3 		mov	r1, #46
 1791 0da8 FEFFFFEB 		bl	strrchr
1483:../lib/fat16.c ****         if(name_ext)
 1792              		.loc 1 1483 0
 1793 0dac 000050E3 		cmp	r0, #0
 1794              		.loc 1 1481 0
 1795 0db0 0D70A0E1 		mov	r7, sp
 1796              		.loc 1 1483 0
 1797 0db4 7803000A 		beq	.L230
 1798              	.LBB26:
1484:../lib/fat16.c ****         {
1485:../lib/fat16.c ****             ++name_ext;
 1799              		.loc 1 1485 0
 1800 0db8 014080E2 		add	r4, r0, #1
 1801              	.LVL184:
1486:../lib/fat16.c ****     
1487:../lib/fat16.c ****             uint8_t name_ext_len = strlen(name_ext);
 1802              		.loc 1 1487 0
 1803 0dbc 0400A0E1 		mov	r0, r4
 1804 0dc0 FEFFFFEB 		bl	strlen
 1805 0dc4 FF2000E2 		and	r2, r0, #255
 1806              	.LVL185:
1488:../lib/fat16.c ****             name_len -= name_ext_len + 1;
 1807              		.loc 1 1488 0
 1808 0dc8 053062E0 		rsb	r3, r2, r5
 1809 0dcc 013043E2 		sub	r3, r3, #1
1489:../lib/fat16.c ****     
1490:../lib/fat16.c ****             if(name_ext_len > 3)
1491:../lib/fat16.c ****                 name_ext_len = 3;
1492:../lib/fat16.c ****     
1493:../lib/fat16.c ****             memcpy(&buffer[8], name_ext, name_ext_len);
 1810              		.loc 1 1493 0
 1811 0dd0 030052E3 		cmp	r2, #3
 1812 0dd4 0320A023 		movcs	r2, #3
 1813 0dd8 0410A0E1 		mov	r1, r4
 1814 0ddc 08008DE2 		add	r0, sp, #8
 1815              		.loc 1 1488 0
 1816 0de0 FF5003E2 		and	r5, r3, #255
 1817              		.loc 1 1493 0
 1818 0de4 FEFFFFEB 		bl	memcpy
 1819              	.LVL186:
 1820              	.L230:
 1821              	.LBE26:
1494:../lib/fat16.c ****         }
1495:../lib/fat16.c ****     
1496:../lib/fat16.c ****         if(name_len <= 8)
 1822              		.loc 1 1496 0
 1823 0de8 080055E3 		cmp	r5, #8
 1824 0dec 7F03008A 		bhi	.L234
1497:../lib/fat16.c ****         {
1498:../lib/fat16.c ****             memcpy(buffer, dir_entry->long_name, name_len);
 1825              		.loc 1 1498 0
 1826 0df0 0D00A0E1 		mov	r0, sp
 1827 0df4 0520A0E1 		mov	r2, r5
 1828 0df8 0610A0E1 		mov	r1, r6
 1829 0dfc FEFFFFEB 		bl	memcpy
 1830 0e00 8E0300EA 		b	.L236
 1831              	.L234:
 1832              	.LBB27:
1499:../lib/fat16.c ****         }
1500:../lib/fat16.c ****         else
1501:../lib/fat16.c ****         {
1502:../lib/fat16.c ****             memcpy(buffer, dir_entry->long_name, 8);
 1833              		.loc 1 1502 0
 1834 0e04 0820A0E3 		mov	r2, #8
 1835 0e08 0D00A0E1 		mov	r0, sp
 1836 0e0c 0610A0E1 		mov	r1, r6
 1837 0e10 FEFFFFEB 		bl	memcpy
1503:../lib/fat16.c ****     
1504:../lib/fat16.c ****             /* Minimize 8.3 name clashes by appending
1505:../lib/fat16.c ****                                              * the lower byte of the cluster number.
1506:../lib/fat16.c ****                                              */
1507:../lib/fat16.c ****             uint8_t num = dir_entry->cluster & 0xff;
 1838              		.loc 1 1507 0
 1839 0e14 2230D6E5 		ldrb	r3, [r6, #34]	@ zero_extendqisi2
1508:../lib/fat16.c ****     
1509:../lib/fat16.c ****             buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
 1840              		.loc 1 1509 0
 1841 0e18 9F0053E3 		cmp	r3, #159
 1842 0e1c 2322A0E1 		mov	r2, r3, lsr #4
1510:../lib/fat16.c ****             num &= 0x0f;
 1843              		.loc 1 1510 0
 1844 0e20 0F3003E2 		and	r3, r3, #15
 1845              	.LVL187:
 1846              		.loc 1 1509 0
 1847 0e24 30208292 		addls	r2, r2, #48
 1848 0e28 61208282 		addhi	r2, r2, #97
1511:../lib/fat16.c ****             buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
 1849              		.loc 1 1511 0
 1850 0e2c 090053E3 		cmp	r3, #9
 1851 0e30 30308392 		addls	r3, r3, #48
 1852              	.LVL188:
 1853 0e34 61308382 		addhi	r3, r3, #97
 1854              	.LVL189:
 1855              		.loc 1 1509 0
 1856 0e38 0620CDE5 		strb	r2, [sp, #6]
 1857              		.loc 1 1511 0
 1858 0e3c 0730CDE5 		strb	r3, [sp, #7]
 1859              	.L236:
 1860              	.LBE27:
1512:../lib/fat16.c ****         }
1513:../lib/fat16.c ****     
1514:../lib/fat16.c ****         /* fill directory entry buffer */
1515:../lib/fat16.c ****         memset(&buffer[11], 0, sizeof(buffer) - 11);
 1861              		.loc 1 1515 0
 1862 0e40 0010A0E3 		mov	r1, #0
 1863 0e44 1520A0E3 		mov	r2, #21
 1864 0e48 0B008DE2 		add	r0, sp, #11
 1865 0e4c FEFFFFEB 		bl	memset
1516:../lib/fat16.c ****         buffer[0x0b] = dir_entry->attributes;
 1866              		.loc 1 1516 0
 1867 0e50 2030D6E5 		ldrb	r3, [r6, #32]	@ zero_extendqisi2
 1868 0e54 0B30CDE5 		strb	r3, [sp, #11]
1517:../lib/fat16.c **** 
1518:../lib/fat16.c ****         //Not used in bootloader
1519:../lib/fat16.c **** 		#ifdef MAIN_FIRMWARE
1520:../lib/fat16.c **** 			//Added modified date/time 12-26-07
1521:../lib/fat16.c **** 			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1522:../lib/fat16.c **** 			//*******************************************
1523:../lib/fat16.c **** 			//char * current_time;
1524:../lib/fat16.c **** 			//*******************************************
1525:../lib/fat16.c **** /*			current_time = GPS_get_time();
1526:../lib/fat16.c **** 			char * current_date;
1527:../lib/fat16.c **** 			current_date = GPS_get_date();
1528:../lib/fat16.c **** 			
1529:../lib/fat16.c **** 			uint16_t modified_time, modified_date;
1530:../lib/fat16.c **** 			uint8_t c_hour, c_minute, c_second;
1531:../lib/fat16.c **** 			uint8_t c_year, c_month, c_day;
1532:../lib/fat16.c **** 			
1533:../lib/fat16.c **** 			c_hour = (current_time[0] - '0') * 10;
1534:../lib/fat16.c **** 			c_hour += (current_time[1] - '0');
1535:../lib/fat16.c **** 			c_minute = (current_time[3] - '0') * 10;
1536:../lib/fat16.c **** 			c_minute += (current_time[4] - '0');
1537:../lib/fat16.c **** 			c_second = (current_time[6] - '0') * 10;
1538:../lib/fat16.c **** 			c_second += (current_time[7] - '0');
1539:../lib/fat16.c **** 			
1540:../lib/fat16.c **** 			c_day = (current_date[0] - '0') * 10;
1541:../lib/fat16.c **** 			c_day += (current_date[1] - '0');
1542:../lib/fat16.c **** 			c_month = (current_date[3] - '0') * 10;
1543:../lib/fat16.c **** 			c_month += (current_date[4] - '0');
1544:../lib/fat16.c **** 			c_year = (current_date[6] - '0') * 10;
1545:../lib/fat16.c **** 			c_year += (current_date[7] - '0');
1546:../lib/fat16.c **** 			
1547:../lib/fat16.c **** 			//Correct for 1980 = 0, 2000 = 20, year code
1548:../lib/fat16.c **** 			c_year += 20;
1549:../lib/fat16.c **** 			
1550:../lib/fat16.c **** 			modified_time = (c_hour << (16-5)) | (c_minute << (16-11)) | (c_second);
1551:../lib/fat16.c **** 			modified_date = (c_year << (16-7)) | (c_month << (16-11)) | (c_day);
1552:../lib/fat16.c **** 
1553:../lib/fat16.c **** 			//Do a little error correction
1554:../lib/fat16.c **** 			if (c_year < 26) //26 = 2006
1555:../lib/fat16.c **** 			{
1556:../lib/fat16.c **** 				modified_time = 0;
1557:../lib/fat16.c **** 				modified_date = 0;
1558:../lib/fat16.c **** 			}
1559:../lib/fat16.c **** 
1560:../lib/fat16.c **** 			//rprintf("c_time=%d, %d, %d\n", c_hour, c_minute, c_second);
1561:../lib/fat16.c **** 			//rprintf("c_date=%d, %d, %d\n", c_month, c_day, c_year);
1562:../lib/fat16.c **** 			//rprintf("mod_time=%x\n", modified_time);
1563:../lib/fat16.c **** 			//rprintf("mod_date=%x\n", modified_date);
1564:../lib/fat16.c **** 			
1565:../lib/fat16.c **** 			buffer[0x16] = (modified_time >> 0) & 0xFF;
1566:../lib/fat16.c **** 			buffer[0x17] = (modified_time >> 8) & 0xFF;
1567:../lib/fat16.c **** 			buffer[0x18] = (modified_date >> 0) & 0xFF;
1568:../lib/fat16.c **** 			buffer[0x19] = (modified_date >> 8) & 0xFF;
1569:../lib/fat16.c **** 			*/
1570:../lib/fat16.c **** 			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1571:../lib/fat16.c **** 		#endif
1572:../lib/fat16.c **** 
1573:../lib/fat16.c ****         buffer[0x1a] = (dir_entry->cluster >> 0) & 0xff;
 1869              		.loc 1 1573 0
 1870 0e58 B222D6E1 		ldrh	r2, [r6, #34]
1574:../lib/fat16.c ****         buffer[0x1b] = (dir_entry->cluster >> 8) & 0xff;
 1871              		.loc 1 1574 0
 1872 0e5c 2234A0E1 		mov	r3, r2, lsr #8
 1873              		.loc 1 1573 0
 1874 0e60 1A20CDE5 		strb	r2, [sp, #26]
 1875              		.loc 1 1574 0
 1876 0e64 1B30CDE5 		strb	r3, [sp, #27]
1575:../lib/fat16.c ****         buffer[0x1c] = (dir_entry->file_size >> 0) & 0xff;
 1877              		.loc 1 1575 0
 1878 0e68 243096E5 		ldr	r3, [r6, #36]
1576:../lib/fat16.c ****         buffer[0x1d] = (dir_entry->file_size >> 8) & 0xff;
1577:../lib/fat16.c ****         buffer[0x1e] = (dir_entry->file_size >> 16) & 0xff;
1578:../lib/fat16.c ****         buffer[0x1f] = (dir_entry->file_size >> 24) & 0xff;
 1879              		.loc 1 1578 0
 1880 0e6c 230CA0E1 		mov	r0, r3, lsr #24
 1881              		.loc 1 1576 0
 1882 0e70 2324A0E1 		mov	r2, r3, lsr #8
 1883              		.loc 1 1577 0
 1884 0e74 2318A0E1 		mov	r1, r3, lsr #16
 1885              		.loc 1 1576 0
 1886 0e78 1D20CDE5 		strb	r2, [sp, #29]
 1887              		.loc 1 1577 0
 1888 0e7c 1E10CDE5 		strb	r1, [sp, #30]
 1889              		.loc 1 1578 0
 1890 0e80 1F00CDE5 		strb	r0, [sp, #31]
 1891              		.loc 1 1575 0
 1892 0e84 1C30CDE5 		strb	r3, [sp, #28]
1579:../lib/fat16.c ****     
1580:../lib/fat16.c ****         /* write to disk */
1581:../lib/fat16.c ****         if(!device_write(offset + (uint32_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
 1893              		.loc 1 1581 0
 1894 0e88 8A0288E0 		add	r0, r8, sl, asl #5
 1895 0e8c 0D10A0E1 		mov	r1, sp
 1896 0e90 2020A0E3 		mov	r2, #32
 1897 0e94 0FE0A0E1 		mov	lr, pc
 1898 0e98 19FF2FE1 		bx	r9
 1899 0e9c 000050E3 		cmp	r0, #0
 1900              		.loc 1 1515 0
 1901 0ea0 0D40A0E1 		mov	r4, sp
 1902              	.LVL190:
 1903              		.loc 1 1581 0
 1904 0ea4 F003000A 		beq	.L228
1582:../lib/fat16.c ****             return 0;
1583:../lib/fat16.c ****     
1584:../lib/fat16.c ****         /* calculate checksum of 8.3 name */
1585:../lib/fat16.c ****         uint8_t checksum = buffer[0];
 1905              		.loc 1 1585 0
 1906 0ea8 0070DDE5 		ldrb	r7, [sp, #0]	@ zero_extendqisi2
 1907              	.LVL191:
 1908 0eac 0D10A0E1 		mov	r1, sp
 1909              	.L244:
1586:../lib/fat16.c ****         uint8_t i;
1587:../lib/fat16.c ****         for(i = 1; i < 11; ++i)
1588:../lib/fat16.c ****             checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
 1910              		.loc 1 1588 0
 1911 0eb0 8733A0E1 		mov	r3, r7, asl #7
 1912 0eb4 0120F1E5 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 1913 0eb8 A73083E1 		orr	r3, r3, r7, lsr #1
 1914 0ebc 032082E0 		add	r2, r2, r3
 1915              		.loc 1 1587 0
 1916 0ec0 0A308DE2 		add	r3, sp, #10
 1917 0ec4 030051E1 		cmp	r1, r3
 1918              		.loc 1 1588 0
 1919 0ec8 FF7002E2 		and	r7, r2, #255
 1920              		.loc 1 1587 0
 1921 0ecc AA03001A 		bne	.L244
 1922 0ed0 0A50A0E1 		mov	r5, sl
 1923              	.LVL192:
 1924 0ed4 EC0300EA 		b	.L246
 1925              	.L247:
 1926              	.LBB28:
1589:../lib/fat16.c ****     
1590:../lib/fat16.c ****         /* write lfn entries */
1591:../lib/fat16.c ****         uint8_t lfn_entry;
1592:../lib/fat16.c ****         for(lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
1593:../lib/fat16.c ****         {
1594:../lib/fat16.c ****             memset(buffer, 0, sizeof(buffer));
 1927              		.loc 1 1594 0
 1928 0ed8 0010A0E3 		mov	r1, #0
 1929 0edc 2020A0E3 		mov	r2, #32
 1930 0ee0 0D00A0E1 		mov	r0, sp
 1931 0ee4 FEFFFFEB 		bl	memset
1595:../lib/fat16.c ****             memset(&buffer[0x01], 0xff, 10);
 1932              		.loc 1 1595 0
 1933 0ee8 FF10A0E3 		mov	r1, #255
 1934 0eec 0A20A0E3 		mov	r2, #10
 1935 0ef0 01008DE2 		add	r0, sp, #1
 1936 0ef4 FEFFFFEB 		bl	memset
1596:../lib/fat16.c ****             memset(&buffer[0x0e], 0xff, 12);
 1937              		.loc 1 1596 0
 1938 0ef8 FF10A0E3 		mov	r1, #255
 1939 0efc 0C20A0E3 		mov	r2, #12
 1940 0f00 0E008DE2 		add	r0, sp, #14
 1941 0f04 FEFFFFEB 		bl	memset
1597:../lib/fat16.c ****             memset(&buffer[0x1c], 0xff, 4);
 1942              		.loc 1 1597 0
 1943 0f08 1C008DE2 		add	r0, sp, #28
 1944 0f0c FF10A0E3 		mov	r1, #255
 1945 0f10 0420A0E3 		mov	r2, #4
 1946 0f14 FEFFFFEB 		bl	memset
1598:../lib/fat16.c ****     
1599:../lib/fat16.c ****             buffer[0x00] = lfn_entry;
1600:../lib/fat16.c ****             if(lfn_entry == lfn_entry_count)
 1947              		.loc 1 1600 0
 1948 0f18 0A0055E1 		cmp	r5, sl
1601:../lib/fat16.c ****                 buffer[0x00] |= FAT16_DIRENTRY_LFNLAST;
 1949              		.loc 1 1601 0
 1950 0f1c 40308503 		orreq	r3, r5, #64
 1951              		.loc 1 1599 0
 1952 0f20 0050CDE5 		strb	r5, [sp, #0]
 1953              		.loc 1 1601 0
 1954 0f24 0030CD05 		streqb	r3, [sp, #0]
1602:../lib/fat16.c ****     
1603:../lib/fat16.c ****             /* set file name */
1604:../lib/fat16.c ****             const char* long_name_curr = dir_entry->long_name + (lfn_entry - 1) * 13;
 1955              		.loc 1 1604 0
 1956 0f28 0D30A0E3 		mov	r3, #13
 1957 0f2c 956323E0 		mla	r3, r5, r3, r6
 1958 0f30 01C0A0E3 		mov	ip, #1
 1959              	.LVL193:
 1960 0f34 0DE043E2 		sub	lr, r3, #13
 1961              	.LVL194:
 1962              	.L250:
1605:../lib/fat16.c ****             i = 1;
1606:../lib/fat16.c ****             while(i < 0x1f)
1607:../lib/fat16.c ****             {
1608:../lib/fat16.c ****                 buffer[i++] = *long_name_curr;
1609:../lib/fat16.c ****                 buffer[i++] = 0;
 1963              		.loc 1 1609 0
 1964 0f38 02208CE2 		add	r2, ip, #2
 1965 0f3c 01308CE2 		add	r3, ip, #1
 1966              		.loc 1 1608 0
 1967 0f40 20408DE2 		add	r4, sp, #32
 1968              		.loc 1 1609 0
 1969 0f44 FF3003E2 		and	r3, r3, #255
 1970              		.loc 1 1608 0
 1971 0f48 0000DEE5 		ldrb	r0, [lr, #0]	@ zero_extendqisi2
 1972 0f4c 0C1084E0 		add	r1, r4, ip
 1973              		.loc 1 1609 0
 1974 0f50 FFC002E2 		and	ip, r2, #255
1610:../lib/fat16.c ****     
1611:../lib/fat16.c ****                 switch(i)
 1975              		.loc 1 1611 0
 1976 0f54 0B005CE3 		cmp	ip, #11
 1977              		.loc 1 1609 0
 1978 0f58 032084E0 		add	r2, r4, r3
 1979 0f5c 0030A0E3 		mov	r3, #0
 1980              		.loc 1 1608 0
 1981 0f60 200041E5 		strb	r0, [r1, #-32]
 1982              		.loc 1 1611 0
 1983 0f64 0EC0A003 		moveq	ip, #14
 1984              		.loc 1 1609 0
 1985 0f68 203042E5 		strb	r3, [r2, #-32]
 1986              		.loc 1 1611 0
 1987 0f6c DC03000A 		beq	.L251
 1988 0f70 1A005CE3 		cmp	ip, #26
 1989 0f74 02C08C02 		addeq	ip, ip, #2
 1990              	.L251:
1612:../lib/fat16.c ****                 {
1613:../lib/fat16.c ****                     case 0x0b:
1614:../lib/fat16.c ****                         i = 0x0e;
1615:../lib/fat16.c ****                         break;
1616:../lib/fat16.c ****                     case 0x1a:
1617:../lib/fat16.c ****                         i = 0x1c;
1618:../lib/fat16.c ****                         break;
1619:../lib/fat16.c ****                 }
1620:../lib/fat16.c ****     
1621:../lib/fat16.c ****                 if(!*long_name_curr++)
 1991              		.loc 1 1621 0
 1992 0f78 0130DEE4 		ldrb	r3, [lr], #1	@ zero_extendqisi2
 1993 0f7c 000053E3 		cmp	r3, #0
 1994 0f80 E103000A 		beq	.L254
 1995              		.loc 1 1606 0
 1996 0f84 1E005CE3 		cmp	ip, #30
 1997 0f88 CC03009A 		bls	.L250
 1998              	.L254:
1622:../lib/fat16.c ****                     break;
1623:../lib/fat16.c ****             }
1624:../lib/fat16.c ****     
1625:../lib/fat16.c ****             /* mark as lfn entry */
1626:../lib/fat16.c ****             buffer[0x0b] = 0x0f;
 1999              		.loc 1 1626 0
 2000 0f8c 0F30A0E3 		mov	r3, #15
 2001 0f90 0B30CDE5 		strb	r3, [sp, #11]
1627:../lib/fat16.c ****     
1628:../lib/fat16.c ****             /* set checksum */
1629:../lib/fat16.c ****             buffer[0x0d] = checksum;
1630:../lib/fat16.c ****     
1631:../lib/fat16.c ****             /* write entry */
1632:../lib/fat16.c ****             device_write(offset, buffer, sizeof(buffer));
 2002              		.loc 1 1632 0
 2003 0f94 0800A0E1 		mov	r0, r8
 2004              		.loc 1 1629 0
 2005 0f98 0D70CDE5 		strb	r7, [sp, #13]
 2006              		.loc 1 1632 0
 2007 0f9c 0D10A0E1 		mov	r1, sp
 2008 0fa0 2020A0E3 		mov	r2, #32
 2009 0fa4 0FE0A0E1 		mov	lr, pc
 2010 0fa8 19FF2FE1 		bx	r9
 2011              	.LVL195:
 2012              	.LBE28:
 2013              		.loc 1 1592 0
 2014 0fac 013045E2 		sub	r3, r5, #1
 2015              	.LBB29:
1633:../lib/fat16.c ****     
1634:../lib/fat16.c ****             offset += sizeof(buffer);
 2016              		.loc 1 1634 0
 2017 0fb0 208088E2 		add	r8, r8, #32
 2018              	.LBE29:
 2019              		.loc 1 1592 0
 2020 0fb4 FF5003E2 		and	r5, r3, #255
 2021              	.L246:
 2022 0fb8 000055E3 		cmp	r5, #0
 2023 0fbc B403001A 		bne	.L247
 2024 0fc0 0100A0E3 		mov	r0, #1
 2025 0fc4 F10300EA 		b	.L257
 2026              	.LVL196:
 2027              	.L228:
 2028 0fc8 0000A0E3 		mov	r0, #0
 2029              	.LVL197:
 2030              	.L257:
1635:../lib/fat16.c ****         }
1636:../lib/fat16.c ****     
1637:../lib/fat16.c ****         return 1;
1638:../lib/fat16.c ****     
1639:../lib/fat16.c ****     #else
1640:../lib/fat16.c ****         return 0;
1641:../lib/fat16.c ****     #endif
1642:../lib/fat16.c **** }
 2031              		.loc 1 1642 0
 2032 0fcc 20D08DE2 		add	sp, sp, #32
 2033 0fd0 F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2034 0fd4 1EFF2FE1 		bx	lr
 2035              	.LFE25:
 2037              		.align	2
 2038              		.global	fat16_resize_file
 2040              	fat16_resize_file:
 2041              	.LFB20:
 2042              		.loc 1 1262 0
 2043              		@ Function supports interworking.
 2044              		@ args = 0, pretend = 0, frame = 4
 2045              		@ frame_needed = 0, uses_anonymous_args = 0
 2046              	.LVL198:
 2047 0fd8 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2048              	.LCFI20:
 2049              		.loc 1 1264 0
 2050 0fdc 006050E2 		subs	r6, r0, #0
 2051              		.loc 1 1262 0
 2052 0fe0 04D04DE2 		sub	sp, sp, #4
 2053              	.LCFI21:
 2054              	.LVL199:
 2055              		.loc 1 1262 0
 2056 0fe4 0180A0E1 		mov	r8, r1
 2057              		.loc 1 1264 0
 2058 0fe8 5804000A 		beq	.L263
 2059              	.LVL200:
 2060              		.loc 1 1267 0
 2061 0fec B642D6E1 		ldrh	r4, [r6, #38]
 2062              	.LVL201:
 2063              		.loc 1 1268 0
 2064 0ff0 003096E5 		ldr	r3, [r6, #0]
 2065              		.loc 1 1273 0
 2066 0ff4 019071E2 		rsbs	r9, r1, #1
 2067 0ff8 0090A033 		movcc	r9, #0
 2068 0ffc 000054E3 		cmp	r4, #0
 2069 1000 00005103 		cmpeq	r1, #0
 2070              		.loc 1 1268 0
 2071 1004 B271D3E1 		ldrh	r7, [r3, #18]
 2072              	.LVL202:
 2073              		.loc 1 1275 0
 2074 1008 0150A011 		movne	r5, r1
 2075              	.LVL203:
 2076              		.loc 1 1273 0
 2077 100c 0904001A 		bne	.L267
 2078              	.LVL204:
 2079 1010 500400EA 		b	.L265
 2080              	.LVL205:
 2081              	.L268:
 2082              	.LBB30:
 2083              		.loc 1 1281 0
 2084 1014 000096E5 		ldr	r0, [r6, #0]
 2085 1018 7E0000EB 		bl	fat16_get_next_cluster
 2086              	.LVL206:
 2087              		.loc 1 1282 0
 2088 101c 000050E3 		cmp	r0, #0
 2089 1020 0C04000A 		beq	.L269
 2090              		.loc 1 1285 0
 2091 1024 055067E0 		rsb	r5, r7, r5
 2092 1028 0040A0E1 		mov	r4, r0
 2093              	.LVL207:
 2094              	.L267:
 2095              	.LBE30:
 2096              		.loc 1 1278 0
 2097 102c 070055E1 		cmp	r5, r7
 2098              	.LBB31:
 2099              		.loc 1 1281 0
 2100 1030 0410A0E1 		mov	r1, r4
 2101              	.LBE31:
 2102              		.loc 1 1278 0
 2103 1034 0304008A 		bhi	.L268
 2104              	.L269:
 2105              		.loc 1 1293 0
 2106 1038 01A074E2 		rsbs	sl, r4, #1
 2107 103c 00A0A033 		movcc	sl, #0
 2108 1040 070055E1 		cmp	r5, r7
 2109 1044 0A30A091 		movls	r3, sl
 2110 1048 01308A83 		orrhi	r3, sl, #1
 2111 104c 000053E3 		cmp	r3, #0
 2112 1050 2504000A 		beq	.L271
 2113              	.LBB32:
 2114              		.loc 1 1298 0
 2115 1054 0710A0E1 		mov	r1, r7
 2116 1058 0500A0E1 		mov	r0, r5
 2117 105c FEFFFFEB 		bl	__udivsi3
 2118 1060 0008A0E1 		mov	r0, r0, asl #16
 2119 1064 2028A0E1 		mov	r2, r0, lsr #16
 2120              	.LVL208:
 2121              		.loc 1 1299 0
 2122 1068 970203E0 		mul	r3, r7, r2
 2123 106c 050053E1 		cmp	r3, r5
 2124              		.loc 1 1300 0
 2125 1070 01308232 		addcc	r3, r2, #1
 2126 1074 0338A031 		movcc	r3, r3, asl #16
 2127 1078 2328A031 		movcc	r2, r3, lsr #16
 2128              		.loc 1 1301 0
 2129 107c 000096E5 		ldr	r0, [r6, #0]
 2130 1080 0410A0E1 		mov	r1, r4
 2131 1084 FE0100EB 		bl	fat16_append_clusters
 2132              	.LVL209:
 2133              		.loc 1 1302 0
 2134 1088 000050E3 		cmp	r0, #0
 2135 108c 5804000A 		beq	.L263
 2136              		.loc 1 1305 0
 2137 1090 00005AE3 		cmp	sl, #0
 2138              		.loc 1 1308 0
 2139 1094 B602C611 		strneh	r0, [r6, #38]	@ movhi
 2140 1098 0040A011 		movne	r4, r0
 2141              	.LVL210:
 2142              	.L271:
 2143              	.LBE32:
 2144              		.loc 1 1314 0
 2145 109c 000059E3 		cmp	r9, #0
 2146              		.loc 1 1315 0
 2147 10a0 0030A013 		movne	r3, #0	@ movhi
 2148 10a4 B632C611 		strneh	r3, [r6, #38]	@ movhi
 2149              		.loc 1 1313 0
 2150 10a8 288086E5 		str	r8, [r6, #40]
 2151              		.loc 1 1316 0
 2152 10ac 000096E5 		ldr	r0, [r6, #0]
 2153 10b0 041086E2 		add	r1, r6, #4
 2154 10b4 510300EB 		bl	fat16_write_dir_entry
 2155 10b8 000050E3 		cmp	r0, #0
 2156 10bc 5804000A 		beq	.L263
 2157              		.loc 1 1319 0
 2158 10c0 000059E3 		cmp	r9, #0
 2159              		.loc 1 1322 0
 2160 10c4 0410A011 		movne	r1, r4
 2161 10c8 00009615 		ldrne	r0, [r6, #0]
 2162              		.loc 1 1319 0
 2163 10cc 4F04001A 		bne	.L290
 2164              	.LVL211:
 2165              		.loc 1 1324 0
 2166 10d0 070055E1 		cmp	r5, r7
 2167 10d4 5004008A 		bhi	.L265
 2168 10d8 0438A0E1 		mov	r3, r4, asl #16
 2169 10dc 005096E5 		ldr	r5, [r6, #0]
 2170              	.LVL212:
 2171 10e0 2348A0E1 		mov	r4, r3, lsr #16
 2172              	.LVL213:
 2173              	.LBB33:
 2174              	.LBB34:
 2175              		.loc 1 895 0
 2176 10e4 000055E3 		cmp	r5, #0
 2177 10e8 01005413 		cmpne	r4, #1
 2178 10ec 5004009A 		bls	.L265
 2179              		.loc 1 899 0
 2180 10f0 0410A0E1 		mov	r1, r4
 2181              	.LVL214:
 2182 10f4 0500A0E1 		mov	r0, r5
 2183 10f8 7E0000EB 		bl	fat16_get_next_cluster
 2184              		.loc 1 903 0
 2185 10fc 0030E0E3 		mvn	r3, #0
 2186              		.loc 1 904 0
 2187 1100 0330CDE5 		strb	r3, [sp, #3]
 2188              		.loc 1 903 0
 2189 1104 0230CDE5 		strb	r3, [sp, #2]
 2190              		.loc 1 899 0
 2191 1108 0070A0E1 		mov	r7, r0
 2192              	.LVL215:
 2193              		.loc 1 905 0
 2194 110c 080095E5 		ldr	r0, [r5, #8]
 2195 1110 003095E5 		ldr	r3, [r5, #0]
 2196 1114 840080E0 		add	r0, r0, r4, asl #1
 2197 1118 02108DE2 		add	r1, sp, #2
 2198 111c 0220A0E3 		mov	r2, #2
 2199 1120 08C093E5 		ldr	ip, [r3, #8]
 2200 1124 0FE0A0E1 		mov	lr, pc
 2201 1128 1CFF2FE1 		bx	ip
 2202 112c 000050E3 		cmp	r0, #0
 2203 1130 5004000A 		beq	.L265
 2204              		.loc 1 909 0
 2205 1134 000057E3 		cmp	r7, #0
 2206 1138 5004000A 		beq	.L265
 2207              		.loc 1 910 0
 2208 113c 0500A0E1 		mov	r0, r5
 2209 1140 0710A0E1 		mov	r1, r7
 2210              	.LVL216:
 2211              	.L290:
 2212 1144 C70100EB 		bl	fat16_free_clusters
 2213              	.LVL217:
 2214              	.L265:
 2215              	.LBE34:
 2216              	.LBE33:
 2217              		.loc 1 1334 0
 2218 1148 303096E5 		ldr	r3, [r6, #48]
 2219 114c 030058E1 		cmp	r8, r3
 2220              		.loc 1 1337 0
 2221 1150 0030A033 		movcc	r3, #0	@ movhi
 2222              		.loc 1 1334 0
 2223 1154 0100A023 		movcs	r0, #1
 2224              		.loc 1 1337 0
 2225 1158 0100A033 		movcc	r0, #1
 2226              		.loc 1 1336 0
 2227 115c 30808635 		strcc	r8, [r6, #48]
 2228              		.loc 1 1337 0
 2229 1160 B433C631 		strcch	r3, [r6, #52]	@ movhi
 2230 1164 590400EA 		b	.L288
 2231              	.LVL218:
 2232              	.L263:
 2233 1168 0000A0E3 		mov	r0, #0
 2234              	.LVL219:
 2235              	.L288:
 2236              		.loc 1 1344 0
 2237 116c 04D08DE2 		add	sp, sp, #4
 2238 1170 F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2239 1174 1EFF2FE1 		bx	lr
 2240              	.LFE20:
 2242              		.align	2
 2243              		.global	fat16_seek_file
 2245              	fat16_seek_file:
 2246              	.LFB19:
 2247              		.loc 1 1212 0
 2248              		@ Function supports interworking.
 2249              		@ args = 0, pretend = 0, frame = 0
 2250              		@ frame_needed = 0, uses_anonymous_args = 0
 2251              	.LVL220:
 2252              		.loc 1 1213 0
 2253 1178 000051E3 		cmp	r1, #0
 2254 117c 00005013 		cmpne	r0, #0
 2255              		.loc 1 1212 0
 2256 1180 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2257              	.LCFI22:
 2258              		.loc 1 1212 0
 2259 1184 FF2002E2 		and	r2, r2, #255
 2260              		.loc 1 1213 0
 2261 1188 0050A0E1 		mov	r5, r0
 2262 118c 0160A0E1 		mov	r6, r1
 2263 1190 7F04000A 		beq	.L292
 2264              	.LVL221:
 2265              		.loc 1 1217 0
 2266 1194 010052E3 		cmp	r2, #1
 2267              		.loc 1 1216 0
 2268 1198 301090E5 		ldr	r1, [r0, #48]
 2269              	.LVL222:
 2270              		.loc 1 1217 0
 2271 119c 6B04000A 		beq	.L295
 2272              	.LVL223:
 2273              		.loc 1 1220 0
 2274 11a0 00409635 		ldrcc	r4, [r6, #0]
 2275              	.LVL224:
 2276              		.loc 1 1217 0
 2277 11a4 7104003A 		bcc	.L297
 2278 11a8 020052E3 		cmp	r2, #2
 2279 11ac 7F04001A 		bne	.L292
 2280 11b0 6E0400EA 		b	.L296
 2281              	.LVL225:
 2282              	.L295:
 2283              		.loc 1 1223 0
 2284 11b4 003096E5 		ldr	r3, [r6, #0]
 2285 11b8 034081E0 		add	r4, r1, r3
 2286              	.LVL226:
 2287 11bc 710400EA 		b	.L297
 2288              	.L296:
 2289              		.loc 1 1226 0
 2290 11c0 282090E5 		ldr	r2, [r0, #40]
 2291              	.LVL227:
 2292 11c4 003096E5 		ldr	r3, [r6, #0]
 2293 11c8 034082E0 		add	r4, r2, r3
 2294              	.LVL228:
 2295              	.L297:
 2296              		.loc 1 1232 0
 2297 11cc 283095E5 		ldr	r3, [r5, #40]
 2298 11d0 030054E1 		cmp	r4, r3
 2299 11d4 7904009A 		bls	.L298
 2300              	.LVL229:
 2301 11d8 0500A0E1 		mov	r0, r5
 2302 11dc 0410A0E1 		mov	r1, r4
 2303              	.LVL230:
 2304 11e0 FEFFFFEB 		bl	fat16_resize_file
 2305              	.LVL231:
 2306 11e4 000050E3 		cmp	r0, #0
 2307 11e8 7F04000A 		beq	.L292
 2308              	.LVL232:
 2309              	.L298:
 2310              		.loc 1 1236 0
 2311 11ec 0030A0E3 		mov	r3, #0	@ movhi
 2312              		.loc 1 1238 0
 2313 11f0 0100A0E3 		mov	r0, #1
 2314              		.loc 1 1235 0
 2315 11f4 304085E5 		str	r4, [r5, #48]
 2316              		.loc 1 1236 0
 2317 11f8 B433C5E1 		strh	r3, [r5, #52]	@ movhi
 2318              		.loc 1 1238 0
 2319 11fc 004086E5 		str	r4, [r6, #0]
 2320 1200 800400EA 		b	.L300
 2321              	.LVL233:
 2322              	.L292:
 2323              		.loc 1 1239 0
 2324 1204 0000A0E3 		mov	r0, #0
 2325              	.L300:
 2326              		.loc 1 1240 0
 2327 1208 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2328 120c 1EFF2FE1 		bx	lr
 2329              	.LFE19:
 2331              		.align	2
 2332              		.global	fat16_write_file
 2334              	fat16_write_file:
 2335              	.LFB18:
 2336              		.loc 1 1066 0
 2337              		@ Function supports interworking.
 2338              		@ args = 0, pretend = 0, frame = 0
 2339              		@ frame_needed = 0, uses_anonymous_args = 0
 2340              	.LVL234:
 2341 1210 0228A0E1 		mov	r2, r2, asl #16
 2342              	.LVL235:
 2343              		.loc 1 1069 0
 2344 1214 000051E3 		cmp	r1, #0
 2345 1218 00005013 		cmpne	r0, #0
 2346              		.loc 1 1066 0
 2347 121c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2348              	.LCFI23:
 2349              		.loc 1 1069 0
 2350 1220 0060A0E1 		mov	r6, r0
 2351 1224 0190A0E1 		mov	r9, r1
 2352              		.loc 1 1066 0
 2353 1228 22B8A0E1 		mov	fp, r2, lsr #16
 2354              	.LVL236:
 2355              		.loc 1 1069 0
 2356 122c FE04000A 		beq	.L303
 2357              	.LVL237:
 2358 1230 00005BE3 		cmp	fp, #0
 2359 1234 FE04000A 		beq	.L303
 2360              		.loc 1 1071 0
 2361 1238 304090E5 		ldr	r4, [r0, #48]
 2362 123c 283090E5 		ldr	r3, [r0, #40]
 2363 1240 030054E1 		cmp	r4, r3
 2364 1244 FE04008A 		bhi	.L303
 2365              	.LVL238:
 2366              		.loc 1 1074 0
 2367 1248 007090E5 		ldr	r7, [r0, #0]
 2368 124c B281D7E1 		ldrh	r8, [r7, #18]
 2369              	.LVL239:
 2370              		.loc 1 1077 0
 2371 1250 0400A0E1 		mov	r0, r4
 2372              	.LVL240:
 2373 1254 0810A0E1 		mov	r1, r8
 2374 1258 FEFFFFEB 		bl	__umodsi3
 2375              		.loc 1 1075 0
 2376 125c B453D6E1 		ldrh	r5, [r6, #52]
 2377              	.LVL241:
 2378              		.loc 1 1077 0
 2379 1260 0008A0E1 		mov	r0, r0, asl #16
 2380              		.loc 1 1080 0
 2381 1264 000055E3 		cmp	r5, #0
 2382              		.loc 1 1077 0
 2383 1268 20A8A0E1 		mov	sl, r0, lsr #16
 2384              	.LVL242:
 2385              		.loc 1 1080 0
 2386 126c BB04001A 		bne	.L307
 2387              		.loc 1 1082 0
 2388 1270 B652D6E1 		ldrh	r5, [r6, #38]
 2389              		.loc 1 1084 0
 2390 1274 000055E3 		cmp	r5, #0
 2391 1278 A704001A 		bne	.L309
 2392              		.loc 1 1086 0
 2393 127c 000054E3 		cmp	r4, #0
 2394 1280 FE04001A 		bne	.L303
 2395              		.loc 1 1089 0
 2396 1284 0510A0E1 		mov	r1, r5
 2397 1288 0700A0E1 		mov	r0, r7
 2398 128c 0120A0E3 		mov	r2, #1
 2399 1290 FE0100EB 		bl	fat16_append_clusters
 2400              		.loc 1 1090 0
 2401 1294 000050E3 		cmp	r0, #0
 2402              		.loc 1 1089 0
 2403 1298 0050A0E1 		mov	r5, r0
 2404 129c B602C6E1 		strh	r0, [r6, #38]	@ movhi
 2405              		.loc 1 1090 0
 2406 12a0 FE04000A 		beq	.L303
 2407              	.L309:
 2408              		.loc 1 1099 0
 2409 12a4 304096E5 		ldr	r4, [r6, #48]
 2410              	.LVL243:
 2411 12a8 000054E3 		cmp	r4, #0
 2412 12ac B704001A 		bne	.L334
 2413 12b0 BB0400EA 		b	.L307
 2414              	.LVL244:
 2415              	.L332:
 2416              	.LBB35:
 2417              	.LBB36:
 2418              		.loc 1 1146 0
 2419 12b4 B403C6E1 		strh	r0, [r6, #52]	@ movhi
 2420 12b8 EC0400EA 		b	.L319
 2421              	.LVL245:
 2422              	.L313:
 2423              	.LBE36:
 2424              	.LBE35:
 2425              	.LBB37:
 2426              		.loc 1 1106 0
 2427 12bc 000096E5 		ldr	r0, [r6, #0]
 2428              	.LVL246:
 2429 12c0 7E0000EB 		bl	fat16_get_next_cluster
 2430              	.LVL247:
 2431              		.loc 1 1107 0
 2432 12c4 000050E3 		cmp	r0, #0
 2433 12c8 00005403 		cmpeq	r4, #0
 2434              		.loc 1 1109 0
 2435 12cc 0510A0E1 		mov	r1, r5
 2436 12d0 0120A0E3 		mov	r2, #1
 2437              		.loc 1 1107 0
 2438              		.loc 1 1109 0
 2439 12d4 00009605 		ldreq	r0, [r6, #0]
 2440              	.LVL248:
 2441 12d8 FE01000B 		bleq	fat16_append_clusters
 2442              	.LVL249:
 2443              	.L314:
 2444              		.loc 1 1110 0
 2445 12dc 005050E2 		subs	r5, r0, #0
 2446 12e0 FE04000A 		beq	.L303
 2447              	.LVL250:
 2448              	.L334:
 2449              		.loc 1 1103 0
 2450 12e4 080054E1 		cmp	r4, r8
 2451              		.loc 1 1106 0
 2452 12e8 0510A0E1 		mov	r1, r5
 2453              		.loc 1 1105 0
 2454 12ec 044068E0 		rsb	r4, r8, r4
 2455              		.loc 1 1103 0
 2456 12f0 AD04002A 		bcs	.L313
 2457              	.L307:
 2458 12f4 0B70A0E1 		mov	r7, fp
 2459              	.LVL251:
 2460              	.LVL252:
 2461              	.L316:
 2462              	.LBE37:
 2463              	.LBB38:
 2464              		.loc 1 1123 0
 2465 12f8 001096E5 		ldr	r1, [r6, #0]
 2466 12fc 182091E5 		ldr	r2, [r1, #24]
 2467 1300 023045E2 		sub	r3, r5, #2
 2468 1304 982320E0 		mla	r0, r8, r3, r2
 2469              	.LVL253:
 2470              		.loc 1 1124 0
 2471 1308 08306AE0 		rsb	r3, sl, r8
 2472 130c 0338A0E1 		mov	r3, r3, asl #16
 2473 1310 2348A0E1 		mov	r4, r3, lsr #16
 2474              	.LVL254:
 2475              		.loc 1 1125 0
 2476 1314 070054E1 		cmp	r4, r7
 2477 1318 0740A021 		movcs	r4, r7
 2478              		.loc 1 1129 0
 2479 131c 003091E5 		ldr	r3, [r1, #0]
 2480 1320 0420A0E1 		mov	r2, r4
 2481 1324 0910A0E1 		mov	r1, r9
 2482 1328 0A0080E0 		add	r0, r0, sl
 2483              	.LVL255:
 2484 132c 08C093E5 		ldr	ip, [r3, #8]
 2485 1330 0FE0A0E1 		mov	lr, pc
 2486 1334 1CFF2FE1 		bx	ip
 2487              	.LVL256:
 2488              		.loc 1 1134 0
 2489 1338 073064E0 		rsb	r3, r4, r7
 2490              		.loc 1 1129 0
 2491 133c 000050E3 		cmp	r0, #0
 2492              	.LBB39:
 2493              		.loc 1 1140 0
 2494 1340 0510A0E1 		mov	r1, r5
 2495              	.LBE39:
 2496              		.loc 1 1137 0
 2497 1344 04208AE0 		add	r2, sl, r4
 2498              		.loc 1 1134 0
 2499 1348 0308A0E1 		mov	r0, r3, asl #16
 2500              		.loc 1 1129 0
 2501 134c EC04000A 		beq	.L319
 2502              		.loc 1 1135 0
 2503 1350 303096E5 		ldr	r3, [r6, #48]
 2504              		.loc 1 1137 0
 2505 1354 080052E1 		cmp	r2, r8
 2506              		.loc 1 1135 0
 2507 1358 043083E0 		add	r3, r3, r4
 2508 135c 303086E5 		str	r3, [r6, #48]
 2509              		.loc 1 1134 0
 2510 1360 2078A0E1 		mov	r7, r0, lsr #16
 2511              		.loc 1 1133 0
 2512 1364 049089E0 		add	r9, r9, r4
 2513              		.loc 1 1137 0
 2514 1368 E90400BA 		blt	.L321
 2515              	.LBB40:
 2516              		.loc 1 1140 0
 2517 136c 000096E5 		ldr	r0, [r6, #0]
 2518 1370 7E0000EB 		bl	fat16_get_next_cluster
 2519              		.loc 1 1147 0
 2520 1374 00A0A0E3 		mov	sl, #0
 2521              	.LVL257:
 2522              		.loc 1 1141 0
 2523 1378 0A0050E1 		cmp	r0, sl
 2524 137c 0030A013 		movne	r3, #0
 2525 1380 0130A003 		moveq	r3, #1
 2526 1384 0A0057E1 		cmp	r7, sl
 2527 1388 0030A003 		moveq	r3, #0
 2528 138c 0A0053E1 		cmp	r3, sl
 2529              		.loc 1 1143 0
 2530 1390 0510A0E1 		mov	r1, r5
 2531 1394 0120A0E3 		mov	r2, #1
 2532              		.loc 1 1141 0
 2533              		.loc 1 1143 0
 2534 1398 00009615 		ldrne	r0, [r6, #0]
 2535              	.LVL258:
 2536 139c FE01001B 		blne	fat16_append_clusters
 2537              	.LVL259:
 2538              	.L323:
 2539              		.loc 1 1144 0
 2540 13a0 000050E3 		cmp	r0, #0
 2541              		.loc 1 1147 0
 2542 13a4 0050A0E1 		mov	r5, r0
 2543              		.loc 1 1144 0
 2544 13a8 AB04000A 		beq	.L332
 2545              	.LVL260:
 2546              	.L321:
 2547              	.LBE40:
 2548              	.LBE38:
 2549              		.loc 1 1157 0
 2550 13ac 000057E3 		cmp	r7, #0
 2551              	.LBB41:
 2552              		.loc 1 1154 0
 2553 13b0 B453C6E1 		strh	r5, [r6, #52]	@ movhi
 2554              	.LBE41:
 2555              		.loc 1 1157 0
 2556 13b4 BC04001A 		bne	.L316
 2557              	.L319:
 2558              		.loc 1 1160 0
 2559 13b8 303096E5 		ldr	r3, [r6, #48]
 2560 13bc 284096E5 		ldr	r4, [r6, #40]
 2561              	.LVL261:
 2562 13c0 040053E1 		cmp	r3, r4
 2563 13c4 FA04009A 		bls	.L327
 2564              	.LBB42:
 2565              		.loc 1 1165 0
 2566 13c8 283086E5 		str	r3, [r6, #40]
 2567              		.loc 1 1167 0
 2568 13cc 000096E5 		ldr	r0, [r6, #0]
 2569              	.LVL262:
 2570 13d0 041086E2 		add	r1, r6, #4
 2571 13d4 510300EB 		bl	fat16_write_dir_entry
 2572 13d8 000050E3 		cmp	r0, #0
 2573              		.loc 1 1173 0
 2574 13dc 30309605 		ldreq	r3, [r6, #48]
 2575 13e0 03306400 		rsbeq	r3, r4, r3
 2576 13e4 0338A001 		moveq	r3, r3, asl #16
 2577              		.loc 1 1174 0
 2578 13e8 30408605 		streq	r4, [r6, #48]
 2579              		.loc 1 1173 0
 2580 13ec 2378A001 		moveq	r7, r3, lsr #16
 2581              	.LVL263:
 2582              	.L327:
 2583              	.LBE42:
 2584              		.loc 1 1178 0
 2585 13f0 0B3067E0 		rsb	r3, r7, fp
 2586 13f4 0338A0E1 		mov	r3, r3, asl #16
 2587 13f8 4308A0E1 		mov	r0, r3, asr #16
 2588              	.LVL264:
 2589 13fc FF0400EA 		b	.L330
 2590              	.LVL265:
 2591              	.L303:
 2592 1400 0000E0E3 		mvn	r0, #0
 2593              	.LVL266:
 2594              	.L330:
 2595              		.loc 1 1183 0
 2596 1404 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2597 1408 1EFF2FE1 		bx	lr
 2598              	.LFE18:
 2600              		.align	2
 2601              		.global	fat16_delete_file
 2603              	fat16_delete_file:
 2604              	.LFB27:
1643:../lib/fat16.c **** 
1644:../lib/fat16.c **** /**
1645:../lib/fat16.c ****  * \ingroup fat16_file
1646:../lib/fat16.c ****  * Creates a file.
1647:../lib/fat16.c ****  *
1648:../lib/fat16.c ****  * Creates a file and obtains the directory entry of the
1649:../lib/fat16.c ****  * new file. If the file to create already exists, the
1650:../lib/fat16.c ****  * directory entry of the existing file will be returned
1651:../lib/fat16.c ****  * within the dir_entry parameter.
1652:../lib/fat16.c ****  *
1653:../lib/fat16.c ****  * \note The file name is not checked for invalid characters.
1654:../lib/fat16.c ****  *
1655:../lib/fat16.c ****  * \note The generation of the short 8.3 file name is quite
1656:../lib/fat16.c ****  * simple. The first eight characters are used for the filename.
1657:../lib/fat16.c ****  * The extension, if any, is made up of the first three characters
1658:../lib/fat16.c ****  * following the last dot within the long filename. If the
1659:../lib/fat16.c ****  * filename (without the extension) is longer than eight characters,
1660:../lib/fat16.c ****  * the lower byte of the cluster number replaces the last two
1661:../lib/fat16.c ****  * characters to avoid name clashes. In any other case, it is your
1662:../lib/fat16.c ****  * responsibility to avoid name clashes.
1663:../lib/fat16.c ****  *
1664:../lib/fat16.c ****  * \param[in] parent The handle of the directory in which to create the file.
1665:../lib/fat16.c ****  * \param[in] file The name of the file to create.
1666:../lib/fat16.c ****  * \param[out] dir_entry The directory entry to fill for the new file.
1667:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1668:../lib/fat16.c ****  * \see fat16_delete_file
1669:../lib/fat16.c ****  */
1670:../lib/fat16.c **** uint8_t fat16_create_file(struct fat16_dir_struct* parent, const char* file, struct fat16_dir_entry
1671:../lib/fat16.c **** {
1672:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
1673:../lib/fat16.c ****         if(!parent || !file || !file[0])
1674:../lib/fat16.c ****             return 0;
1675:../lib/fat16.c ****     
1676:../lib/fat16.c ****         /* check if the file already exists */
1677:../lib/fat16.c ****         while(1)
1678:../lib/fat16.c ****         {
1679:../lib/fat16.c ****             if(!fat16_read_dir(parent, dir_entry))
1680:../lib/fat16.c ****                 break;
1681:../lib/fat16.c ****     
1682:../lib/fat16.c ****             if(strcmp(file, dir_entry->long_name) == 0)
1683:../lib/fat16.c ****             {
1684:../lib/fat16.c ****                 fat16_reset_dir(parent);
1685:../lib/fat16.c ****                 return 1;
1686:../lib/fat16.c ****             }
1687:../lib/fat16.c ****         }
1688:../lib/fat16.c ****     
1689:../lib/fat16.c ****         memset(dir_entry, 0, sizeof(*dir_entry));
1690:../lib/fat16.c ****         strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
1691:../lib/fat16.c ****     
1692:../lib/fat16.c ****         /* search for a place where to write the directory entry to disk */
1693:../lib/fat16.c ****         uint8_t free_dir_entries_needed = strlen(file) / 13 + 1 + 1;
1694:../lib/fat16.c ****         uint8_t free_dir_entries_found = 0;
1695:../lib/fat16.c ****         struct fat16_fs_struct* fs = parent->fs;
1696:../lib/fat16.c ****         uint16_t cluster_num = parent->dir_entry.cluster;
1697:../lib/fat16.c ****         uint32_t dir_entry_offset = 0;
1698:../lib/fat16.c ****         uint32_t offset = 0;
1699:../lib/fat16.c ****         uint32_t offset_to = 0;
1700:../lib/fat16.c ****     
1701:../lib/fat16.c ****         if(cluster_num == 0)
1702:../lib/fat16.c ****         {
1703:../lib/fat16.c ****             /* we read/write from the root directory entry */
1704:../lib/fat16.c ****             offset = fs->header.root_dir_offset;
1705:../lib/fat16.c ****             offset_to = fs->header.cluster_zero_offset;
1706:../lib/fat16.c ****             dir_entry_offset = offset;
1707:../lib/fat16.c ****         }
1708:../lib/fat16.c ****     
1709:../lib/fat16.c ****         while(1)
1710:../lib/fat16.c ****         {
1711:../lib/fat16.c ****             if(offset == offset_to)
1712:../lib/fat16.c ****             {
1713:../lib/fat16.c ****                 if(cluster_num == 0)
1714:../lib/fat16.c **** 				/* We iterated through the whole root directory entry
1715:../lib/fat16.c ****                 * and could not find enough space for the directory entry.
1716:../lib/fat16.c ****                 */
1717:../lib/fat16.c ****                 return 0;
1718:../lib/fat16.c ****     
1719:../lib/fat16.c ****                 if(offset)
1720:../lib/fat16.c ****                 {
1721:../lib/fat16.c ****                     /* We reached a cluster boundary and have to
1722:../lib/fat16.c ****                     * switch to the next cluster.
1723:../lib/fat16.c ****                     */
1724:../lib/fat16.c ****     
1725:../lib/fat16.c ****                     uint16_t cluster_next = fat16_get_next_cluster(fs, cluster_num);
1726:../lib/fat16.c ****                     if(!cluster_next)
1727:../lib/fat16.c ****                     {
1728:../lib/fat16.c ****                         cluster_next = fat16_append_clusters(fs, cluster_num, 1);
1729:../lib/fat16.c ****                         if(!cluster_next)
1730:../lib/fat16.c ****                             return 0;
1731:../lib/fat16.c ****     
1732:../lib/fat16.c ****                         /* we appended a new cluster and know it is free */
1733:../lib/fat16.c ****                         dir_entry_offset = fs->header.cluster_zero_offset +
1734:../lib/fat16.c ****                         (uint32_t) (cluster_next - 2) * fs->header.cluster_size;
1735:../lib/fat16.c ****     
1736:../lib/fat16.c ****                         /* TODO: This cluster has to be zeroed in an efficient way, or at least
1737:../lib/fat16.c ****                         *       every 32th byte should be set to FAT16_DIRENTRY_DELETED.
1738:../lib/fat16.c ****                         */
1739:../lib/fat16.c ****                         break;
1740:../lib/fat16.c ****                     }
1741:../lib/fat16.c ****                     cluster_num = cluster_next;
1742:../lib/fat16.c ****                 }
1743:../lib/fat16.c ****     
1744:../lib/fat16.c ****                 offset = fs->header.cluster_zero_offset +
1745:../lib/fat16.c ****                 (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
1746:../lib/fat16.c ****                 offset_to = offset + fs->header.cluster_size;
1747:../lib/fat16.c ****                 dir_entry_offset = offset;
1748:../lib/fat16.c ****                 free_dir_entries_found = 0;
1749:../lib/fat16.c ****             }
1750:../lib/fat16.c ****     
1751:../lib/fat16.c ****             /* read next lfn or 8.3 entry */
1752:../lib/fat16.c ****             uint8_t first_char;
1753:../lib/fat16.c ****             if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
1754:../lib/fat16.c ****                 return 0;
1755:../lib/fat16.c ****     
1756:../lib/fat16.c ****             /* check if we found a free directory entry */
1757:../lib/fat16.c ****             if(first_char == FAT16_DIRENTRY_DELETED || !first_char)
1758:../lib/fat16.c ****             {
1759:../lib/fat16.c ****                 /* check if we have the needed number of available entries */
1760:../lib/fat16.c ****                 ++free_dir_entries_found;
1761:../lib/fat16.c ****                 if(free_dir_entries_found >= free_dir_entries_needed)
1762:../lib/fat16.c ****                     break;
1763:../lib/fat16.c ****     
1764:../lib/fat16.c ****                 offset += 32;
1765:../lib/fat16.c ****             }
1766:../lib/fat16.c ****             else
1767:../lib/fat16.c ****             {
1768:../lib/fat16.c ****                 offset += 32;
1769:../lib/fat16.c ****                 dir_entry_offset = offset;
1770:../lib/fat16.c ****                 free_dir_entries_found = 0;
1771:../lib/fat16.c ****             }
1772:../lib/fat16.c ****         }
1773:../lib/fat16.c **** 
1774:../lib/fat16.c ****         /* write directory entry to disk */
1775:../lib/fat16.c ****         dir_entry->entry_offset = dir_entry_offset;
1776:../lib/fat16.c ****         if(!fat16_write_dir_entry(fs, dir_entry))
1777:../lib/fat16.c ****             return 0;
1778:../lib/fat16.c ****     
1779:../lib/fat16.c ****         return 1;
1780:../lib/fat16.c ****     
1781:../lib/fat16.c ****     #else
1782:../lib/fat16.c ****         return 0;
1783:../lib/fat16.c ****     #endif
1784:../lib/fat16.c **** }
1785:../lib/fat16.c **** 
1786:../lib/fat16.c **** /**
1787:../lib/fat16.c ****  * \ingroup fat16_file
1788:../lib/fat16.c ****  * Deletes a file or directory.
1789:../lib/fat16.c ****  *
1790:../lib/fat16.c ****  * It is not checked if the file to delete is a directory.
1791:../lib/fat16.c ****  * If a directory is deleted without first deleting its
1792:../lib/fat16.c ****  * subdirectories and files, disk space occupied by these
1793:../lib/fat16.c ****  * files will get wasted as there is no chance to release
1794:../lib/fat16.c ****  * it and mark it as free.
1795:../lib/fat16.c ****  *
1796:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1797:../lib/fat16.c ****  * \param[in] dir_entry The directory entry of the file to delete.
1798:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1799:../lib/fat16.c ****  * \see fat16_create_file
1800:../lib/fat16.c ****  */
1801:../lib/fat16.c **** uint8_t fat16_delete_file(struct fat16_fs_struct* fs, struct fat16_dir_entry_struct* dir_entry)
1802:../lib/fat16.c **** {
 2605              		.loc 1 1802 0
 2606              		@ Function supports interworking.
 2607              		@ args = 0, pretend = 0, frame = 12
 2608              		@ frame_needed = 0, uses_anonymous_args = 0
 2609              	.LVL267:
 2610 140c F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 2611              	.LCFI24:
1803:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
1804:../lib/fat16.c ****         if(!fs || !dir_entry)
 2612              		.loc 1 1804 0
 2613 1410 000051E3 		cmp	r1, #0
 2614 1414 00005013 		cmpne	r0, #0
 2615              		.loc 1 1802 0
 2616 1418 0CD04DE2 		sub	sp, sp, #12
 2617              	.LCFI25:
 2618              	.LVL268:
 2619              		.loc 1 1804 0
 2620 141c 0060A0E1 		mov	r6, r0
 2621 1420 0170A0E1 		mov	r7, r1
 2622 1424 2805000A 		beq	.L336
 2623              	.LVL269:
1805:../lib/fat16.c ****             return 0;
1806:../lib/fat16.c ****     
1807:../lib/fat16.c ****         /* get offset of the file's directory entry */
1808:../lib/fat16.c ****         uint32_t dir_entry_offset = dir_entry->entry_offset;
 2624              		.loc 1 1808 0
 2625 1428 285091E5 		ldr	r5, [r1, #40]
 2626              	.LVL270:
1809:../lib/fat16.c ****         if(!dir_entry_offset)
 2627              		.loc 1 1809 0
 2628 142c 000055E3 		cmp	r5, #0
 2629 1430 2805000A 		beq	.L336
 2630              	.L345:
1810:../lib/fat16.c ****             return 0;
1811:../lib/fat16.c ****     
1812:../lib/fat16.c ****         uint8_t buffer[12];
1813:../lib/fat16.c ****         while(1)
1814:../lib/fat16.c ****         {
1815:../lib/fat16.c ****             /* read directory entry */
1816:../lib/fat16.c ****             if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
 2631              		.loc 1 1816 0
 2632 1434 0D10A0E1 		mov	r1, sp
 2633 1438 0500A0E1 		mov	r0, r5
 2634 143c 0C20A0E3 		mov	r2, #12
 2635 1440 003096E5 		ldr	r3, [r6, #0]
 2636 1444 00C093E5 		ldr	ip, [r3, #0]
 2637 1448 0FE0A0E1 		mov	lr, pc
 2638 144c 1CFF2FE1 		bx	ip
 2639 1450 000050E3 		cmp	r0, #0
 2640 1454 0D40A0E1 		mov	r4, sp
1817:../lib/fat16.c ****                 return 0;
1818:../lib/fat16.c ****     
1819:../lib/fat16.c ****             /* mark the directory entry as deleted */
1820:../lib/fat16.c ****             buffer[0] = FAT16_DIRENTRY_DELETED;
1821:../lib/fat16.c ****     
1822:../lib/fat16.c ****             /* write back entry */
1823:../lib/fat16.c ****             if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
 2641              		.loc 1 1823 0
 2642 1458 0500A0E1 		mov	r0, r5
 2643 145c 0D10A0E1 		mov	r1, sp
 2644 1460 0C20A0E3 		mov	r2, #12
1824:../lib/fat16.c ****                 return 0;
1825:../lib/fat16.c ****     
1826:../lib/fat16.c ****             /* check if we deleted the whole entry */
1827:../lib/fat16.c ****             if(buffer[11] != 0x0f)
1828:../lib/fat16.c ****                 break;
1829:../lib/fat16.c ****     
1830:../lib/fat16.c ****             dir_entry_offset += 32;
 2645              		.loc 1 1830 0
 2646 1464 205085E2 		add	r5, r5, #32
 2647              		.loc 1 1816 0
 2648 1468 2805000A 		beq	.L336
 2649              		.loc 1 1820 0
 2650 146c 1A30E0E3 		mvn	r3, #26
 2651 1470 0030CDE5 		strb	r3, [sp, #0]
 2652              		.loc 1 1823 0
 2653 1474 003096E5 		ldr	r3, [r6, #0]
 2654 1478 08C093E5 		ldr	ip, [r3, #8]
 2655 147c 0FE0A0E1 		mov	lr, pc
 2656 1480 1CFF2FE1 		bx	ip
 2657 1484 000050E3 		cmp	r0, #0
 2658 1488 2805000A 		beq	.L336
 2659              		.loc 1 1827 0
 2660 148c 0B30DDE5 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 2661 1490 0F0053E3 		cmp	r3, #15
 2662 1494 0B05000A 		beq	.L345
1831:../lib/fat16.c ****         }
1832:../lib/fat16.c ****     
1833:../lib/fat16.c ****         /* We deleted the directory entry. The next thing to do is
1834:../lib/fat16.c ****                              * marking all occupied clusters as free.
1835:../lib/fat16.c ****                              */
1836:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 2663              		.loc 1 1836 0
 2664 1498 0600A0E1 		mov	r0, r6
 2665 149c B212D7E1 		ldrh	r1, [r7, #34]
 2666 14a0 C70100EB 		bl	fat16_free_clusters
 2667 14a4 290500EA 		b	.L343
 2668              	.LVL271:
 2669              	.L336:
 2670 14a8 0000A0E3 		mov	r0, #0
 2671              	.L343:
1837:../lib/fat16.c ****     #else
1838:../lib/fat16.c ****         return 0;
1839:../lib/fat16.c ****     #endif
1840:../lib/fat16.c **** }
 2672              		.loc 1 1840 0
 2673 14ac 0CD08DE2 		add	sp, sp, #12
 2674 14b0 F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 2675 14b4 1EFF2FE1 		bx	lr
 2676              	.LFE27:
 2678              		.align	2
 2679              		.global	fat16_get_fs_size
 2681              	fat16_get_fs_size:
 2682              	.LFB28:
1841:../lib/fat16.c **** 
1842:../lib/fat16.c **** /**
1843:../lib/fat16.c ****  * \ingroup fat16_fs
1844:../lib/fat16.c ****  * Returns the amount of total storage capacity of the filesystem in bytes.
1845:../lib/fat16.c ****  *
1846:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1847:../lib/fat16.c ****  * \returns 0 on failure, the filesystem size in bytes otherwise.
1848:../lib/fat16.c ****  */
1849:../lib/fat16.c **** uint32_t fat16_get_fs_size(const struct fat16_fs_struct* fs)
1850:../lib/fat16.c **** {
 2683              		.loc 1 1850 0
 2684              		@ Function supports interworking.
 2685              		@ args = 0, pretend = 0, frame = 0
 2686              		@ frame_needed = 0, uses_anonymous_args = 0
 2687              		@ link register save eliminated.
 2688              	.LVL272:
1851:../lib/fat16.c ****     if(!fs)
 2689              		.loc 1 1851 0
 2690 14b8 000050E3 		cmp	r0, #0
1852:../lib/fat16.c ****         return 0;
1853:../lib/fat16.c **** 
1854:../lib/fat16.c ****     return (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
 2691              		.loc 1 1854 0
 2692 14bc 0C309015 		ldrne	r3, [r0, #12]
 2693              		.loc 1 1851 0
 2694 14c0 0020A0E1 		mov	r2, r0
 2695              		.loc 1 1854 0
 2696 14c4 A330A011 		movne	r3, r3, lsr #1
 2697 14c8 B221D011 		ldrneh	r2, [r0, #18]
 2698 14cc 02304312 		subne	r3, r3, #2
 2699 14d0 93020210 		mulne	r2, r3, r2
1855:../lib/fat16.c **** }
 2700              		.loc 1 1855 0
 2701 14d4 0200A0E1 		mov	r0, r2
 2702              	.LVL273:
 2703              		.loc 1 1850 0
 2704              		@ lr needed for prologue
 2705              		.loc 1 1855 0
 2706 14d8 1EFF2FE1 		bx	lr
 2707              	.LFE28:
 2709              		.align	2
 2710              		.global	fat16_get_fs_free
 2712              	fat16_get_fs_free:
 2713              	.LFB29:
1856:../lib/fat16.c **** 
1857:../lib/fat16.c **** /**
1858:../lib/fat16.c ****  * \ingroup fat16_fs
1859:../lib/fat16.c ****  * Returns the amount of free storage capacity on the filesystem in bytes.
1860:../lib/fat16.c ****  *
1861:../lib/fat16.c ****  * \note As the FAT16 filesystem is cluster based, this function does not
1862:../lib/fat16.c ****  *       return continuous values but multiples of the cluster size.
1863:../lib/fat16.c ****  *
1864:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1865:../lib/fat16.c ****  * \returns 0 on failure, the free filesystem space in bytes otherwise.
1866:../lib/fat16.c ****  */
1867:../lib/fat16.c **** uint32_t fat16_get_fs_free(const struct fat16_fs_struct* fs)
1868:../lib/fat16.c **** {
 2714              		.loc 1 1868 0
 2715              		@ Function supports interworking.
 2716              		@ args = 0, pretend = 0, frame = 36
 2717              		@ frame_needed = 0, uses_anonymous_args = 0
 2718              	.LVL274:
 2719 14dc F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 2720              	.LCFI26:
1869:../lib/fat16.c ****     if(!fs)
 2721              		.loc 1 1869 0
 2722 14e0 006050E2 		subs	r6, r0, #0
 2723              		.loc 1 1868 0
 2724 14e4 2CD04DE2 		sub	sp, sp, #44
 2725              	.LCFI27:
 2726              	.LVL275:
 2727              		.loc 1 1869 0
 2728 14e8 5B05000A 		beq	.L352
 2729              	.LVL276:
1870:../lib/fat16.c ****         return 0;
1871:../lib/fat16.c **** 
1872:../lib/fat16.c ****     uint8_t fat[32];
1873:../lib/fat16.c ****     struct fat16_usage_count_callback_arg count_arg;
1874:../lib/fat16.c ****     count_arg.cluster_count = 0;
1875:../lib/fat16.c ****     count_arg.buffer_size = sizeof(fat);
 2730              		.loc 1 1875 0
 2731 14ec 2030A0E3 		mov	r3, #32
 2732 14f0 2A30CDE5 		strb	r3, [sp, #42]
1876:../lib/fat16.c **** 
1877:../lib/fat16.c ****     uint32_t fat_offset = fs->header.fat_offset;
 2733              		.loc 1 1877 0
 2734 14f4 087096E5 		ldr	r7, [r6, #8]
 2735              	.LVL277:
1878:../lib/fat16.c ****     uint32_t fat_size = fs->header.fat_size;
 2736              		.loc 1 1878 0
 2737 14f8 0C5096E5 		ldr	r5, [r6, #12]
 2738              	.LVL278:
 2739              		.loc 1 1874 0
 2740 14fc 0030A0E3 		mov	r3, #0	@ movhi
 2741 1500 B832CDE1 		strh	r3, [sp, #40]	@ movhi
 2742 1504 530500EA 		b	.L354
 2743              	.LVL279:
 2744              	.L355:
 2745              	.LBB43:
1879:../lib/fat16.c ****     while(fat_size > 0)
1880:../lib/fat16.c ****     {
1881:../lib/fat16.c ****         uint16_t length = UINT16_MAX - 1;
1882:../lib/fat16.c ****         if(fat_size < length)
 2746              		.loc 1 1882 0
 2747 1508 74309FE5 		ldr	r3, .L363
 2748 150c 030055E1 		cmp	r5, r3
1883:../lib/fat16.c ****             length = fat_size;
1884:../lib/fat16.c **** 
1885:../lib/fat16.c ****         if(!fs->partition->device_read_interval(fat_offset,
 2749              		.loc 1 1885 0
 2750 1510 70309FE5 		ldr	r3, .L363+4
 2751              		.loc 1 1883 0
 2752 1514 2248A091 		movls	r4, r2, lsr #16
 2753              		.loc 1 1885 0
 2754 1518 00C096E5 		ldr	ip, [r6, #0]
 2755 151c 00308DE5 		str	r3, [sp, #0]
 2756 1520 28308DE2 		add	r3, sp, #40
 2757 1524 04308DE5 		str	r3, [sp, #4]
 2758 1528 0700A0E1 		mov	r0, r7
 2759 152c 08108DE2 		add	r1, sp, #8
 2760 1530 2020A0E3 		mov	r2, #32
 2761 1534 0430A0E1 		mov	r3, r4
 2762 1538 04C09CE5 		ldr	ip, [ip, #4]
 2763 153c 0FE0A0E1 		mov	lr, pc
 2764 1540 1CFF2FE1 		bx	ip
 2765 1544 000050E3 		cmp	r0, #0
 2766 1548 5B05000A 		beq	.L352
1886:../lib/fat16.c ****             fat,
1887:../lib/fat16.c ****            sizeof(fat),
1888:../lib/fat16.c ****            length,
1889:../lib/fat16.c ****            fat16_get_fs_free_callback,
1890:../lib/fat16.c ****            &count_arg
1891:../lib/fat16.c ****            )
1892:../lib/fat16.c ****            )
1893:../lib/fat16.c ****         return 0;
1894:../lib/fat16.c **** 
1895:../lib/fat16.c ****         fat_offset += length;
1896:../lib/fat16.c ****         fat_size -= length;
 2767              		.loc 1 1896 0
 2768 154c 055064E0 		rsb	r5, r4, r5
 2769              		.loc 1 1895 0
 2770 1550 047087E0 		add	r7, r7, r4
 2771              	.LVL280:
 2772              	.L354:
 2773              	.LBE43:
 2774              		.loc 1 1879 0
 2775 1554 000055E3 		cmp	r5, #0
 2776              	.LBB44:
 2777              		.loc 1 1882 0
 2778 1558 2C409FE5 		ldr	r4, .L363+8
 2779              		.loc 1 1883 0
 2780 155c 0528A0E1 		mov	r2, r5, asl #16
 2781              	.LBE44:
 2782              		.loc 1 1879 0
 2783 1560 4005001A 		bne	.L355
1897:../lib/fat16.c ****     }
1898:../lib/fat16.c **** 
1899:../lib/fat16.c ****     return (uint32_t) count_arg.cluster_count * fs->header.cluster_size;
 2784              		.loc 1 1899 0
 2785 1564 B221D6E1 		ldrh	r2, [r6, #18]
 2786 1568 B832DDE1 		ldrh	r3, [sp, #40]
 2787 156c 920300E0 		mul	r0, r2, r3
 2788 1570 5C0500EA 		b	.L361
 2789              	.LVL281:
 2790              	.L352:
 2791 1574 0000A0E3 		mov	r0, #0
 2792              	.L361:
1900:../lib/fat16.c **** }
 2793              		.loc 1 1900 0
 2794 1578 2CD08DE2 		add	sp, sp, #44
 2795 157c F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 2796 1580 1EFF2FE1 		bx	lr
 2797              	.L364:
 2798              		.align	2
 2799              	.L363:
 2800 1584 FDFF0000 		.word	65533
 2801 1588 90150000 		.word	fat16_get_fs_free_callback
 2802 158c FEFF0000 		.word	65534
 2803              	.LFE29:
 2805              		.align	2
 2807              	fat16_get_fs_free_callback:
 2808              	.LFB30:
1901:../lib/fat16.c **** 
1902:../lib/fat16.c **** /**
1903:../lib/fat16.c ****  * \ingroup fat16_fs
1904:../lib/fat16.c ****  * Callback function used for counting free clusters.
1905:../lib/fat16.c ****  */
1906:../lib/fat16.c **** uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p)
1907:../lib/fat16.c **** {
 2809              		.loc 1 1907 0
 2810              		@ Function supports interworking.
 2811              		@ args = 0, pretend = 0, frame = 0
 2812              		@ frame_needed = 0, uses_anonymous_args = 0
 2813              	.LVL282:
 2814 1590 10402DE9 		stmfd	sp!, {r4, lr}
 2815              	.LCFI28:
 2816              	.LVL283:
1908:../lib/fat16.c ****     struct fat16_usage_count_callback_arg* count_arg = (struct fat16_usage_count_callback_arg*) p;
1909:../lib/fat16.c ****     uint8_t buffer_size = count_arg->buffer_size;
 2817              		.loc 1 1909 0
 2818 1594 0240D2E5 		ldrb	r4, [r2, #2]	@ zero_extendqisi2
 2819              	.LVL284:
 2820              	.LVL285:
 2821              		.loc 1 1907 0
 2822 1598 02C0A0E1 		mov	ip, r2
 2823              	.LVL286:
 2824              		.loc 1 1909 0
 2825 159c 0010A0E1 		mov	r1, r0
 2826              	.LVL287:
 2827 15a0 00E0A0E3 		mov	lr, #0
 2828 15a4 700500EA 		b	.L372
 2829              	.L367:
1910:../lib/fat16.c ****     uint8_t i;
1911:../lib/fat16.c ****     for(i = 0; i < buffer_size; i += 2)
1912:../lib/fat16.c ****     {
1913:../lib/fat16.c ****         if((((uint16_t) buffer[1] << 8) | ((uint16_t) buffer[0] << 0)) == FAT16_CLUSTER_FREE)
 2830              		.loc 1 1913 0
 2831 15a8 0030DEE7 		ldrb	r3, [lr, r0]	@ zero_extendqisi2
 2832 15ac 0120D1E5 		ldrb	r2, [r1, #1]	@ zero_extendqisi2
 2833              	.LVL288:
 2834 15b0 022493E1 		orrs	r2, r3, r2, asl #8
1914:../lib/fat16.c ****             ++(count_arg->cluster_count);
 2835              		.loc 1 1914 0
 2836 15b4 B030DC01 		ldreqh	r3, [ip, #0]
 2837 15b8 01308302 		addeq	r3, r3, #1
 2838 15bc B030CC01 		streqh	r3, [ip, #0]	@ movhi
1915:../lib/fat16.c **** 
1916:../lib/fat16.c ****         buffer += 2;
 2839              		.loc 1 1916 0
 2840 15c0 021081E2 		add	r1, r1, #2
 2841 15c4 02E08EE2 		add	lr, lr, #2
 2842              	.LVL289:
 2843              	.L372:
 2844              		.loc 1 1911 0
 2845 15c8 FF300EE2 		and	r3, lr, #255
 2846 15cc 040053E1 		cmp	r3, r4
 2847 15d0 6805003A 		bcc	.L367
1917:../lib/fat16.c ****     }
1918:../lib/fat16.c **** 
1919:../lib/fat16.c ****     return 1;
1920:../lib/fat16.c **** }
 2848              		.loc 1 1920 0
 2849 15d4 0100A0E3 		mov	r0, #1
 2850              	.LVL290:
 2851 15d8 1040BDE8 		ldmfd	sp!, {r4, lr}
 2852 15dc 1EFF2FE1 		bx	lr
 2853              	.LFE30:
 2855              		.align	2
 2856              		.global	fat16_file_size
 2858              	fat16_file_size:
 2859              	.LFB33:
1921:../lib/fat16.c **** 
1922:../lib/fat16.c **** uint8_t find_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd, const char* name,
1923:../lib/fat16.c **** {
1924:../lib/fat16.c ****     while(fat16_read_dir(dd, dir_entry))
1925:../lib/fat16.c ****     {
1926:../lib/fat16.c ****         if(strcmp(dir_entry->long_name, name) == 0)
1927:../lib/fat16.c ****         {
1928:../lib/fat16.c ****             fat16_reset_dir(dd);
1929:../lib/fat16.c ****             return 1;
1930:../lib/fat16.c ****         }
1931:../lib/fat16.c ****     }
1932:../lib/fat16.c **** 
1933:../lib/fat16.c ****     return 0;
1934:../lib/fat16.c **** }
1935:../lib/fat16.c **** 
1936:../lib/fat16.c **** struct fat16_file_struct* open_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd,
1937:../lib/fat16.c **** {
1938:../lib/fat16.c ****     struct fat16_dir_entry_struct file_entry;
1939:../lib/fat16.c ****     if(!find_file_in_dir(fs, dd, name, &file_entry))
1940:../lib/fat16.c ****         return 0;
1941:../lib/fat16.c **** 
1942:../lib/fat16.c ****     return fat16_open_file(fs, &file_entry);
1943:../lib/fat16.c **** }
1944:../lib/fat16.c **** 
1945:../lib/fat16.c **** int fat16_file_size(struct fat16_file_struct * file)
1946:../lib/fat16.c **** {
 2860              		.loc 1 1946 0
 2861              		@ Function supports interworking.
 2862              		@ args = 0, pretend = 0, frame = 0
 2863              		@ frame_needed = 0, uses_anonymous_args = 0
 2864              		@ link register save eliminated.
 2865              	.LVL291:
1947:../lib/fat16.c ****     return(file->dir_entry.file_size);
1948:../lib/fat16.c **** }
 2866              		.loc 1 1948 0
 2867 15e0 280090E5 		ldr	r0, [r0, #40]
 2868              	.LVL292:
 2869              		.loc 1 1946 0
 2870              		@ lr needed for prologue
 2871              		.loc 1 1948 0
 2872 15e4 1EFF2FE1 		bx	lr
 2873              	.LFE33:
 2875              		.align	2
 2876              		.global	fat16_create_file
 2878              	fat16_create_file:
 2879              	.LFB26:
 2880              		.loc 1 1671 0
 2881              		@ Function supports interworking.
 2882              		@ args = 0, pretend = 0, frame = 4
 2883              		@ frame_needed = 0, uses_anonymous_args = 0
 2884              	.LVL293:
 2885 15e8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2886              	.LCFI29:
 2887              		.loc 1 1673 0
 2888 15ec 016070E2 		rsbs	r6, r0, #1
 2889 15f0 0060A033 		movcc	r6, #0
 2890 15f4 000050E3 		cmp	r0, #0
 2891 15f8 00005113 		cmpne	r1, #0
 2892              		.loc 1 1671 0
 2893 15fc 04D04DE2 		sub	sp, sp, #4
 2894              	.LCFI30:
 2895              	.LVL294:
 2896              		.loc 1 1673 0
 2897 1600 0050A0E1 		mov	r5, r0
 2898 1604 0140A0E1 		mov	r4, r1
 2899              		.loc 1 1671 0
 2900 1608 0280A0E1 		mov	r8, r2
 2901              		.loc 1 1673 0
 2902 160c E505000A 		beq	.L376
 2903              	.LVL295:
 2904 1610 0030D1E5 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 2905 1614 000053E3 		cmp	r3, #0
 2906 1618 E505000A 		beq	.L376
 2907              	.L401:
 2908              		.loc 1 1679 0
 2909 161c 0810A0E1 		mov	r1, r8
 2910 1620 0500A0E1 		mov	r0, r5
 2911 1624 FEFFFFEB 		bl	fat16_read_dir
 2912 1628 003050E2 		subs	r3, r0, #0
 2913              		.loc 1 1682 0
 2914 162c 0810A0E1 		mov	r1, r8
 2915 1630 0400A0E1 		mov	r0, r4
 2916              		.loc 1 1679 0
 2917 1634 9405000A 		beq	.L379
 2918              	.LVL296:
 2919              		.loc 1 1682 0
 2920 1638 FEFFFFEB 		bl	strcmp
 2921              	.LVL297:
 2922 163c 000050E3 		cmp	r0, #0
 2923 1640 8505001A 		bne	.L401
 2924              	.LBB45:
 2925              	.LBB46:
 2926              		.loc 1 1440 0
 2927 1644 000056E3 		cmp	r6, #0
 2928              		.loc 1 1443 0
 2929 1648 01008002 		addeq	r0, r0, #1
 2930 164c B063C501 		streqh	r6, [r5, #48]	@ movhi
 2931              		.loc 1 1440 0
 2932 1650 E805000A 		beq	.L384
 2933 1654 E70500EA 		b	.L382
 2934              	.LVL298:
 2935              	.L379:
 2936              	.LBE46:
 2937              	.LBE45:
 2938              		.loc 1 1689 0
 2939 1658 0310A0E1 		mov	r1, r3
 2940              	.LVL299:
 2941 165c 2C20A0E3 		mov	r2, #44
 2942 1660 0800A0E1 		mov	r0, r8
 2943              	.LVL300:
 2944 1664 FEFFFFEB 		bl	memset
 2945              		.loc 1 1690 0
 2946 1668 0410A0E1 		mov	r1, r4
 2947 166c 1F20A0E3 		mov	r2, #31
 2948 1670 0800A0E1 		mov	r0, r8
 2949 1674 FEFFFFEB 		bl	strncpy
 2950              		.loc 1 1693 0
 2951 1678 0400A0E1 		mov	r0, r4
 2952 167c FEFFFFEB 		bl	strlen
 2953 1680 0D10A0E3 		mov	r1, #13
 2954 1684 FEFFFFEB 		bl	__udivsi3
 2955              		.loc 1 1696 0
 2956 1688 B662D5E1 		ldrh	r6, [r5, #38]
 2957              	.LVL301:
 2958              		.loc 1 1693 0
 2959 168c 020080E2 		add	r0, r0, #2
 2960              		.loc 1 1701 0
 2961 1690 000056E3 		cmp	r6, #0
 2962              		.loc 1 1693 0
 2963 1694 FFB000E2 		and	fp, r0, #255
 2964              	.LVL302:
 2965              		.loc 1 1695 0
 2966 1698 005095E5 		ldr	r5, [r5, #0]
 2967              	.LVL303:
 2968              		.loc 1 1701 0
 2969 169c C105001A 		bne	.L385
 2970              		.loc 1 1704 0
 2971              	.LVL304:
 2972 16a0 144085E2 		add	r4, r5, #20
 2973 16a4 100294E8 		ldmia	r4, {r4, r9}	@ phole ldm
 2974              	.LVL305:
 2975              		.loc 1 1705 0
 2976 16a8 0470A0E1 		mov	r7, r4
 2977              	.LVL306:
 2978 16ac 06A0A0E1 		mov	sl, r6
 2979              	.LVL307:
 2980              	.L387:
 2981              	.LBB47:
 2982              		.loc 1 1711 0
 2983 16b0 090054E1 		cmp	r4, r9
 2984 16b4 C805001A 		bne	.L388
 2985              		.loc 1 1713 0
 2986 16b8 000056E3 		cmp	r6, #0
 2987 16bc E505000A 		beq	.L376
 2988              		.loc 1 1719 0
 2989 16c0 000054E3 		cmp	r4, #0
 2990 16c4 C105000A 		beq	.L385
 2991              	.LBB48:
 2992              		.loc 1 1725 0
 2993 16c8 0610A0E1 		mov	r1, r6
 2994 16cc 0500A0E1 		mov	r0, r5
 2995 16d0 7E0000EB 		bl	fat16_get_next_cluster
 2996              		.loc 1 1726 0
 2997 16d4 000050E3 		cmp	r0, #0
 2998              	.LVL308:
 2999              		.loc 1 1739 0
 3000 16d8 0060A011 		movne	r6, r0
 3001              		.loc 1 1726 0
 3002 16dc C105001A 		bne	.L385
 3003              		.loc 1 1728 0
 3004 16e0 0610A0E1 		mov	r1, r6
 3005 16e4 0500A0E1 		mov	r0, r5
 3006              	.LVL309:
 3007 16e8 0120A0E3 		mov	r2, #1
 3008 16ec FE0100EB 		bl	fat16_append_clusters
 3009              		.loc 1 1729 0
 3010 16f0 000050E3 		cmp	r0, #0
 3011 16f4 E505000A 		beq	.L376
 3012              		.loc 1 1733 0
 3013 16f8 B211D5E1 		ldrh	r1, [r5, #18]
 3014 16fc 182095E5 		ldr	r2, [r5, #24]
 3015 1700 023040E2 		sub	r3, r0, #2
 3016 1704 912327E0 		mla	r7, r1, r3, r2
 3017 1708 DF0500EA 		b	.L395
 3018              	.LVL310:
 3019              	.L385:
 3020              	.LBE48:
 3021              		.loc 1 1744 0
 3022 170c B211D5E1 		ldrh	r1, [r5, #18]
 3023 1710 182095E5 		ldr	r2, [r5, #24]
 3024 1714 023046E2 		sub	r3, r6, #2
 3025 1718 912324E0 		mla	r4, r1, r3, r2
 3026              	.LVL311:
 3027              		.loc 1 1746 0
 3028 171c 00A0A0E3 		mov	sl, #0
 3029 1720 019084E0 		add	r9, r4, r1
 3030 1724 0470A0E1 		mov	r7, r4
 3031              	.L388:
 3032              		.loc 1 1753 0
 3033 1728 003095E5 		ldr	r3, [r5, #0]
 3034 172c 0400A0E1 		mov	r0, r4
 3035              	.LVL312:
 3036 1730 03108DE2 		add	r1, sp, #3
 3037 1734 0120A0E3 		mov	r2, #1
 3038 1738 00C093E5 		ldr	ip, [r3, #0]
 3039 173c 0FE0A0E1 		mov	lr, pc
 3040 1740 1CFF2FE1 		bx	ip
 3041 1744 000050E3 		cmp	r0, #0
 3042 1748 E505000A 		beq	.L376
 3043              		.loc 1 1757 0
 3044 174c 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 3045 1750 000053E3 		cmp	r3, #0
 3046 1754 E5005313 		cmpne	r3, #229
 3047 1758 0030A013 		movne	r3, #0
 3048 175c 0130A003 		moveq	r3, #1
 3049              		.loc 1 1768 0
 3050 1760 20708412 		addne	r7, r4, #32
 3051 1764 03A0A011 		movne	sl, r3
 3052 1768 0740A011 		movne	r4, r7
 3053              		.loc 1 1757 0
 3054 176c AA05001A 		bne	.L387
 3055              		.loc 1 1760 0
 3056 1770 01308AE2 		add	r3, sl, #1
 3057 1774 FFA003E2 		and	sl, r3, #255
 3058              		.loc 1 1761 0
 3059 1778 0B005AE1 		cmp	sl, fp
 3060              		.loc 1 1764 0
 3061 177c 20408432 		addcc	r4, r4, #32
 3062              		.loc 1 1761 0
 3063 1780 AA05003A 		bcc	.L387
 3064              	.L395:
 3065              	.LBE47:
 3066              		.loc 1 1775 0
 3067 1784 287088E5 		str	r7, [r8, #40]
 3068              		.loc 1 1776 0
 3069 1788 0500A0E1 		mov	r0, r5
 3070 178c 0810A0E1 		mov	r1, r8
 3071 1790 510300EB 		bl	fat16_write_dir_entry
 3072 1794 000050E3 		cmp	r0, #0
 3073 1798 E705001A 		bne	.L382
 3074              	.LVL313:
 3075              	.L376:
 3076 179c 0000A0E3 		mov	r0, #0
 3077 17a0 E80500EA 		b	.L384
 3078              	.LVL314:
 3079              	.L382:
 3080 17a4 0100A0E3 		mov	r0, #1
 3081              	.LVL315:
 3082              	.L384:
 3083              		.loc 1 1784 0
 3084 17a8 04D08DE2 		add	sp, sp, #4
 3085 17ac F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3086 17b0 1EFF2FE1 		bx	lr
 3087              	.LFE26:
 3089              		.align	2
 3090              		.global	find_file_in_dir
 3092              	find_file_in_dir:
 3093              	.LFB31:
 3094              		.loc 1 1923 0
 3095              		@ Function supports interworking.
 3096              		@ args = 0, pretend = 0, frame = 0
 3097              		@ frame_needed = 0, uses_anonymous_args = 0
 3098              	.LVL316:
 3099 17b4 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 3100              	.LCFI31:
 3101              		.loc 1 1923 0
 3102 17b8 0140A0E1 		mov	r4, r1
 3103 17bc 0260A0E1 		mov	r6, r2
 3104 17c0 0350A0E1 		mov	r5, r3
 3105 17c4 F80500EA 		b	.L405
 3106              	.LVL317:
 3107              	.L406:
 3108              		.loc 1 1926 0
 3109 17c8 FEFFFFEB 		bl	strcmp
 3110              	.LVL318:
 3111 17cc 000050E3 		cmp	r0, #0
 3112 17d0 F805001A 		bne	.L405
 3113              	.LBB49:
 3114              	.LBB50:
 3115              		.loc 1 1440 0
 3116 17d4 000054E3 		cmp	r4, #0
 3117 17d8 0130A003 		moveq	r3, #1
 3118              		.loc 1 1443 0
 3119 17dc 0130A013 		movne	r3, #1
 3120 17e0 B003C411 		strneh	r0, [r4, #48]	@ movhi
 3121 17e4 FF0500EA 		b	.L410
 3122              	.LVL319:
 3123              	.L405:
 3124              	.LBE50:
 3125              	.LBE49:
 3126              		.loc 1 1924 0
 3127 17e8 0510A0E1 		mov	r1, r5
 3128 17ec 0400A0E1 		mov	r0, r4
 3129              	.LVL320:
 3130 17f0 FEFFFFEB 		bl	fat16_read_dir
 3131 17f4 003050E2 		subs	r3, r0, #0
 3132              		.loc 1 1926 0
 3133 17f8 0610A0E1 		mov	r1, r6
 3134 17fc 0500A0E1 		mov	r0, r5
 3135              		.loc 1 1924 0
 3136 1800 F005001A 		bne	.L406
 3137              	.L410:
 3138              		.loc 1 1934 0
 3139 1804 0300A0E1 		mov	r0, r3
 3140 1808 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 3141 180c 1EFF2FE1 		bx	lr
 3142              	.LFE31:
 3144              		.align	2
 3145              		.global	open_file_in_dir
 3147              	open_file_in_dir:
 3148              	.LFB32:
 3149              		.loc 1 1937 0
 3150              		@ Function supports interworking.
 3151              		@ args = 0, pretend = 0, frame = 44
 3152              		@ frame_needed = 0, uses_anonymous_args = 0
 3153              	.LVL321:
 3154 1810 30402DE9 		stmfd	sp!, {r4, r5, lr}
 3155              	.LCFI32:
 3156 1814 2CD04DE2 		sub	sp, sp, #44
 3157              	.LCFI33:
 3158              	.LVL322:
 3159              		.loc 1 1939 0
 3160 1818 0D30A0E1 		mov	r3, sp
 3161              		.loc 1 1937 0
 3162 181c 0040A0E1 		mov	r4, r0
 3163              		.loc 1 1939 0
 3164 1820 FEFFFFEB 		bl	find_file_in_dir
 3165              	.LVL323:
 3166 1824 000050E3 		cmp	r0, #0
 3167 1828 0030A0E1 		mov	r3, r0
 3168 182c 0D50A0E1 		mov	r5, sp
 3169              		.loc 1 1942 0
 3170 1830 0400A0E1 		mov	r0, r4
 3171 1834 0D10A0E1 		mov	r1, sp
 3172              		.loc 1 1939 0
 3173 1838 0F06000A 		beq	.L418
 3174              	.LVL324:
 3175              		.loc 1 1942 0
 3176 183c FEFFFFEB 		bl	fat16_open_file
 3177              	.LVL325:
 3178 1840 0030A0E1 		mov	r3, r0
 3179              	.LVL326:
 3180              	.L418:
 3181              		.loc 1 1943 0
 3182 1844 0300A0E1 		mov	r0, r3
 3183 1848 2CD08DE2 		add	sp, sp, #44
 3184 184c 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 3185 1850 1EFF2FE1 		bx	lr
 3186              	.LFE32:
 3809              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fat16.c
     /tmp/ccLfiELg.s:23     .text:0000000000000000 fat16_open
     /tmp/ccLfiELg.s:31     .text:0000000000000000 $a
     /tmp/ccLfiELg.s:265    .text:00000000000001e4 $d
     /tmp/ccLfiELg.s:272    .text:00000000000001ec fat16_close
     /tmp/ccLfiELg.s:280    .text:00000000000001ec $a
     /tmp/ccLfiELg.s:297    .text:0000000000000200 fat16_get_next_cluster
     /tmp/ccLfiELg.s:372    .text:00000000000002a4 $d
     /tmp/ccLfiELg.s:377    .text:00000000000002a8 fat16_dir_entry_seek_callback
     /tmp/ccLfiELg.s:386    .text:00000000000002a8 $a
     /tmp/ccLfiELg.s:441    .text:0000000000000318 fat16_dir_entry_read_callback
     /tmp/ccLfiELg.s:647    .text:00000000000004e0 fat16_read_dir
     /tmp/ccLfiELg.s:886    .text:0000000000000708 $d
     /tmp/ccLfiELg.s:893    .text:0000000000000710 fat16_close_dir
     /tmp/ccLfiELg.s:901    .text:0000000000000710 $a
     /tmp/ccLfiELg.s:918    .text:0000000000000724 fat16_free_clusters
     /tmp/ccLfiELg.s:1028   .text:00000000000007fc $d
     /tmp/ccLfiELg.s:1033   .text:0000000000000800 fat16_append_clusters
     /tmp/ccLfiELg.s:1040   .text:0000000000000800 $a
     /tmp/ccLfiELg.s:1206   .text:0000000000000970 fat16_open_dir
     /tmp/ccLfiELg.s:1273   .text:00000000000009ec fat16_get_dir_entry_of_path
     /tmp/ccLfiELg.s:1408   .text:0000000000000b10 fat16_open_file
     /tmp/ccLfiELg.s:1477   .text:0000000000000b8c fat16_close_file
     /tmp/ccLfiELg.s:1504   .text:0000000000000ba0 fat16_read_file
     /tmp/ccLfiELg.s:1711   .text:0000000000000d30 fat16_reset_dir
     /tmp/ccLfiELg.s:1737   .text:0000000000000d4c fat16_write_dir_entry
     /tmp/ccLfiELg.s:2040   .text:0000000000000fd8 fat16_resize_file
     /tmp/ccLfiELg.s:2245   .text:0000000000001178 fat16_seek_file
     /tmp/ccLfiELg.s:2334   .text:0000000000001210 fat16_write_file
     /tmp/ccLfiELg.s:2603   .text:000000000000140c fat16_delete_file
     /tmp/ccLfiELg.s:2681   .text:00000000000014b8 fat16_get_fs_size
     /tmp/ccLfiELg.s:2712   .text:00000000000014dc fat16_get_fs_free
     /tmp/ccLfiELg.s:2800   .text:0000000000001584 $d
     /tmp/ccLfiELg.s:2807   .text:0000000000001590 fat16_get_fs_free_callback
     /tmp/ccLfiELg.s:2814   .text:0000000000001590 $a
     /tmp/ccLfiELg.s:2858   .text:00000000000015e0 fat16_file_size
     /tmp/ccLfiELg.s:2878   .text:00000000000015e8 fat16_create_file
     /tmp/ccLfiELg.s:3092   .text:00000000000017b4 find_file_in_dir
     /tmp/ccLfiELg.s:3147   .text:0000000000001810 open_file_in_dir

UNDEFINED SYMBOLS
__divsi3
__udivsi3
malloc
rprintf
memset
free
strchr
strlen
strncmp
__umodsi3
strrchr
memcpy
strcmp
strncpy
