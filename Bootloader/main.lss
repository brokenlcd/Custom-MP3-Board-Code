
main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .bl_version_number 00000008  00000000  000080e0  00018000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006254  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         000008cc  40000200  00006254  00010200  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000768  40000acc  40000acc  00018008  2**2
                  ALLOC
  4 .debug_line   00001676  00000000  00000000  00018008  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005476  00000000  00000000  0001967e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001b00  00000000  00000000  0001eaf4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000300  00000000  00000000  000205f8  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000e00  00000000  00000000  000208f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00002ffc  00000000  00000000  000216f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000098c  00000000  00000000  000246f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000019e6  00000000  00000000  00025080  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      00000360  00000000  00000000  00026a66  2**0
                  CONTENTS, READONLY
 13 .debug_ranges 00000358  00000000  00000000  00026dc6  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <_startup>:
_startup:

# Exception Vectors

_vectors:       ldr     PC, Reset_Addr         
       0:	e59ff018 	ldr	pc, [pc, #24]	; 20 <Reset_Addr>
                ldr     PC, Undef_Addr
       4:	e59ff018 	ldr	pc, [pc, #24]	; 24 <Undef_Addr>
                ldr     PC, SWI_Addr
       8:	e59ff018 	ldr	pc, [pc, #24]	; 28 <SWI_Addr>
                ldr     PC, PAbt_Addr
       c:	e59ff018 	ldr	pc, [pc, #24]	; 2c <PAbt_Addr>
                ldr     PC, DAbt_Addr
      10:	e59ff018 	ldr	pc, [pc, #24]	; 30 <DAbt_Addr>
                nop							/* Reserved Vector (holds Philips ISP checksum) */
      14:	e1a00000 	nop			(mov r0,r0)
                //ldr     PC, [PC,#-0xFF0]	/* see page 71 of "Insiders Guide to the Philips ARM7-Based Microcontrollers" by Trevor Martin  */
				ldr     PC, IRQ_Addr //Original line from DCarne implementation
      18:	e59ff014 	ldr	pc, [pc, #20]	; 34 <IRQ_Addr>
                ldr     PC, FIQ_Addr
      1c:	e59ff014 	ldr	pc, [pc, #20]	; 38 <FIQ_Addr>

00000020 <Reset_Addr>:
      20:	00000040 	andeq	r0, r0, r0, asr #32

00000024 <Undef_Addr>:
      24:	000001b8 	streqh	r0, [r0], -r8

00000028 <SWI_Addr>:
      28:	000001b4 	streqh	r0, [r0], -r4

0000002c <PAbt_Addr>:
      2c:	000001b8 	streqh	r0, [r0], -r8

00000030 <DAbt_Addr>:
      30:	000001b8 	streqh	r0, [r0], -r8

00000034 <IRQ_Addr>:
      34:	000000c0 	andeq	r0, r0, r0, asr #1

00000038 <FIQ_Addr>:
      38:	000001b0 	streqh	r0, [r0], -r0
      3c:	00000000 	andeq	r0, r0, r0

00000040 <Reset_Handler>:

Reset_Addr:     .word   Reset_Handler		/* defined in this module below  */
Undef_Addr:     .word   UNDEF_Routine		/* defined in main.c  */
SWI_Addr:       .word   SWI_Routine			/* defined in main.c  */
PAbt_Addr:      .word   UNDEF_Routine		/* defined in main.c  */
DAbt_Addr:      .word   UNDEF_Routine		/* defined in main.c  */
IRQ_Addr:       .word   IRQ_Handler			/* defined in main.c  */
//IRQ_Addr:       .word   IRQ_Routine			/* defined in main.c  */
FIQ_Addr:       .word   FIQ_Routine			/* defined in main.c  */
                .word   0					/* rounds the vectors and ISR addresses to 64 bytes total  */

# Reset Handler

Reset_Handler:  

				/* Setup a stack for each mode - note that this only sets up a usable stack
				for User mode.   Also each mode is setup with interrupts initially disabled. */
    			  
    			ldr   r0, =_stack_end
      40:	e59f0090 	ldr	r0, [pc, #144]	; d8 <.text+0xd8>
    			msr   CPSR_c, #MODE_UND|I_BIT|F_BIT 	/* Undefined Instruction Mode  */
      44:	e321f0db 	msr	CPSR_c, #219	; 0xdb
    			mov   sp, r0
      48:	e1a0d000 	mov	sp, r0
    			sub   r0, r0, #UND_STACK_SIZE
      4c:	e2400080 	sub	r0, r0, #128	; 0x80
    			msr   CPSR_c, #MODE_ABT|I_BIT|F_BIT 	/* Abort Mode */
      50:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
    			mov   sp, r0
      54:	e1a0d000 	mov	sp, r0
    			sub   r0, r0, #ABT_STACK_SIZE
      58:	e2400080 	sub	r0, r0, #128	; 0x80
    			msr   CPSR_c, #MODE_FIQ|I_BIT|F_BIT 	/* FIQ Mode */
      5c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
    			mov   sp, r0	
      60:	e1a0d000 	mov	sp, r0
   				sub   r0, r0, #FIQ_STACK_SIZE
      64:	e2400080 	sub	r0, r0, #128	; 0x80
    			msr   CPSR_c, #MODE_IRQ|I_BIT|F_BIT 	/* IRQ Mode */
      68:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
    			mov   sp, r0
      6c:	e1a0d000 	mov	sp, r0
    			sub   r0, r0, #IRQ_STACK_SIZE
      70:	e2400080 	sub	r0, r0, #128	; 0x80
    			msr   CPSR_c, #MODE_SVC|I_BIT|F_BIT 	/* Supervisor Mode */
      74:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
    			mov   sp, r0
      78:	e1a0d000 	mov	sp, r0
    			sub   r0, r0, #SVC_STACK_SIZE
      7c:	e2400080 	sub	r0, r0, #128	; 0x80
    	/*		msr   CPSR_c, #MODE_SYS|I_BIT|F_BIT */	/* User Mode */
    			msr   CPSR_c, #MODE_SYS|F_BIT 	/* User Mode */
      80:	e321f05f 	msr	CPSR_c, #95	; 0x5f
    			mov   sp, r0
      84:	e1a0d000 	mov	sp, r0

				/* copy .data section (Copy from ROM to RAM) */
                ldr     R1, =_etext
      88:	e59f104c 	ldr	r1, [pc, #76]	; dc <.text+0xdc>
                ldr     R2, =_data
      8c:	e59f204c 	ldr	r2, [pc, #76]	; e0 <.text+0xe0>
                ldr     R3, =_edata
      90:	e59f304c 	ldr	r3, [pc, #76]	; e4 <.text+0xe4>
1:        		cmp     R2, R3
      94:	e1520003 	cmp	r2, r3
                ldrlo   R0, [R1], #4
      98:	34910004 	ldrcc	r0, [r1], #4
                strlo   R0, [R2], #4
      9c:	34820004 	strcc	r0, [r2], #4
                blo     1b
      a0:	3afffffb 	bcc	94 <ABT_STACK_SIZE+0x14>

				/* Clear .bss section (Zero init)  */
                mov     R0, #0
      a4:	e3a00000 	mov	r0, #0	; 0x0
                ldr     R1, =_bss_start
      a8:	e59f1038 	ldr	r1, [pc, #56]	; e8 <.text+0xe8>
                ldr     R2, =_bss_end
      ac:	e59f2038 	ldr	r2, [pc, #56]	; ec <.text+0xec>
2:				cmp     R1, R2
      b0:	e1510002 	cmp	r1, r2
                strlo   R0, [R1], #4
      b4:	34810004 	strcc	r0, [r1], #4
                blo     2b
      b8:	3afffffc 	bcc	b0 <ABT_STACK_SIZE+0x30>

				/* Enter the C code  */
                b       main
      bc:	ea00000c 	b	f4 <main>

000000c0 <IRQ_Handler>:

.endfunc

//Needed because of glitch in GCC compiler v4.1.1
IRQ_Handler: 	
				sub lr, lr, #4
      c0:	e24ee004 	sub	lr, lr, #4	; 0x4
				stmdb sp!, {r0-r12, lr}
      c4:	e92d5fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
				ldr r0, =0xFFFFF030
      c8:	e59f0020 	ldr	r0, [pc, #32]	; f0 <.text+0xf0>
				mov lr, pc
      cc:	e1a0e00f 	mov	lr, pc
				ldr pc, [r0]
      d0:	e590f000 	ldr	pc, [r0]
				ldmia sp!, {r0-r12, pc}^
      d4:	e8fd9fff 	ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}^
      d8:	40007edc 	ldrmid	r7, [r0], -ip
      dc:	00006254 	andeq	r6, r0, r4, asr r2
      e0:	40000200 	andmi	r0, r0, r0, lsl #4
      e4:	40000acc 	andmi	r0, r0, ip, asr #21
      e8:	40000acc 	andmi	r0, r0, ip, asr #21
      ec:	40001234 	andmi	r1, r0, r4, lsr r2
      f0:	fffff030 	undefined instruction 0xfffff030

000000f4 <main>:
#define OFF	1


int main (void)
{
      f4:	e52de004 	str	lr, [sp, #-4]!

	boot_up();
      f8:	eb000069 	bl	2a4 <boot_up>
	rprintf("Boot up complete\n");
      fc:	e59f0084 	ldr	r0, [pc, #132]	; 188 <.text+0x188>
     100:	eb0000b4 	bl	3d8 <rprintf>

	if(IOPIN0 & (1<<23))
     104:	e59f3080 	ldr	r3, [pc, #128]	; 18c <.text+0x18c>
     108:	e5933000 	ldr	r3, [r3]
     10c:	e3130502 	tst	r3, #8388608	; 0x800000
     110:	0a000001 	beq	11c <main+0x28>
	{
		main_msc();
     114:	eb000c8e 	bl	3354 <main_msc>
     118:	ea000001 	b	124 <main+0x30>
	}
	else{
		rprintf("No USB Detected\n");
     11c:	e59f006c 	ldr	r0, [pc, #108]	; 190 <.text+0x190>
     120:	eb0000ac 	bl	3d8 <rprintf>
	}
	
	//Init SD
	if(sd_raw_init())
     124:	eb000526 	bl	15c4 <sd_raw_init>
     128:	e3500000 	cmp	r0, #0	; 0x0
     12c:	0a00000d 	beq	168 <main+0x74>
	{
		openroot();
     130:	eb0002cd 	bl	c6c <openroot>
		rprintf("Root open\n");
     134:	e59f0058 	ldr	r0, [pc, #88]	; 194 <.text+0x194>
     138:	eb0000a6 	bl	3d8 <rprintf>
		if(root_file_exists(FW_FILE))
     13c:	e59f0054 	ldr	r0, [pc, #84]	; 198 <.text+0x198>
     140:	eb0001e2 	bl	8d0 <root_file_exists>
     144:	e3500000 	cmp	r0, #0	; 0x0
     148:	0a00000a 	beq	178 <main+0x84>
		{
			rprintf("New firmware found\n");
     14c:	e59f0048 	ldr	r0, [pc, #72]	; 19c <.text+0x19c>
     150:	eb0000a0 	bl	3d8 <rprintf>
			load_fw(FW_FILE);
     154:	e59f003c 	ldr	r0, [pc, #60]	; 198 <.text+0x198>
     158:	eb000187 	bl	77c <load_fw>
			rprintf("New firmware loaded\n");
     15c:	e59f003c 	ldr	r0, [pc, #60]	; 1a0 <.text+0x1a0>
     160:	eb00009c 	bl	3d8 <rprintf>
     164:	ea000003 	b	178 <main+0x84>
		}
	}
	else{
		//Didn't find a card to initialize
		rprintf("No SD Card Detected\n");
     168:	e59f0034 	ldr	r0, [pc, #52]	; 1a4 <.text+0x1a4>
     16c:	eb000099 	bl	3d8 <rprintf>
		delay_ms(250);
     170:	e3a000fa 	mov	r0, #250	; 0xfa
     174:	eb000010 	bl	1bc <delay_ms>
	}
	rprintf("Boot Done. Calling firmware...\n");
     178:	e59f0028 	ldr	r0, [pc, #40]	; 1a8 <.text+0x1a8>
     17c:	eb000095 	bl	3d8 <rprintf>
	call_firmware();
     180:	eb000177 	bl	764 <call_firmware>
     184:	eafffffe 	b	184 <main+0x90>
     188:	00005cfc 	streqd	r5, [r0], -ip
     18c:	e0028000 	and	r8, r2, r0
     190:	00005d10 	andeq	r5, r0, r0, lsl sp
     194:	00005d24 	andeq	r5, r0, r4, lsr #26
     198:	00005d30 	andeq	r5, r0, r0, lsr sp
     19c:	00005d38 	andeq	r5, r0, r8, lsr sp
     1a0:	00005d4c 	andeq	r5, r0, ip, asr #26
     1a4:	00005d64 	andeq	r5, r0, r4, ror #26
     1a8:	00005d7c 	andeq	r5, r0, ip, ror sp

000001ac <IRQ_Routine>:
/* Define catchall routines for vector table */
void IRQ_Routine (void)   __attribute__ ((interrupt("IRQ")));
void IRQ_Routine (void)
{
}
     1ac:	e25ef004 	subs	pc, lr, #4	; 0x4

000001b0 <FIQ_Routine>:

void FIQ_Routine (void)   __attribute__ ((interrupt("FIQ")));
void FIQ_Routine (void)
{
}
     1b0:	e25ef004 	subs	pc, lr, #4	; 0x4

000001b4 <SWI_Routine>:

void SWI_Routine (void)   __attribute__ ((interrupt("SWI")));
void SWI_Routine (void)
{
}
     1b4:	e1b0f00e 	movs	pc, lr

000001b8 <UNDEF_Routine>:

void UNDEF_Routine (void) __attribute__ ((interrupt("UNDEF")));
void UNDEF_Routine (void)
{
};
     1b8:	e1b0f00e 	movs	pc, lr

000001bc <delay_ms>:

//Short delay
void delay_ms(int count)
{
    int i;
    count *= 10000;
     1bc:	e59f301c 	ldr	r3, [pc, #28]	; 1e0 <.text+0x1e0>
     1c0:	e0000093 	mul	r0, r3, r0
     1c4:	e3a03000 	mov	r3, #0	; 0x0
     1c8:	ea000001 	b	1d4 <delay_ms+0x18>
    for (i = 0; i < count; i++)
    {
        asm volatile ("nop");
     1cc:	e1a00000 	nop			(mov r0,r0)
     1d0:	e2833001 	add	r3, r3, #1	; 0x1
     1d4:	e1530000 	cmp	r3, r0
     1d8:	bafffffb 	blt	1cc <delay_ms+0x10>
    }
}
     1dc:	e12fff1e 	bx	lr
     1e0:	00002710 	andeq	r2, r0, r0, lsl r7

000001e4 <system_init>:

void boot_up(void)
{
    //Initialize the MCU clock PLL
    system_init();

	IODIR0 |= (1 << 31);
	IOCLR0 |= (1 << 31); //Turn on USB LED

    //Init UART0 for debug
    PINSEL0 |= 0x00000005; //enable uart0
    U0LCR = 0x83; // 8 bits, no Parity, 1 Stop bit, DLAB = 1 
    U0DLM = 0x00; 
    U0DLL = 0x20; // 9600 Baud Rate @ 58982400 VPB Clock  
    U0LCR = 0x03; // DLAB = 0                          

    //Init rprintf
    rprintf_devopen(putc_serial0); 
    rprintf("\n\n\nUSB Bootloader v1.1\n");

	//IOSET0 |= (1 << 31); //Turn off USB LED
}

/**********************************************************
  Initialize
 **********************************************************/

#define PLOCK 0x400

void system_init(void)
{
    // Setting Multiplier and Divider values
    PLLCFG=0x24;
     1e4:	e59f2068 	ldr	r2, [pc, #104]	; 254 <.text+0x254>
     1e8:	e3a03024 	mov	r3, #36	; 0x24
     1ec:	e5823084 	str	r3, [r2, #132]
    feed();

    // Enabling the PLL */
    PLLCON=0x1;
    feed();

    // Wait for the PLL to lock to set frequency
    while(!(PLLSTAT & PLOCK)) ;

    // Connect the PLL as the clock source
    PLLCON=0x3;
    feed();

    // Enabling MAM and setting number of clocks used for Flash memory fetch (4 cclks in this case)
    //MAMTIM=0x3; //VCOM?
    MAMCR=0x2;
    MAMTIM=0x4; //Original

    // Setting peripheral Clock (pclk) to System Clock (cclk)
    VPBDIV=0x1;
}

void feed(void)
{
    PLLFEED=0xAA;
     1f0:	e3a010aa 	mov	r1, #170	; 0xaa
    PLLFEED=0x55;
     1f4:	e3a00055 	mov	r0, #85	; 0x55
     1f8:	e3a03001 	mov	r3, #1	; 0x1
     1fc:	e582108c 	str	r1, [r2, #140]
     200:	e582008c 	str	r0, [r2, #140]
     204:	e5823080 	str	r3, [r2, #128]
     208:	e582108c 	str	r1, [r2, #140]
     20c:	e582008c 	str	r0, [r2, #140]
     210:	e59f203c 	ldr	r2, [pc, #60]	; 254 <.text+0x254>
     214:	e5923088 	ldr	r3, [r2, #136]
     218:	e3130b01 	tst	r3, #1024	; 0x400
     21c:	0afffffb 	beq	210 <system_init+0x2c>
     220:	e3a03003 	mov	r3, #3	; 0x3
     224:	e5823080 	str	r3, [r2, #128]
     228:	e28330a7 	add	r3, r3, #167	; 0xa7
     22c:	e582308c 	str	r3, [r2, #140]
     230:	e3a03055 	mov	r3, #85	; 0x55
     234:	e582308c 	str	r3, [r2, #140]
     238:	e3a03002 	mov	r3, #2	; 0x2
     23c:	e5823000 	str	r3, [r2]
     240:	e0833003 	add	r3, r3, r3
     244:	e5823004 	str	r3, [r2, #4]
     248:	e3a03001 	mov	r3, #1	; 0x1
     24c:	e5823100 	str	r3, [r2, #256]
     250:	e12fff1e 	bx	lr
     254:	e01fc000 	ands	ip, pc, r0

00000258 <feed>:
     258:	e59f3010 	ldr	r3, [pc, #16]	; 270 <.text+0x270>
     25c:	e3a020aa 	mov	r2, #170	; 0xaa
     260:	e583208c 	str	r2, [r3, #140]
     264:	e3a02055 	mov	r2, #85	; 0x55
     268:	e583208c 	str	r2, [r3, #140]
}
     26c:	e12fff1e 	bx	lr
     270:	e01fc000 	ands	ip, pc, r0

00000274 <reset>:

void reset(void)
{
    // Intentionally fault Watchdog to trigger a reset condition
    WDMOD |= 3;
     274:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
     278:	e5923000 	ldr	r3, [r2]
     27c:	e3833003 	orr	r3, r3, #3	; 0x3
     280:	e5823000 	str	r3, [r2]
    WDFEED = 0xAA;
     284:	e3a010aa 	mov	r1, #170	; 0xaa
    WDFEED = 0x55;
     288:	e3a03055 	mov	r3, #85	; 0x55
     28c:	e5821008 	str	r1, [r2, #8]
     290:	e5823008 	str	r3, [r2, #8]
    WDFEED = 0xAA;
    WDFEED = 0x00;
     294:	e3a03000 	mov	r3, #0	; 0x0
     298:	e5821008 	str	r1, [r2, #8]
     29c:	e5823008 	str	r3, [r2, #8]
}
     2a0:	e12fff1e 	bx	lr

000002a4 <boot_up>:
     2a4:	e52de004 	str	lr, [sp, #-4]!
     2a8:	ebffffcd 	bl	1e4 <system_init>
     2ac:	e59f2060 	ldr	r2, [pc, #96]	; 314 <.text+0x314>
     2b0:	e5923008 	ldr	r3, [r2, #8]
     2b4:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
     2b8:	e5823008 	str	r3, [r2, #8]
     2bc:	e592300c 	ldr	r3, [r2, #12]
     2c0:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
     2c4:	e582300c 	str	r3, [r2, #12]
     2c8:	e59f1048 	ldr	r1, [pc, #72]	; 318 <.text+0x318>
     2cc:	e5913000 	ldr	r3, [r1]
     2d0:	e3833005 	orr	r3, r3, #5	; 0x5
     2d4:	e5813000 	str	r3, [r1]
     2d8:	e2422907 	sub	r2, r2, #114688	; 0x1c000
     2dc:	e3a03083 	mov	r3, #131	; 0x83
     2e0:	e582300c 	str	r3, [r2, #12]
     2e4:	e3a03000 	mov	r3, #0	; 0x0
     2e8:	e5823004 	str	r3, [r2, #4]
     2ec:	e2833020 	add	r3, r3, #32	; 0x20
     2f0:	e5823000 	str	r3, [r2]
     2f4:	e3a03003 	mov	r3, #3	; 0x3
     2f8:	e59f001c 	ldr	r0, [pc, #28]	; 31c <.text+0x31c>
     2fc:	e582300c 	str	r3, [r2, #12]
     300:	eb000020 	bl	388 <rprintf_devopen>
     304:	e59f0014 	ldr	r0, [pc, #20]	; 320 <.text+0x320>
     308:	eb000032 	bl	3d8 <rprintf>
     30c:	e49de004 	ldr	lr, [sp], #4
     310:	e12fff1e 	bx	lr
     314:	e0028000 	and	r8, r2, r0
     318:	e002c000 	and	ip, r2, r0
     31c:	000006e4 	andeq	r0, r0, r4, ror #13
     320:	00005d9c 	muleq	r0, ip, sp

00000324 <_read_r>:
	}
*/
//	return len - i;
	return 0;
}
     324:	e3a00000 	mov	r0, #0	; 0x0
     328:	e12fff1e 	bx	lr

0000032c <_write_r>:

_ssize_t _write_r (
    struct _reent *r, 
    int file, 
    const void *ptr, 
    size_t len)
{
/*
	int i;
	const unsigned char *p;
	
	p = (const unsigned char*) ptr;
	
	for (i = 0; i < len; i++) {
		if (*p == '\n' ) uart0Putch('\r');
		uart0Putch(*p++);
	}
*/
	return len;
}
     32c:	e1a00003 	mov	r0, r3
     330:	e12fff1e 	bx	lr

00000334 <_close_r>:

int _close_r(
    struct _reent *r, 
    int file)
{
	return 0;
}
     334:	e3a00000 	mov	r0, #0	; 0x0
     338:	e12fff1e 	bx	lr

0000033c <_lseek_r>:

_off_t _lseek_r(
    struct _reent *r, 
    int file, 
    _off_t ptr, 
    int dir)
{
	return (_off_t)0;	/*  Always indicate we are at file beginning.	*/
}
     33c:	e3a00000 	mov	r0, #0	; 0x0
     340:	e12fff1e 	bx	lr

00000344 <_fstat_r>:


int _fstat_r(
    struct _reent *r, 
    int file, 
    struct stat *st)
{
	/*  Always set as character device.				*/
	st->st_mode = S_IFCHR;	
     344:	e3a03a02 	mov	r3, #8192	; 0x2000
		/* assigned to strong type with implicit 	*/
		/* signed/unsigned conversion.  Required by 	*/
		/* newlib.					*/

	return 0;
}
     348:	e3a00000 	mov	r0, #0	; 0x0
     34c:	e5823004 	str	r3, [r2, #4]
     350:	e12fff1e 	bx	lr

00000354 <isatty>:

int isatty(int file); /* avoid warning */

int isatty(int file)
{
	return 1;
}
     354:	e3a00001 	mov	r0, #1	; 0x1
     358:	e12fff1e 	bx	lr

0000035c <_sbrk_r>:

#if 0
static void _exit (int n) {
label:  goto label; /* endless loop */
}
#endif 

/* "malloc clue function" */

	/**** Locally used variables. ****/
extern char end[];              /*  end is set in the linker command 	*/
				/* file and is the end of statically 	*/
				/* allocated data (thus start of heap).	*/

static char *heap_ptr;		/* Points to current end of the heap.	*/

/************************** _sbrk_r *************************************/
/*  Support function.  Adjusts end of heap to provide more memory to	*/
/* memory allocator. Simple and dumb with no sanity checks.		*/
/*  struct _reent *r	-- re-entrancy structure, used by newlib to 	*/
/*			support multiple threads of operation.		*/
/*  ptrdiff_t nbytes	-- number of bytes to add.			*/
/*  Returns pointer to start of new heap area.				*/
/*  Note:  This implementation is not thread safe (despite taking a	*/
/* _reent structure as a parameter).  					*/
/*  Since _s_r is not used in the current implementation, the following	*/
/* messages must be suppressed.						*/

void * _sbrk_r(
    struct _reent *_s_r, 
    ptrdiff_t nbytes)
{
	char  *base;		/*  errno should be set to  ENOMEM on error	*/

	if (!heap_ptr) {	/*  Initialize if first time through.		*/
     35c:	e59f201c 	ldr	r2, [pc, #28]	; 380 <.text+0x380>
     360:	e5923000 	ldr	r3, [r2]
     364:	e3530000 	cmp	r3, #0	; 0x0
		heap_ptr = end;
     368:	059f3014 	ldreq	r3, [pc, #20]	; 384 <.text+0x384>
     36c:	05823000 	streq	r3, [r2]
	}
	base = heap_ptr;	/*  Point to end of heap.			*/
     370:	e5920000 	ldr	r0, [r2]
	heap_ptr += nbytes;	/*  Increase heap.				*/
     374:	e0803001 	add	r3, r0, r1
     378:	e5823000 	str	r3, [r2]
	
	return base;		/*  Return pointer to start of new heap area.	*/
}
     37c:	e12fff1e 	bx	lr
     380:	40000acc 	andmi	r0, r0, ip, asr #21
     384:	40001234 	andmi	r1, r0, r4, lsr r2

00000388 <rprintf_devopen>:
static int (*putcharfunc)(int c);

void rprintf_devopen( int(*put)(int) )
{
    putcharfunc = put;
     388:	e59f3004 	ldr	r3, [pc, #4]	; 394 <.text+0x394>
     38c:	e5830000 	str	r0, [r3]
}
     390:	e12fff1e 	bx	lr
     394:	40000ad0 	ldrmid	r0, [r0], -r0

00000398 <myputchar>:

static void myputchar(unsigned char c)
{
     398:	e92d4010 	stmdb	sp!, {r4, lr}
     39c:	e20040ff 	and	r4, r0, #255	; 0xff
    if(c == '\n') putcharfunc('\r');
     3a0:	e354000a 	cmp	r4, #10	; 0xa
     3a4:	e3a0000d 	mov	r0, #13	; 0xd
     3a8:	059f3024 	ldreq	r3, [pc, #36]	; 3d4 <.text+0x3d4>
     3ac:	0593c000 	ldreq	ip, [r3]
     3b0:	01a0e00f 	moveq	lr, pc
     3b4:	012fff1c 	bxeq	ip
    putcharfunc(c);
     3b8:	e1a00004 	mov	r0, r4
     3bc:	e59f3010 	ldr	r3, [pc, #16]	; 3d4 <.text+0x3d4>
     3c0:	e593c000 	ldr	ip, [r3]
     3c4:	e1a0e00f 	mov	lr, pc
     3c8:	e12fff1c 	bx	ip
}
     3cc:	e8bd4010 	ldmia	sp!, {r4, lr}
     3d0:	e12fff1e 	bx	lr
     3d4:	40000ad0 	ldrmid	r0, [r0], -r0

000003d8 <rprintf>:

void rprintf(char const *format, ...)
{
     3d8:	e92d000f 	stmdb	sp!, {r0, r1, r2, r3}
     3dc:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
     3e0:	e24dd010 	sub	sp, sp, #16	; 0x10
    unsigned char scratch[SCRATCH];
    unsigned char format_flag;
    unsigned short base;
    unsigned char *ptr;
    unsigned char issigned=0;
    va_list ap;

    #ifdef USE_LONG
        // #warning "use long"
        unsigned char islong=0;
        unsigned long u_val=0;
        long s_val=0;
    #else
        unsigned int u_val=0;
        int s_val=0;
    #endif

    unsigned char fill;
    unsigned char width;

    va_start (ap, format);
     3e4:	e28d3030 	add	r3, sp, #48	; 0x30
     3e8:	e58d300c 	str	r3, [sp, #12]
     3ec:	e59d502c 	ldr	r5, [sp, #44]
    for (;;)
    {
		delay_ms(1); //Added for VCOM testing - without it, rprintf will overrun the VCOM buffer causing it to crash
     3f0:	e3a00001 	mov	r0, #1	; 0x1
     3f4:	ebffff70 	bl	1bc <delay_ms>
     3f8:	ea000002 	b	408 <rprintf+0x30>
		
        while ((format_flag = *(format++)) != '%')
        {      // Until '%' or '\0'
            if (!format_flag){va_end (ap); return;}
     3fc:	e3530000 	cmp	r3, #0	; 0x0
     400:	0a00008e 	beq	640 <rprintf+0x268>
                myputchar(format_flag);
     404:	ebffffe3 	bl	398 <myputchar>
     408:	e4d53001 	ldrb	r3, [r5], #1
     40c:	e3530025 	cmp	r3, #37	; 0x25
     410:	e1a00003 	mov	r0, r3
     414:	1afffff8 	bne	3fc <rprintf+0x24>
        }

        issigned=0; //default unsigned
        base = 10;

        format_flag = *format++; //get char after '%'
     418:	e4d52001 	ldrb	r2, [r5], #1

        #ifdef PADDING
            width=0; //no formatting
            fill=0;  //no formatting
            if(format_flag=='0' || format_flag==' ') //SPACE or ZERO padding  ?
     41c:	e3520020 	cmp	r2, #32	; 0x20
     420:	13520030 	cmpne	r2, #48	; 0x30
     424:	13a03000 	movne	r3, #0	; 0x0
     428:	03a03001 	moveq	r3, #1	; 0x1
     42c:	11a07003 	movne	r7, r3
     430:	11a00002 	movne	r0, r2
     434:	11a0a007 	movne	sl, r7
     438:	1a000007 	bne	45c <rprintf+0x84>
            {
                fill=format_flag;
                format_flag = *format++; //get char after padding char
     43c:	e4d50001 	ldrb	r0, [r5], #1
                if(format_flag>='0' && format_flag<='9')
     440:	e2403030 	sub	r3, r0, #48	; 0x30
     444:	e20370ff 	and	r7, r3, #255	; 0xff
     448:	e3570009 	cmp	r7, #9	; 0x9
                {
                    width=format_flag-'0';
                    format_flag = *format++; //get char after width char
     44c:	94d50001 	ldrlsb	r0, [r5], #1
     450:	81a0a002 	movhi	sl, r2
     454:	83a07000 	movhi	r7, #0	; 0x0
     458:	91a0a002 	movls	sl, r2
                }
            }
        #endif

        #ifdef USE_LONG
            islong=0; //default int value
            #ifdef USE_UPPER
            if(format_flag=='l' || format_flag=='L') //Long value
     45c:	e350004c 	cmp	r0, #76	; 0x4c
     460:	1350006c 	cmpne	r0, #108	; 0x6c
            #else
            if(format_flag=='l') //Long value
            #endif
        {
            islong=1;
            format_flag = *format++; //get char after 'l' or 'L'
     464:	04d50001 	ldreqb	r0, [r5], #1
     468:	13a03000 	movne	r3, #0	; 0x0
     46c:	03a03001 	moveq	r3, #1	; 0x1
     470:	03a03001 	moveq	r3, #1	; 0x1
        }
        #endif

        switch (format_flag)
     474:	e3500058 	cmp	r0, #88	; 0x58
     478:	0a00003e 	beq	578 <rprintf+0x1a0>
     47c:	8a00000b 	bhi	4b0 <rprintf+0xd8>
     480:	e3500049 	cmp	r0, #73	; 0x49
     484:	0a00006a 	beq	634 <rprintf+0x25c>
     488:	8a000003 	bhi	49c <rprintf+0xc4>
     48c:	e3500043 	cmp	r0, #67	; 0x43
     490:	0a000015 	beq	4ec <rprintf+0x114>
     494:	e3500044 	cmp	r0, #68	; 0x44
     498:	ea00000a 	b	4c8 <rprintf+0xf0>
     49c:	e3500053 	cmp	r0, #83	; 0x53
     4a0:	0a000017 	beq	504 <rprintf+0x12c>
     4a4:	e3500055 	cmp	r0, #85	; 0x55
     4a8:	1a000013 	bne	4fc <rprintf+0x124>
     4ac:	ea000020 	b	534 <rprintf+0x15c>
     4b0:	e3500069 	cmp	r0, #105	; 0x69
     4b4:	0a00005e 	beq	634 <rprintf+0x25c>
     4b8:	8a000004 	bhi	4d0 <rprintf+0xf8>
     4bc:	e3500063 	cmp	r0, #99	; 0x63
     4c0:	0a000009 	beq	4ec <rprintf+0x114>
     4c4:	e3500064 	cmp	r0, #100	; 0x64
     4c8:	1a00000b 	bne	4fc <rprintf+0x124>
     4cc:	ea000058 	b	634 <rprintf+0x25c>
     4d0:	e3500075 	cmp	r0, #117	; 0x75
     4d4:	0a000016 	beq	534 <rprintf+0x15c>
     4d8:	e3500078 	cmp	r0, #120	; 0x78
     4dc:	0a000025 	beq	578 <rprintf+0x1a0>
     4e0:	e3500073 	cmp	r0, #115	; 0x73
     4e4:	1a000004 	bne	4fc <rprintf+0x124>
     4e8:	ea000005 	b	504 <rprintf+0x12c>
        {
            #ifdef USE_CHAR
                case 'c':
                    #ifdef USE_UPPER
                    case 'C':
                #endif
                format_flag = va_arg(ap,int);
     4ec:	e59d200c 	ldr	r2, [sp, #12]
     4f0:	e2823004 	add	r3, r2, #4	; 0x4
     4f4:	e58d300c 	str	r3, [sp, #12]
     4f8:	e5d20000 	ldrb	r0, [r2]
                // no break -> run into default
            #endif

            default:
                myputchar(format_flag);
     4fc:	ebffffa5 	bl	398 <myputchar>
     500:	eaffffba 	b	3f0 <rprintf+0x18>
                continue;

                #ifdef USE_STRING
                    #ifdef USE_UPPER
                    case 'S':
                #endif
                case 's':
                ptr = (unsigned char*)va_arg(ap,char *);
     504:	e59d300c 	ldr	r3, [sp, #12]
     508:	e5936000 	ldr	r6, [r3]
     50c:	e3a04000 	mov	r4, #0	; 0x0
     510:	e2833004 	add	r3, r3, #4	; 0x4
     514:	e58d300c 	str	r3, [sp, #12]
     518:	ea000000 	b	520 <rprintf+0x148>
                while(*ptr) { myputchar(*ptr); ptr++; }
     51c:	ebffff9d 	bl	398 <myputchar>
     520:	e7d43006 	ldrb	r3, [r4, r6]
     524:	e2530000 	subs	r0, r3, #0	; 0x0
     528:	e2844001 	add	r4, r4, #1	; 0x1
     52c:	1afffffa 	bne	51c <rprintf+0x144>
     530:	eaffffae 	b	3f0 <rprintf+0x18>
                    continue;
                #endif

                #ifdef USE_OCTAL
                    case 'o':
                    #ifdef USE_UPPER
                    case 'O':
                #endif
                base = 8;
                myputchar('0');
                goto CONVERSION_LOOP;
                #endif

                #ifdef USE_INTEGER //don't use %i, is same as %d
                    case 'i':
                    #ifdef USE_UPPER
                    case 'I':
                #endif
                #endif
                case 'd':
                #ifdef USE_UPPER
                    case 'D':
                #endif
                issigned=1;
                // no break -> run into next case
            case 'u':
                #ifdef USE_UPPER
                    case 'U':
                #endif

                //don't insert some case below this if USE_HEX is undefined !
                //or put       goto CONVERSION_LOOP;  before next case.
                #ifdef USE_HEX
                    goto CONVERSION_LOOP;
                    case 'x':
                    #ifdef USE_UPPER
                    case 'X':
                #endif
                base = 16;
                #endif

                CONVERSION_LOOP:
     534:	e3a0800a 	mov	r8, #10	; 0xa
     538:	ea00000f 	b	57c <rprintf+0x1a4>

                if(issigned) //Signed types
                {
                    #ifdef USE_LONG
                        if(islong) { s_val = va_arg(ap,long); }
     53c:	e59d300c 	ldr	r3, [sp, #12]
     540:	e5934000 	ldr	r4, [r3]
     544:	e2833004 	add	r3, r3, #4	; 0x4
     548:	e58d300c 	str	r3, [sp, #12]
     54c:	ea000003 	b	560 <rprintf+0x188>
                            else { s_val = va_arg(ap,int); }
     550:	e59d200c 	ldr	r2, [sp, #12]
     554:	e2823004 	add	r3, r2, #4	; 0x4
     558:	e58d300c 	str	r3, [sp, #12]
     55c:	e5924000 	ldr	r4, [r2]
                        #else
                        s_val = va_arg(ap,int);
                    #endif

                    if(s_val < 0) //Value negativ ?
     560:	e3540000 	cmp	r4, #0	; 0x0
                    {
                        s_val = - s_val; //Make it positiv
                        myputchar('-');    //Output sign
     564:	b3a0002d 	movlt	r0, #45	; 0x2d
     568:	b2644000 	rsblt	r4, r4, #0	; 0x0
     56c:	bbffff89 	bllt	398 <myputchar>
                    }

                    u_val = (unsigned long)s_val;
     570:	e3a0800a 	mov	r8, #10	; 0xa
     574:	ea000008 	b	59c <rprintf+0x1c4>
     578:	e3a08010 	mov	r8, #16	; 0x10
     57c:	e59d200c 	ldr	r2, [sp, #12]
                }
                else //Unsigned types
                {
                    #ifdef USE_LONG
                        if(islong) { u_val = va_arg(ap,unsigned long); }
     580:	e3530000 	cmp	r3, #0	; 0x0
     584:	12823004 	addne	r3, r2, #4	; 0x4
                            else { u_val = va_arg(ap,unsigned int); }
     588:	02823004 	addeq	r3, r2, #4	; 0x4
     58c:	15924000 	ldrne	r4, [r2]
     590:	158d300c 	strne	r3, [sp, #12]
     594:	058d300c 	streq	r3, [sp, #12]
     598:	05924000 	ldreq	r4, [r2]
                        #else
                        u_val = va_arg(ap,unsigned int);
                    #endif
                }

                ptr = scratch + SCRATCH;
                *--ptr = 0;
     59c:	e3a03000 	mov	r3, #0	; 0x0
     5a0:	e5cd300b 	strb	r3, [sp, #11]
     5a4:	e28d600b 	add	r6, sp, #11	; 0xb
                do
                {
                    char ch = u_val % base + '0';
     5a8:	e1a00004 	mov	r0, r4
     5ac:	e1a01008 	mov	r1, r8
     5b0:	eb00158d 	bl	5bec <__umodsi3>
     5b4:	e2800030 	add	r0, r0, #48	; 0x30
     5b8:	e20030ff 	and	r3, r0, #255	; 0xff
                    #ifdef USE_HEX
                        if (ch > '9')
     5bc:	e3530039 	cmp	r3, #57	; 0x39
                        {
                            ch += 'a' - '9' - 1;
                            #ifdef USE_UPPERHEX
                            ch-=0x20;
     5c0:	e2832007 	add	r2, r3, #7	; 0x7
     5c4:	820230ff 	andhi	r3, r2, #255	; 0xff
                        #endif
                    }
                    #endif
                    *--ptr = ch;
     5c8:	e5463001 	strb	r3, [r6, #-1]
                    u_val /= base;
     5cc:	e1a00004 	mov	r0, r4
     5d0:	e1a01008 	mov	r1, r8
     5d4:	eb0014ee 	bl	5994 <__aeabi_uidiv>

                    #ifdef PADDING
                        if(width) width--; //calculate number of padding chars
     5d8:	e3570000 	cmp	r7, #0	; 0x0
     5dc:	e2473001 	sub	r3, r7, #1	; 0x1
     5e0:	120370ff 	andne	r7, r3, #255	; 0xff
                    #endif
                }
                while (u_val);
     5e4:	e3500000 	cmp	r0, #0	; 0x0
     5e8:	e2466001 	sub	r6, r6, #1	; 0x1
     5ec:	e1a04000 	mov	r4, r0
     5f0:	1affffec 	bne	5a8 <rprintf+0x1d0>
     5f4:	e1a01007 	mov	r1, r7
     5f8:	e1a02006 	mov	r2, r6
     5fc:	ea000000 	b	604 <rprintf+0x22c>

                #ifdef PADDING
                    while(width--) *--ptr = fill; //insert padding chars
     600:	e562a001 	strb	sl, [r2, #-1]!
     604:	e2473001 	sub	r3, r7, #1	; 0x1
     608:	e20370ff 	and	r7, r3, #255	; 0xff
     60c:	e35700ff 	cmp	r7, #255	; 0xff
     610:	1afffffa 	bne	600 <rprintf+0x228>
     614:	e0614006 	rsb	r4, r1, r6
     618:	ea000000 	b	620 <rprintf+0x248>
                #endif

                while(*ptr) { myputchar(*ptr); ptr++; }
     61c:	ebffff5d 	bl	398 <myputchar>
     620:	e5d43000 	ldrb	r3, [r4]
     624:	e2530000 	subs	r0, r3, #0	; 0x0
     628:	e2844001 	add	r4, r4, #1	; 0x1
     62c:	1afffffa 	bne	61c <rprintf+0x244>
     630:	eaffff6e 	b	3f0 <rprintf+0x18>
     634:	e3530000 	cmp	r3, #0	; 0x0
     638:	1affffbf 	bne	53c <rprintf+0x164>
     63c:	eaffffc3 	b	550 <rprintf+0x178>
                    }
        }
    }
     640:	e28dd010 	add	sp, sp, #16	; 0x10
     644:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
     648:	e28dd010 	add	sp, sp, #16	; 0x10
     64c:	e12fff1e 	bx	lr

00000650 <init_serial0>:
void init_serial0 ( unsigned long baudrate )
{
    unsigned long Fdiv;

    PINSEL0 = 0x00000005;                  /* Enable RxD0 and TxD0              */
     650:	e59f3040 	ldr	r3, [pc, #64]	; 698 <.text+0x698>
     654:	e92d4010 	stmdb	sp!, {r4, lr}
     658:	e3a02005 	mov	r2, #5	; 0x5
    U0LCR = 0x83;                          /* 8 bits, no Parity, 1 Stop bit     */
     65c:	e59f4038 	ldr	r4, [pc, #56]	; 69c <.text+0x69c>
     660:	e5832000 	str	r2, [r3]
     664:	e3a03083 	mov	r3, #131	; 0x83
     668:	e1a01000 	mov	r1, r0
     66c:	e584300c 	str	r3, [r4, #12]
    Fdiv = ( Fpclk / 16 ) / baudrate ;     /* baud rate                        */
     670:	e59f0028 	ldr	r0, [pc, #40]	; 6a0 <.text+0x6a0>
     674:	eb0014c6 	bl	5994 <__aeabi_uidiv>
    U0DLM = Fdiv / 256;
    U0DLL = Fdiv % 256;
     678:	e20030ff 	and	r3, r0, #255	; 0xff
     67c:	e1a00420 	mov	r0, r0, lsr #8
     680:	e5840004 	str	r0, [r4, #4]
     684:	e5843000 	str	r3, [r4]
    U0LCR = 0x03;                           /* DLAB = 0                         */
     688:	e3a03003 	mov	r3, #3	; 0x3
     68c:	e584300c 	str	r3, [r4, #12]
}
     690:	e8bd4010 	ldmia	sp!, {r4, lr}
     694:	e12fff1e 	bx	lr
     698:	e002c000 	and	ip, r2, r0
     69c:	e000c000 	and	ip, r0, r0
     6a0:	000e4e1c 	andeq	r4, lr, ip, lsl lr

000006a4 <putchar_serial0>:

/* Write character to Serial Port 0 with \n -> \r\n  */
int putchar_serial0 (int ch)
{
    if (ch == '\n')
     6a4:	e350000a 	cmp	r0, #10	; 0xa
     6a8:	1a000005 	bne	6c4 <putchar_serial0+0x20>
    {
        while (!(U0LSR & 0x20));
     6ac:	e59f202c 	ldr	r2, [pc, #44]	; 6e0 <.text+0x6e0>
     6b0:	e5923014 	ldr	r3, [r2, #20]
     6b4:	e3130020 	tst	r3, #32	; 0x20
     6b8:	0afffffb 	beq	6ac <putchar_serial0+0x8>
        U0THR = CR;                  /* output CR */
     6bc:	e3a0300d 	mov	r3, #13	; 0xd
     6c0:	e5823000 	str	r3, [r2]
    }
    while (!(U0LSR & 0x20));
     6c4:	e59f2014 	ldr	r2, [pc, #20]	; 6e0 <.text+0x6e0>
     6c8:	e5923014 	ldr	r3, [r2, #20]
     6cc:	e3130020 	tst	r3, #32	; 0x20
     6d0:	0afffffb 	beq	6c4 <putchar_serial0+0x20>
    return (U0THR = ch);
     6d4:	e5820000 	str	r0, [r2]
     6d8:	e5920000 	ldr	r0, [r2]
}
     6dc:	e12fff1e 	bx	lr
     6e0:	e000c000 	and	ip, r0, r0

000006e4 <putc_serial0>:

/* Write character to Serial Port 0 without \n -> \r\n  */
int putc_serial0 (int ch)
{
    while (!(U0LSR & 0x20));
     6e4:	e59f2014 	ldr	r2, [pc, #20]	; 700 <.text+0x700>
     6e8:	e5923014 	ldr	r3, [r2, #20]
     6ec:	e3130020 	tst	r3, #32	; 0x20
     6f0:	0afffffb 	beq	6e4 <putc_serial0>
    return (U0THR = ch);
     6f4:	e5820000 	str	r0, [r2]
     6f8:	e5920000 	ldr	r0, [r2]
}
     6fc:	e12fff1e 	bx	lr
     700:	e000c000 	and	ip, r0, r0

00000704 <putstring_serial0>:


void putstring_serial0 (const char *string)
{
     704:	e92d4010 	stmdb	sp!, {r4, lr}
     708:	e1a04000 	mov	r4, r0
     70c:	ea000000 	b	714 <putstring_serial0+0x10>
    char ch;

    while ((ch = *string))
    {
        putchar_serial0(ch);
     710:	ebffffe3 	bl	6a4 <putchar_serial0>
     714:	e5d43000 	ldrb	r3, [r4]
     718:	e2530000 	subs	r0, r3, #0	; 0x0
        string++;
     71c:	e2844001 	add	r4, r4, #1	; 0x1
     720:	1afffffa 	bne	710 <putstring_serial0+0xc>
    }
}
     724:	e8bd4010 	ldmia	sp!, {r4, lr}
     728:	e12fff1e 	bx	lr

0000072c <getkey_serial0>:


/* Read character from Serial Port   */
int getkey_serial0 (void)
{
	if (U0LSR & 0x01)
     72c:	e59f2010 	ldr	r2, [pc, #16]	; 744 <.text+0x744>
     730:	e5923014 	ldr	r3, [r2, #20]
     734:	e2133001 	ands	r3, r3, #1	; 0x1
     738:	e1a00003 	mov	r0, r3
    {
        return (U0RBR);
     73c:	15920000 	ldrne	r0, [r2]
    }
    else
    {
        return 0;
    }
}
     740:	e12fff1e 	bx	lr
     744:	e000c000 	and	ip, r0, r0

00000748 <getc0>:

/* Read character from Serial Port   */
int getc0 (void)
{
	while ( (U0LSR & 0x01) == 0 ); //Wait for character
     748:	e59f2010 	ldr	r2, [pc, #16]	; 760 <.text+0x760>
     74c:	e5923014 	ldr	r3, [r2, #20]
     750:	e3130001 	tst	r3, #1	; 0x1
     754:	0afffffb 	beq	748 <getc0>
	return U0RBR;
     758:	e5920000 	ldr	r0, [r2]
}
     75c:	e12fff1e 	bx	lr
     760:	e000c000 	and	ip, r0, r0

00000764 <call_firmware>:
    return 0;
}

void call_firmware(void)
{
     764:	e52de004 	str	lr, [sp, #-4]!
    /* Note that we're calling a routine that *SHOULD*
           * re-init the stack... so this function should never return...
           */
    void(*fncall)(void)=(void*)STARTADDR;
    fncall();
     768:	e3a03801 	mov	r3, #65536	; 0x10000
     76c:	e1a0e00f 	mov	lr, pc
     770:	e12fff13 	bx	r3

}
     774:	e49de004 	ldr	lr, [sp], #4
     778:	e12fff1e 	bx	lr

0000077c <load_fw>:
     77c:	e59f2130 	ldr	r2, [pc, #304]	; 8b4 <.text+0x8b4>
     780:	e3a03009 	mov	r3, #9	; 0x9
     784:	e5823004 	str	r3, [r2, #4]
     788:	e2833011 	add	r3, r3, #17	; 0x11
     78c:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     790:	e5823008 	str	r3, [r2, #8]
     794:	e1a08000 	mov	r8, r0
     798:	e59f4118 	ldr	r4, [pc, #280]	; 8b8 <.text+0x8b8>
     79c:	e1a00002 	mov	r0, r2
     7a0:	e59f1114 	ldr	r1, [pc, #276]	; 8bc <.text+0x8bc>
     7a4:	e594c000 	ldr	ip, [r4]
     7a8:	e1a0e00f 	mov	lr, pc
     7ac:	e12fff1c 	bx	ip
     7b0:	e59f1104 	ldr	r1, [pc, #260]	; 8bc <.text+0x8bc>
     7b4:	e59f0104 	ldr	r0, [pc, #260]	; 8c0 <.text+0x8c0>
     7b8:	e594c000 	ldr	ip, [r4]
     7bc:	e1a0e00f 	mov	lr, pc
     7c0:	e12fff1c 	bx	ip
     7c4:	e1a00008 	mov	r0, r8
     7c8:	eb00010a 	bl	bf8 <root_open>
     7cc:	e59f20f0 	ldr	r2, [pc, #240]	; 8c4 <.text+0x8c4>
     7d0:	e1a07000 	mov	r7, r0
     7d4:	e3a03000 	mov	r3, #0	; 0x0
     7d8:	e4c23001 	strb	r3, [r2], #1
     7dc:	e59f30e4 	ldr	r3, [pc, #228]	; 8c8 <.text+0x8c8>
     7e0:	e1520003 	cmp	r2, r3
     7e4:	1afffffa 	bne	7d4 <load_fw+0x58>
     7e8:	e3a06801 	mov	r6, #65536	; 0x10000
     7ec:	ea000021 	b	878 <load_fw+0xfc>
     7f0:	e3560a79 	cmp	r6, #495616	; 0x79000
     7f4:	a2463a79 	subge	r3, r6, #495616	; 0x79000
     7f8:	b2463902 	sublt	r3, r6, #32768	; 0x8000
     7fc:	a1a03643 	movge	r3, r3, asr #12
     800:	b1a037c3 	movlt	r3, r3, asr #15
     804:	a2832017 	addge	r2, r3, #23	; 0x17
     808:	b2832008 	addlt	r2, r3, #8	; 0x8
     80c:	e59f30a0 	ldr	r3, [pc, #160]	; 8b4 <.text+0x8b4>
     810:	e59f10a4 	ldr	r1, [pc, #164]	; 8bc <.text+0x8bc>
     814:	e1a00003 	mov	r0, r3
     818:	e5832008 	str	r2, [r3, #8]
     81c:	e5832004 	str	r2, [r3, #4]
     820:	e59f5090 	ldr	r5, [pc, #144]	; 8b8 <.text+0x8b8>
     824:	e595c000 	ldr	ip, [r5]
     828:	e1a0e00f 	mov	lr, pc
     82c:	e12fff1c 	bx	ip
     830:	e59f408c 	ldr	r4, [pc, #140]	; 8c4 <.text+0x8c4>
     834:	e59f0090 	ldr	r0, [pc, #144]	; 8cc <.text+0x8cc>
     838:	e3a03c02 	mov	r3, #512	; 0x200
     83c:	e580300c 	str	r3, [r0, #12]
     840:	e5806004 	str	r6, [r0, #4]
     844:	e5804008 	str	r4, [r0, #8]
     848:	e59f106c 	ldr	r1, [pc, #108]	; 8bc <.text+0x8bc>
     84c:	e595c000 	ldr	ip, [r5]
     850:	e1a0e00f 	mov	lr, pc
     854:	e12fff1c 	bx	ip
     858:	e3a03000 	mov	r3, #0	; 0x0
     85c:	e4c43001 	strb	r3, [r4], #1
     860:	e59f3060 	ldr	r3, [pc, #96]	; 8c8 <.text+0x8c8>
     864:	e1540003 	cmp	r4, r3
     868:	1afffffa 	bne	858 <load_fw+0xdc>
     86c:	e2866c02 	add	r6, r6, #512	; 0x200
     870:	e3560a7d 	cmp	r6, #512000	; 0x7d000
     874:	0a000006 	beq	894 <load_fw+0x118>
     878:	e1a00007 	mov	r0, r7
     87c:	e59f1040 	ldr	r1, [pc, #64]	; 8c4 <.text+0x8c4>
     880:	e3a02c02 	mov	r2, #512	; 0x200
     884:	eb000592 	bl	1ed4 <fat16_read_file>
     888:	e1a00800 	mov	r0, r0, lsl #16
     88c:	e3500000 	cmp	r0, #0	; 0x0
     890:	caffffd6 	bgt	7f0 <load_fw+0x74>
     894:	eb00030c 	bl	14cc <sd_raw_sync>
     898:	e1a00007 	mov	r0, r7
     89c:	eb0008cb 	bl	2bd0 <fat16_close_file>
     8a0:	e1a00008 	mov	r0, r8
     8a4:	eb000016 	bl	904 <root_delete>
     8a8:	e3a00000 	mov	r0, #0	; 0x0
     8ac:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
     8b0:	e12fff1e 	bx	lr
     8b4:	40000204 	andmi	r0, r0, r4, lsl #4
     8b8:	40000200 	andmi	r0, r0, r0, lsl #4
     8bc:	400011f0 	strmid	r1, [r0], -r0
     8c0:	4000022c 	andmi	r0, r0, ip, lsr #4
     8c4:	40000ff0 	strmid	r0, [r0], -r0
     8c8:	400011f0 	strmid	r1, [r0], -r0
     8cc:	40000218 	andmi	r0, r0, r8, lsl r2

000008d0 <root_file_exists>:

/* returns 1 if file exists, 0 else */
int root_file_exists(char* name)
{
    return(find_file_in_dir(fs,dd,name,&dir_entry));
     8d0:	e59f3020 	ldr	r3, [pc, #32]	; 8f8 <.text+0x8f8>
     8d4:	e5931000 	ldr	r1, [r3]
     8d8:	e59f301c 	ldr	r3, [pc, #28]	; 8fc <.text+0x8fc>
     8dc:	e1a02000 	mov	r2, r0
     8e0:	e52de004 	str	lr, [sp, #-4]!
     8e4:	e5930000 	ldr	r0, [r3]
     8e8:	e59f3010 	ldr	r3, [pc, #16]	; 900 <.text+0x900>
     8ec:	eb0006e3 	bl	2480 <find_file_in_dir>
}
     8f0:	e49de004 	ldr	lr, [sp], #4
     8f4:	e12fff1e 	bx	lr
     8f8:	40001230 	andmi	r1, r0, r0, lsr r2
     8fc:	400011f8 	strmid	r1, [r0], -r8
     900:	400011fc 	strmid	r1, [r0], -ip

00000904 <root_delete>:

/* returns NULL if error, pointer if file opened */
struct fat16_file_struct * root_open_new(char* name)
{
    if(fat16_create_file(dd,name,&dir_entry))
    {
        return(open_file_in_dir(fs,dd,name));
    }
    else
    {
        return NULL;
    }
}

struct fat16_file_struct * root_open(char* name)
{
    return(open_file_in_dir(fs,dd,name));
}

uint8_t print_disk_info(const struct fat16_fs_struct* disk_fs)
{
    if(!disk_fs)
        return 0;

    struct sd_raw_info disk_info;
    if(!sd_raw_get_info(&disk_info))
        return 0;

//    int temp = get_output();
//    set_output(UART_ONLY);
    rprintf("manuf:  0x%02x\n\r", disk_info.manufacturer);
    rprintf("oem:    %s\n\r", disk_info.oem);
    rprintf("prod:   %s\n\r", disk_info.product);
    rprintf("rev:    %02x\n\r", disk_info.revision);
    rprintf("serial: 0x%08lx\n\r", disk_info.serial);
    rprintf("date:   %02d/%02d\n\r", disk_info.manufacturing_month, disk_info.manufacturing_year);
    rprintf("size:   %ld\n\r", disk_info.capacity);
    rprintf("copy:   %d\n\r", disk_info.flag_copy);
    rprintf("wr.pr.: %d/%d\n\r", disk_info.flag_write_protect_temp, disk_info.flag_write_protect);
    rprintf("format: %d\n\r", disk_info.format);
    rprintf("free:   %ld/%ld\n\r", fat16_get_fs_free(disk_fs), fat16_get_fs_size(disk_fs));
//    set_output(temp);
    return 1;
}

void root_disk_info(void)
{
    print_disk_info(fs);
}

/* sequential calls return sequential characters
 * of the sequence of file names in the rootdir
 * in place of '\0' it returns ',' only
 * returning a zero when the end of all files
 * has been reached.
 *
 * Assert (1) reset whenever you want to re-start
 */
char rootDirectory_files_stream(int reset)
{

    static int idx = 0;

    /* If reset, we need to reset the dir */
    if(reset)
    {
        fat16_reset_dir(dd);
        return 0;
    }

    /* Whenever IDX is zero, we're gonna start a new file,
       * so read a new one.
       * if there's no new file,
       * return 0, because it's over
       */
    if(idx == 0)
    {
        if(fat16_read_dir(dd,&dir_entry)==0)
        {
            return '\0';
        }
    }

    /* If we've reached the end of a string,
       * return comma instead of \0,
       * so the list is comma delimited,
       * and terminated with a zero
       */
    if(dir_entry.long_name[idx]=='\0')
    {
        idx = 0;
        return ',';
    }


    return dir_entry.long_name[idx++];

}
//Description: Fills buf with len number of chars.  Returns the number of files
//				that were cycled through during the read
//Pre: buf is an array of characters at least as big as len
//		len is the size of the array to read
//Post: buf contains the characters of the filenames in Root, starting at the first file
//		and ending after len characters
int rootDirectory_files(char* buf, int len)
{
    int i;
    int num=0;
    /* Loop will walk through every file in directory dd */
    fat16_reset_dir(dd);
    while(fat16_read_dir(dd,&dir_entry))
    {
        i = 0;
        /* Spin through the filename */
        while(dir_entry.long_name[i]!='\0')
        {
            /* And copy each character into buf */
            *buf++=dir_entry.long_name[i++];
            len--;
            if(len==1)
            {
                /* Buf if we ever get to the end of buf, quit */
                *buf='\0';
                return 1;
            }
        }
        *buf++=',';
        num++;
        len--;
        if(len==1)
        {
            /* Buf if we ever get to the end of buf, quit */
            *buf='\0';
            return 1;
        }
    }
    *buf='\0';
    return num;
}

void root_format(void)
{
    fat16_reset_dir(dd);
    while(fat16_read_dir(dd,&dir_entry))
    {
        fat16_delete_file(fs,&dir_entry);
        fat16_reset_dir(dd);
    }
}

int root_delete(char* filename)
{
     904:	e92d4010 	stmdb	sp!, {r4, lr}
    if(find_file_in_dir(fs,dd,filename,&dir_entry))
     908:	e59f3038 	ldr	r3, [pc, #56]	; 948 <.text+0x948>
     90c:	e59f4038 	ldr	r4, [pc, #56]	; 94c <.text+0x94c>
     910:	e5931000 	ldr	r1, [r3]
     914:	e1a02000 	mov	r2, r0
     918:	e59f3030 	ldr	r3, [pc, #48]	; 950 <.text+0x950>
     91c:	e5940000 	ldr	r0, [r4]
     920:	eb0006d6 	bl	2480 <find_file_in_dir>
     924:	e3500000 	cmp	r0, #0	; 0x0
    {
        fat16_delete_file(fs,&dir_entry);
     928:	e59f1020 	ldr	r1, [pc, #32]	; 950 <.text+0x950>
     92c:	e3a00001 	mov	r0, #1	; 0x1
     930:	0a000002 	beq	940 <root_delete+0x3c>
     934:	e5940000 	ldr	r0, [r4]
     938:	eb0005d3 	bl	208c <fat16_delete_file>
     93c:	e3a00000 	mov	r0, #0	; 0x0
        return 0;
    }
    return 1;
}
     940:	e8bd4010 	ldmia	sp!, {r4, lr}
     944:	e12fff1e 	bx	lr
     948:	40001230 	andmi	r1, r0, r0, lsr r2
     94c:	400011f8 	strmid	r1, [r0], -r8
     950:	400011fc 	strmid	r1, [r0], -ip

00000954 <root_format>:
     954:	e92d4010 	stmdb	sp!, {r4, lr}
     958:	e59f303c 	ldr	r3, [pc, #60]	; 99c <.text+0x99c>
     95c:	e5930000 	ldr	r0, [r3]
     960:	ea000003 	b	974 <root_format+0x20>
     964:	e59f3034 	ldr	r3, [pc, #52]	; 9a0 <.text+0x9a0>
     968:	e5930000 	ldr	r0, [r3]
     96c:	eb0005c6 	bl	208c <fat16_delete_file>
     970:	e5940000 	ldr	r0, [r4]
     974:	e59f4020 	ldr	r4, [pc, #32]	; 99c <.text+0x99c>
     978:	eb0005bc 	bl	2070 <fat16_reset_dir>
     97c:	e59f1020 	ldr	r1, [pc, #32]	; 9a4 <.text+0x9a4>
     980:	e5940000 	ldr	r0, [r4]
     984:	eb000637 	bl	2268 <fat16_read_dir>
     988:	e3500000 	cmp	r0, #0	; 0x0
     98c:	e59f1010 	ldr	r1, [pc, #16]	; 9a4 <.text+0x9a4>
     990:	1afffff3 	bne	964 <root_format+0x10>
     994:	e8bd4010 	ldmia	sp!, {r4, lr}
     998:	e12fff1e 	bx	lr
     99c:	40001230 	andmi	r1, r0, r0, lsr r2
     9a0:	400011f8 	strmid	r1, [r0], -r8
     9a4:	400011fc 	strmid	r1, [r0], -ip

000009a8 <rootDirectory_files>:
     9a8:	e59f30a0 	ldr	r3, [pc, #160]	; a50 <.text+0xa50>
     9ac:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
     9b0:	e1a04000 	mov	r4, r0
     9b4:	e5930000 	ldr	r0, [r3]
     9b8:	e1a05001 	mov	r5, r1
     9bc:	eb0005ab 	bl	2070 <fat16_reset_dir>
     9c0:	e3a06000 	mov	r6, #0	; 0x0
     9c4:	ea000017 	b	a28 <rootDirectory_files+0x80>
     9c8:	e3520001 	cmp	r2, #1	; 0x1
     9cc:	e5c41000 	strb	r1, [r4]
     9d0:	e1a04000 	mov	r4, r0
     9d4:	1a000004 	bne	9ec <rootDirectory_files+0x44>
     9d8:	e3a03000 	mov	r3, #0	; 0x0
     9dc:	e1a06002 	mov	r6, r2
     9e0:	e5c03000 	strb	r3, [r0]
     9e4:	ea000016 	b	a44 <rootDirectory_files+0x9c>
     9e8:	e59f3064 	ldr	r3, [pc, #100]	; a54 <.text+0xa54>
     9ec:	e5d31000 	ldrb	r1, [r3]
     9f0:	e2452001 	sub	r2, r5, #1	; 0x1
     9f4:	e3510000 	cmp	r1, #0	; 0x0
     9f8:	e2833001 	add	r3, r3, #1	; 0x1
     9fc:	e1a05002 	mov	r5, r2
     a00:	e2840001 	add	r0, r4, #1	; 0x1
     a04:	1affffef 	bne	9c8 <rootDirectory_files+0x20>
     a08:	e3a0302c 	mov	r3, #44	; 0x2c
     a0c:	e3520001 	cmp	r2, #1	; 0x1
     a10:	e5c43000 	strb	r3, [r4]
     a14:	e1a04000 	mov	r4, r0
     a18:	01a06002 	moveq	r6, r2
     a1c:	05c01000 	streqb	r1, [r0]
     a20:	0a000007 	beq	a44 <rootDirectory_files+0x9c>
     a24:	e2866001 	add	r6, r6, #1	; 0x1
     a28:	e59f3020 	ldr	r3, [pc, #32]	; a50 <.text+0xa50>
     a2c:	e59f1020 	ldr	r1, [pc, #32]	; a54 <.text+0xa54>
     a30:	e5930000 	ldr	r0, [r3]
     a34:	eb00060b 	bl	2268 <fat16_read_dir>
     a38:	e3500000 	cmp	r0, #0	; 0x0
     a3c:	1affffe9 	bne	9e8 <rootDirectory_files+0x40>
     a40:	e5c40000 	strb	r0, [r4]
     a44:	e1a00006 	mov	r0, r6
     a48:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
     a4c:	e12fff1e 	bx	lr
     a50:	40001230 	andmi	r1, r0, r0, lsr r2
     a54:	400011fc 	strmid	r1, [r0], -ip

00000a58 <rootDirectory_files_stream>:
     a58:	e3500000 	cmp	r0, #0	; 0x0
     a5c:	e52de004 	str	lr, [sp, #-4]!
     a60:	0a000004 	beq	a78 <rootDirectory_files_stream+0x20>
     a64:	e59f3064 	ldr	r3, [pc, #100]	; ad0 <.text+0xad0>
     a68:	e5930000 	ldr	r0, [r3]
     a6c:	eb00057f 	bl	2070 <fat16_reset_dir>
     a70:	e3a00000 	mov	r0, #0	; 0x0
     a74:	ea000013 	b	ac8 <rootDirectory_files_stream+0x70>
     a78:	e59f3054 	ldr	r3, [pc, #84]	; ad4 <.text+0xad4>
     a7c:	e5933000 	ldr	r3, [r3]
     a80:	e3530000 	cmp	r3, #0	; 0x0
     a84:	e59f104c 	ldr	r1, [pc, #76]	; ad8 <.text+0xad8>
     a88:	1a000004 	bne	aa0 <rootDirectory_files_stream+0x48>
     a8c:	e59f303c 	ldr	r3, [pc, #60]	; ad0 <.text+0xad0>
     a90:	e5930000 	ldr	r0, [r3]
     a94:	eb0005f3 	bl	2268 <fat16_read_dir>
     a98:	e3500000 	cmp	r0, #0	; 0x0
     a9c:	0a000009 	beq	ac8 <rootDirectory_files_stream+0x70>
     aa0:	e59f102c 	ldr	r1, [pc, #44]	; ad4 <.text+0xad4>
     aa4:	e59f302c 	ldr	r3, [pc, #44]	; ad8 <.text+0xad8>
     aa8:	e5912000 	ldr	r2, [r1]
     aac:	e7d33002 	ldrb	r3, [r3, r2]
     ab0:	e2822001 	add	r2, r2, #1	; 0x1
     ab4:	e3530000 	cmp	r3, #0	; 0x0
     ab8:	05813000 	streq	r3, [r1]
     abc:	15812000 	strne	r2, [r1]
     ac0:	e3a0002c 	mov	r0, #44	; 0x2c
     ac4:	11a00003 	movne	r0, r3
     ac8:	e49de004 	ldr	lr, [sp], #4
     acc:	e12fff1e 	bx	lr
     ad0:	40001230 	andmi	r1, r0, r0, lsr r2
     ad4:	40000ad4 	ldrmid	r0, [r0], -r4
     ad8:	400011fc 	strmid	r1, [r0], -ip

00000adc <print_disk_info>:
     adc:	e92d4030 	stmdb	sp!, {r4, r5, lr}
     ae0:	e2505000 	subs	r5, r0, #0	; 0x0
     ae4:	e24dd01c 	sub	sp, sp, #28	; 0x1c
     ae8:	e1a0400d 	mov	r4, sp
     aec:	e1a0000d 	mov	r0, sp
     af0:	0a00002d 	beq	bac <print_disk_info+0xd0>
     af4:	eb0000f2 	bl	ec4 <sd_raw_get_info>
     af8:	e3500000 	cmp	r0, #0	; 0x0
     afc:	e59f00b8 	ldr	r0, [pc, #184]	; bbc <.text+0xbbc>
     b00:	0a000029 	beq	bac <print_disk_info+0xd0>
     b04:	e5dd1000 	ldrb	r1, [sp]
     b08:	ebfffe32 	bl	3d8 <rprintf>
     b0c:	e59f00ac 	ldr	r0, [pc, #172]	; bc0 <.text+0xbc0>
     b10:	e28d1001 	add	r1, sp, #1	; 0x1
     b14:	ebfffe2f 	bl	3d8 <rprintf>
     b18:	e28d1004 	add	r1, sp, #4	; 0x4
     b1c:	e59f00a0 	ldr	r0, [pc, #160]	; bc4 <.text+0xbc4>
     b20:	ebfffe2c 	bl	3d8 <rprintf>
     b24:	e59f009c 	ldr	r0, [pc, #156]	; bc8 <.text+0xbc8>
     b28:	e5dd100a 	ldrb	r1, [sp, #10]
     b2c:	ebfffe29 	bl	3d8 <rprintf>
     b30:	e59f0094 	ldr	r0, [pc, #148]	; bcc <.text+0xbcc>
     b34:	e59d100c 	ldr	r1, [sp, #12]
     b38:	ebfffe26 	bl	3d8 <rprintf>
     b3c:	e5dd2010 	ldrb	r2, [sp, #16]
     b40:	e59f0088 	ldr	r0, [pc, #136]	; bd0 <.text+0xbd0>
     b44:	e5dd1011 	ldrb	r1, [sp, #17]
     b48:	ebfffe22 	bl	3d8 <rprintf>
     b4c:	e59f0080 	ldr	r0, [pc, #128]	; bd4 <.text+0xbd4>
     b50:	e59d1014 	ldr	r1, [sp, #20]
     b54:	ebfffe1f 	bl	3d8 <rprintf>
     b58:	e59f0078 	ldr	r0, [pc, #120]	; bd8 <.text+0xbd8>
     b5c:	e5dd1018 	ldrb	r1, [sp, #24]
     b60:	ebfffe1c 	bl	3d8 <rprintf>
     b64:	e5dd2019 	ldrb	r2, [sp, #25]
     b68:	e59f006c 	ldr	r0, [pc, #108]	; bdc <.text+0xbdc>
     b6c:	e5dd101a 	ldrb	r1, [sp, #26]
     b70:	ebfffe18 	bl	3d8 <rprintf>
     b74:	e5dd101b 	ldrb	r1, [sp, #27]
     b78:	e59f0060 	ldr	r0, [pc, #96]	; be0 <.text+0xbe0>
     b7c:	ebfffe15 	bl	3d8 <rprintf>
     b80:	e1a00005 	mov	r0, r5
     b84:	eb000574 	bl	215c <fat16_get_fs_free>
     b88:	e1a04000 	mov	r4, r0
     b8c:	e1a00005 	mov	r0, r5
     b90:	eb000568 	bl	2138 <fat16_get_fs_size>
     b94:	e1a01004 	mov	r1, r4
     b98:	e1a02000 	mov	r2, r0
     b9c:	e59f0040 	ldr	r0, [pc, #64]	; be4 <.text+0xbe4>
     ba0:	ebfffe0c 	bl	3d8 <rprintf>
     ba4:	e3a00001 	mov	r0, #1	; 0x1
     ba8:	ea000000 	b	bb0 <print_disk_info+0xd4>
     bac:	e3a00000 	mov	r0, #0	; 0x0
     bb0:	e28dd01c 	add	sp, sp, #28	; 0x1c
     bb4:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
     bb8:	e12fff1e 	bx	lr
     bbc:	00005db4 	streqh	r5, [r0], -r4
     bc0:	00005dc8 	andeq	r5, r0, r8, asr #27
     bc4:	00005dd8 	ldreqd	r5, [r0], -r8
     bc8:	00005de8 	andeq	r5, r0, r8, ror #27
     bcc:	00005df8 	streqd	r5, [r0], -r8
     bd0:	00005e0c 	andeq	r5, r0, ip, lsl #28
     bd4:	00005e20 	andeq	r5, r0, r0, lsr #28
     bd8:	00005e30 	andeq	r5, r0, r0, lsr lr
     bdc:	00005e40 	andeq	r5, r0, r0, asr #28
     be0:	00005e50 	andeq	r5, r0, r0, asr lr
     be4:	00005e60 	andeq	r5, r0, r0, ror #28

00000be8 <root_disk_info>:
     be8:	e59f3004 	ldr	r3, [pc, #4]	; bf4 <.text+0xbf4>
     bec:	e5930000 	ldr	r0, [r3]
     bf0:	eaffffb9 	b	adc <print_disk_info>
     bf4:	400011f8 	strmid	r1, [r0], -r8

00000bf8 <root_open>:
     bf8:	e59f301c 	ldr	r3, [pc, #28]	; c1c <.text+0xc1c>
     bfc:	e5931000 	ldr	r1, [r3]
     c00:	e59f3018 	ldr	r3, [pc, #24]	; c20 <.text+0xc20>
     c04:	e1a02000 	mov	r2, r0
     c08:	e52de004 	str	lr, [sp, #-4]!
     c0c:	e5930000 	ldr	r0, [r3]
     c10:	eb000838 	bl	2cf8 <open_file_in_dir>
     c14:	e49de004 	ldr	lr, [sp], #4
     c18:	e12fff1e 	bx	lr
     c1c:	40001230 	andmi	r1, r0, r0, lsr r2
     c20:	400011f8 	strmid	r1, [r0], -r8

00000c24 <root_open_new>:
     c24:	e92d4030 	stmdb	sp!, {r4, r5, lr}
     c28:	e59f5030 	ldr	r5, [pc, #48]	; c60 <.text+0xc60>
     c2c:	e1a04000 	mov	r4, r0
     c30:	e1a01000 	mov	r1, r0
     c34:	e59f2028 	ldr	r2, [pc, #40]	; c64 <.text+0xc64>
     c38:	e5950000 	ldr	r0, [r5]
     c3c:	eb000904 	bl	3054 <fat16_create_file>
     c40:	e3500000 	cmp	r0, #0	; 0x0
     c44:	e1a02004 	mov	r2, r4
     c48:	159f3018 	ldrne	r3, [pc, #24]	; c68 <.text+0xc68>
     c4c:	15951000 	ldrne	r1, [r5]
     c50:	15930000 	ldrne	r0, [r3]
     c54:	1b000827 	blne	2cf8 <open_file_in_dir>
     c58:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
     c5c:	e12fff1e 	bx	lr
     c60:	40001230 	andmi	r1, r0, r0, lsr r2
     c64:	400011fc 	strmid	r1, [r0], -ip
     c68:	400011f8 	strmid	r1, [r0], -r8

00000c6c <openroot>:
     c6c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
     c70:	e3a03000 	mov	r3, #0	; 0x0
     c74:	e59f10ac 	ldr	r1, [pc, #172]	; d28 <.text+0xd28>
     c78:	e59f20ac 	ldr	r2, [pc, #172]	; d2c <.text+0xd2c>
     c7c:	e59f00ac 	ldr	r0, [pc, #172]	; d30 <.text+0xd30>
     c80:	eb00096f 	bl	3244 <partition_open>
     c84:	e59f40a8 	ldr	r4, [pc, #168]	; d34 <.text+0xd34>
     c88:	e1a0c000 	mov	ip, r0
     c8c:	e35c0000 	cmp	ip, #0	; 0x0
     c90:	e3e03000 	mvn	r3, #0	; 0x0
     c94:	e59f108c 	ldr	r1, [pc, #140]	; d28 <.text+0xd28>
     c98:	e59f208c 	ldr	r2, [pc, #140]	; d2c <.text+0xd2c>
     c9c:	e59f008c 	ldr	r0, [pc, #140]	; d30 <.text+0xd30>
     ca0:	e59f5090 	ldr	r5, [pc, #144]	; d38 <.text+0xd38>
     ca4:	e584c000 	str	ip, [r4]
     ca8:	1a000005 	bne	cc4 <openroot+0x58>
     cac:	eb000964 	bl	3244 <partition_open>
     cb0:	e1a03000 	mov	r3, r0
     cb4:	e3530000 	cmp	r3, #0	; 0x0
     cb8:	e59f007c 	ldr	r0, [pc, #124]	; d3c <.text+0xd3c>
     cbc:	e5843000 	str	r3, [r4]
     cc0:	0a000013 	beq	d14 <openroot+0xa8>
     cc4:	e59f3068 	ldr	r3, [pc, #104]	; d34 <.text+0xd34>
     cc8:	e5930000 	ldr	r0, [r3]
     ccc:	eb000863 	bl	2e60 <fat16_open>
     cd0:	e3500000 	cmp	r0, #0	; 0x0
     cd4:	e5850000 	str	r0, [r5]
     cd8:	e59f2060 	ldr	r2, [pc, #96]	; d40 <.text+0xd40>
     cdc:	e59f1060 	ldr	r1, [pc, #96]	; d44 <.text+0xd44>
     ce0:	059f0060 	ldreq	r0, [pc, #96]	; d48 <.text+0xd48>
     ce4:	0a00000a 	beq	d14 <openroot+0xa8>
     ce8:	eb000813 	bl	2d3c <fat16_get_dir_entry_of_path>
     cec:	e59f104c 	ldr	r1, [pc, #76]	; d40 <.text+0xd40>
     cf0:	e5950000 	ldr	r0, [r5]
     cf4:	eb0007bf 	bl	2bf8 <fat16_open_dir>
     cf8:	e59f304c 	ldr	r3, [pc, #76]	; d4c <.text+0xd4c>
     cfc:	e1a02000 	mov	r2, r0
     d00:	e3500000 	cmp	r0, #0	; 0x0
     d04:	e3a01000 	mov	r1, #0	; 0x0
     d08:	e59f0040 	ldr	r0, [pc, #64]	; d50 <.text+0xd50>
     d0c:	e5832000 	str	r2, [r3]
     d10:	1a000001 	bne	d1c <openroot+0xb0>
     d14:	ebfffdaf 	bl	3d8 <rprintf>
     d18:	e3a01001 	mov	r1, #1	; 0x1
     d1c:	e1a00001 	mov	r0, r1
     d20:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
     d24:	e12fff1e 	bx	lr
     d28:	00001514 	andeq	r1, r0, r4, lsl r5
     d2c:	000012b8 	streqh	r1, [r0], -r8
     d30:	00001158 	andeq	r1, r0, r8, asr r1
     d34:	4000122c 	andmi	r1, r0, ip, lsr #4
     d38:	400011f8 	strmid	r1, [r0], -r8
     d3c:	00005e74 	andeq	r5, r0, r4, ror lr
     d40:	400011fc 	strmid	r1, [r0], -ip
     d44:	00005eac 	andeq	r5, r0, ip, lsr #29
     d48:	00005e90 	muleq	r0, r0, lr
     d4c:	40001230 	andmi	r1, r0, r0, lsr r2
     d50:	00005eb0 	streqh	r5, [r0], -r0

00000d54 <sd_raw_available>:
 */
unsigned char sd_raw_available()
{
    unsigned int i;
    configure_pin_available();
     d54:	e59f2028 	ldr	r2, [pc, #40]	; d84 <.text+0xd84>
     d58:	e5923008 	ldr	r3, [r2, #8]
     d5c:	e3c33080 	bic	r3, r3, #128	; 0x80
     d60:	e5823008 	str	r3, [r2, #8]
    for(i=0;i<100000;i++);
    i = get_pin_available();
     d64:	e5921000 	ldr	r1, [r2]
    configure_pin_ss();
     d68:	e5923008 	ldr	r3, [r2, #8]
     d6c:	e3110080 	tst	r1, #128	; 0x80
     d70:	e3833080 	orr	r3, r3, #128	; 0x80
    return i == 0x00;
}
     d74:	03a00000 	moveq	r0, #0	; 0x0
     d78:	13a00001 	movne	r0, #1	; 0x1
     d7c:	e5823008 	str	r3, [r2, #8]
     d80:	e12fff1e 	bx	lr
     d84:	e0028000 	and	r8, r2, r0

00000d88 <sd_raw_locked>:

/**
 * \ingroup sd_raw
 * Checks wether the memory card is locked for write access.
 *
 * \returns 1 if the card is locked, 0 if it is not.
 */
unsigned char sd_raw_locked()
{
    return get_pin_locked() == 0x00;
}
     d88:	e3a00001 	mov	r0, #1	; 0x1
     d8c:	e12fff1e 	bx	lr

00000d90 <sd_raw_rec_byte>:

/**
 * \ingroup sd_raw
 * Sends a raw byte to the memory card.
 *
 * \param[in] b The byte to sent.
 * \see sd_raw_rec_byte
 */
void sd_raw_send_byte(unsigned char b)
{
    S0SPDR = b;
    /* wait for byte to be shifted out */
    while(!(S0SPSR & 0x80));
}

/**
 * \ingroup sd_raw
 * Receives a raw byte from the memory card.
 *
 * \returns The byte which should be read.
 * \see sd_raw_send_byte
 */
unsigned char sd_raw_rec_byte(void)
{
    /* send dummy data for receiving some */
    S0SPDR = 0xff;
     d90:	e59f3020 	ldr	r3, [pc, #32]	; db8 <.text+0xdb8>
     d94:	e3a020ff 	mov	r2, #255	; 0xff
     d98:	e5832008 	str	r2, [r3, #8]
    while(!(S0SPSR & 0x80));
     d9c:	e59f2014 	ldr	r2, [pc, #20]	; db8 <.text+0xdb8>
     da0:	e5923004 	ldr	r3, [r2, #4]
     da4:	e3130080 	tst	r3, #128	; 0x80
     da8:	0afffffb 	beq	d9c <sd_raw_rec_byte+0xc>

    return S0SPDR;
     dac:	e5920008 	ldr	r0, [r2, #8]
     db0:	e20000ff 	and	r0, r0, #255	; 0xff
}
     db4:	e12fff1e 	bx	lr
     db8:	e0020000 	and	r0, r2, r0

00000dbc <sd_raw_send_command_r1>:

/**
 * \ingroup sd_raw
 * Send a command to the memory card which responses with a R1 response.
 *
 * \param[in] command The command to send.
 * \param[in] arg The argument for command.
 * \returns The command answer.
 */
unsigned char sd_raw_send_command_r1(unsigned char command, unsigned int arg)
{
     dbc:	e92d4030 	stmdb	sp!, {r4, r5, lr}
     dc0:	e20050ff 	and	r5, r0, #255	; 0xff
     dc4:	e1a04001 	mov	r4, r1
    unsigned char response;
    unsigned char i;

    /* wait some clock cycles */
    sd_raw_rec_byte();
     dc8:	ebfffff0 	bl	d90 <sd_raw_rec_byte>
     dcc:	e59f30c4 	ldr	r3, [pc, #196]	; e98 <.text+0xe98>
     dd0:	e3852040 	orr	r2, r5, #64	; 0x40
     dd4:	e5832008 	str	r2, [r3, #8]
     dd8:	e59f20b8 	ldr	r2, [pc, #184]	; e98 <.text+0xe98>
     ddc:	e5923004 	ldr	r3, [r2, #4]
     de0:	e3130080 	tst	r3, #128	; 0x80
     de4:	0afffffb 	beq	dd8 <sd_raw_send_command_r1+0x1c>
     de8:	e1a03c24 	mov	r3, r4, lsr #24
     dec:	e5823008 	str	r3, [r2, #8]
     df0:	e59f20a0 	ldr	r2, [pc, #160]	; e98 <.text+0xe98>
     df4:	e5923004 	ldr	r3, [r2, #4]
     df8:	e3130080 	tst	r3, #128	; 0x80
     dfc:	0afffffb 	beq	df0 <sd_raw_send_command_r1+0x34>
     e00:	e1a03824 	mov	r3, r4, lsr #16
     e04:	e20330ff 	and	r3, r3, #255	; 0xff
     e08:	e5823008 	str	r3, [r2, #8]
     e0c:	e59f2084 	ldr	r2, [pc, #132]	; e98 <.text+0xe98>
     e10:	e5923004 	ldr	r3, [r2, #4]
     e14:	e3130080 	tst	r3, #128	; 0x80
     e18:	0afffffb 	beq	e0c <sd_raw_send_command_r1+0x50>
     e1c:	e1a03424 	mov	r3, r4, lsr #8
     e20:	e20330ff 	and	r3, r3, #255	; 0xff
     e24:	e5823008 	str	r3, [r2, #8]
     e28:	e59f2068 	ldr	r2, [pc, #104]	; e98 <.text+0xe98>
     e2c:	e5923004 	ldr	r3, [r2, #4]
     e30:	e3130080 	tst	r3, #128	; 0x80
     e34:	0afffffb 	beq	e28 <sd_raw_send_command_r1+0x6c>
     e38:	e20430ff 	and	r3, r4, #255	; 0xff
     e3c:	e5823008 	str	r3, [r2, #8]
     e40:	e59f2050 	ldr	r2, [pc, #80]	; e98 <.text+0xe98>
     e44:	e5923004 	ldr	r3, [r2, #4]
     e48:	e3130080 	tst	r3, #128	; 0x80
     e4c:	0afffffb 	beq	e40 <sd_raw_send_command_r1+0x84>
     e50:	e3550000 	cmp	r5, #0	; 0x0
     e54:	13a030ff 	movne	r3, #255	; 0xff
     e58:	03a03095 	moveq	r3, #149	; 0x95
     e5c:	e5823008 	str	r3, [r2, #8]
     e60:	e59f3030 	ldr	r3, [pc, #48]	; e98 <.text+0xe98>
     e64:	e5933004 	ldr	r3, [r3, #4]
     e68:	e3130080 	tst	r3, #128	; 0x80
     e6c:	0afffffb 	beq	e60 <sd_raw_send_command_r1+0xa4>
     e70:	e3a04000 	mov	r4, #0	; 0x0

    /* send command via SPI */
    sd_raw_send_byte(0x40 | command);
    sd_raw_send_byte((arg >> 24) & 0xff);
    sd_raw_send_byte((arg >> 16) & 0xff);
    sd_raw_send_byte((arg >> 8) & 0xff);
    sd_raw_send_byte((arg >> 0) & 0xff);
    sd_raw_send_byte((command == CMD_GO_IDLE_STATE) ? 0x95 : 0xff);

    /* receive response */
    for(i = 0; i < 10; ++i)
    {
        response = sd_raw_rec_byte();
     e74:	ebffffc5 	bl	d90 <sd_raw_rec_byte>
     e78:	e2843001 	add	r3, r4, #1	; 0x1
        if(response != 0xff)
     e7c:	e35000ff 	cmp	r0, #255	; 0xff
     e80:	e20340ff 	and	r4, r3, #255	; 0xff
     e84:	1a000001 	bne	e90 <sd_raw_send_command_r1+0xd4>
     e88:	e354000a 	cmp	r4, #10	; 0xa
     e8c:	1afffff8 	bne	e74 <sd_raw_send_command_r1+0xb8>
            break;
    }

    return response;
}
     e90:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
     e94:	e12fff1e 	bx	lr
     e98:	e0020000 	and	r0, r2, r0

00000e9c <SDoff>:

/**
 * \ingroup sd_raw
 * Send a command to the memory card which responses with a R2 response.
 *
 * \param[in] command The command to send.
 * \param[in] arg The argument for command.
 * \returns The command answer.
 */
/*
unsigned short sd_raw_send_command_r2(unsigned char command, unsigned int arg)
{
    unsigned short response;
    unsigned char i;

    // wait some clock cycles
    sd_raw_rec_byte();

    // send command via SPI
    sd_raw_send_byte(0x40 | command);
    sd_raw_send_byte((arg >> 24) & 0xff);
    sd_raw_send_byte((arg >> 16) & 0xff);
    sd_raw_send_byte((arg >> 8) & 0xff);
    sd_raw_send_byte((arg >> 0) & 0xff);
    sd_raw_send_byte(command == CMD_GO_IDLE_STATE ? 0x95 : 0xff);

    // receive response
    for(i = 0; i < 10; ++i)
    {
        response = sd_raw_rec_byte();
        if(response != 0xff)
            break;
    }
    response <<= 8;
    response |= sd_raw_rec_byte();

    return response;
}
*/

/**
 * \ingroup sd_raw
 * Reads raw data from the card.
 *
 * \param[in] offset The offset from which to read.
 * \param[out] buffer The buffer into which to write the data.
 * \param[in] length The number of bytes to read.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_read_interval, sd_raw_write
 */
unsigned char sd_raw_read(unsigned int offset, unsigned char* buffer, unsigned short length)
{
    unsigned int block_address;
    unsigned short block_offset;
    unsigned short read_length;
    while(length > 0)
    {
        /* determine byte count to read at once */
        block_address = offset & 0xfffffe00;
        block_offset = offset & 0x01ff;
        read_length = 512 - block_offset; /* read up to block border */
        if(read_length > length)
            read_length = length;

        #if !SD_RAW_SAVE_RAM
            /* check if the requested data is cached */
            if(block_address != raw_block_address)
            #endif
        {
            #if SD_RAW_WRITE_BUFFERING
                if(!raw_block_written)
                {
                    if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
                        return 0;
                }
            #endif

            /* address card */
            select_card();

            /* send single block request */
            if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, block_address))
            {
                unselect_card();
                return 0;
            }

            /* wait for data block (start byte 0xfe) */
            while(sd_raw_rec_byte() != 0xfe);

            #if SD_RAW_SAVE_RAM
                /* read byte block */
                unsigned short read_to = block_offset + read_length;
                for(unsigned short i = 0; i < 512; ++i)
                {
                    unsigned char b = sd_raw_rec_byte();
                    if(i >= block_offset && i < read_to)
                        *buffer++ = b;
                }
            #else
                /* read byte block */
                unsigned char* cache = raw_block;
                unsigned short i;
                for(i = 0; i < 512; ++i)
                    *cache++ = sd_raw_rec_byte();
                raw_block_address = block_address;
    
                memcpy(buffer, raw_block + block_offset, read_length);
                buffer += read_length;
            #endif

            /* read crc16 */
            sd_raw_rec_byte();
            sd_raw_rec_byte();

            /* deaddress card */
            unselect_card();

            /* let card some time to finish */
            sd_raw_rec_byte();
        }
        #if !SD_RAW_SAVE_RAM
            else
            {
                /* use cached data */
                memcpy(buffer, raw_block + block_offset, read_length);
            }
        #endif

        length -= read_length;
        offset += read_length;
    }

    return 1;
}

/**
 * \ingroup sd_raw
 * Continuously reads units of \c interval bytes and calls a callback function.
 *
 * This function starts reading at the specified offset. Every \c interval bytes,
 * it calls the callback function with the associated data buffer.
 *
 * By returning zero, the callback may stop reading.
 *
 * \note Within the callback function, you can not start another read or
 *       write operation.
 * \note This function only works if the following conditions are met:
 *       - (offset - (offset % 512)) % interval == 0
 *       - length % interval == 0
 *
 * \param[in] offset Offset from which to start reading.
 * \param[in] buffer Pointer to a buffer which is at least interval bytes in size.
 * \param[in] interval Number of bytes to read before calling the callback function.
 * \param[in] length Number of bytes to read altogether.
 * \param[in] callback The function to call every interval bytes.
 * \param[in] p An opaque pointer directly passed to the callback function.
 * \returns 0 on failure, 1 on success
 * \see sd_raw_read, sd_raw_write
 */
unsigned char sd_raw_read_interval(unsigned int offset, unsigned char* buffer, unsigned short interval, unsigned short length, sd_raw_interval_handler callback, void* p)
{
    if(!buffer || interval == 0 || length < interval || !callback)
        return 0;

    #if !SD_RAW_SAVE_RAM
        while(length >= interval)
        {
            /* as reading is now buffered, we directly
                     * hand over the request to sd_raw_read()
                     */
            if(!sd_raw_read(offset, buffer, interval))
                return 0;
            if(!callback(buffer, offset, p))
                break;
            offset += interval;
            length -= interval;
        }
    
        return 1;
    #else
        /* address card */
        select_card();
    
        unsigned short block_offset;
        unsigned short read_length;
        unsigned char* buffer_cur;
        unsigned char finished = 0;
        do
        {
            /* determine byte count to read at once */
            block_offset = offset & 0x01ff;
            read_length = 512 - block_offset;
    
            /* send single block request */
            if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, offset & 0xfffffe00))
            {
                unselect_card();
                return 0;
            }
    
            /* wait for data block (start byte 0xfe) */
            while(sd_raw_rec_byte() != 0xfe);
            unsigned short i;
            /* read up to the data of interest */
            for(i = 0; i < block_offset; ++i)
                sd_raw_rec_byte();
    
            /* read interval bytes of data and execute the callback */
            do
            {
                if(read_length < interval || length < interval)
                    break;
    
                buffer_cur = buffer;
                for(i = 0; i < interval; ++i)
                    *buffer_cur++ = sd_raw_rec_byte();
    
                if(!callback(buffer, offset + (512 - read_length), p))
                {
                    finished = 1;
                    break;
                }
    
                read_length -= interval;
                length -= interval;
    
            }
            while(read_length > 0 && length > 0);
    
            /* read rest of data block */
            while(read_length-- > 0)
                sd_raw_rec_byte();
    
            /* read crc16 */
            sd_raw_rec_byte();
            sd_raw_rec_byte();
    
            if(length < interval)
                break;
    
            offset = (offset & 0xfffffe00) + 512;
    
        }
        while(!finished);
    
        /* deaddress card */
        unselect_card();
    
        /* let card some time to finish */
        sd_raw_rec_byte();
    
        return 1;
    #endif
}

/**
 * \ingroup sd_raw
 * Writes raw data to the card.
 *
 * \note If write buffering is enabled, you might have to
 *       call sd_raw_sync() before disconnecting the card
 *       to ensure all remaining data has been written.
 *
 * \param[in] offset The offset where to start writing.
 * \param[in] buffer The buffer containing the data to be written.
 * \param[in] length The number of bytes to write.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_read
 */
unsigned char sd_raw_write(unsigned int offset, const unsigned char* buffer, unsigned short length)
{
    #if SD_RAW_WRITE_SUPPORT
    
        if(get_pin_locked())
            return 0;
    
        unsigned int block_address;
        unsigned short block_offset;
        unsigned short write_length;
        while(length > 0)
        {
            /* determine byte count to write at once */
            block_address = offset & 0xfffffe00;
            block_offset = offset & 0x01ff;
            write_length = 512 - block_offset; /* write up to block border */
            if(write_length > length)
                write_length = length;
    
            /* Merge the data to write with the content of the block.
                     * Use the cached block if available.
                     */
            if(block_address != raw_block_address)
            {
                #if SD_RAW_WRITE_BUFFERING
                if(!raw_block_written)
                {
                    if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
                        return 0;
                }
            #endif

            if(block_offset || write_length < 512)
            {
                if(!sd_raw_read(block_address, raw_block, sizeof(raw_block)))
                    return 0;
            }
            raw_block_address = block_address;
        }

        if(buffer != raw_block)
        {
            memcpy(raw_block + block_offset, buffer, write_length);

            #if SD_RAW_WRITE_BUFFERING
                raw_block_written = 0;
    
                if(length == write_length)
                    return 1;
            #endif
        }

        buffer += write_length;

        /* address card */
        select_card();

        /* send single block request */
        if(sd_raw_send_command_r1(CMD_WRITE_SINGLE_BLOCK, block_address))
        {
            unselect_card();
            return 0;
        }

        /* send start byte */
        sd_raw_send_byte(0xfe);

        /* write byte block */
        unsigned char* cache = raw_block;
        unsigned short i;
        for(i = 0; i < 512; ++i)
            sd_raw_send_byte(*cache++);

        /* write dummy crc16 */
        sd_raw_send_byte(0xff);
        sd_raw_send_byte(0xff);

        /* wait while card is busy */
        while(sd_raw_rec_byte() != 0xff);
        sd_raw_rec_byte();

        /* deaddress card */
        unselect_card();

        length -= write_length;
        offset += write_length;

        #if SD_RAW_WRITE_BUFFERING
            raw_block_written = 1;
        #endif
    }

    return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup sd_raw
 * Writes the write buffer's content to the card.
 *
 * \note When write buffering is enabled, you should
 *       call this function before disconnecting the
 *       card to ensure all remaining data has been
 *       written.
 *
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_write
 */
unsigned char sd_raw_sync()
{
    #if SD_RAW_WRITE_SUPPORT
        #if SD_RAW_WRITE_BUFFERING
        if(raw_block_written)
            return 1;
        if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
            return 0;
    #endif
    return 1;
    #else
    return 0;
    #endif
}

/**
 * \ingroup sd_raw
 * Reads informational data from the card.
 *
 * This function reads and returns the card's registers
 * containing manufacturing and status information.
 *
 * \note: The information retrieved by this function is
 *        not required in any way to operate on the card,
 *        but it might be nice to display some of the data
 *        to the user.
 *
 * \param[in] info A pointer to the structure into which to save the information.
 * \returns 0 on failure, 1 on success.
 */
unsigned char sd_raw_get_info(struct sd_raw_info* info)
{
    if(!info || !sd_raw_available())
        return 0;

    memset(info, 0, sizeof(*info));

    select_card();

    /* read cid register */
    if(sd_raw_send_command_r1(CMD_SEND_CID, 0))
    {
        unselect_card();
        return 0;
    }
    while(sd_raw_rec_byte() != 0xfe);
    unsigned char i;
    for(i = 0; i < 18; ++i)
    {
        unsigned char b = sd_raw_rec_byte();

        switch(i)
        {
            case 0:
                info->manufacturer = b;
                break;
            case 1:
            case 2:
                info->oem[i - 1] = b;
                break;
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                info->product[i - 3] = b;
                break;
            case 8:
                info->revision = b;
                break;
            case 9:
            case 10:
            case 11:
            case 12:
                info->serial |= (unsigned int) b << ((12 - i) * 8);
                break;
            case 13:
                info->manufacturing_year = b << 4;
                break;
            case 14:
                info->manufacturing_year |= b >> 4;
                info->manufacturing_month = b & 0x0f;
                break;
        }
    }

    /* read csd register */
    unsigned char csd_read_bl_len = 0;
    unsigned char csd_c_size_mult = 0;
    unsigned short csd_c_size = 0;
    if(sd_raw_send_command_r1(CMD_SEND_CSD, 0))
    {
        unselect_card();
        return 0;
    }
    while(sd_raw_rec_byte() != 0xfe);
    for(i = 0; i < 18; ++i)
    {
        unsigned char b = sd_raw_rec_byte();

        switch(i)
        {
            case 5:
                csd_read_bl_len = b & 0x0f;
                break;
            case 6:
                csd_c_size = (unsigned short) (b & 0x03) << 8;
                break;
            case 7:
                csd_c_size |= b;
                csd_c_size <<= 2;
                break;
            case 8:
                csd_c_size |= b >> 6;
                ++csd_c_size;
                break;
            case 9:
                csd_c_size_mult = (b & 0x03) << 1;
                break;
            case 10:
                csd_c_size_mult |= b >> 7;

                info->capacity = (unsigned int) csd_c_size << (csd_c_size_mult + csd_read_bl_len + 2);

                break;
            case 14:
                if(b & 0x40)
                    info->flag_copy = 1;
                if(b & 0x20)
                    info->flag_write_protect = 1;
                if(b & 0x10)
                    info->flag_write_protect_temp = 1;
                info->format = (b & 0x0c) >> 2;
                break;
        }
    }

    unselect_card();

    return 1;
}

void SDoff(void)
{
    IODIR1 &= ~(CS);
     e9c:	e59f201c 	ldr	r2, [pc, #28]	; ec0 <.text+0xec0>
     ea0:	e5923018 	ldr	r3, [r2, #24]
     ea4:	e3c33080 	bic	r3, r3, #128	; 0x80
     ea8:	e5823018 	str	r3, [r2, #24]
    PINSEL0 &= ~(0x1500);
     eac:	e2822901 	add	r2, r2, #16384	; 0x4000
     eb0:	e5923000 	ldr	r3, [r2]
     eb4:	e3c33c15 	bic	r3, r3, #5376	; 0x1500
     eb8:	e5823000 	str	r3, [r2]
}
     ebc:	e12fff1e 	bx	lr
     ec0:	e0028000 	and	r8, r2, r0

00000ec4 <sd_raw_get_info>:
     ec4:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     ec8:	e2504000 	subs	r4, r0, #0	; 0x0
     ecc:	0a000097 	beq	1130 <.text+0x1130>
     ed0:	ebffff9f 	bl	d54 <sd_raw_available>
     ed4:	e3500000 	cmp	r0, #0	; 0x0
     ed8:	0a000094 	beq	1130 <.text+0x1130>
     edc:	e59f5270 	ldr	r5, [pc, #624]	; 1154 <.text+0x1154>
     ee0:	e3a01000 	mov	r1, #0	; 0x0
     ee4:	e3a0201c 	mov	r2, #28	; 0x1c
     ee8:	e1a00004 	mov	r0, r4
     eec:	eb00116e 	bl	54ac <memset>
     ef0:	e595300c 	ldr	r3, [r5, #12]
     ef4:	e3833080 	orr	r3, r3, #128	; 0x80
     ef8:	e3a0000a 	mov	r0, #10	; 0xa
     efc:	e3a01000 	mov	r1, #0	; 0x0
     f00:	e585300c 	str	r3, [r5, #12]
     f04:	ebffffac 	bl	dbc <sd_raw_send_command_r1>
     f08:	e3500000 	cmp	r0, #0	; 0x0
     f0c:	15953004 	ldrne	r3, [r5, #4]
     f10:	13a00000 	movne	r0, #0	; 0x0
     f14:	13833080 	orrne	r3, r3, #128	; 0x80
     f18:	15853004 	strne	r3, [r5, #4]
     f1c:	1a00008a 	bne	114c <.text+0x114c>
     f20:	ebffff9a 	bl	d90 <sd_raw_rec_byte>
     f24:	e35000fe 	cmp	r0, #254	; 0xfe
     f28:	1afffffc 	bne	f20 <sd_raw_get_info+0x5c>
     f2c:	ebffff97 	bl	d90 <sd_raw_rec_byte>
     f30:	e3a05000 	mov	r5, #0	; 0x0
     f34:	ea000012 	b	f84 <.text+0xf84>
     f38:	ebffff94 	bl	d90 <sd_raw_rec_byte>
     f3c:	e355000e 	cmp	r5, #14	; 0xe
     f40:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
     f44:	ea000026 	b	fe4 <.text+0xfe4>
     f48:	00000f84 	andeq	r0, r0, r4, lsl #31
     f4c:	00000f8c 	andeq	r0, r0, ip, lsl #31
     f50:	00000f8c 	andeq	r0, r0, ip, lsl #31
     f54:	00000f94 	muleq	r0, r4, pc
     f58:	00000f94 	muleq	r0, r4, pc
     f5c:	00000f94 	muleq	r0, r4, pc
     f60:	00000f94 	muleq	r0, r4, pc
     f64:	00000f94 	muleq	r0, r4, pc
     f68:	00000fa0 	andeq	r0, r0, r0, lsr #31
     f6c:	00000fa8 	andeq	r0, r0, r8, lsr #31
     f70:	00000fa8 	andeq	r0, r0, r8, lsr #31
     f74:	00000fa8 	andeq	r0, r0, r8, lsr #31
     f78:	00000fa8 	andeq	r0, r0, r8, lsr #31
     f7c:	00000fc0 	andeq	r0, r0, r0, asr #31
     f80:	00000fcc 	andeq	r0, r0, ip, asr #31
     f84:	e5c40000 	strb	r0, [r4]
     f88:	ea00006a 	b	1138 <.text+0x1138>
     f8c:	e7c50004 	strb	r0, [r5, r4]
     f90:	ea000013 	b	fe4 <.text+0xfe4>
     f94:	e0853004 	add	r3, r5, r4
     f98:	e5c30001 	strb	r0, [r3, #1]
     f9c:	ea000010 	b	fe4 <.text+0xfe4>
     fa0:	e5c4000a 	strb	r0, [r4, #10]
     fa4:	ea000063 	b	1138 <.text+0x1138>
     fa8:	e594200c 	ldr	r2, [r4, #12]
     fac:	e265300c 	rsb	r3, r5, #12	; 0xc
     fb0:	e1a03183 	mov	r3, r3, lsl #3
     fb4:	e1822310 	orr	r2, r2, r0, lsl r3
     fb8:	e584200c 	str	r2, [r4, #12]
     fbc:	ea000008 	b	fe4 <.text+0xfe4>
     fc0:	e1a03200 	mov	r3, r0, lsl #4
     fc4:	e5c43010 	strb	r3, [r4, #16]
     fc8:	ea00005a 	b	1138 <.text+0x1138>
     fcc:	e5d43010 	ldrb	r3, [r4, #16]
     fd0:	e200200f 	and	r2, r0, #15	; 0xf
     fd4:	e1833220 	orr	r3, r3, r0, lsr #4
     fd8:	e5c43010 	strb	r3, [r4, #16]
     fdc:	e5c42011 	strb	r2, [r4, #17]
     fe0:	ea000054 	b	1138 <.text+0x1138>
     fe4:	e2853001 	add	r3, r5, #1	; 0x1
     fe8:	e20350ff 	and	r5, r3, #255	; 0xff
     fec:	e3550011 	cmp	r5, #17	; 0x11
     ff0:	9affffd0 	bls	f38 <sd_raw_get_info+0x74>
     ff4:	e3a00009 	mov	r0, #9	; 0x9
     ff8:	e3a01000 	mov	r1, #0	; 0x0
     ffc:	ebffff6e 	bl	dbc <sd_raw_send_command_r1>
    1000:	e3500000 	cmp	r0, #0	; 0x0
    1004:	159f2148 	ldrne	r2, [pc, #328]	; 1154 <.text+0x1154>
    1008:	15923004 	ldrne	r3, [r2, #4]
    100c:	13a00000 	movne	r0, #0	; 0x0
    1010:	13833080 	orrne	r3, r3, #128	; 0x80
    1014:	1a000043 	bne	1128 <.text+0x1128>
    1018:	ebffff5c 	bl	d90 <sd_raw_rec_byte>
    101c:	e35000fe 	cmp	r0, #254	; 0xfe
    1020:	1afffffc 	bne	1018 <.text+0x1018>
    1024:	ebffff59 	bl	d90 <sd_raw_rec_byte>
    1028:	e3a07000 	mov	r7, #0	; 0x0
    102c:	e3a05001 	mov	r5, #1	; 0x1
    1030:	e1a08007 	mov	r8, r7
    1034:	e1a06007 	mov	r6, r7
    1038:	ebffff54 	bl	d90 <sd_raw_rec_byte>
    103c:	e2453005 	sub	r3, r5, #5	; 0x5
    1040:	e2852001 	add	r2, r5, #1	; 0x1
    1044:	e3530009 	cmp	r3, #9	; 0x9
    1048:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    104c:	ea00002e 	b	110c <.text+0x110c>
    1050:	00001078 	andeq	r1, r0, r8, ror r0
    1054:	00001080 	andeq	r1, r0, r0, lsl #1
    1058:	0000108c 	andeq	r1, r0, ip, lsl #1
    105c:	00001098 	muleq	r0, r8, r0
    1060:	000010b0 	streqh	r1, [r0], -r0
    1064:	000010bc 	streqh	r1, [r0], -ip
    1068:	0000110c 	andeq	r1, r0, ip, lsl #2
    106c:	0000110c 	andeq	r1, r0, ip, lsl #2
    1070:	0000110c 	andeq	r1, r0, ip, lsl #2
    1074:	000010d8 	ldreqd	r1, [r0], -r8
    1078:	e200800f 	and	r8, r0, #15	; 0xf
    107c:	ea000030 	b	1144 <.text+0x1144>
    1080:	e2003003 	and	r3, r0, #3	; 0x3
    1084:	e1a06403 	mov	r6, r3, lsl #8
    1088:	ea00002d 	b	1144 <.text+0x1144>
    108c:	e1863000 	orr	r3, r6, r0
    1090:	e1a03903 	mov	r3, r3, lsl #18
    1094:	ea000003 	b	10a8 <.text+0x10a8>
    1098:	e1a03900 	mov	r3, r0, lsl #18
    109c:	e1863c23 	orr	r3, r6, r3, lsr #24
    10a0:	e2833001 	add	r3, r3, #1	; 0x1
    10a4:	e1a03803 	mov	r3, r3, lsl #16
    10a8:	e1a06823 	mov	r6, r3, lsr #16
    10ac:	ea000024 	b	1144 <.text+0x1144>
    10b0:	e2003003 	and	r3, r0, #3	; 0x3
    10b4:	e1a07083 	mov	r7, r3, lsl #1
    10b8:	ea000021 	b	1144 <.text+0x1144>
    10bc:	e18733a0 	orr	r3, r7, r0, lsr #7
    10c0:	e20370ff 	and	r7, r3, #255	; 0xff
    10c4:	e2883002 	add	r3, r8, #2	; 0x2
    10c8:	e0873003 	add	r3, r7, r3
    10cc:	e1a03316 	mov	r3, r6, lsl r3
    10d0:	e5843014 	str	r3, [r4, #20]
    10d4:	ea00001a 	b	1144 <.text+0x1144>
    10d8:	e3100040 	tst	r0, #64	; 0x40
    10dc:	13a03001 	movne	r3, #1	; 0x1
    10e0:	15c43018 	strneb	r3, [r4, #24]
    10e4:	e3100020 	tst	r0, #32	; 0x20
    10e8:	13a03001 	movne	r3, #1	; 0x1
    10ec:	15c43019 	strneb	r3, [r4, #25]
    10f0:	e3100010 	tst	r0, #16	; 0x10
    10f4:	13a03001 	movne	r3, #1	; 0x1
    10f8:	15c4301a 	strneb	r3, [r4, #26]
    10fc:	e200300c 	and	r3, r0, #12	; 0xc
    1100:	e1a03143 	mov	r3, r3, asr #2
    1104:	e5c4301b 	strb	r3, [r4, #27]
    1108:	ea00000d 	b	1144 <.text+0x1144>
    110c:	e20250ff 	and	r5, r2, #255	; 0xff
    1110:	e3550011 	cmp	r5, #17	; 0x11
    1114:	9affffc7 	bls	1038 <.text+0x1038>
    1118:	e59f2034 	ldr	r2, [pc, #52]	; 1154 <.text+0x1154>
    111c:	e5923004 	ldr	r3, [r2, #4]
    1120:	e3a00001 	mov	r0, #1	; 0x1
    1124:	e3833080 	orr	r3, r3, #128	; 0x80
    1128:	e5823004 	str	r3, [r2, #4]
    112c:	ea000006 	b	114c <.text+0x114c>
    1130:	e3a00000 	mov	r0, #0	; 0x0
    1134:	ea000004 	b	114c <.text+0x114c>
    1138:	e2853001 	add	r3, r5, #1	; 0x1
    113c:	e20350ff 	and	r5, r3, #255	; 0xff
    1140:	eaffff7c 	b	f38 <sd_raw_get_info+0x74>
    1144:	e20250ff 	and	r5, r2, #255	; 0xff
    1148:	eaffffba 	b	1038 <.text+0x1038>
    114c:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    1150:	e12fff1e 	bx	lr
    1154:	e0028000 	and	r8, r2, r0

00001158 <sd_raw_read>:
    1158:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    115c:	e1a02802 	mov	r2, r2, lsl #16
    1160:	e1a09000 	mov	r9, r0
    1164:	e1a0a001 	mov	sl, r1
    1168:	e1a08822 	mov	r8, r2, lsr #16
    116c:	ea000046 	b	128c <sd_raw_read+0x134>
    1170:	e1a06b89 	mov	r6, r9, lsl #23
    1174:	e1a06ba6 	mov	r6, r6, lsr #23
    1178:	e59f3120 	ldr	r3, [pc, #288]	; 12a0 <.text+0x12a0>
    117c:	e2662c02 	rsb	r2, r6, #512	; 0x200
    1180:	e1a02802 	mov	r2, r2, lsl #16
    1184:	e5930000 	ldr	r0, [r3]
    1188:	e3c95f7f 	bic	r5, r9, #508	; 0x1fc
    118c:	e3c55003 	bic	r5, r5, #3	; 0x3
    1190:	e1a02822 	mov	r2, r2, lsr #16
    1194:	e1580002 	cmp	r8, r2
    1198:	31a07008 	movcc	r7, r8
    119c:	21a07002 	movcs	r7, r2
    11a0:	e1550000 	cmp	r5, r0
    11a4:	0a00002f 	beq	1268 <sd_raw_read+0x110>
    11a8:	e59f30f4 	ldr	r3, [pc, #244]	; 12a4 <.text+0x12a4>
    11ac:	e5d33000 	ldrb	r3, [r3]
    11b0:	e3530000 	cmp	r3, #0	; 0x0
    11b4:	1a000004 	bne	11cc <sd_raw_read+0x74>
    11b8:	e59f10e8 	ldr	r1, [pc, #232]	; 12a8 <.text+0x12a8>
    11bc:	e3a02c02 	mov	r2, #512	; 0x200
    11c0:	eb00003c 	bl	12b8 <sd_raw_write>
    11c4:	e3500000 	cmp	r0, #0	; 0x0
    11c8:	0a000032 	beq	1298 <sd_raw_read+0x140>
    11cc:	e59f40d8 	ldr	r4, [pc, #216]	; 12ac <.text+0x12ac>
    11d0:	e594300c 	ldr	r3, [r4, #12]
    11d4:	e3833080 	orr	r3, r3, #128	; 0x80
    11d8:	e3a00011 	mov	r0, #17	; 0x11
    11dc:	e1a01005 	mov	r1, r5
    11e0:	e584300c 	str	r3, [r4, #12]
    11e4:	ebfffef4 	bl	dbc <sd_raw_send_command_r1>
    11e8:	e3500000 	cmp	r0, #0	; 0x0
    11ec:	15943004 	ldrne	r3, [r4, #4]
    11f0:	13a00000 	movne	r0, #0	; 0x0
    11f4:	13833080 	orrne	r3, r3, #128	; 0x80
    11f8:	15843004 	strne	r3, [r4, #4]
    11fc:	1a000025 	bne	1298 <sd_raw_read+0x140>
    1200:	ebfffee2 	bl	d90 <sd_raw_rec_byte>
    1204:	e35000fe 	cmp	r0, #254	; 0xfe
    1208:	1afffffc 	bne	1200 <sd_raw_read+0xa8>
    120c:	e59f409c 	ldr	r4, [pc, #156]	; 12b0 <.text+0x12b0>
    1210:	ebfffede 	bl	d90 <sd_raw_rec_byte>
    1214:	e59f3098 	ldr	r3, [pc, #152]	; 12b4 <.text+0x12b4>
    1218:	e5440001 	strb	r0, [r4, #-1]
    121c:	e2844001 	add	r4, r4, #1	; 0x1
    1220:	e1540003 	cmp	r4, r3
    1224:	1afffff9 	bne	1210 <sd_raw_read+0xb8>
    1228:	e59f3070 	ldr	r3, [pc, #112]	; 12a0 <.text+0x12a0>
    122c:	e59f1074 	ldr	r1, [pc, #116]	; 12a8 <.text+0x12a8>
    1230:	e1a02007 	mov	r2, r7
    1234:	e5835000 	str	r5, [r3]
    1238:	e0861001 	add	r1, r6, r1
    123c:	e1a0000a 	mov	r0, sl
    1240:	eb001091 	bl	548c <memcpy>
    1244:	ebfffed1 	bl	d90 <sd_raw_rec_byte>
    1248:	ebfffed0 	bl	d90 <sd_raw_rec_byte>
    124c:	e59f2058 	ldr	r2, [pc, #88]	; 12ac <.text+0x12ac>
    1250:	e5923004 	ldr	r3, [r2, #4]
    1254:	e3833080 	orr	r3, r3, #128	; 0x80
    1258:	e5823004 	str	r3, [r2, #4]
    125c:	e08aa007 	add	sl, sl, r7
    1260:	ebfffeca 	bl	d90 <sd_raw_rec_byte>
    1264:	ea000004 	b	127c <sd_raw_read+0x124>
    1268:	e59f1038 	ldr	r1, [pc, #56]	; 12a8 <.text+0x12a8>
    126c:	e1a0000a 	mov	r0, sl
    1270:	e0861001 	add	r1, r6, r1
    1274:	e1a02007 	mov	r2, r7
    1278:	eb001083 	bl	548c <memcpy>
    127c:	e0673008 	rsb	r3, r7, r8
    1280:	e1a03803 	mov	r3, r3, lsl #16
    1284:	e0899007 	add	r9, r9, r7
    1288:	e1a08823 	mov	r8, r3, lsr #16
    128c:	e3580000 	cmp	r8, #0	; 0x0
    1290:	1affffb6 	bne	1170 <sd_raw_read+0x18>
    1294:	e3a00001 	mov	r0, #1	; 0x1
    1298:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    129c:	e12fff1e 	bx	lr
    12a0:	40000cd8 	ldrmid	r0, [r0], -r8
    12a4:	40000cdc 	ldrmid	r0, [r0], -ip
    12a8:	40000ad8 	ldrmid	r0, [r0], -r8
    12ac:	e0028000 	and	r8, r2, r0
    12b0:	40000ad9 	ldrmid	r0, [r0], -r9
    12b4:	40000cd9 	ldrmid	r0, [r0], -r9

000012b8 <sd_raw_write>:
    12b8:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    12bc:	e1a02802 	mov	r2, r2, lsl #16
    12c0:	e1a0a000 	mov	sl, r0
    12c4:	e1a08001 	mov	r8, r1
    12c8:	e1a07822 	mov	r7, r2, lsr #16
    12cc:	ea000069 	b	1478 <sd_raw_write+0x1c0>
    12d0:	e1a04b8a 	mov	r4, sl, lsl #23
    12d4:	e1a04ba4 	mov	r4, r4, lsr #23
    12d8:	e59f91cc 	ldr	r9, [pc, #460]	; 14ac <.text+0x14ac>
    12dc:	e2643c02 	rsb	r3, r4, #512	; 0x200
    12e0:	e1a03803 	mov	r3, r3, lsl #16
    12e4:	e3ca5f7f 	bic	r5, sl, #508	; 0x1fc
    12e8:	e5990000 	ldr	r0, [r9]
    12ec:	e3c55003 	bic	r5, r5, #3	; 0x3
    12f0:	e1a03823 	mov	r3, r3, lsr #16
    12f4:	e1570003 	cmp	r7, r3
    12f8:	31a06007 	movcc	r6, r7
    12fc:	21a06003 	movcs	r6, r3
    1300:	e1550000 	cmp	r5, r0
    1304:	0a000017 	beq	1368 <sd_raw_write+0xb0>
    1308:	e59f31a0 	ldr	r3, [pc, #416]	; 14b0 <.text+0x14b0>
    130c:	e5d33000 	ldrb	r3, [r3]
    1310:	e3530000 	cmp	r3, #0	; 0x0
    1314:	1a000004 	bne	132c <sd_raw_write+0x74>
    1318:	e59f1194 	ldr	r1, [pc, #404]	; 14b4 <.text+0x14b4>
    131c:	e3a02c02 	mov	r2, #512	; 0x200
    1320:	ebffffe4 	bl	12b8 <sd_raw_write>
    1324:	e3500000 	cmp	r0, #0	; 0x0
    1328:	0a000055 	beq	1484 <sd_raw_write+0x1cc>
    132c:	e59f3184 	ldr	r3, [pc, #388]	; 14b8 <.text+0x14b8>
    1330:	e1560003 	cmp	r6, r3
    1334:	83a03000 	movhi	r3, #0	; 0x0
    1338:	93a03001 	movls	r3, #1	; 0x1
    133c:	e3540000 	cmp	r4, #0	; 0x0
    1340:	13833001 	orrne	r3, r3, #1	; 0x1
    1344:	e3530000 	cmp	r3, #0	; 0x0
    1348:	0a000005 	beq	1364 <sd_raw_write+0xac>
    134c:	e1a00005 	mov	r0, r5
    1350:	e59f115c 	ldr	r1, [pc, #348]	; 14b4 <.text+0x14b4>
    1354:	e3a02c02 	mov	r2, #512	; 0x200
    1358:	ebffff7e 	bl	1158 <sd_raw_read>
    135c:	e3500000 	cmp	r0, #0	; 0x0
    1360:	0a000047 	beq	1484 <sd_raw_write+0x1cc>
    1364:	e5895000 	str	r5, [r9]
    1368:	e59f3144 	ldr	r3, [pc, #324]	; 14b4 <.text+0x14b4>
    136c:	e1580003 	cmp	r8, r3
    1370:	0a000008 	beq	1398 <sd_raw_write+0xe0>
    1374:	e0840003 	add	r0, r4, r3
    1378:	e1a02006 	mov	r2, r6
    137c:	e1a01008 	mov	r1, r8
    1380:	eb001041 	bl	548c <memcpy>
    1384:	e59f3124 	ldr	r3, [pc, #292]	; 14b0 <.text+0x14b0>
    1388:	e3a02000 	mov	r2, #0	; 0x0
    138c:	e1570006 	cmp	r7, r6
    1390:	e5c32000 	strb	r2, [r3]
    1394:	0a000041 	beq	14a0 <sd_raw_write+0x1e8>
    1398:	e59f411c 	ldr	r4, [pc, #284]	; 14bc <.text+0x14bc>
    139c:	e594300c 	ldr	r3, [r4, #12]
    13a0:	e3833080 	orr	r3, r3, #128	; 0x80
    13a4:	e1a01005 	mov	r1, r5
    13a8:	e3a00018 	mov	r0, #24	; 0x18
    13ac:	e584300c 	str	r3, [r4, #12]
    13b0:	ebfffe81 	bl	dbc <sd_raw_send_command_r1>
    13b4:	e3500000 	cmp	r0, #0	; 0x0
    13b8:	1a000033 	bne	148c <sd_raw_write+0x1d4>
    13bc:	e59f30fc 	ldr	r3, [pc, #252]	; 14c0 <.text+0x14c0>
    13c0:	e3a020fe 	mov	r2, #254	; 0xfe
    13c4:	e5832008 	str	r2, [r3, #8]
    13c8:	e59f30f0 	ldr	r3, [pc, #240]	; 14c0 <.text+0x14c0>
    13cc:	e5933004 	ldr	r3, [r3, #4]
    13d0:	e3130080 	tst	r3, #128	; 0x80
    13d4:	0afffffb 	beq	13c8 <sd_raw_write+0x110>
    13d8:	e59f10e4 	ldr	r1, [pc, #228]	; 14c4 <.text+0x14c4>
    13dc:	e5512001 	ldrb	r2, [r1, #-1]
    13e0:	e59f30d8 	ldr	r3, [pc, #216]	; 14c0 <.text+0x14c0>
    13e4:	e5832008 	str	r2, [r3, #8]
    13e8:	e59f20d0 	ldr	r2, [pc, #208]	; 14c0 <.text+0x14c0>
    13ec:	e5923004 	ldr	r3, [r2, #4]
    13f0:	e3130080 	tst	r3, #128	; 0x80
    13f4:	0afffffb 	beq	13e8 <sd_raw_write+0x130>
    13f8:	e59f30c8 	ldr	r3, [pc, #200]	; 14c8 <.text+0x14c8>
    13fc:	e2811001 	add	r1, r1, #1	; 0x1
    1400:	e1510003 	cmp	r1, r3
    1404:	1afffff4 	bne	13dc <sd_raw_write+0x124>
    1408:	e3a030ff 	mov	r3, #255	; 0xff
    140c:	e5823008 	str	r3, [r2, #8]
    1410:	e59f20a8 	ldr	r2, [pc, #168]	; 14c0 <.text+0x14c0>
    1414:	e5923004 	ldr	r3, [r2, #4]
    1418:	e3130080 	tst	r3, #128	; 0x80
    141c:	0afffffb 	beq	1410 <sd_raw_write+0x158>
    1420:	e3a030ff 	mov	r3, #255	; 0xff
    1424:	e5823008 	str	r3, [r2, #8]
    1428:	e59f3090 	ldr	r3, [pc, #144]	; 14c0 <.text+0x14c0>
    142c:	e5933004 	ldr	r3, [r3, #4]
    1430:	e3130080 	tst	r3, #128	; 0x80
    1434:	0afffffb 	beq	1428 <sd_raw_write+0x170>
    1438:	ebfffe54 	bl	d90 <sd_raw_rec_byte>
    143c:	e35000ff 	cmp	r0, #255	; 0xff
    1440:	1afffffc 	bne	1438 <sd_raw_write+0x180>
    1444:	ebfffe51 	bl	d90 <sd_raw_rec_byte>
    1448:	e59f206c 	ldr	r2, [pc, #108]	; 14bc <.text+0x14bc>
    144c:	e5923004 	ldr	r3, [r2, #4]
    1450:	e3833080 	orr	r3, r3, #128	; 0x80
    1454:	e5823004 	str	r3, [r2, #4]
    1458:	e59f3050 	ldr	r3, [pc, #80]	; 14b0 <.text+0x14b0>
    145c:	e0661007 	rsb	r1, r6, r7
    1460:	e3a02001 	mov	r2, #1	; 0x1
    1464:	e1a01801 	mov	r1, r1, lsl #16
    1468:	e5c32000 	strb	r2, [r3]
    146c:	e08aa006 	add	sl, sl, r6
    1470:	e0888006 	add	r8, r8, r6
    1474:	e1a07821 	mov	r7, r1, lsr #16
    1478:	e3570000 	cmp	r7, #0	; 0x0
    147c:	1affff93 	bne	12d0 <sd_raw_write+0x18>
    1480:	ea000006 	b	14a0 <sd_raw_write+0x1e8>
    1484:	e3a00000 	mov	r0, #0	; 0x0
    1488:	ea000005 	b	14a4 <sd_raw_write+0x1ec>
    148c:	e5943004 	ldr	r3, [r4, #4]
    1490:	e3a00000 	mov	r0, #0	; 0x0
    1494:	e3833080 	orr	r3, r3, #128	; 0x80
    1498:	e5843004 	str	r3, [r4, #4]
    149c:	ea000000 	b	14a4 <sd_raw_write+0x1ec>
    14a0:	e3a00001 	mov	r0, #1	; 0x1
    14a4:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    14a8:	e12fff1e 	bx	lr
    14ac:	40000cd8 	ldrmid	r0, [r0], -r8
    14b0:	40000cdc 	ldrmid	r0, [r0], -ip
    14b4:	40000ad8 	ldrmid	r0, [r0], -r8
    14b8:	000001ff 	streqd	r0, [r0], -pc
    14bc:	e0028000 	and	r8, r2, r0
    14c0:	e0020000 	and	r0, r2, r0
    14c4:	40000ad9 	ldrmid	r0, [r0], -r9
    14c8:	40000cd9 	ldrmid	r0, [r0], -r9

000014cc <sd_raw_sync>:
    14cc:	e52de004 	str	lr, [sp, #-4]!
    14d0:	e59f3030 	ldr	r3, [pc, #48]	; 1508 <.text+0x1508>
    14d4:	e5d33000 	ldrb	r3, [r3]
    14d8:	e3530000 	cmp	r3, #0	; 0x0
    14dc:	e59f1028 	ldr	r1, [pc, #40]	; 150c <.text+0x150c>
    14e0:	e3a02c02 	mov	r2, #512	; 0x200
    14e4:	e3a00001 	mov	r0, #1	; 0x1
    14e8:	1a000004 	bne	1500 <sd_raw_sync+0x34>
    14ec:	e59f301c 	ldr	r3, [pc, #28]	; 1510 <.text+0x1510>
    14f0:	e5930000 	ldr	r0, [r3]
    14f4:	ebffff6f 	bl	12b8 <sd_raw_write>
    14f8:	e2500000 	subs	r0, r0, #0	; 0x0
    14fc:	13a00001 	movne	r0, #1	; 0x1
    1500:	e49de004 	ldr	lr, [sp], #4
    1504:	e12fff1e 	bx	lr
    1508:	40000cdc 	ldrmid	r0, [r0], -ip
    150c:	40000ad8 	ldrmid	r0, [r0], -r8
    1510:	40000cd8 	ldrmid	r0, [r0], -r8

00001514 <sd_raw_read_interval>:
    1514:	e1a02802 	mov	r2, r2, lsl #16
    1518:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
    151c:	e1a03803 	mov	r3, r3, lsl #16
    1520:	e3520000 	cmp	r2, #0	; 0x0
    1524:	13510000 	cmpne	r1, #0	; 0x0
    1528:	e1a07001 	mov	r7, r1
    152c:	e1a06000 	mov	r6, r0
    1530:	e1a05823 	mov	r5, r3, lsr #16
    1534:	e28d801c 	add	r8, sp, #28	; 0x1c
    1538:	e8980500 	ldmia	r8, {r8, sl}
    153c:	e1a04822 	mov	r4, r2, lsr #16
    1540:	0a00001a 	beq	15b0 <sd_raw_read_interval+0x9c>
    1544:	e2783001 	rsbs	r3, r8, #1	; 0x1
    1548:	33a03000 	movcc	r3, #0	; 0x0
    154c:	e1550004 	cmp	r5, r4
    1550:	33833001 	orrcc	r3, r3, #1	; 0x1
    1554:	e3530000 	cmp	r3, #0	; 0x0
    1558:	0a00000e 	beq	1598 <sd_raw_read_interval+0x84>
    155c:	ea000013 	b	15b0 <sd_raw_read_interval+0x9c>
    1560:	ebfffefc 	bl	1158 <sd_raw_read>
    1564:	e3500000 	cmp	r0, #0	; 0x0
    1568:	e1a01006 	mov	r1, r6
    156c:	e1a0200a 	mov	r2, sl
    1570:	e1a00007 	mov	r0, r7
    1574:	e0866004 	add	r6, r6, r4
    1578:	0a00000c 	beq	15b0 <sd_raw_read_interval+0x9c>
    157c:	e1a0e00f 	mov	lr, pc
    1580:	e12fff18 	bx	r8
    1584:	e3500000 	cmp	r0, #0	; 0x0
    1588:	0a00000a 	beq	15b8 <sd_raw_read_interval+0xa4>
    158c:	e0643005 	rsb	r3, r4, r5
    1590:	e1a03803 	mov	r3, r3, lsl #16
    1594:	e1a05823 	mov	r5, r3, lsr #16
    1598:	e1550004 	cmp	r5, r4
    159c:	e1a00006 	mov	r0, r6
    15a0:	e1a01007 	mov	r1, r7
    15a4:	e1a02004 	mov	r2, r4
    15a8:	2affffec 	bcs	1560 <sd_raw_read_interval+0x4c>
    15ac:	ea000001 	b	15b8 <sd_raw_read_interval+0xa4>
    15b0:	e3a00000 	mov	r0, #0	; 0x0
    15b4:	ea000000 	b	15bc <sd_raw_read_interval+0xa8>
    15b8:	e3a00001 	mov	r0, #1	; 0x1
    15bc:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
    15c0:	e12fff1e 	bx	lr

000015c4 <sd_raw_init>:
    15c4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    15c8:	e59f41e0 	ldr	r4, [pc, #480]	; 17b0 <.text+0x17b0>
    15cc:	e5943008 	ldr	r3, [r4, #8]
    15d0:	e3833080 	orr	r3, r3, #128	; 0x80
    15d4:	e5843008 	str	r3, [r4, #8]
    15d8:	e59f21d4 	ldr	r2, [pc, #468]	; 17b4 <.text+0x17b4>
    15dc:	e5923000 	ldr	r3, [r2]
    15e0:	e3833a01 	orr	r3, r3, #4096	; 0x1000
    15e4:	e5823000 	str	r3, [r2]
    15e8:	e5923000 	ldr	r3, [r2]
    15ec:	e3833b01 	orr	r3, r3, #1024	; 0x400
    15f0:	e5823000 	str	r3, [r2]
    15f4:	e5923000 	ldr	r3, [r2]
    15f8:	e3833c01 	orr	r3, r3, #256	; 0x100
    15fc:	e5823000 	str	r3, [r2]
    1600:	e5943004 	ldr	r3, [r4, #4]
    1604:	e3833080 	orr	r3, r3, #128	; 0x80
    1608:	e5843004 	str	r3, [r4, #4]
    160c:	e2422903 	sub	r2, r2, #49152	; 0xc000
    1610:	e3a03096 	mov	r3, #150	; 0x96
    1614:	e582300c 	str	r3, [r2, #12]
    1618:	e3a03038 	mov	r3, #56	; 0x38
    161c:	e5823000 	str	r3, [r2]
    1620:	ebfffdcb 	bl	d54 <sd_raw_available>
    1624:	e2505000 	subs	r5, r0, #0	; 0x0
    1628:	1a000002 	bne	1638 <sd_raw_init+0x74>
    162c:	e59f0184 	ldr	r0, [pc, #388]	; 17b8 <.text+0x17b8>
    1630:	ebfffb68 	bl	3d8 <rprintf>
    1634:	ea000045 	b	1750 <sd_raw_init+0x18c>
    1638:	e5943008 	ldr	r3, [r4, #8]
    163c:	e3833080 	orr	r3, r3, #128	; 0x80
    1640:	e5843008 	str	r3, [r4, #8]
    1644:	e5943004 	ldr	r3, [r4, #4]
    1648:	e3833080 	orr	r3, r3, #128	; 0x80
    164c:	e5843004 	str	r3, [r4, #4]
    1650:	e3a04000 	mov	r4, #0	; 0x0
    1654:	ebfffdcd 	bl	d90 <sd_raw_rec_byte>
    1658:	e2843001 	add	r3, r4, #1	; 0x1
    165c:	e1a03803 	mov	r3, r3, lsl #16
    1660:	e1a04823 	mov	r4, r3, lsr #16
    1664:	e354000a 	cmp	r4, #10	; 0xa
    1668:	1afffff9 	bne	1654 <sd_raw_init+0x90>
    166c:	e59f213c 	ldr	r2, [pc, #316]	; 17b0 <.text+0x17b0>
    1670:	e592300c 	ldr	r3, [r2, #12]
    1674:	e3833080 	orr	r3, r3, #128	; 0x80
    1678:	e582300c 	str	r3, [r2, #12]
    167c:	e3a04000 	mov	r4, #0	; 0x0
    1680:	e3a00000 	mov	r0, #0	; 0x0
    1684:	e1a01000 	mov	r1, r0
    1688:	ebfffdcb 	bl	dbc <sd_raw_send_command_r1>
    168c:	e2843001 	add	r3, r4, #1	; 0x1
    1690:	e3500001 	cmp	r0, #1	; 0x1
    1694:	e1a02803 	mov	r2, r3, lsl #16
    1698:	0a000004 	beq	16b0 <sd_raw_init+0xec>
    169c:	e59f3118 	ldr	r3, [pc, #280]	; 17bc <.text+0x17bc>
    16a0:	e1540003 	cmp	r4, r3
    16a4:	e1a04822 	mov	r4, r2, lsr #16
    16a8:	0a00002a 	beq	1758 <sd_raw_init+0x194>
    16ac:	eafffff3 	b	1680 <sd_raw_init+0xbc>
    16b0:	e3a04000 	mov	r4, #0	; 0x0
    16b4:	e3a01000 	mov	r1, #0	; 0x0
    16b8:	e3a00001 	mov	r0, #1	; 0x1
    16bc:	ebfffdbe 	bl	dbc <sd_raw_send_command_r1>
    16c0:	e2843001 	add	r3, r4, #1	; 0x1
    16c4:	e3100001 	tst	r0, #1	; 0x1
    16c8:	e1a02803 	mov	r2, r3, lsl #16
    16cc:	0a000004 	beq	16e4 <sd_raw_init+0x120>
    16d0:	e59f30e8 	ldr	r3, [pc, #232]	; 17c0 <.text+0x17c0>
    16d4:	e1540003 	cmp	r4, r3
    16d8:	e1a04822 	mov	r4, r2, lsr #16
    16dc:	0a000026 	beq	177c <sd_raw_init+0x1b8>
    16e0:	eafffff3 	b	16b4 <sd_raw_init+0xf0>
    16e4:	e3a00010 	mov	r0, #16	; 0x10
    16e8:	e3a01c02 	mov	r1, #512	; 0x200
    16ec:	ebfffdb2 	bl	dbc <sd_raw_send_command_r1>
    16f0:	e3500000 	cmp	r0, #0	; 0x0
    16f4:	159f20b4 	ldrne	r2, [pc, #180]	; 17b0 <.text+0x17b0>
    16f8:	15923004 	ldrne	r3, [r2, #4]
    16fc:	159f00c0 	ldrne	r0, [pc, #192]	; 17c4 <.text+0x17c4>
    1700:	13833080 	orrne	r3, r3, #128	; 0x80
    1704:	1a000020 	bne	178c <sd_raw_init+0x1c8>
    1708:	e59fc0a0 	ldr	ip, [pc, #160]	; 17b0 <.text+0x17b0>
    170c:	e59c3004 	ldr	r3, [ip, #4]
    1710:	e3833080 	orr	r3, r3, #128	; 0x80
    1714:	e58c3004 	str	r3, [ip, #4]
    1718:	e59f30a8 	ldr	r3, [pc, #168]	; 17c8 <.text+0x17c8>
    171c:	e3e0c000 	mvn	ip, #0	; 0x0
    1720:	e583c000 	str	ip, [r3]
    1724:	e59f30a0 	ldr	r3, [pc, #160]	; 17cc <.text+0x17cc>
    1728:	e28cc03d 	add	ip, ip, #61	; 0x3d
    172c:	e583c00c 	str	ip, [r3, #12]
    1730:	e59f3098 	ldr	r3, [pc, #152]	; 17d0 <.text+0x17d0>
    1734:	e3a05001 	mov	r5, #1	; 0x1
    1738:	e59f1094 	ldr	r1, [pc, #148]	; 17d4 <.text+0x17d4>
    173c:	e3a02c02 	mov	r2, #512	; 0x200
    1740:	e5c35000 	strb	r5, [r3]
    1744:	ebfffe83 	bl	1158 <sd_raw_read>
    1748:	e2504000 	subs	r4, r0, #0	; 0x0
    174c:	0a000012 	beq	179c <sd_raw_init+0x1d8>
    1750:	e1a00005 	mov	r0, r5
    1754:	ea000013 	b	17a8 <sd_raw_init+0x1e4>
    1758:	e1a01000 	mov	r1, r0
    175c:	e59f0074 	ldr	r0, [pc, #116]	; 17d8 <.text+0x17d8>
    1760:	ebfffb1c 	bl	3d8 <rprintf>
    1764:	e59f2044 	ldr	r2, [pc, #68]	; 17b0 <.text+0x17b0>
    1768:	e5923004 	ldr	r3, [r2, #4]
    176c:	e3a00000 	mov	r0, #0	; 0x0
    1770:	e3833080 	orr	r3, r3, #128	; 0x80
    1774:	e5823004 	str	r3, [r2, #4]
    1778:	ea00000a 	b	17a8 <sd_raw_init+0x1e4>
    177c:	e59f202c 	ldr	r2, [pc, #44]	; 17b0 <.text+0x17b0>
    1780:	e5923004 	ldr	r3, [r2, #4]
    1784:	e59f0050 	ldr	r0, [pc, #80]	; 17dc <.text+0x17dc>
    1788:	e3833080 	orr	r3, r3, #128	; 0x80
    178c:	e5823004 	str	r3, [r2, #4]
    1790:	ebfffb10 	bl	3d8 <rprintf>
    1794:	e3a00000 	mov	r0, #0	; 0x0
    1798:	ea000002 	b	17a8 <sd_raw_init+0x1e4>
    179c:	e59f003c 	ldr	r0, [pc, #60]	; 17e0 <.text+0x17e0>
    17a0:	ebfffb0c 	bl	3d8 <rprintf>
    17a4:	e1a00004 	mov	r0, r4
    17a8:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    17ac:	e12fff1e 	bx	lr
    17b0:	e0028000 	and	r8, r2, r0
    17b4:	e002c000 	and	ip, r2, r0
    17b8:	00005ed0 	ldreqd	r5, [r0], -r0
    17bc:	000001ff 	streqd	r0, [r0], -pc
    17c0:	00007fff 	streqd	r7, [r0], -pc
    17c4:	00005f0c 	andeq	r5, r0, ip, lsl #30
    17c8:	40000cd8 	ldrmid	r0, [r0], -r8
    17cc:	e0020000 	and	r0, r2, r0
    17d0:	40000cdc 	ldrmid	r0, [r0], -ip
    17d4:	40000ad8 	ldrmid	r0, [r0], -r8
    17d8:	00005ee8 	andeq	r5, r0, r8, ror #29
    17dc:	00005efc 	streqd	r5, [r0], -ip
    17e0:	00005f24 	andeq	r5, r0, r4, lsr #30

000017e4 <format_card>:

//NES : 10-28-7 
//Low-level formats a 512MB card
//Assumes *many* things
//You must pass this fuction 0xAA to get it to work (safety check)
char format_card(char make_sure)
{
    17e4:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    17e8:	e20000ff 	and	r0, r0, #255	; 0xff
	#define MBR_LOCATION	0x00
	#define BR_LOCATION		(MBR_LOCATION+0x80000)
	#define FAT_TABLE		(BR_LOCATION + (0x200 * 512))
	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))

	//Safety check
	if (make_sure != 0xAA) return 0;
    17ec:	e35000aa 	cmp	r0, #170	; 0xaa
    17f0:	e24ddc02 	sub	sp, sp, #512	; 0x200
    17f4:	13a00000 	movne	r0, #0	; 0x0
    17f8:	1a00006d 	bne	19b4 <format_card+0x1d0>
    17fc:	e3a04000 	mov	r4, #0	; 0x0
	
	int i;
	unsigned char my_buff[512];
	for(i = 0 ; i < 512 ; i++) my_buff[i] = 0x00;
    1800:	e3a06000 	mov	r6, #0	; 0x0
    1804:	e7c4600d 	strb	r6, [r4, sp]
    1808:	e2844001 	add	r4, r4, #1	; 0x1
    180c:	e3540c02 	cmp	r4, #512	; 0x200
    1810:	1afffffa 	bne	1800 <format_card+0x1c>
	
	//Init SD card interface
	sd_raw_init();
    1814:	ebffff6a 	bl	15c4 <sd_raw_init>

	//Erase Master Boot record
	sd_raw_sync();
    1818:	ebffff2b 	bl	14cc <sd_raw_sync>
	sd_raw_write(MBR_LOCATION, my_buff, 512);
    181c:	e1a02004 	mov	r2, r4
    1820:	e1a0100d 	mov	r1, sp
    1824:	e1a00006 	mov	r0, r6
    1828:	ebfffea2 	bl	12b8 <sd_raw_write>

	//Erase Boot record
	sd_raw_sync();
    182c:	ebffff26 	bl	14cc <sd_raw_sync>
	sd_raw_write(BR_LOCATION, my_buff, 512);
    1830:	e1a02004 	mov	r2, r4
    1834:	e1a0100d 	mov	r1, sp
    1838:	e3a00702 	mov	r0, #524288	; 0x80000
    183c:	ebfffe9d 	bl	12b8 <sd_raw_write>
    1840:	e3a04703 	mov	r4, #786432	; 0xc0000

	//Erase FAT tables
	for(i = 0 ; i < 0x00F5 ; i++) //0x00F5 = 245 bytes : comes from byte 0x16 from Boot Record
	{
		sd_raw_sync();
    1844:	ebffff20 	bl	14cc <sd_raw_sync>
		sd_raw_write( (FAT_TABLE + (i*512)), my_buff, 512);
    1848:	e1a00004 	mov	r0, r4
    184c:	e1a0100d 	mov	r1, sp
    1850:	e3a02c02 	mov	r2, #512	; 0x200
    1854:	ebfffe97 	bl	12b8 <sd_raw_write>
    1858:	e59f3160 	ldr	r3, [pc, #352]	; 19c0 <.text+0x19c0>
    185c:	e2844c02 	add	r4, r4, #512	; 0x200
    1860:	e1540003 	cmp	r4, r3
    1864:	e1a0900d 	mov	r9, sp
    1868:	1afffff5 	bne	1844 <format_card+0x60>
	}
	
	//Write Master Boot Record
	#define PART1	0x01BE
	my_buff[PART1 + 0] = 0x00;
	my_buff[PART1 + 1] = 0x00;
	my_buff[PART1 + 2] = 0x01;
	my_buff[PART1 + 3] = 0x01;
	my_buff[PART1 + 4] = 0x06;
    186c:	e3a03006 	mov	r3, #6	; 0x6
    1870:	e5cd31c2 	strb	r3, [sp, #450]
	my_buff[PART1 + 5] = 0x1F;
    1874:	e2833019 	add	r3, r3, #25	; 0x19
    1878:	e5cd31c3 	strb	r3, [sp, #451]
	my_buff[PART1 + 6] = 0xE0;
    187c:	e3e0301f 	mvn	r3, #31	; 0x1f
    1880:	e3a04000 	mov	r4, #0	; 0x0
    1884:	e3a02001 	mov	r2, #1	; 0x1
	my_buff[PART1 + 7] = 0xD3;
	my_buff[PART1 + 8] = 0x00;
	my_buff[PART1 + 9] = 0x04;
	my_buff[PART1 + 10] = 0x00;
	my_buff[PART1 + 11] = 0x00;
	my_buff[PART1 + 12] = 0x00;
	my_buff[PART1 + 13] = 0x4C;
	my_buff[PART1 + 14] = 0x0F;
	my_buff[510] = 0x55;
    1888:	e3a05055 	mov	r5, #85	; 0x55
    188c:	e3a06004 	mov	r6, #4	; 0x4
    1890:	e3a0704c 	mov	r7, #76	; 0x4c
    1894:	e3a0800f 	mov	r8, #15	; 0xf
	my_buff[511] = 0xAA;
    1898:	e3e0a055 	mvn	sl, #85	; 0x55
    189c:	e5cd31c4 	strb	r3, [sp, #452]
    18a0:	e3e0302c 	mvn	r3, #44	; 0x2c
    18a4:	e5cd31c5 	strb	r3, [sp, #453]
    18a8:	e5cd21c1 	strb	r2, [sp, #449]
    18ac:	e5cd21c0 	strb	r2, [sp, #448]
    18b0:	e5cd41be 	strb	r4, [sp, #446]
    18b4:	e5cd41bf 	strb	r4, [sp, #447]
    18b8:	e5cd41c6 	strb	r4, [sp, #454]
    18bc:	e5cd61c7 	strb	r6, [sp, #455]
    18c0:	e5cd41c8 	strb	r4, [sp, #456]
    18c4:	e5cd41c9 	strb	r4, [sp, #457]
    18c8:	e5cd41ca 	strb	r4, [sp, #458]
    18cc:	e5cd71cb 	strb	r7, [sp, #459]
    18d0:	e5cd81cc 	strb	r8, [sp, #460]
    18d4:	e5cd51fe 	strb	r5, [sp, #510]
    18d8:	e5cda1ff 	strb	sl, [sp, #511]

	sd_raw_sync();
    18dc:	ebfffefa 	bl	14cc <sd_raw_sync>
	sd_raw_write(MBR_LOCATION, my_buff, 512);
    18e0:	e1a0100d 	mov	r1, sp
    18e4:	e3a02c02 	mov	r2, #512	; 0x200
    18e8:	e1a00004 	mov	r0, r4
    18ec:	ebfffe71 	bl	12b8 <sd_raw_write>
	sd_raw_sync();
    18f0:	ebfffef5 	bl	14cc <sd_raw_sync>

	//Write Boot Record
	#define BOOTRECORD1	0x80000
	my_buff[0] = 0xEB;
    18f4:	e3e03014 	mvn	r3, #20	; 0x14
    18f8:	e5cd3000 	strb	r3, [sp]
	my_buff[1] = 0xFE;
    18fc:	e2833013 	add	r3, r3, #19	; 0x13
    1900:	e5cd3001 	strb	r3, [sp, #1]
	my_buff[2] = 0x90;
    1904:	e3e0306f 	mvn	r3, #111	; 0x6f
    1908:	e5cd3002 	strb	r3, [sp, #2]
	my_buff[12] = 0x02;
	my_buff[13] = 0x10;
    190c:	e2833080 	add	r3, r3, #128	; 0x80
    1910:	e5cd300d 	strb	r3, [sp, #13]
	my_buff[14] = 0x16;
    1914:	e2833006 	add	r3, r3, #6	; 0x6
    1918:	e5cd300e 	strb	r3, [sp, #14]
	my_buff[16] = 0x02;
	my_buff[18] = 0x02;
	my_buff[21] = 0xF8;
    191c:	e3e03007 	mvn	r3, #7	; 0x7
    1920:	e5cd3015 	strb	r3, [sp, #21]
	my_buff[22] = 0xF5;
    1924:	e3e0300a 	mvn	r3, #10	; 0xa
    1928:	e5cd3016 	strb	r3, [sp, #22]
	my_buff[24] = 0x20;
	my_buff[26] = 0x20;
	my_buff[29] = 0x04;
	my_buff[33] = 0x4C;
	my_buff[34] = 0x0F;
	my_buff[38] = 0x29;
    192c:	e2833034 	add	r3, r3, #52	; 0x34
    1930:	e5cd3026 	strb	r3, [sp, #38]
	my_buff[54] = 0x46;
    1934:	e283301d 	add	r3, r3, #29	; 0x1d
    1938:	e5cd3036 	strb	r3, [sp, #54]
	my_buff[55] = 0x41;
    193c:	e3a03041 	mov	r3, #65	; 0x41
    1940:	e5cd3037 	strb	r3, [sp, #55]
	my_buff[56] = 0x54;
    1944:	e2833013 	add	r3, r3, #19	; 0x13
    1948:	e5cd3038 	strb	r3, [sp, #56]
	my_buff[57] = 0x31;
    194c:	e3a03031 	mov	r3, #49	; 0x31
    1950:	e3a02020 	mov	r2, #32	; 0x20
    1954:	e3a01002 	mov	r1, #2	; 0x2
    1958:	e5cd3039 	strb	r3, [sp, #57]
	my_buff[58] = 0x36;
    195c:	e2833005 	add	r3, r3, #5	; 0x5
    1960:	e5cd303a 	strb	r3, [sp, #58]
    1964:	e5cd1012 	strb	r1, [sp, #18]
	my_buff[59] = 0x20;
	my_buff[60] = 0x20;
	my_buff[61] = 0x20;
    1968:	e5cd203d 	strb	r2, [sp, #61]
    196c:	e5cd100c 	strb	r1, [sp, #12]
    1970:	e5cd1010 	strb	r1, [sp, #16]
    1974:	e5cd2018 	strb	r2, [sp, #24]
    1978:	e5cd201a 	strb	r2, [sp, #26]
    197c:	e5cd203b 	strb	r2, [sp, #59]
    1980:	e5cd203c 	strb	r2, [sp, #60]
    1984:	e5cd601d 	strb	r6, [sp, #29]
    1988:	e5cd7021 	strb	r7, [sp, #33]
    198c:	e5cd8022 	strb	r8, [sp, #34]
	my_buff[510] = 0x55;
	my_buff[511] = 0xAA;
    1990:	e5cda1ff 	strb	sl, [sp, #511]
    1994:	e5cd51fe 	strb	r5, [sp, #510]
	
	sd_raw_sync();
    1998:	ebfffecb 	bl	14cc <sd_raw_sync>
	sd_raw_write(BR_LOCATION, my_buff, 512);
    199c:	e1a0100d 	mov	r1, sp
    19a0:	e3a02c02 	mov	r2, #512	; 0x200
    19a4:	e3a00702 	mov	r0, #524288	; 0x80000
    19a8:	ebfffe42 	bl	12b8 <sd_raw_write>
	sd_raw_sync();
    19ac:	ebfffec6 	bl	14cc <sd_raw_sync>
    19b0:	e1a00005 	mov	r0, r5
	
	return(0x55); //Successful format
}
    19b4:	e28ddc02 	add	sp, sp, #512	; 0x200
    19b8:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    19bc:	e12fff1e 	bx	lr
    19c0:	000dea00 	andeq	lr, sp, r0, lsl #20

000019c4 <fat16_dir_entry_seek_callback>:
{
    struct fat16_read_callback_arg* arg = p;

    /* skip deleted or empty entries */
    if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
    19c4:	e5d03000 	ldrb	r3, [r0]
    19c8:	e3530000 	cmp	r3, #0	; 0x0
    19cc:	135300e5 	cmpne	r3, #229	; 0xe5
    19d0:	0a000015 	beq	1a2c <fat16_dir_entry_seek_callback+0x68>
        return 1;

    if(arg->entry_cur == arg->entry_num)
    19d4:	e1d2c0b0 	ldrh	ip, [r2]
    19d8:	e1d230b2 	ldrh	r3, [r2, #2]
    19dc:	e153000c 	cmp	r3, ip
    19e0:	1a00000b 	bne	1a14 <fat16_dir_entry_seek_callback+0x50>
    {
        arg->entry_offset = offset;
    19e4:	e5821004 	str	r1, [r2, #4]
        arg->byte_count = buffer[11] == 0x0f ?
    19e8:	e5d0300b 	ldrb	r3, [r0, #11]
    19ec:	e353000f 	cmp	r3, #15	; 0xf
    19f0:	05d03000 	ldreqb	r3, [r0]
    19f4:	0203303f 	andeq	r3, r3, #63	; 0x3f
    19f8:	01a03283 	moveq	r3, r3, lsl #5
    19fc:	02833020 	addeq	r3, r3, #32	; 0x20
    1a00:	e3a01020 	mov	r1, #32	; 0x20
    1a04:	e3a00000 	mov	r0, #0	; 0x0
    1a08:	020310ff 	andeq	r1, r3, #255	; 0xff
    1a0c:	e5c21008 	strb	r1, [r2, #8]
    1a10:	e12fff1e 	bx	lr
        ((buffer[0] & FAT16_DIRENTRY_LFNSEQMASK) + 1) * 32 :
        32;
        return 0;
    }

    /* if we read a 8.3 entry, we reached a new directory entry */
    if(buffer[11] != 0x0f)
    1a14:	e5d0300b 	ldrb	r3, [r0, #11]
        ++arg->entry_cur;
    1a18:	e28c1001 	add	r1, ip, #1	; 0x1
    1a1c:	e353000f 	cmp	r3, #15	; 0xf
    1a20:	e3a00001 	mov	r0, #1	; 0x1
    1a24:	11c210b0 	strneh	r1, [r2]
    1a28:	112fff1e 	bxne	lr
    1a2c:	e3a00001 	mov	r0, #1	; 0x1

    return 1;
}
    1a30:	e12fff1e 	bx	lr

00001a34 <fat16_dir_entry_read_callback>:

/**
 * \ingroup fat16_fs
 * Callback function for reading a directory entry.
 */
uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p)
{
    1a34:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    struct fat16_dir_entry_struct* dir_entry = p;

    /* there should not be any deleted or empty entries */
    if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
    1a38:	e5d03000 	ldrb	r3, [r0]
    1a3c:	e3530000 	cmp	r3, #0	; 0x0
    1a40:	135300e5 	cmpne	r3, #229	; 0xe5
    1a44:	e1a0c002 	mov	ip, r2
    1a48:	0a000062 	beq	1bd8 <fat16_dir_entry_read_callback+0x1a4>
        return 0;

    if(!dir_entry->entry_offset)
    1a4c:	e5923028 	ldr	r3, [r2, #40]
    1a50:	e3530000 	cmp	r3, #0	; 0x0
        dir_entry->entry_offset = offset;
    1a54:	05821028 	streq	r1, [r2, #40]

    switch(fat16_interpret_dir_entry(dir_entry, buffer))
    {
        case 0: /* failure */
            return 0;
            case 1: /* buffer successfully parsed, continue */
            return 1;
            case 2: /* directory entry complete, finish */
            return 0;
        }

    return 0;
}

/**
 * \ingroup fat16_fs
 * Interprets a raw directory entry and puts the contained
 * information into the directory entry.
 *
 * For a single file there may exist multiple directory
 * entries. All except the last one are lfn entries, which
 * contain parts of the long filename. The last directory
 * entry is a traditional 8.3 style one. It contains all
 * other information like size, cluster, date and time.
 *
 * \param[in,out] dir_entry The directory entry to fill.
 * \param[in] raw_entry A pointer to 32 bytes of raw data.
 * \returns 0 on failure, 1 on success and 2 if the
 *          directory entry is complete.
 */
uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* raw_entry)
{
    if(!dir_entry || !raw_entry || !raw_entry[0])
    1a58:	e5d02000 	ldrb	r2, [r0]
    1a5c:	e3520000 	cmp	r2, #0	; 0x0
    1a60:	0a00005c 	beq	1bd8 <fat16_dir_entry_read_callback+0x1a4>
        return 0;

    char* long_name = dir_entry->long_name;
    if(raw_entry[11] == 0x0f)
    1a64:	e5d0300b 	ldrb	r3, [r0, #11]
    1a68:	e353000f 	cmp	r3, #15	; 0xf
    1a6c:	e280500b 	add	r5, r0, #11	; 0xb
    1a70:	1a000026 	bne	1b10 <fat16_dir_entry_read_callback+0xdc>
    {
        uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
    1a74:	e202203f 	and	r2, r2, #63	; 0x3f
    1a78:	e3a0300d 	mov	r3, #13	; 0xd
    1a7c:	e0030392 	mul	r3, r2, r3
    1a80:	e243300d 	sub	r3, r3, #13	; 0xd
    1a84:	e1a03803 	mov	r3, r3, lsl #16
    1a88:	e1a02823 	mov	r2, r3, lsr #16

        if(char_offset + 12 < sizeof(dir_entry->long_name))
    1a8c:	e282300c 	add	r3, r2, #12	; 0xc
    1a90:	e353001f 	cmp	r3, #31	; 0x1f
    1a94:	83a00001 	movhi	r0, #1	; 0x1
    1a98:	8a00004f 	bhi	1bdc <fat16_dir_entry_read_callback+0x1a8>
        {
            /* Lfn supports unicode, but we do not, for now.
                                                 * So we assume pure ascii and read only every
                                                 * second byte.
                                                 */
            long_name[char_offset + 0] = raw_entry[1];
    1a9c:	e5d03001 	ldrb	r3, [r0, #1]
    1aa0:	e7cc3002 	strb	r3, [ip, r2]
            long_name[char_offset + 1] = raw_entry[3];
    1aa4:	e5d03003 	ldrb	r3, [r0, #3]
    1aa8:	e08c2002 	add	r2, ip, r2
    1aac:	e5c23001 	strb	r3, [r2, #1]
            long_name[char_offset + 2] = raw_entry[5];
    1ab0:	e5d03005 	ldrb	r3, [r0, #5]
    1ab4:	e5c23002 	strb	r3, [r2, #2]
            long_name[char_offset + 3] = raw_entry[7];
    1ab8:	e5d03007 	ldrb	r3, [r0, #7]
    1abc:	e5c23003 	strb	r3, [r2, #3]
            long_name[char_offset + 4] = raw_entry[9];
    1ac0:	e5d03009 	ldrb	r3, [r0, #9]
    1ac4:	e5c23004 	strb	r3, [r2, #4]
            long_name[char_offset + 5] = raw_entry[14];
    1ac8:	e5d0300e 	ldrb	r3, [r0, #14]
    1acc:	e5c23005 	strb	r3, [r2, #5]
            long_name[char_offset + 6] = raw_entry[16];
    1ad0:	e5d03010 	ldrb	r3, [r0, #16]
    1ad4:	e5c23006 	strb	r3, [r2, #6]
            long_name[char_offset + 7] = raw_entry[18];
    1ad8:	e5d03012 	ldrb	r3, [r0, #18]
    1adc:	e5c23007 	strb	r3, [r2, #7]
            long_name[char_offset + 8] = raw_entry[20];
    1ae0:	e5d03014 	ldrb	r3, [r0, #20]
    1ae4:	e5c23008 	strb	r3, [r2, #8]
            long_name[char_offset + 9] = raw_entry[22];
    1ae8:	e5d03016 	ldrb	r3, [r0, #22]
    1aec:	e5c23009 	strb	r3, [r2, #9]
            long_name[char_offset + 10] = raw_entry[24];
    1af0:	e5d03018 	ldrb	r3, [r0, #24]
    1af4:	e5c2300a 	strb	r3, [r2, #10]
            long_name[char_offset + 11] = raw_entry[28];
    1af8:	e5d0301c 	ldrb	r3, [r0, #28]
    1afc:	e5c2300b 	strb	r3, [r2, #11]
            long_name[char_offset + 12] = raw_entry[30];
    1b00:	e5d0301e 	ldrb	r3, [r0, #30]
    1b04:	e3a00001 	mov	r0, #1	; 0x1
    1b08:	e5c2300c 	strb	r3, [r2, #12]
    1b0c:	ea000032 	b	1bdc <fat16_dir_entry_read_callback+0x1a8>
        }

        return 1;
    }
    else
    {
        /* if we do not have a long name, take the short one */
        if(long_name[0] == '\0')
    1b10:	e5dc2000 	ldrb	r2, [ip]
    1b14:	e3520000 	cmp	r2, #0	; 0x0
    1b18:	1a00001d 	bne	1b94 <fat16_dir_entry_read_callback+0x160>
    1b1c:	e1a01002 	mov	r1, r2
        {
            uint8_t i;
            for(i = 0; i < 8; ++i)
            {
                if(raw_entry[i] == ' ')
    1b20:	e7d23000 	ldrb	r3, [r2, r0]
    1b24:	e3530020 	cmp	r3, #32	; 0x20
    1b28:	e281e001 	add	lr, r1, #1	; 0x1
    1b2c:	0a000004 	beq	1b44 <fat16_dir_entry_read_callback+0x110>
    1b30:	e20e10ff 	and	r1, lr, #255	; 0xff
    1b34:	e3510008 	cmp	r1, #8	; 0x8
                    break;
                long_name[i] = raw_entry[i];
    1b38:	e7c2300c 	strb	r3, [r2, ip]
    1b3c:	e2822001 	add	r2, r2, #1	; 0x1
    1b40:	1afffff6 	bne	1b20 <fat16_dir_entry_read_callback+0xec>
            }
            if(raw_entry[8] != ' ')
    1b44:	e5d03008 	ldrb	r3, [r0, #8]
    1b48:	e3530020 	cmp	r3, #32	; 0x20
    1b4c:	0a00000e 	beq	1b8c <fat16_dir_entry_read_callback+0x158>
            {
                long_name[i++] = '.';
    1b50:	e3a0302e 	mov	r3, #46	; 0x2e
    1b54:	e2812001 	add	r2, r1, #1	; 0x1
    1b58:	e7cc3001 	strb	r3, [ip, r1]
    1b5c:	e20210ff 	and	r1, r2, #255	; 0xff
    1b60:	e1a03000 	mov	r3, r0

                uint8_t j = 8;
                for(; j < 11; ++j)
                {
                    if(raw_entry[j] != ' ')
    1b64:	e5d32008 	ldrb	r2, [r3, #8]
    1b68:	e3520020 	cmp	r2, #32	; 0x20
    1b6c:	e280e003 	add	lr, r0, #3	; 0x3
                    {
                        long_name[i++] = raw_entry[j];
    1b70:	e2814001 	add	r4, r1, #1	; 0x1
    1b74:	e2833001 	add	r3, r3, #1	; 0x1
    1b78:	0a000003 	beq	1b8c <fat16_dir_entry_read_callback+0x158>
    1b7c:	e153000e 	cmp	r3, lr
    1b80:	e7cc2001 	strb	r2, [ip, r1]
    1b84:	e20410ff 	and	r1, r4, #255	; 0xff
    1b88:	1afffff5 	bne	1b64 <fat16_dir_entry_read_callback+0x130>
                    }
                    else
                    {
                        break;
                    }
                }
            }

            long_name[i] = '\0';
    1b8c:	e3a03000 	mov	r3, #0	; 0x0
    1b90:	e7cc3001 	strb	r3, [ip, r1]
        }

        /* extract properties of file and store them within the structure */
        dir_entry->attributes = raw_entry[11];
    1b94:	e5d53000 	ldrb	r3, [r5]
    1b98:	e5cc3020 	strb	r3, [ip, #32]
        dir_entry->cluster = ((uint16_t) raw_entry[26]) |
    1b9c:	e5d0201b 	ldrb	r2, [r0, #27]
    1ba0:	e5d0301a 	ldrb	r3, [r0, #26]
    1ba4:	e1833402 	orr	r3, r3, r2, lsl #8
    1ba8:	e1cc32b2 	strh	r3, [ip, #34]
        ((uint16_t) raw_entry[27] << 8);
        dir_entry->file_size = ((uint32_t) raw_entry[28]) |
    1bac:	e5d0301e 	ldrb	r3, [r0, #30]
    1bb0:	e5d0201c 	ldrb	r2, [r0, #28]
    1bb4:	e5d0101d 	ldrb	r1, [r0, #29]
    1bb8:	e5d0001f 	ldrb	r0, [r0, #31]
    1bbc:	e1a03803 	mov	r3, r3, lsl #16
    1bc0:	e1833c00 	orr	r3, r3, r0, lsl #24
    1bc4:	e1822401 	orr	r2, r2, r1, lsl #8
    1bc8:	e1822003 	orr	r2, r2, r3
    1bcc:	e3a00000 	mov	r0, #0	; 0x0
    1bd0:	e58c2024 	str	r2, [ip, #36]
    1bd4:	ea000000 	b	1bdc <fat16_dir_entry_read_callback+0x1a8>
    1bd8:	e3a00000 	mov	r0, #0	; 0x0
    1bdc:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    1be0:	e12fff1e 	bx	lr

00001be4 <fat16_get_next_cluster>:
        ((uint32_t) raw_entry[29] << 8) |
        ((uint32_t) raw_entry[30] << 16) |
        ((uint32_t) raw_entry[31] << 24);

        return 2;
    }
}

/**
 * \ingroup fat16_file
 * Retrieves the directory entry of a path.
 *
 * The given path may both describe a file or a directory.
 *
 * \param[in] fs The FAT16 filesystem on which to search.
 * \param[in] path The path of which to read the directory entry.
 * \param[out] dir_entry The directory entry to fill.
 * \returns 0 on failure, 1 on success.
 * \see fat16_read_dir
 */
uint8_t fat16_get_dir_entry_of_path(struct fat16_fs_struct* fs, const char* path, struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !path || path[0] == '\0' || !dir_entry)
        return 0;

    if(path[0] == '/')
        ++path;

    /* begin with the root directory */
    memset(dir_entry, 0, sizeof(*dir_entry));
    dir_entry->attributes = FAT16_ATTRIB_DIR;

    if(path[0] == '\0')
        return 1;

    while(1)
    {
        struct fat16_dir_struct* dd = fat16_open_dir(fs, dir_entry);
        if(!dd)
            break;

        /* extract the next hierarchy we will search for */
        const char* sep_pos = strchr(path, '/');
        if(!sep_pos)
            sep_pos = path + strlen(path);
        uint8_t length_to_sep = sep_pos - path;

        /* read directory entries */
        while(fat16_read_dir(dd, dir_entry))
        {
            /* check if we have found the next hierarchy */
            if((strlen(dir_entry->long_name) != length_to_sep ||
                strncmp(path, dir_entry->long_name, length_to_sep) != 0))
            continue;

            fat16_close_dir(dd);
            dd = 0;

            if(path[length_to_sep] == '\0')
    /* we iterated through the whole path and have found the file */
                return 1;

            if(dir_entry->attributes & FAT16_ATTRIB_DIR)
            {
                /* we found a parent directory of the file we are searching for */
                path = sep_pos + 1;
                break;
            }

            /* a parent of the file exists, but not the file itself */
            return 0;
        }

        fat16_close_dir(dd);
    }

    return 0;
}

/**
 * \ingroup fat16_fs
 * Retrieves the next following cluster of a given cluster.
 *
 * Using the filesystem file allocation table, this function returns
 * the number of the cluster containing the data directly following
 * the data within the cluster with the given number.
 *
 * \param[in] fs The filesystem for which to determine the next cluster.
 * \param[in] cluster_num The number of the cluster for which to determine its successor.
 * \returns The wanted cluster number, or 0 on error.
 */
uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    1be4:	e52de004 	str	lr, [sp, #-4]!
    1be8:	e1a03801 	mov	r3, r1, lsl #16
    1bec:	e1a03823 	mov	r3, r3, lsr #16
    1bf0:	e24dd004 	sub	sp, sp, #4	; 0x4
    if(!fs || cluster_num < 2)
        return 0;

    /* read appropriate fat entry */
    uint8_t fat_entry[2];
    if(!fs->partition->device_read(fs->header.fat_offset + 2 * cluster_num, fat_entry, 2))
    1bf4:	e3a02002 	mov	r2, #2	; 0x2
    1bf8:	e3500000 	cmp	r0, #0	; 0x0
    1bfc:	13530001 	cmpne	r3, #1	; 0x1
    1c00:	e08d1002 	add	r1, sp, r2
    1c04:	e1a0c000 	mov	ip, r0
    1c08:	9a00001a 	bls	1c78 <fat16_get_next_cluster+0x94>
    1c0c:	e5900008 	ldr	r0, [r0, #8]
    1c10:	e0200293 	mla	r0, r3, r2, r0
    1c14:	e59c3000 	ldr	r3, [ip]
    1c18:	e593c000 	ldr	ip, [r3]
    1c1c:	e1a0e00f 	mov	lr, pc
    1c20:	e12fff1c 	bx	ip
    1c24:	e3500000 	cmp	r0, #0	; 0x0
        return 0;

    /* determine next cluster from fat */
    cluster_num = ((uint16_t) fat_entry[0]) |
    ((uint16_t) fat_entry[1] << 8);
	///*
    if(cluster_num == FAT16_CLUSTER_FREE ||
    1c28:	e59f1058 	ldr	r1, [pc, #88]	; 1c88 <.text+0x1c88>
    1c2c:	0a000011 	beq	1c78 <fat16_get_next_cluster+0x94>
    1c30:	e5dd2002 	ldrb	r2, [sp, #2]
    1c34:	e5dd3003 	ldrb	r3, [sp, #3]
    1c38:	e1920403 	orrs	r0, r2, r3, lsl #8
    1c3c:	13a03000 	movne	r3, #0	; 0x0
    1c40:	03a03001 	moveq	r3, #1	; 0x1
    1c44:	e1500001 	cmp	r0, r1
    1c48:	03833001 	orreq	r3, r3, #1	; 0x1
    1c4c:	e2802010 	add	r2, r0, #16	; 0x10
    1c50:	e3530000 	cmp	r3, #0	; 0x0
    1c54:	e1a02802 	mov	r2, r2, lsl #16
    1c58:	1a000006 	bne	1c78 <fat16_get_next_cluster+0x94>
    1c5c:	e1500001 	cmp	r0, r1
    1c60:	93a03000 	movls	r3, #0	; 0x0
    1c64:	83a03001 	movhi	r3, #1	; 0x1
    1c68:	e3520806 	cmp	r2, #393216	; 0x60000
    1c6c:	93833001 	orrls	r3, r3, #1	; 0x1
    1c70:	e3530000 	cmp	r3, #0	; 0x0
    1c74:	0a000000 	beq	1c7c <fat16_get_next_cluster+0x98>
        cluster_num == FAT16_CLUSTER_BAD ||
       (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX) ||
	   //********************************************************************************
       //(cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
	   (cluster_num >= FAT16_CLUSTER_LAST_MIN))
	   //********************************************************************************
    //*/
	return 0;

    return cluster_num;
    1c78:	e3a00000 	mov	r0, #0	; 0x0
}
    1c7c:	e28dd004 	add	sp, sp, #4	; 0x4
    1c80:	e49de004 	ldr	lr, [sp], #4
    1c84:	e12fff1e 	bx	lr
    1c88:	0000fff7 	streqd	pc, [r0], -r7

00001c8c <fat16_free_clusters>:

/**
 * \ingroup fat16_fs
 * Appends a new cluster chain to an existing one.
 *
 * Set cluster_num to zero to create a completely new one.
 *
 * \param[in] fs The file system on which to operate.
 * \param[in] cluster_num The cluster to which to append the new chain.
 * \param[in] count The number of clusters to allocate.
 * \returns 0 on failure, the number of the first new cluster on success.
 */
uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint16_t count)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs)
            return 0;
    
        device_read_t device_read = fs->partition->device_read;
        device_write_t device_write = fs->partition->device_write;
        uint32_t fat_offset = fs->header.fat_offset;
        uint16_t cluster_max = fs->header.fat_size / 2;
        uint16_t cluster_next = 0;
        uint16_t count_left = count;
        uint8_t buffer[2];
        uint16_t cluster_new;
        for(cluster_new = 0; cluster_new < cluster_max; ++cluster_new)
        {
            if(!device_read(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
                return 0;
    
            /* check if this is a free cluster */
            if(buffer[0] == (FAT16_CLUSTER_FREE & 0xff) &&
                buffer[1] == ((FAT16_CLUSTER_FREE >> 8) & 0xff))
            {
                /* allocate cluster */
                if(count_left == count)
                {
                    buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
                    buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
                }
                else
                {
                    buffer[0] = cluster_next & 0xff;
                    buffer[1] = (cluster_next >> 8) & 0xff;
                }
    
                if(!device_write(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
                    break;
    
                cluster_next = cluster_new;
                if(--count_left == 0)
                    break;
            }
        }
    
        do
        {
            if(count_left > 0)
                break;
    
            /* We allocated a new cluster chain. Now join
                                             * it with the existing one.
                                             */
            if(cluster_num >= 2)
            {
                buffer[0] = cluster_next & 0xff;
                buffer[1] = (cluster_next >> 8) & 0xff;
                if(!device_write(fat_offset + 2 * cluster_num, buffer, sizeof(buffer)))
                    break;
            }
    
            return cluster_next;
    
        }
        while(0);
    
        /* No space left on device or writing error.
                             * Free up all clusters already allocated.
                             */
        fat16_free_clusters(fs, cluster_next);
    
        return 0;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_fs
 * Frees a cluster chain, or a part thereof.
 *
 * Marks the specified cluster and all clusters which are sequentially
 * referenced by it as free. They may then be used again for future
 * file allocations.
 *
 * \note If this function is used for freeing just a part of a cluster
 *       chain, the new end of the chain is not correctly terminated
 *       within the FAT. Use fat16_terminate_clusters() instead.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] cluster_num The starting cluster of the chain which to free.
 * \returns 0 on failure, 1 on success.
 * \see fat16_terminate_clusters
 */
uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    1c8c:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    1c90:	e1a01801 	mov	r1, r1, lsl #16
    1c94:	e1a03821 	mov	r3, r1, lsr #16
    #if FAT16_WRITE_SUPPORT
        if(!fs || cluster_num < 2)
    1c98:	e3500000 	cmp	r0, #0	; 0x0
    1c9c:	13530001 	cmpne	r3, #1	; 0x1
    1ca0:	e24dd004 	sub	sp, sp, #4	; 0x4
    1ca4:	e1a05000 	mov	r5, r0
            return 0;
    
        uint32_t fat_offset = fs->header.fat_offset;
    1ca8:	85907008 	ldrhi	r7, [r0, #8]
    1cac:	8a00001d 	bhi	1d28 <fat16_free_clusters+0x9c>
    1cb0:	ea000024 	b	1d48 <fat16_free_clusters+0xbc>
        uint8_t buffer[2];
        while(cluster_num)
        {
            if(!fs->partition->device_read(fat_offset + 2 * cluster_num, buffer, 2))
    1cb4:	e5953000 	ldr	r3, [r5]
    1cb8:	e593c000 	ldr	ip, [r3]
    1cbc:	e1a0e00f 	mov	lr, pc
    1cc0:	e12fff1c 	bx	ip
                return 0;
    
            /* get next cluster of current cluster before freeing current cluster */
            uint16_t cluster_num_next = ((uint16_t) buffer[0]) |
            ((uint16_t) buffer[1] << 8);
    
            if(cluster_num_next == FAT16_CLUSTER_FREE)
                return 1;
            if(cluster_num_next == FAT16_CLUSTER_BAD ||
                (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
               cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
               )
               )
            return 0;
			///*
			//**********************************************************
            //if((cluster_num_next >= FAT16_CLUSTER_LAST_MIN) &&
            //    (cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
            //   )
			if(cluster_num_next >= FAT16_CLUSTER_LAST_MIN)
			//***********************************************************
			//*/
            cluster_num_next = 0;
    
            /* free cluster */
            buffer[0] = FAT16_CLUSTER_FREE & 0xff;
    1cc4:	e3a0e000 	mov	lr, #0	; 0x0
    1cc8:	e150000e 	cmp	r0, lr
            buffer[1] = (FAT16_CLUSTER_FREE >> 8) & 0xff;
            fs->partition->device_write(fat_offset + 2 * cluster_num, buffer, 2);
    1ccc:	e1a01006 	mov	r1, r6
    1cd0:	e3a02002 	mov	r2, #2	; 0x2
    1cd4:	e1a00004 	mov	r0, r4
    1cd8:	0a00001a 	beq	1d48 <fat16_free_clusters+0xbc>
    1cdc:	e5dd3002 	ldrb	r3, [sp, #2]
    1ce0:	e5ddc003 	ldrb	ip, [sp, #3]
    1ce4:	e193340c 	orrs	r3, r3, ip, lsl #8
    1ce8:	e1a04003 	mov	r4, r3
    1cec:	e2833010 	add	r3, r3, #16	; 0x10
    1cf0:	e1a03803 	mov	r3, r3, lsl #16
    1cf4:	0a000015 	beq	1d50 <fat16_free_clusters+0xc4>
    1cf8:	e3530807 	cmp	r3, #458752	; 0x70000
    1cfc:	9a000011 	bls	1d48 <fat16_free_clusters+0xbc>
    1d00:	e59f3058 	ldr	r3, [pc, #88]	; 1d60 <.text+0x1d60>
    1d04:	e5cde003 	strb	lr, [sp, #3]
    1d08:	e5cde002 	strb	lr, [sp, #2]
    1d0c:	e1540003 	cmp	r4, r3
    1d10:	81a0400e 	movhi	r4, lr
    1d14:	e5953000 	ldr	r3, [r5]
    1d18:	e593c008 	ldr	ip, [r3, #8]
    1d1c:	e1a0e00f 	mov	lr, pc
    1d20:	e12fff1c 	bx	ip
    1d24:	e1a03004 	mov	r3, r4
    1d28:	e0874083 	add	r4, r7, r3, lsl #1
    1d2c:	e28d6002 	add	r6, sp, #2	; 0x2
    1d30:	e3530000 	cmp	r3, #0	; 0x0
    1d34:	e1a01006 	mov	r1, r6
    1d38:	e3a02002 	mov	r2, #2	; 0x2
    1d3c:	e1a00004 	mov	r0, r4
    1d40:	1affffdb 	bne	1cb4 <fat16_free_clusters+0x28>
    1d44:	ea000001 	b	1d50 <fat16_free_clusters+0xc4>
    1d48:	e3a00000 	mov	r0, #0	; 0x0
    1d4c:	ea000000 	b	1d54 <fat16_free_clusters+0xc8>
    1d50:	e3a00001 	mov	r0, #1	; 0x1
    
            /* We continue in any case here, even if freeing the cluster failed.
                                             * The cluster is lost, but maybe we can still free up some later ones.
                                             */
    
            cluster_num = cluster_num_next;
        }
    
        return 1;
    #else
        return 0;
    #endif
}
    1d54:	e28dd004 	add	sp, sp, #4	; 0x4
    1d58:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    1d5c:	e12fff1e 	bx	lr
    1d60:	0000fff7 	streqd	pc, [r0], -r7

00001d64 <fat16_append_clusters>:
    1d64:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1d68:	e1a01801 	mov	r1, r1, lsl #16
    1d6c:	e24dd014 	sub	sp, sp, #20	; 0x14
    1d70:	e1a02802 	mov	r2, r2, lsl #16
    1d74:	e1a01821 	mov	r1, r1, lsr #16
    1d78:	e2507000 	subs	r7, r0, #0	; 0x0
    1d7c:	e58d1000 	str	r1, [sp]
    1d80:	e1a09822 	mov	r9, r2, lsr #16
    1d84:	0a00004e 	beq	1ec4 <fat16_append_clusters+0x160>
    1d88:	e5972000 	ldr	r2, [r7]
    1d8c:	e597300c 	ldr	r3, [r7, #12]
    1d90:	e5921008 	ldr	r1, [r2, #8]
    1d94:	e1a03783 	mov	r3, r3, lsl #15
    1d98:	e3a04000 	mov	r4, #0	; 0x0
    1d9c:	e5922000 	ldr	r2, [r2]
    1da0:	e597b008 	ldr	fp, [r7, #8]
    1da4:	e1a03823 	mov	r3, r3, lsr #16
    1da8:	e1a05009 	mov	r5, r9
    1dac:	e1a0a004 	mov	sl, r4
    1db0:	e58d1008 	str	r1, [sp, #8]
    1db4:	e58d2004 	str	r2, [sp, #4]
    1db8:	e58d300c 	str	r3, [sp, #12]
    1dbc:	ea000023 	b	1e50 <fat16_append_clusters+0xec>
    1dc0:	e08b8086 	add	r8, fp, r6, lsl #1
    1dc4:	e1a00008 	mov	r0, r8
    1dc8:	e28d1012 	add	r1, sp, #18	; 0x12
    1dcc:	e3a02002 	mov	r2, #2	; 0x2
    1dd0:	e59d3004 	ldr	r3, [sp, #4]
    1dd4:	e1a0e00f 	mov	lr, pc
    1dd8:	e12fff13 	bx	r3
    1ddc:	e3500000 	cmp	r0, #0	; 0x0
    1de0:	0a000037 	beq	1ec4 <fat16_append_clusters+0x160>
    1de4:	e5dd3012 	ldrb	r3, [sp, #18]
    1de8:	e3530000 	cmp	r3, #0	; 0x0
    1dec:	1a000016 	bne	1e4c <fat16_append_clusters+0xe8>
    1df0:	e5dd3013 	ldrb	r3, [sp, #19]
    1df4:	e3530000 	cmp	r3, #0	; 0x0
    1df8:	1a000013 	bne	1e4c <fat16_append_clusters+0xe8>
    1dfc:	e1550009 	cmp	r5, r9
    1e00:	03e03000 	mvneq	r3, #0	; 0x0
    1e04:	11a03424 	movne	r3, r4, lsr #8
    1e08:	05cd3013 	streqb	r3, [sp, #19]
    1e0c:	05cd3012 	streqb	r3, [sp, #18]
    1e10:	15cd3013 	strneb	r3, [sp, #19]
    1e14:	15cd4012 	strneb	r4, [sp, #18]
    1e18:	e1a00008 	mov	r0, r8
    1e1c:	e28d1012 	add	r1, sp, #18	; 0x12
    1e20:	e3a02002 	mov	r2, #2	; 0x2
    1e24:	e59d3008 	ldr	r3, [sp, #8]
    1e28:	e1a0e00f 	mov	lr, pc
    1e2c:	e12fff13 	bx	r3
    1e30:	e3500000 	cmp	r0, #0	; 0x0
    1e34:	0a00000a 	beq	1e64 <fat16_append_clusters+0x100>
    1e38:	e2453001 	sub	r3, r5, #1	; 0x1
    1e3c:	e1a03803 	mov	r3, r3, lsl #16
    1e40:	e1b05823 	movs	r5, r3, lsr #16
    1e44:	0a000019 	beq	1eb0 <fat16_append_clusters+0x14c>
    1e48:	e1a04006 	mov	r4, r6
    1e4c:	e28aa001 	add	sl, sl, #1	; 0x1
    1e50:	e59d100c 	ldr	r1, [sp, #12]
    1e54:	e1a0380a 	mov	r3, sl, lsl #16
    1e58:	e15a0001 	cmp	sl, r1
    1e5c:	e1a06823 	mov	r6, r3, lsr #16
    1e60:	1affffd6 	bne	1dc0 <fat16_append_clusters+0x5c>
    1e64:	e3550000 	cmp	r5, #0	; 0x0
    1e68:	1a000012 	bne	1eb8 <fat16_append_clusters+0x154>
    1e6c:	e59d3000 	ldr	r3, [sp]
    1e70:	e3530001 	cmp	r3, #1	; 0x1
    1e74:	9a00000b 	bls	1ea8 <fat16_append_clusters+0x144>
    1e78:	e59d1000 	ldr	r1, [sp]
    1e7c:	e1a03424 	mov	r3, r4, lsr #8
    1e80:	e5cd3013 	strb	r3, [sp, #19]
    1e84:	e08b0081 	add	r0, fp, r1, lsl #1
    1e88:	e5cd4012 	strb	r4, [sp, #18]
    1e8c:	e28d1012 	add	r1, sp, #18	; 0x12
    1e90:	e3a02002 	mov	r2, #2	; 0x2
    1e94:	e59d3008 	ldr	r3, [sp, #8]
    1e98:	e1a0e00f 	mov	lr, pc
    1e9c:	e12fff13 	bx	r3
    1ea0:	e3500000 	cmp	r0, #0	; 0x0
    1ea4:	0a000003 	beq	1eb8 <fat16_append_clusters+0x154>
    1ea8:	e1a00004 	mov	r0, r4
    1eac:	ea000005 	b	1ec8 <fat16_append_clusters+0x164>
    1eb0:	e1a04006 	mov	r4, r6
    1eb4:	eaffffec 	b	1e6c <fat16_append_clusters+0x108>
    1eb8:	e1a00007 	mov	r0, r7
    1ebc:	e1a01004 	mov	r1, r4
    1ec0:	ebffff71 	bl	1c8c <fat16_free_clusters>
    1ec4:	e3a00000 	mov	r0, #0	; 0x0
    1ec8:	e28dd014 	add	sp, sp, #20	; 0x14
    1ecc:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1ed0:	e12fff1e 	bx	lr

00001ed4 <fat16_read_file>:

/**
 * \ingroup fat16_fs
 * Frees a part of a cluster chain and correctly terminates the rest.
 *
 * Marks the specified cluster as the new end of a cluster chain and
 * frees all following clusters.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] cluster_num The new end of the cluster chain.
 * \returns 0 on failure, 1 on success.
 * \see fat16_free_clusters
 */
uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs || cluster_num < 2)
            return 0;
    
        /* fetch next cluster before overwriting the cluster entry */
        uint16_t cluster_num_next = fat16_get_next_cluster(fs, cluster_num);
    
        /* mark cluster as the last one */
        uint8_t buffer[2];
        buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
        buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
        if(!fs->partition->device_write(fs->header.fat_offset + 2 * cluster_num, buffer, 2))
            return 0;
    
        /* free remaining clusters */
        if(cluster_num_next)
            return fat16_free_clusters(fs, cluster_num_next);
        else
            return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Opens a file on a FAT16 filesystem.
 *
 * \param[in] fs The filesystem on which the file to open lies.
 * \param[in] dir_entry The directory entry of the file to open.
 * \returns The file handle, or 0 on failure.
 * \see fat16_close_file
 */
struct fat16_file_struct* fat16_open_file(struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !dir_entry || (dir_entry->attributes & FAT16_ATTRIB_DIR))
        return 0;

    struct fat16_file_struct* fd = malloc(sizeof(*fd));
    if(!fd)
        return 0;

    memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
    fd->fs = fs;
    fd->pos = 0;
    fd->pos_cluster = dir_entry->cluster;

    return fd;
}

/**
 * \ingroup fat16_file
 * Closes a file.
 *
 * \param[in] fd The file handle of the file to close.
 * \see fat16_open_file
 */
void fat16_close_file(struct fat16_file_struct* fd)
{
    if(fd)
        free(fd);
}

/**
 * \ingroup fat16_file
 * Reads data from a file.
 *
 * The data requested is read from the current file location.
 *
 * \param[in] fd The file handle of the file from which to read.
 * \param[out] buffer The buffer into which to write.
 * \param[in] buffer_len The amount of data to read.
 * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 * \see fat16_write_file
 */
int16_t fat16_read_file(struct fat16_file_struct* fd, uint8_t* buffer, uint16_t buffer_len)
{
    1ed4:	e1a02802 	mov	r2, r2, lsl #16
    /* check arguments */
    if(!fd || !buffer || buffer_len < 1)
    1ed8:	e3510000 	cmp	r1, #0	; 0x0
    1edc:	13500000 	cmpne	r0, #0	; 0x0
    1ee0:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1ee4:	e1a06000 	mov	r6, r0
    1ee8:	e1a0b001 	mov	fp, r1
    1eec:	e1a08822 	mov	r8, r2, lsr #16
    1ef0:	0a000050 	beq	2038 <fat16_read_file+0x164>
    1ef4:	e3580000 	cmp	r8, #0	; 0x0
    1ef8:	0a00004e 	beq	2038 <fat16_read_file+0x164>
        return -1;

    /* determine number of bytes to read */
    if(fd->pos + buffer_len > fd->dir_entry.file_size)
    1efc:	e5907030 	ldr	r7, [r0, #48]
    1f00:	e5902028 	ldr	r2, [r0, #40]
    1f04:	e0873008 	add	r3, r7, r8
    1f08:	e1530002 	cmp	r3, r2
    1f0c:	9a000003 	bls	1f20 <fat16_read_file+0x4c>
        buffer_len = fd->dir_entry.file_size - fd->pos;
    1f10:	e0673002 	rsb	r3, r7, r2
    1f14:	e1a03803 	mov	r3, r3, lsl #16
    if(buffer_len == 0)
    1f18:	e1b08823 	movs	r8, r3, lsr #16
    1f1c:	0a000050 	beq	2064 <fat16_read_file+0x190>
        return 0;

    uint16_t cluster_size = fd->fs->header.cluster_size;
    uint16_t cluster_num = fd->pos_cluster;
    1f20:	e1d653b4 	ldrh	r5, [r6, #52]
    1f24:	e5963000 	ldr	r3, [r6]
    uint16_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = fd->pos % cluster_size;

    /* find cluster in which to start reading */
    if(!cluster_num)
    1f28:	e3550000 	cmp	r5, #0	; 0x0
    1f2c:	e1d391b2 	ldrh	r9, [r3, #18]
    1f30:	1a000011 	bne	1f7c <fat16_read_file+0xa8>
    {
        cluster_num = fd->dir_entry.cluster;
    1f34:	e1d652b6 	ldrh	r5, [r6, #38]

        if(!cluster_num)
    1f38:	e3550000 	cmp	r5, #0	; 0x0
    1f3c:	1a000002 	bne	1f4c <fat16_read_file+0x78>
        {
            if(!fd->pos)
    1f40:	e3570000 	cmp	r7, #0	; 0x0
    1f44:	0a000046 	beq	2064 <fat16_read_file+0x190>
    1f48:	ea00003a 	b	2038 <fat16_read_file+0x164>
                return 0;
            else
                return -1;
        }

        if(fd->pos)
    1f4c:	e3570000 	cmp	r7, #0	; 0x0
    1f50:	11a04007 	movne	r4, r7
    1f54:	1a000004 	bne	1f6c <fat16_read_file+0x98>
    1f58:	ea000007 	b	1f7c <fat16_read_file+0xa8>
        {
            uint32_t pos = fd->pos;
            while(pos >= cluster_size)
            {
                pos -= cluster_size;
                cluster_num = fat16_get_next_cluster(fd->fs, cluster_num);
    1f5c:	e5960000 	ldr	r0, [r6]
    1f60:	ebffff1f 	bl	1be4 <fat16_get_next_cluster>
                if(!cluster_num)
    1f64:	e2505000 	subs	r5, r0, #0	; 0x0
    1f68:	0a000032 	beq	2038 <fat16_read_file+0x164>
    1f6c:	e1540009 	cmp	r4, r9
    1f70:	e1a01005 	mov	r1, r5
    1f74:	e0694004 	rsb	r4, r9, r4
    1f78:	2afffff7 	bcs	1f5c <fat16_read_file+0x88>
    1f7c:	e1a00007 	mov	r0, r7
    1f80:	e1a01009 	mov	r1, r9
    1f84:	eb000f18 	bl	5bec <__umodsi3>
    1f88:	e1a00800 	mov	r0, r0, lsl #16
    1f8c:	e1a0a820 	mov	sl, r0, lsr #16
    1f90:	e1a07008 	mov	r7, r8
                    return -1;
            }
        }
    }

    /* read data */
    do
    {
        /* calculate data size to copy from cluster */
        uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
        (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
        uint16_t copy_length = cluster_size - first_cluster_offset;
    1f94:	e06a3009 	rsb	r3, sl, r9
    1f98:	e596c000 	ldr	ip, [r6]
    1f9c:	e1a03803 	mov	r3, r3, lsl #16
    1fa0:	e1a03823 	mov	r3, r3, lsr #16
    1fa4:	e1570003 	cmp	r7, r3
    1fa8:	31a03007 	movcc	r3, r7
        if(copy_length > buffer_left)
            copy_length = buffer_left;

        /* read data */
        if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
    1fac:	e59c2018 	ldr	r2, [ip, #24]
    1fb0:	e1a03803 	mov	r3, r3, lsl #16
    1fb4:	e1a04823 	mov	r4, r3, lsr #16
    1fb8:	e08a2002 	add	r2, sl, r2
    1fbc:	e2453002 	sub	r3, r5, #2	; 0x2
    1fc0:	e0202399 	mla	r0, r9, r3, r2
    1fc4:	e1a0100b 	mov	r1, fp
    1fc8:	e1a02004 	mov	r2, r4
    1fcc:	e59c3000 	ldr	r3, [ip]
    1fd0:	e593c000 	ldr	ip, [r3]
    1fd4:	e1a0e00f 	mov	lr, pc
    1fd8:	e12fff1c 	bx	ip
            return buffer_len - buffer_left;

        /* calculate new file position */
        buffer += copy_length;
        buffer_left -= copy_length;
    1fdc:	e0643007 	rsb	r3, r4, r7
    1fe0:	e3500000 	cmp	r0, #0	; 0x0
        fd->pos += copy_length;

        if(first_cluster_offset + copy_length >= cluster_size)
        {
            /* we are on a cluster boundary, so get the next cluster */
            if((cluster_num = fat16_get_next_cluster(fd->fs, cluster_num)))
    1fe4:	e1a01005 	mov	r1, r5
    1fe8:	e08bb004 	add	fp, fp, r4
    1fec:	e08a2004 	add	r2, sl, r4
    1ff0:	e1a00803 	mov	r0, r3, lsl #16
    1ff4:	0a000011 	beq	2040 <fat16_read_file+0x16c>
    1ff8:	e5963030 	ldr	r3, [r6, #48]
    1ffc:	e1520009 	cmp	r2, r9
    2000:	e0833004 	add	r3, r3, r4
    2004:	e5863030 	str	r3, [r6, #48]
    2008:	e1a07820 	mov	r7, r0, lsr #16
    200c:	ba000004 	blt	2024 <fat16_read_file+0x150>
    2010:	e5960000 	ldr	r0, [r6]
    2014:	ebfffef2 	bl	1be4 <fat16_get_next_cluster>
    2018:	e2505000 	subs	r5, r0, #0	; 0x0
            {
                first_cluster_offset = 0;
            }
            else
            {
                fd->pos_cluster = 0;
                return buffer_len - buffer_left;
    201c:	e3a0a000 	mov	sl, #0	; 0x0
    2020:	0a00000a 	beq	2050 <fat16_read_file+0x17c>
            }
        }

        fd->pos_cluster = cluster_num;

    }
    while(buffer_left > 0); /* check if we are done */
    2024:	e3570000 	cmp	r7, #0	; 0x0
    2028:	e1c653b4 	strh	r5, [r6, #52]
    202c:	1affffd8 	bne	1f94 <fat16_read_file+0xc0>

    return buffer_len;
    2030:	e1a03808 	mov	r3, r8, lsl #16
    2034:	ea000003 	b	2048 <fat16_read_file+0x174>
    2038:	e3e00000 	mvn	r0, #0	; 0x0
    203c:	ea000009 	b	2068 <fat16_read_file+0x194>
    2040:	e0673008 	rsb	r3, r7, r8
    2044:	e1a03803 	mov	r3, r3, lsl #16
    2048:	e1a00843 	mov	r0, r3, asr #16
    204c:	ea000005 	b	2068 <fat16_read_file+0x194>
    2050:	e0673008 	rsb	r3, r7, r8
    2054:	e1a03803 	mov	r3, r3, lsl #16
    2058:	e1a00843 	mov	r0, r3, asr #16
    205c:	e1c653b4 	strh	r5, [r6, #52]
    2060:	ea000000 	b	2068 <fat16_read_file+0x194>
    2064:	e3a00000 	mov	r0, #0	; 0x0
}
    2068:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    206c:	e12fff1e 	bx	lr

00002070 <fat16_reset_dir>:

/**
 * \ingroup fat16_file
 * Writes data to a file.
 *
 * The data is written to the current file location.
 *
 * \param[in] fd The file handle of the file to which to write.
 * \param[in] buffer The buffer from which to read the data to be written.
 * \param[in] buffer_len The amount of data to write.
 * \returns The number of bytes written, 0 on disk full, or -1 on failure.
 * \see fat16_read_file
 */
int16_t fat16_write_file(struct fat16_file_struct* fd, const uint8_t* buffer, uint16_t buffer_len)
{
    #if FAT16_WRITE_SUPPORT
        /* check arguments */
        if(!fd || !buffer || buffer_len < 1)
            return -1;
        if(fd->pos > fd->dir_entry.file_size)
            return -1;
    
        uint16_t cluster_size = fd->fs->header.cluster_size;
        uint16_t cluster_num = fd->pos_cluster;
        uint16_t buffer_left = buffer_len;
        uint16_t first_cluster_offset = fd->pos % cluster_size;
    
        /* find cluster in which to start writing */
        if(!cluster_num)
        {
            cluster_num = fd->dir_entry.cluster;
    
            if(!cluster_num)
            {
                if(!fd->pos)
                {
                    /* empty file */
                    fd->dir_entry.cluster = cluster_num = fat16_append_clusters(fd->fs, 0, 1);
                    if(!cluster_num)
                        return -1;
                }
                else
                {
                    return -1;
                }
            }
    
            if(fd->pos)
            {
                uint32_t pos = fd->pos;
                uint16_t cluster_num_next;
                while(pos >= cluster_size)
                {
                    pos -= cluster_size;
                    cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                    if(!cluster_num_next && pos == 0)
        /* the file exactly ends on a cluster boundary, and we append to it */
                        cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
                    if(!cluster_num_next)
                        return -1;
    
                    cluster_num = cluster_num_next;
                }
            }
        }
    
        /* write data */
        do
        {
            /* calculate data size to write to cluster */
            uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
            (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
            uint16_t write_length = cluster_size - first_cluster_offset;
            if(write_length > buffer_left)
                write_length = buffer_left;
    
            /* write data which fits into the current cluster */
            if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
                break;
    
            /* calculate new file position */
            buffer += write_length;
            buffer_left -= write_length;
            fd->pos += write_length;
    
            if(first_cluster_offset + write_length >= cluster_size)
            {
                /* we are on a cluster boundary, so get the next cluster */
                uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                if(!cluster_num_next && buffer_left > 0)
        /* we reached the last cluster, append a new one */
                    cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
                if(!cluster_num_next)
                {
                    fd->pos_cluster = 0;
                    break;
                }
    
                cluster_num = cluster_num_next;
                first_cluster_offset = 0;
            }
    
            fd->pos_cluster = cluster_num;
    
        }
        while(buffer_left > 0); /* check if we are done */
    
        /* update directory entry */
        if(fd->pos > fd->dir_entry.file_size)
        {
            uint32_t size_old = fd->dir_entry.file_size;
    
            /* update file size */
            fd->dir_entry.file_size = fd->pos;
            /* write directory entry */
            if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
            {
                /* We do not return an error here since we actually wrote
                                                             * some data to disk. So we calculate the amount of data
                                                             * we wrote to disk and which lies within the old file size.
                                                             */
                buffer_left = fd->pos - size_old;
                fd->pos = size_old;
            }
        }
    
        return buffer_len - buffer_left;
    
    #else
        return -1;
    #endif
}

/**
 * \ingroup fat16_file
 * Repositions the read/write file offset.
 *
 * Changes the file offset where the next call to fat16_read_file()
 * or fat16_write_file() starts reading/writing.
 *
 * If the new offset is beyond the end of the file, fat16_resize_file()
 * is implicitly called, i.e. the file is expanded.
 *
 * The new offset can be given in different ways determined by
 * the \c whence parameter:
 * - \b FAT16_SEEK_SET: \c *offset is relative to the beginning of the file.
 * - \b FAT16_SEEK_CUR: \c *offset is relative to the current file position.
 * - \b FAT16_SEEK_END: \c *offset is relative to the end of the file.
 *
 * The resulting absolute offset is written to the location the \c offset
 * parameter points to.
 *
 * \param[in] fd The file decriptor of the file on which to seek.
 * \param[in,out] offset A pointer to the new offset, as affected by the \c whence
 *                   parameter. The function writes the new absolute offset
 *                   to this location before it returns.
 * \param[in] whence Affects the way \c offset is interpreted, see above.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_seek_file(struct fat16_file_struct* fd, int32_t* offset, uint8_t whence)
{
    if(!fd || !offset)
        return 0;

    uint32_t new_pos = fd->pos;
    switch(whence)
    {
        case FAT16_SEEK_SET:
            new_pos = *offset;
            break;
        case FAT16_SEEK_CUR:
            new_pos += *offset;
            break;
        case FAT16_SEEK_END:
            new_pos = fd->dir_entry.file_size + *offset;
            break;
        default:
            return 0;
    }

    if(new_pos > fd->dir_entry.file_size && !fat16_resize_file(fd, new_pos))
        return 0;

    fd->pos = new_pos;
    fd->pos_cluster = 0;

    *offset = new_pos;
    return 1;
}

/**
 * \ingroup fat16_file
 * Resizes a file to have a specific size.
 *
 * Enlarges or shrinks the file pointed to by the file descriptor to have
 * exactly the specified size.
 *
 * If the file is truncated, all bytes having an equal or larger offset
 * than the given size are lost. If the file is expanded, the additional
 * bytes are allocated.
 *
 * \note Please be aware that this function just allocates or deallocates disk
 * space, it does not explicitely clear it. To avoid data leakage, this
 * must be done manually.
 *
 * \param[in] fd The file decriptor of the file which to resize.
 * \param[in] size The new size of the file.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_resize_file(struct fat16_file_struct* fd, uint32_t size)
{
    #if FAT16_WRITE_SUPPORT
        if(!fd)
            return 0;
    
        uint16_t cluster_num = fd->dir_entry.cluster;
        uint16_t cluster_size = fd->fs->header.cluster_size;
        uint32_t size_new = size;
    
        do
        {
            if(cluster_num == 0 && size_new == 0)
        /* the file stays empty */
                break;
    
            /* seek to the next cluster as long as we need the space */
            while(size_new > cluster_size)
            {
                /* get next cluster of file */
                uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                if(cluster_num_next)
                {
                    cluster_num = cluster_num_next;
                    size_new -= cluster_size;
                }
                else
                {
                    break;
                }
            }
    
            if(size_new > cluster_size || cluster_num == 0)
            {
                /* Allocate new cluster chain and append
                                                             * it to the existing one, if available.
                                                             */
                uint16_t cluster_count = size_new / cluster_size;
                if((uint32_t) cluster_count * cluster_size < size_new)
                    ++cluster_count;
                uint16_t cluster_new_chain = fat16_append_clusters(fd->fs, cluster_num, cluster_count);
                if(!cluster_new_chain)
                    return 0;
    
                if(!cluster_num)
                {
                    cluster_num = cluster_new_chain;
                    fd->dir_entry.cluster = cluster_num;
                }
            }
    
            /* write new directory entry */
            fd->dir_entry.file_size = size;
            if(size == 0)
                fd->dir_entry.cluster = 0;
            if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
                return 0;
    
            if(size == 0)
            {
                /* free all clusters of file */
                fat16_free_clusters(fd->fs, cluster_num);
            }
            else if(size_new <= cluster_size)
            {
                /* free all clusters no longer needed */
                fat16_terminate_clusters(fd->fs, cluster_num);
            }
    
        }
        while(0);
    
        /* correct file position */
        if(size < fd->pos)
        {
            fd->pos = size;
            fd->pos_cluster = 0;
        }
    
        return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_dir
 * Opens a directory.
 *
 * \param[in] fs The filesystem on which the directory to open resides.
 * \param[in] dir_entry The directory entry which stands for the directory to open.
 * \returns An opaque directory descriptor on success, 0 on failure.
 * \see fat16_close_dir
 */
struct fat16_dir_struct* fat16_open_dir(struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !dir_entry || !(dir_entry->attributes & FAT16_ATTRIB_DIR))
        return 0;

    struct fat16_dir_struct* dd = malloc(sizeof(*dd));
    if(!dd)
        return 0;

    memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
    dd->fs = fs;
    dd->entry_next = 0;

    return dd;
}

/**
 * \ingroup fat16_dir
 * Closes a directory descriptor.
 *
 * This function destroys a directory descriptor which was
 * previously obtained by calling fat16_open_dir(). When this
 * function returns, the given descriptor will be invalid.
 *
 * \param[in] dd The directory descriptor to close.
 * \see fat16_open_dir
 */
void fat16_close_dir(struct fat16_dir_struct* dd)
{
    if(dd)
        free(dd);
}

/**
 * \ingroup fat16_dir
 * Reads the next directory entry contained within a parent directory.
 *
 * \param[in] dd The descriptor of the parent directory from which to read the entry.
 * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
 * \returns 0 on failure, 1 on success.
 * \see fat16_reset_dir
 */
uint8_t fat16_read_dir(struct fat16_dir_struct* dd, struct fat16_dir_entry_struct* dir_entry)
{
    if(!dd || !dir_entry)
        return 0;

    if(dd->dir_entry.cluster == 0)
    {
        /* read entry from root directory */
        if(fat16_read_root_dir_entry(dd->fs, dd->entry_next, dir_entry))
        {
            ++dd->entry_next;
            return 1;
        }
    }
    else
    {
        /* read entry from a subdirectory */
        if(fat16_read_sub_dir_entry(dd->fs, dd->entry_next, &dd->dir_entry, dir_entry))
        {
            ++dd->entry_next;
            return 1;
        }
    }

    /* restart reading */
    dd->entry_next = 0;

    return 0;
}

/**
 * \ingroup fat16_dir
 * Resets a directory handle.
 *
 * Resets the directory handle such that reading restarts
 * with the first directory entry.
 *
 * \param[in] dd The directory handle to reset.
 * \returns 0 on failure, 1 on success.
 * \see fat16_read_dir
 */
uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
{
    if(!dd)
    2070:	e3500000 	cmp	r0, #0	; 0x0
    2074:	e1a03000 	mov	r3, r0
        return 0;

    dd->entry_next = 0;
    2078:	13a03000 	movne	r3, #0	; 0x0
    207c:	11c033b0 	strneh	r3, [r0, #48]
    2080:	13a03001 	movne	r3, #1	; 0x1
    return 1;
}
    2084:	e1a00003 	mov	r0, r3
    2088:	e12fff1e 	bx	lr

0000208c <fat16_delete_file>:

/**
 * \ingroup fat16_fs
 * Writes a directory entry to disk.
 *
 * \note The file name is not checked for invalid characters.
 *
 * \note The generation of the short 8.3 file name is quite
 * simple. The first eight characters are used for the filename.
 * The extension, if any, is made up of the first three characters
 * following the last dot within the long filename. If the
 * filename (without the extension) is longer than eight characters,
 * the lower byte of the cluster number replaces the last two
 * characters to avoid name clashes. In any other case, it is your
 * responsibility to avoid name clashes.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] dir_entry The directory entry to write.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs || !dir_entry)
            return 0;
    
        device_write_t device_write = fs->partition->device_write;
        uint32_t offset = dir_entry->entry_offset;
        uint8_t name_len = strlen(dir_entry->long_name);
        uint8_t lfn_entry_count = (name_len + 12) / 13;
        uint8_t buffer[32];
    
        /* write 8.3 entry */
    
        /* generate 8.3 file name */
        memset(&buffer[0], ' ', 11);
        char* name_ext = strrchr(dir_entry->long_name, '.');
        if(name_ext)
        {
            ++name_ext;
    
            uint8_t name_ext_len = strlen(name_ext);
            name_len -= name_ext_len + 1;
    
            if(name_ext_len > 3)
                name_ext_len = 3;
    
            memcpy(&buffer[8], name_ext, name_ext_len);
        }
    
        if(name_len <= 8)
        {
            memcpy(buffer, dir_entry->long_name, name_len);
        }
        else
        {
            memcpy(buffer, dir_entry->long_name, 8);
    
            /* Minimize 8.3 name clashes by appending
                                             * the lower byte of the cluster number.
                                             */
            uint8_t num = dir_entry->cluster & 0xff;
    
            buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
            num &= 0x0f;
            buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
        }
    
        /* fill directory entry buffer */
        memset(&buffer[11], 0, sizeof(buffer) - 11);
        buffer[0x0b] = dir_entry->attributes;

        //Not used in bootloader
		#ifdef MAIN_FIRMWARE
			//Added modified date/time 12-26-07
			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			//*******************************************
			//char * current_time;
			//*******************************************
/*			current_time = GPS_get_time();
			char * current_date;
			current_date = GPS_get_date();
			
			uint16_t modified_time, modified_date;
			uint8_t c_hour, c_minute, c_second;
			uint8_t c_year, c_month, c_day;
			
			c_hour = (current_time[0] - '0') * 10;
			c_hour += (current_time[1] - '0');
			c_minute = (current_time[3] - '0') * 10;
			c_minute += (current_time[4] - '0');
			c_second = (current_time[6] - '0') * 10;
			c_second += (current_time[7] - '0');
			
			c_day = (current_date[0] - '0') * 10;
			c_day += (current_date[1] - '0');
			c_month = (current_date[3] - '0') * 10;
			c_month += (current_date[4] - '0');
			c_year = (current_date[6] - '0') * 10;
			c_year += (current_date[7] - '0');
			
			//Correct for 1980 = 0, 2000 = 20, year code
			c_year += 20;
			
			modified_time = (c_hour << (16-5)) | (c_minute << (16-11)) | (c_second);
			modified_date = (c_year << (16-7)) | (c_month << (16-11)) | (c_day);

			//Do a little error correction
			if (c_year < 26) //26 = 2006
			{
				modified_time = 0;
				modified_date = 0;
			}

			//rprintf("c_time=%d, %d, %d\n", c_hour, c_minute, c_second);
			//rprintf("c_date=%d, %d, %d\n", c_month, c_day, c_year);
			//rprintf("mod_time=%x\n", modified_time);
			//rprintf("mod_date=%x\n", modified_date);
			
			buffer[0x16] = (modified_time >> 0) & 0xFF;
			buffer[0x17] = (modified_time >> 8) & 0xFF;
			buffer[0x18] = (modified_date >> 0) & 0xFF;
			buffer[0x19] = (modified_date >> 8) & 0xFF;
			*/
			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
		#endif

        buffer[0x1a] = (dir_entry->cluster >> 0) & 0xff;
        buffer[0x1b] = (dir_entry->cluster >> 8) & 0xff;
        buffer[0x1c] = (dir_entry->file_size >> 0) & 0xff;
        buffer[0x1d] = (dir_entry->file_size >> 8) & 0xff;
        buffer[0x1e] = (dir_entry->file_size >> 16) & 0xff;
        buffer[0x1f] = (dir_entry->file_size >> 24) & 0xff;
    
        /* write to disk */
        if(!device_write(offset + (uint32_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
            return 0;
    
        /* calculate checksum of 8.3 name */
        uint8_t checksum = buffer[0];
        uint8_t i;
        for(i = 1; i < 11; ++i)
            checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
    
        /* write lfn entries */
        uint8_t lfn_entry;
        for(lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
        {
            memset(buffer, 0, sizeof(buffer));
            memset(&buffer[0x01], 0xff, 10);
            memset(&buffer[0x0e], 0xff, 12);
            memset(&buffer[0x1c], 0xff, 4);
    
            buffer[0x00] = lfn_entry;
            if(lfn_entry == lfn_entry_count)
                buffer[0x00] |= FAT16_DIRENTRY_LFNLAST;
    
            /* set file name */
            const char* long_name_curr = dir_entry->long_name + (lfn_entry - 1) * 13;
            i = 1;
            while(i < 0x1f)
            {
                buffer[i++] = *long_name_curr;
                buffer[i++] = 0;
    
                switch(i)
                {
                    case 0x0b:
                        i = 0x0e;
                        break;
                    case 0x1a:
                        i = 0x1c;
                        break;
                }
    
                if(!*long_name_curr++)
                    break;
            }
    
            /* mark as lfn entry */
            buffer[0x0b] = 0x0f;
    
            /* set checksum */
            buffer[0x0d] = checksum;
    
            /* write entry */
            device_write(offset, buffer, sizeof(buffer));
    
            offset += sizeof(buffer);
        }
    
        return 1;
    
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Creates a file.
 *
 * Creates a file and obtains the directory entry of the
 * new file. If the file to create already exists, the
 * directory entry of the existing file will be returned
 * within the dir_entry parameter.
 *
 * \note The file name is not checked for invalid characters.
 *
 * \note The generation of the short 8.3 file name is quite
 * simple. The first eight characters are used for the filename.
 * The extension, if any, is made up of the first three characters
 * following the last dot within the long filename. If the
 * filename (without the extension) is longer than eight characters,
 * the lower byte of the cluster number replaces the last two
 * characters to avoid name clashes. In any other case, it is your
 * responsibility to avoid name clashes.
 *
 * \param[in] parent The handle of the directory in which to create the file.
 * \param[in] file The name of the file to create.
 * \param[out] dir_entry The directory entry to fill for the new file.
 * \returns 0 on failure, 1 on success.
 * \see fat16_delete_file
 */
uint8_t fat16_create_file(struct fat16_dir_struct* parent, const char* file, struct fat16_dir_entry_struct* dir_entry)
{
    #if FAT16_WRITE_SUPPORT
        if(!parent || !file || !file[0])
            return 0;
    
        /* check if the file already exists */
        while(1)
        {
            if(!fat16_read_dir(parent, dir_entry))
                break;
    
            if(strcmp(file, dir_entry->long_name) == 0)
            {
                fat16_reset_dir(parent);
                return 1;
            }
        }
    
        memset(dir_entry, 0, sizeof(*dir_entry));
        strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
    
        /* search for a place where to write the directory entry to disk */
        uint8_t free_dir_entries_needed = strlen(file) / 13 + 1 + 1;
        uint8_t free_dir_entries_found = 0;
        struct fat16_fs_struct* fs = parent->fs;
        uint16_t cluster_num = parent->dir_entry.cluster;
        uint32_t dir_entry_offset = 0;
        uint32_t offset = 0;
        uint32_t offset_to = 0;
    
        if(cluster_num == 0)
        {
            /* we read/write from the root directory entry */
            offset = fs->header.root_dir_offset;
            offset_to = fs->header.cluster_zero_offset;
            dir_entry_offset = offset;
        }
    
        while(1)
        {
            if(offset == offset_to)
            {
                if(cluster_num == 0)
				/* We iterated through the whole root directory entry
                * and could not find enough space for the directory entry.
                */
                return 0;
    
                if(offset)
                {
                    /* We reached a cluster boundary and have to
                    * switch to the next cluster.
                    */
    
                    uint16_t cluster_next = fat16_get_next_cluster(fs, cluster_num);
                    if(!cluster_next)
                    {
                        cluster_next = fat16_append_clusters(fs, cluster_num, 1);
                        if(!cluster_next)
                            return 0;
    
                        /* we appended a new cluster and know it is free */
                        dir_entry_offset = fs->header.cluster_zero_offset +
                        (uint32_t) (cluster_next - 2) * fs->header.cluster_size;
    
                        /* TODO: This cluster has to be zeroed in an efficient way, or at least
                        *       every 32th byte should be set to FAT16_DIRENTRY_DELETED.
                        */
                        break;
                    }
                    cluster_num = cluster_next;
                }
    
                offset = fs->header.cluster_zero_offset +
                (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
                offset_to = offset + fs->header.cluster_size;
                dir_entry_offset = offset;
                free_dir_entries_found = 0;
            }
    
            /* read next lfn or 8.3 entry */
            uint8_t first_char;
            if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
                return 0;
    
            /* check if we found a free directory entry */
            if(first_char == FAT16_DIRENTRY_DELETED || !first_char)
            {
                /* check if we have the needed number of available entries */
                ++free_dir_entries_found;
                if(free_dir_entries_found >= free_dir_entries_needed)
                    break;
    
                offset += 32;
            }
            else
            {
                offset += 32;
                dir_entry_offset = offset;
                free_dir_entries_found = 0;
            }
        }

        /* write directory entry to disk */
        dir_entry->entry_offset = dir_entry_offset;
        if(!fat16_write_dir_entry(fs, dir_entry))
            return 0;
    
        return 1;
    
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Deletes a file or directory.
 *
 * It is not checked if the file to delete is a directory.
 * If a directory is deleted without first deleting its
 * subdirectories and files, disk space occupied by these
 * files will get wasted as there is no chance to release
 * it and mark it as free.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] dir_entry The directory entry of the file to delete.
 * \returns 0 on failure, 1 on success.
 * \see fat16_create_file
 */
uint8_t fat16_delete_file(struct fat16_fs_struct* fs, struct fat16_dir_entry_struct* dir_entry)
{
    208c:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    #if FAT16_WRITE_SUPPORT
        if(!fs || !dir_entry)
    2090:	e3510000 	cmp	r1, #0	; 0x0
    2094:	13500000 	cmpne	r0, #0	; 0x0
    2098:	e24dd00c 	sub	sp, sp, #12	; 0xc
    209c:	e1a06000 	mov	r6, r0
    20a0:	e1a07001 	mov	r7, r1
    20a4:	0a00001f 	beq	2128 <fat16_delete_file+0x9c>
            return 0;
    
        /* get offset of the file's directory entry */
        uint32_t dir_entry_offset = dir_entry->entry_offset;
    20a8:	e5915028 	ldr	r5, [r1, #40]
        if(!dir_entry_offset)
    20ac:	e3550000 	cmp	r5, #0	; 0x0
    20b0:	0a00001c 	beq	2128 <fat16_delete_file+0x9c>
            return 0;
    
        uint8_t buffer[12];
        while(1)
        {
            /* read directory entry */
            if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
    20b4:	e1a0100d 	mov	r1, sp
    20b8:	e1a00005 	mov	r0, r5
    20bc:	e3a0200c 	mov	r2, #12	; 0xc
    20c0:	e5963000 	ldr	r3, [r6]
    20c4:	e593c000 	ldr	ip, [r3]
    20c8:	e1a0e00f 	mov	lr, pc
    20cc:	e12fff1c 	bx	ip
    20d0:	e3500000 	cmp	r0, #0	; 0x0
    20d4:	e1a0400d 	mov	r4, sp
                return 0;
    
            /* mark the directory entry as deleted */
            buffer[0] = FAT16_DIRENTRY_DELETED;
    
            /* write back entry */
            if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
    20d8:	e1a00005 	mov	r0, r5
    20dc:	e1a0100d 	mov	r1, sp
    20e0:	e3a0200c 	mov	r2, #12	; 0xc
                return 0;
    
            /* check if we deleted the whole entry */
            if(buffer[11] != 0x0f)
                break;
    
            dir_entry_offset += 32;
    20e4:	e2855020 	add	r5, r5, #32	; 0x20
    20e8:	0a00000e 	beq	2128 <fat16_delete_file+0x9c>
    20ec:	e3e0301a 	mvn	r3, #26	; 0x1a
    20f0:	e5cd3000 	strb	r3, [sp]
    20f4:	e5963000 	ldr	r3, [r6]
    20f8:	e593c008 	ldr	ip, [r3, #8]
    20fc:	e1a0e00f 	mov	lr, pc
    2100:	e12fff1c 	bx	ip
    2104:	e3500000 	cmp	r0, #0	; 0x0
    2108:	0a000006 	beq	2128 <fat16_delete_file+0x9c>
    210c:	e5dd300b 	ldrb	r3, [sp, #11]
    2110:	e353000f 	cmp	r3, #15	; 0xf
    2114:	0affffe6 	beq	20b4 <fat16_delete_file+0x28>
        }
    
        /* We deleted the directory entry. The next thing to do is
                             * marking all occupied clusters as free.
                             */
        return fat16_free_clusters(fs, dir_entry->cluster);
    2118:	e1a00006 	mov	r0, r6
    211c:	e1d712b2 	ldrh	r1, [r7, #34]
    2120:	ebfffed9 	bl	1c8c <fat16_free_clusters>
    2124:	ea000000 	b	212c <fat16_delete_file+0xa0>
    2128:	e3a00000 	mov	r0, #0	; 0x0
    #else
        return 0;
    #endif
}
    212c:	e28dd00c 	add	sp, sp, #12	; 0xc
    2130:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    2134:	e12fff1e 	bx	lr

00002138 <fat16_get_fs_size>:

/**
 * \ingroup fat16_fs
 * Returns the amount of total storage capacity of the filesystem in bytes.
 *
 * \param[in] fs The filesystem on which to operate.
 * \returns 0 on failure, the filesystem size in bytes otherwise.
 */
uint32_t fat16_get_fs_size(const struct fat16_fs_struct* fs)
{
    if(!fs)
    2138:	e3500000 	cmp	r0, #0	; 0x0
        return 0;

    return (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
    213c:	1590300c 	ldrne	r3, [r0, #12]
    2140:	e1a02000 	mov	r2, r0
    2144:	11a030a3 	movne	r3, r3, lsr #1
    2148:	11d021b2 	ldrneh	r2, [r0, #18]
    214c:	12433002 	subne	r3, r3, #2	; 0x2
    2150:	10020293 	mulne	r2, r3, r2
}
    2154:	e1a00002 	mov	r0, r2
    2158:	e12fff1e 	bx	lr

0000215c <fat16_get_fs_free>:

/**
 * \ingroup fat16_fs
 * Returns the amount of free storage capacity on the filesystem in bytes.
 *
 * \note As the FAT16 filesystem is cluster based, this function does not
 *       return continuous values but multiples of the cluster size.
 *
 * \param[in] fs The filesystem on which to operate.
 * \returns 0 on failure, the free filesystem space in bytes otherwise.
 */
uint32_t fat16_get_fs_free(const struct fat16_fs_struct* fs)
{
    215c:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    if(!fs)
    2160:	e2506000 	subs	r6, r0, #0	; 0x0
    2164:	e24dd02c 	sub	sp, sp, #44	; 0x2c
    2168:	0a000021 	beq	21f4 <fat16_get_fs_free+0x98>
        return 0;

    uint8_t fat[32];
    struct fat16_usage_count_callback_arg count_arg;
    count_arg.cluster_count = 0;
    count_arg.buffer_size = sizeof(fat);
    216c:	e3a03020 	mov	r3, #32	; 0x20
    2170:	e5cd302a 	strb	r3, [sp, #42]

    uint32_t fat_offset = fs->header.fat_offset;
    2174:	e5967008 	ldr	r7, [r6, #8]
    uint32_t fat_size = fs->header.fat_size;
    2178:	e596500c 	ldr	r5, [r6, #12]
    217c:	e3a03000 	mov	r3, #0	; 0x0
    2180:	e1cd32b8 	strh	r3, [sp, #40]
    2184:	ea000012 	b	21d4 <fat16_get_fs_free+0x78>
    while(fat_size > 0)
    {
        uint16_t length = UINT16_MAX - 1;
        if(fat_size < length)
    2188:	e59f3074 	ldr	r3, [pc, #116]	; 2204 <.text+0x2204>
    218c:	e1550003 	cmp	r5, r3
            length = fat_size;

        if(!fs->partition->device_read_interval(fat_offset,
    2190:	e59f3070 	ldr	r3, [pc, #112]	; 2208 <.text+0x2208>
    2194:	91a04822 	movls	r4, r2, lsr #16
    2198:	e596c000 	ldr	ip, [r6]
    219c:	e58d3000 	str	r3, [sp]
    21a0:	e28d3028 	add	r3, sp, #40	; 0x28
    21a4:	e58d3004 	str	r3, [sp, #4]
    21a8:	e1a00007 	mov	r0, r7
    21ac:	e28d1008 	add	r1, sp, #8	; 0x8
    21b0:	e3a02020 	mov	r2, #32	; 0x20
    21b4:	e1a03004 	mov	r3, r4
    21b8:	e59cc004 	ldr	ip, [ip, #4]
    21bc:	e1a0e00f 	mov	lr, pc
    21c0:	e12fff1c 	bx	ip
    21c4:	e3500000 	cmp	r0, #0	; 0x0
    21c8:	0a000009 	beq	21f4 <fat16_get_fs_free+0x98>
            fat,
           sizeof(fat),
           length,
           fat16_get_fs_free_callback,
           &count_arg
           )
           )
        return 0;

        fat_offset += length;
        fat_size -= length;
    21cc:	e0645005 	rsb	r5, r4, r5
    21d0:	e0877004 	add	r7, r7, r4
    21d4:	e3550000 	cmp	r5, #0	; 0x0
    21d8:	e59f402c 	ldr	r4, [pc, #44]	; 220c <.text+0x220c>
    21dc:	e1a02805 	mov	r2, r5, lsl #16
    21e0:	1affffe8 	bne	2188 <fat16_get_fs_free+0x2c>
    }

    return (uint32_t) count_arg.cluster_count * fs->header.cluster_size;
    21e4:	e1d621b2 	ldrh	r2, [r6, #18]
    21e8:	e1dd32b8 	ldrh	r3, [sp, #40]
    21ec:	e0000392 	mul	r0, r2, r3
    21f0:	ea000000 	b	21f8 <fat16_get_fs_free+0x9c>
    21f4:	e3a00000 	mov	r0, #0	; 0x0
}
    21f8:	e28dd02c 	add	sp, sp, #44	; 0x2c
    21fc:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    2200:	e12fff1e 	bx	lr
    2204:	0000fffd 	streqd	pc, [r0], -sp
    2208:	00002210 	andeq	r2, r0, r0, lsl r2
    220c:	0000fffe 	streqd	pc, [r0], -lr

00002210 <fat16_get_fs_free_callback>:

/**
 * \ingroup fat16_fs
 * Callback function used for counting free clusters.
 */
uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p)
{
    2210:	e92d4010 	stmdb	sp!, {r4, lr}
    struct fat16_usage_count_callback_arg* count_arg = (struct fat16_usage_count_callback_arg*) p;
    uint8_t buffer_size = count_arg->buffer_size;
    2214:	e5d24002 	ldrb	r4, [r2, #2]
    2218:	e1a0c002 	mov	ip, r2
    221c:	e1a01000 	mov	r1, r0
    2220:	e3a0e000 	mov	lr, #0	; 0x0
    2224:	ea000007 	b	2248 <fat16_get_fs_free_callback+0x38>
    uint8_t i;
    for(i = 0; i < buffer_size; i += 2)
    {
        if((((uint16_t) buffer[1] << 8) | ((uint16_t) buffer[0] << 0)) == FAT16_CLUSTER_FREE)
    2228:	e7de3000 	ldrb	r3, [lr, r0]
    222c:	e5d12001 	ldrb	r2, [r1, #1]
    2230:	e1932402 	orrs	r2, r3, r2, lsl #8
            ++(count_arg->cluster_count);
    2234:	01dc30b0 	ldreqh	r3, [ip]
    2238:	02833001 	addeq	r3, r3, #1	; 0x1
    223c:	01cc30b0 	streqh	r3, [ip]

        buffer += 2;
    2240:	e2811002 	add	r1, r1, #2	; 0x2
    2244:	e28ee002 	add	lr, lr, #2	; 0x2
    2248:	e20e30ff 	and	r3, lr, #255	; 0xff
    224c:	e1530004 	cmp	r3, r4
    2250:	3afffff4 	bcc	2228 <fat16_get_fs_free_callback+0x18>
    }

    return 1;
}
    2254:	e3a00001 	mov	r0, #1	; 0x1
    2258:	e8bd4010 	ldmia	sp!, {r4, lr}
    225c:	e12fff1e 	bx	lr

00002260 <fat16_file_size>:

uint8_t find_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd, const char* name, struct fat16_dir_entry_struct* dir_entry)
{
    while(fat16_read_dir(dd, dir_entry))
    {
        if(strcmp(dir_entry->long_name, name) == 0)
        {
            fat16_reset_dir(dd);
            return 1;
        }
    }

    return 0;
}

struct fat16_file_struct* open_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd, const char* name)
{
    struct fat16_dir_entry_struct file_entry;
    if(!find_file_in_dir(fs, dd, name, &file_entry))
        return 0;

    return fat16_open_file(fs, &file_entry);
}

int fat16_file_size(struct fat16_file_struct * file)
{
    return(file->dir_entry.file_size);
}
    2260:	e5900028 	ldr	r0, [r0, #40]
    2264:	e12fff1e 	bx	lr

00002268 <fat16_read_dir>:
    2268:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    226c:	e1a0a001 	mov	sl, r1
    2270:	e2711001 	rsbs	r1, r1, #1	; 0x1
    2274:	33a01000 	movcc	r1, #0	; 0x0
    2278:	e35a0000 	cmp	sl, #0	; 0x0
    227c:	13500000 	cmpne	r0, #0	; 0x0
    2280:	e24dd038 	sub	sp, sp, #56	; 0x38
    2284:	e1a08000 	mov	r8, r0
    2288:	0a000076 	beq	2468 <fat16_read_dir+0x200>
    228c:	e1d032b6 	ldrh	r3, [r0, #38]
    2290:	e3530000 	cmp	r3, #0	; 0x0
    2294:	e1d093b0 	ldrh	r9, [r0, #48]
    2298:	e5906000 	ldr	r6, [r0]
    229c:	1a00002c 	bne	2354 <fat16_read_dir+0xec>
    22a0:	e3560000 	cmp	r6, #0	; 0x0
    22a4:	11a07001 	movne	r7, r1
    22a8:	03817001 	orreq	r7, r1, #1	; 0x1
    22ac:	e3570000 	cmp	r7, #0	; 0x0
    22b0:	1a00006a 	bne	2460 <fat16_read_dir+0x1f8>
    22b4:	e5963000 	ldr	r3, [r6]
    22b8:	e28d502c 	add	r5, sp, #44	; 0x2c
    22bc:	e2864004 	add	r4, r6, #4	; 0x4
    22c0:	e1a01007 	mov	r1, r7
    22c4:	e3a0200c 	mov	r2, #12	; 0xc
    22c8:	e1a00005 	mov	r0, r5
    22cc:	e5936004 	ldr	r6, [r3, #4]
    22d0:	eb000c75 	bl	54ac <memset>
    22d4:	e2840010 	add	r0, r4, #16	; 0x10
    22d8:	e8900009 	ldmia	r0, {r0, r3}
    22dc:	e59f2194 	ldr	r2, [pc, #404]	; 2478 <.text+0x2478>
    22e0:	e0603003 	rsb	r3, r0, r3
    22e4:	e1a03803 	mov	r3, r3, lsl #16
    22e8:	e28d400c 	add	r4, sp, #12	; 0xc
    22ec:	e58d2000 	str	r2, [sp]
    22f0:	e1cd92be 	strh	r9, [sp, #46]
    22f4:	e58d5004 	str	r5, [sp, #4]
    22f8:	e1a03823 	mov	r3, r3, lsr #16
    22fc:	e1a01004 	mov	r1, r4
    2300:	e3a02020 	mov	r2, #32	; 0x20
    2304:	e1a0e00f 	mov	lr, pc
    2308:	e12fff16 	bx	r6
    230c:	e3500000 	cmp	r0, #0	; 0x0
    2310:	0a000052 	beq	2460 <fat16_read_dir+0x1f8>
    2314:	e59d3030 	ldr	r3, [sp, #48]
    2318:	e3530000 	cmp	r3, #0	; 0x0
    231c:	0a00004f 	beq	2460 <fat16_read_dir+0x1f8>
    2320:	e1a01007 	mov	r1, r7
    2324:	e3a0202c 	mov	r2, #44	; 0x2c
    2328:	e1a0000a 	mov	r0, sl
    232c:	eb000c5e 	bl	54ac <memset>
    2330:	e59f2144 	ldr	r2, [pc, #324]	; 247c <.text+0x247c>
    2334:	e5dd3034 	ldrb	r3, [sp, #52]
    2338:	e88d0404 	stmia	sp, {r2, sl}
    233c:	e1a01004 	mov	r1, r4
    2340:	e59d0030 	ldr	r0, [sp, #48]
    2344:	e3a02020 	mov	r2, #32	; 0x20
    2348:	e1a0e00f 	mov	lr, pc
    234c:	e12fff16 	bx	r6
    2350:	ea000039 	b	243c <fat16_read_dir+0x1d4>
    2354:	e3560000 	cmp	r6, #0	; 0x0
    2358:	e58d9008 	str	r9, [sp, #8]
    235c:	0a00003f 	beq	2460 <fat16_read_dir+0x1f8>
    2360:	e3510000 	cmp	r1, #0	; 0x0
    2364:	1a00003d 	bne	2460 <fat16_read_dir+0x1f8>
    2368:	e2800004 	add	r0, r0, #4	; 0x4
    236c:	e5d03020 	ldrb	r3, [r0, #32]
    2370:	e3130010 	tst	r3, #16	; 0x10
    2374:	0a000039 	beq	2460 <fat16_read_dir+0x1f8>
    2378:	e1d072b2 	ldrh	r7, [r0, #34]
    237c:	e1d691b2 	ldrh	r9, [r6, #18]
    2380:	e5962018 	ldr	r2, [r6, #24]
    2384:	e2473002 	sub	r3, r7, #2	; 0x2
    2388:	e0252399 	mla	r5, r9, r3, r2
    238c:	e28d402c 	add	r4, sp, #44	; 0x2c
    2390:	e3a01000 	mov	r1, #0	; 0x0
    2394:	e3a0200c 	mov	r2, #12	; 0xc
    2398:	e1a00004 	mov	r0, r4
    239c:	eb000c42 	bl	54ac <memset>
    23a0:	e59d3008 	ldr	r3, [sp, #8]
    23a4:	e1cd32be 	strh	r3, [sp, #46]
    23a8:	e59f30c8 	ldr	r3, [pc, #200]	; 2478 <.text+0x2478>
    23ac:	e28db00c 	add	fp, sp, #12	; 0xc
    23b0:	e596c000 	ldr	ip, [r6]
    23b4:	e1a0100b 	mov	r1, fp
    23b8:	e58d3000 	str	r3, [sp]
    23bc:	e1a00005 	mov	r0, r5
    23c0:	e58d4004 	str	r4, [sp, #4]
    23c4:	e3a02020 	mov	r2, #32	; 0x20
    23c8:	e1a03009 	mov	r3, r9
    23cc:	e59cc004 	ldr	ip, [ip, #4]
    23d0:	e1a0e00f 	mov	lr, pc
    23d4:	e12fff1c 	bx	ip
    23d8:	e3500000 	cmp	r0, #0	; 0x0
    23dc:	e1a01007 	mov	r1, r7
    23e0:	e1a00006 	mov	r0, r6
    23e4:	0a00001d 	beq	2460 <fat16_read_dir+0x1f8>
    23e8:	e59d3030 	ldr	r3, [sp, #48]
    23ec:	e3530000 	cmp	r3, #0	; 0x0
    23f0:	1a000003 	bne	2404 <fat16_read_dir+0x19c>
    23f4:	ebfffdfa 	bl	1be4 <fat16_get_next_cluster>
    23f8:	e2507000 	subs	r7, r0, #0	; 0x0
    23fc:	0a000017 	beq	2460 <fat16_read_dir+0x1f8>
    2400:	eaffffde 	b	2380 <fat16_read_dir+0x118>
    2404:	e3a01000 	mov	r1, #0	; 0x0
    2408:	e3a0202c 	mov	r2, #44	; 0x2c
    240c:	e1a0000a 	mov	r0, sl
    2410:	eb000c25 	bl	54ac <memset>
    2414:	e59f2060 	ldr	r2, [pc, #96]	; 247c <.text+0x247c>
    2418:	e596c000 	ldr	ip, [r6]
    241c:	e5dd3034 	ldrb	r3, [sp, #52]
    2420:	e88d0404 	stmia	sp, {r2, sl}
    2424:	e1a0100b 	mov	r1, fp
    2428:	e59d0030 	ldr	r0, [sp, #48]
    242c:	e3a02020 	mov	r2, #32	; 0x20
    2430:	e59cc004 	ldr	ip, [ip, #4]
    2434:	e1a0e00f 	mov	lr, pc
    2438:	e12fff1c 	bx	ip
    243c:	e3500000 	cmp	r0, #0	; 0x0
    2440:	0a000006 	beq	2460 <fat16_read_dir+0x1f8>
    2444:	e5da3000 	ldrb	r3, [sl]
    2448:	e3530000 	cmp	r3, #0	; 0x0
    244c:	11d833b0 	ldrneh	r3, [r8, #48]
    2450:	13a00001 	movne	r0, #1	; 0x1
    2454:	12833001 	addne	r3, r3, #1	; 0x1
    2458:	11c833b0 	strneh	r3, [r8, #48]
    245c:	1a000002 	bne	246c <fat16_read_dir+0x204>
    2460:	e3a03000 	mov	r3, #0	; 0x0
    2464:	e1c833b0 	strh	r3, [r8, #48]
    2468:	e3a00000 	mov	r0, #0	; 0x0
    246c:	e28dd038 	add	sp, sp, #56	; 0x38
    2470:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2474:	e12fff1e 	bx	lr
    2478:	000019c4 	andeq	r1, r0, r4, asr #19
    247c:	00001a34 	andeq	r1, r0, r4, lsr sl

00002480 <find_file_in_dir>:
    2480:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    2484:	e1a04001 	mov	r4, r1
    2488:	e1a06002 	mov	r6, r2
    248c:	e1a05003 	mov	r5, r3
    2490:	ea000007 	b	24b4 <find_file_in_dir+0x34>
    2494:	eb000c19 	bl	5500 <strcmp>
    2498:	e3500000 	cmp	r0, #0	; 0x0
    249c:	1a000004 	bne	24b4 <find_file_in_dir+0x34>
    24a0:	e3540000 	cmp	r4, #0	; 0x0
    24a4:	03a03001 	moveq	r3, #1	; 0x1
    24a8:	13a03001 	movne	r3, #1	; 0x1
    24ac:	11c403b0 	strneh	r0, [r4, #48]
    24b0:	ea000006 	b	24d0 <find_file_in_dir+0x50>
    24b4:	e1a01005 	mov	r1, r5
    24b8:	e1a00004 	mov	r0, r4
    24bc:	ebffff69 	bl	2268 <fat16_read_dir>
    24c0:	e2503000 	subs	r3, r0, #0	; 0x0
    24c4:	e1a01006 	mov	r1, r6
    24c8:	e1a00005 	mov	r0, r5
    24cc:	1afffff0 	bne	2494 <find_file_in_dir+0x14>
    24d0:	e1a00003 	mov	r0, r3
    24d4:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    24d8:	e12fff1e 	bx	lr

000024dc <fat16_write_dir_entry>:
    24dc:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    24e0:	e3510000 	cmp	r1, #0	; 0x0
    24e4:	13500000 	cmpne	r0, #0	; 0x0
    24e8:	e24dd020 	sub	sp, sp, #32	; 0x20
    24ec:	e1a06001 	mov	r6, r1
    24f0:	0a000098 	beq	2758 <fat16_write_dir_entry+0x27c>
    24f4:	e5903000 	ldr	r3, [r0]
    24f8:	e1a00001 	mov	r0, r1
    24fc:	e5939008 	ldr	r9, [r3, #8]
    2500:	eb000c0a 	bl	5530 <strlen>
    2504:	e20050ff 	and	r5, r0, #255	; 0xff
    2508:	e3a0100d 	mov	r1, #13	; 0xd
    250c:	e285000c 	add	r0, r5, #12	; 0xc
    2510:	eb000d64 	bl	5aa8 <__aeabi_idiv>
    2514:	e3a01020 	mov	r1, #32	; 0x20
    2518:	e1a03000 	mov	r3, r0
    251c:	e3a0200b 	mov	r2, #11	; 0xb
    2520:	e1a0000d 	mov	r0, sp
    2524:	e203a0ff 	and	sl, r3, #255	; 0xff
    2528:	e5968028 	ldr	r8, [r6, #40]
    252c:	eb000bde 	bl	54ac <memset>
    2530:	e1a00006 	mov	r0, r6
    2534:	e3a0102e 	mov	r1, #46	; 0x2e
    2538:	eb000c2b 	bl	55ec <strrchr>
    253c:	e3500000 	cmp	r0, #0	; 0x0
    2540:	e1a0700d 	mov	r7, sp
    2544:	0a00000b 	beq	2578 <fat16_write_dir_entry+0x9c>
    2548:	e2804001 	add	r4, r0, #1	; 0x1
    254c:	e1a00004 	mov	r0, r4
    2550:	eb000bf6 	bl	5530 <strlen>
    2554:	e20020ff 	and	r2, r0, #255	; 0xff
    2558:	e0623005 	rsb	r3, r2, r5
    255c:	e2433001 	sub	r3, r3, #1	; 0x1
    2560:	e3520003 	cmp	r2, #3	; 0x3
    2564:	23a02003 	movcs	r2, #3	; 0x3
    2568:	e1a01004 	mov	r1, r4
    256c:	e28d0008 	add	r0, sp, #8	; 0x8
    2570:	e20350ff 	and	r5, r3, #255	; 0xff
    2574:	eb000bc4 	bl	548c <memcpy>
    2578:	e3550008 	cmp	r5, #8	; 0x8
    257c:	8a000004 	bhi	2594 <fat16_write_dir_entry+0xb8>
    2580:	e1a0000d 	mov	r0, sp
    2584:	e1a02005 	mov	r2, r5
    2588:	e1a01006 	mov	r1, r6
    258c:	eb000bbe 	bl	548c <memcpy>
    2590:	ea00000e 	b	25d0 <fat16_write_dir_entry+0xf4>
    2594:	e3a02008 	mov	r2, #8	; 0x8
    2598:	e1a0000d 	mov	r0, sp
    259c:	e1a01006 	mov	r1, r6
    25a0:	eb000bb9 	bl	548c <memcpy>
    25a4:	e5d63022 	ldrb	r3, [r6, #34]
    25a8:	e353009f 	cmp	r3, #159	; 0x9f
    25ac:	e1a02223 	mov	r2, r3, lsr #4
    25b0:	e203300f 	and	r3, r3, #15	; 0xf
    25b4:	92822030 	addls	r2, r2, #48	; 0x30
    25b8:	82822061 	addhi	r2, r2, #97	; 0x61
    25bc:	e3530009 	cmp	r3, #9	; 0x9
    25c0:	92833030 	addls	r3, r3, #48	; 0x30
    25c4:	82833061 	addhi	r3, r3, #97	; 0x61
    25c8:	e5cd2006 	strb	r2, [sp, #6]
    25cc:	e5cd3007 	strb	r3, [sp, #7]
    25d0:	e3a01000 	mov	r1, #0	; 0x0
    25d4:	e3a02015 	mov	r2, #21	; 0x15
    25d8:	e28d000b 	add	r0, sp, #11	; 0xb
    25dc:	eb000bb2 	bl	54ac <memset>
    25e0:	e5d63020 	ldrb	r3, [r6, #32]
    25e4:	e5cd300b 	strb	r3, [sp, #11]
    25e8:	e1d622b2 	ldrh	r2, [r6, #34]
    25ec:	e1a03422 	mov	r3, r2, lsr #8
    25f0:	e5cd201a 	strb	r2, [sp, #26]
    25f4:	e5cd301b 	strb	r3, [sp, #27]
    25f8:	e5963024 	ldr	r3, [r6, #36]
    25fc:	e1a00c23 	mov	r0, r3, lsr #24
    2600:	e1a02423 	mov	r2, r3, lsr #8
    2604:	e1a01823 	mov	r1, r3, lsr #16
    2608:	e5cd201d 	strb	r2, [sp, #29]
    260c:	e5cd101e 	strb	r1, [sp, #30]
    2610:	e5cd001f 	strb	r0, [sp, #31]
    2614:	e5cd301c 	strb	r3, [sp, #28]
    2618:	e088028a 	add	r0, r8, sl, lsl #5
    261c:	e1a0100d 	mov	r1, sp
    2620:	e3a02020 	mov	r2, #32	; 0x20
    2624:	e1a0e00f 	mov	lr, pc
    2628:	e12fff19 	bx	r9
    262c:	e3500000 	cmp	r0, #0	; 0x0
    2630:	e1a0400d 	mov	r4, sp
    2634:	0a000047 	beq	2758 <fat16_write_dir_entry+0x27c>
    2638:	e5dd7000 	ldrb	r7, [sp]
    263c:	e1a0100d 	mov	r1, sp
    2640:	e5f12001 	ldrb	r2, [r1, #1]!
    2644:	e1a03387 	mov	r3, r7, lsl #7
    2648:	e18330a7 	orr	r3, r3, r7, lsr #1
    264c:	e0833002 	add	r3, r3, r2
    2650:	e28d200a 	add	r2, sp, #10	; 0xa
    2654:	e1510002 	cmp	r1, r2
    2658:	e20370ff 	and	r7, r3, #255	; 0xff
    265c:	1afffff7 	bne	2640 <fat16_write_dir_entry+0x164>
    2660:	e1a0500a 	mov	r5, sl
    2664:	ea000037 	b	2748 <fat16_write_dir_entry+0x26c>
    2668:	e3a01000 	mov	r1, #0	; 0x0
    266c:	e3a02020 	mov	r2, #32	; 0x20
    2670:	e1a0000d 	mov	r0, sp
    2674:	eb000b8c 	bl	54ac <memset>
    2678:	e3a010ff 	mov	r1, #255	; 0xff
    267c:	e3a0200a 	mov	r2, #10	; 0xa
    2680:	e28d0001 	add	r0, sp, #1	; 0x1
    2684:	eb000b88 	bl	54ac <memset>
    2688:	e3a010ff 	mov	r1, #255	; 0xff
    268c:	e3a0200c 	mov	r2, #12	; 0xc
    2690:	e28d000e 	add	r0, sp, #14	; 0xe
    2694:	eb000b84 	bl	54ac <memset>
    2698:	e28d001c 	add	r0, sp, #28	; 0x1c
    269c:	e3a010ff 	mov	r1, #255	; 0xff
    26a0:	e3a02004 	mov	r2, #4	; 0x4
    26a4:	eb000b80 	bl	54ac <memset>
    26a8:	e155000a 	cmp	r5, sl
    26ac:	03853040 	orreq	r3, r5, #64	; 0x40
    26b0:	e5cd5000 	strb	r5, [sp]
    26b4:	05cd3000 	streqb	r3, [sp]
    26b8:	e3a0300d 	mov	r3, #13	; 0xd
    26bc:	e02e6395 	mla	lr, r5, r3, r6
    26c0:	e3a0c001 	mov	ip, #1	; 0x1
    26c4:	e28c3001 	add	r3, ip, #1	; 0x1
    26c8:	e20330ff 	and	r3, r3, #255	; 0xff
    26cc:	e2832001 	add	r2, r3, #1	; 0x1
    26d0:	e28d4020 	add	r4, sp, #32	; 0x20
    26d4:	e55e000d 	ldrb	r0, [lr, #-13]
    26d8:	e084100c 	add	r1, r4, ip
    26dc:	e202c0ff 	and	ip, r2, #255	; 0xff
    26e0:	e35c000b 	cmp	ip, #11	; 0xb
    26e4:	e0842003 	add	r2, r4, r3
    26e8:	e3a03000 	mov	r3, #0	; 0x0
    26ec:	e5410020 	strb	r0, [r1, #-32]
    26f0:	03a0c00e 	moveq	ip, #14	; 0xe
    26f4:	e5423020 	strb	r3, [r2, #-32]
    26f8:	0a000001 	beq	2704 <fat16_write_dir_entry+0x228>
    26fc:	e35c001a 	cmp	ip, #26	; 0x1a
    2700:	028cc002 	addeq	ip, ip, #2	; 0x2
    2704:	e55e300d 	ldrb	r3, [lr, #-13]
    2708:	e3530000 	cmp	r3, #0	; 0x0
    270c:	e28ee001 	add	lr, lr, #1	; 0x1
    2710:	0a000001 	beq	271c <fat16_write_dir_entry+0x240>
    2714:	e35c001e 	cmp	ip, #30	; 0x1e
    2718:	9affffe9 	bls	26c4 <fat16_write_dir_entry+0x1e8>
    271c:	e3a0300f 	mov	r3, #15	; 0xf
    2720:	e5cd300b 	strb	r3, [sp, #11]
    2724:	e1a00008 	mov	r0, r8
    2728:	e5cd700d 	strb	r7, [sp, #13]
    272c:	e1a0100d 	mov	r1, sp
    2730:	e3a02020 	mov	r2, #32	; 0x20
    2734:	e1a0e00f 	mov	lr, pc
    2738:	e12fff19 	bx	r9
    273c:	e2453001 	sub	r3, r5, #1	; 0x1
    2740:	e2888020 	add	r8, r8, #32	; 0x20
    2744:	e20350ff 	and	r5, r3, #255	; 0xff
    2748:	e3550000 	cmp	r5, #0	; 0x0
    274c:	1affffc5 	bne	2668 <fat16_write_dir_entry+0x18c>
    2750:	e3a00001 	mov	r0, #1	; 0x1
    2754:	ea000000 	b	275c <fat16_write_dir_entry+0x280>
    2758:	e3a00000 	mov	r0, #0	; 0x0
    275c:	e28dd020 	add	sp, sp, #32	; 0x20
    2760:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2764:	e12fff1e 	bx	lr

00002768 <fat16_resize_file>:
    2768:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    276c:	e2506000 	subs	r6, r0, #0	; 0x0
    2770:	e24dd004 	sub	sp, sp, #4	; 0x4
    2774:	e1a0a001 	mov	sl, r1
    2778:	0a00005b 	beq	28ec <fat16_resize_file+0x184>
    277c:	e1d642b6 	ldrh	r4, [r6, #38]
    2780:	e5963000 	ldr	r3, [r6]
    2784:	e2719001 	rsbs	r9, r1, #1	; 0x1
    2788:	33a09000 	movcc	r9, #0	; 0x0
    278c:	e3540000 	cmp	r4, #0	; 0x0
    2790:	03510000 	cmpeq	r1, #0	; 0x0
    2794:	e1d381b2 	ldrh	r8, [r3, #18]
    2798:	11a07001 	movne	r7, r1
    279c:	1a000006 	bne	27bc <fat16_resize_file+0x54>
    27a0:	ea000049 	b	28cc <fat16_resize_file+0x164>
    27a4:	e5960000 	ldr	r0, [r6]
    27a8:	ebfffd0d 	bl	1be4 <fat16_get_next_cluster>
    27ac:	e3500000 	cmp	r0, #0	; 0x0
    27b0:	0a00004f 	beq	28f4 <fat16_resize_file+0x18c>
    27b4:	e0687007 	rsb	r7, r8, r7
    27b8:	e1a04000 	mov	r4, r0
    27bc:	e1570008 	cmp	r7, r8
    27c0:	e1a01004 	mov	r1, r4
    27c4:	8afffff6 	bhi	27a4 <fat16_resize_file+0x3c>
    27c8:	e2745001 	rsbs	r5, r4, #1	; 0x1
    27cc:	33a05000 	movcc	r5, #0	; 0x0
    27d0:	e3550000 	cmp	r5, #0	; 0x0
    27d4:	0a000011 	beq	2820 <fat16_resize_file+0xb8>
    27d8:	e1a01008 	mov	r1, r8
    27dc:	e1a00007 	mov	r0, r7
    27e0:	eb000c6b 	bl	5994 <__aeabi_uidiv>
    27e4:	e1a00800 	mov	r0, r0, lsl #16
    27e8:	e1a02820 	mov	r2, r0, lsr #16
    27ec:	e0030298 	mul	r3, r8, r2
    27f0:	e1530007 	cmp	r3, r7
    27f4:	32823001 	addcc	r3, r2, #1	; 0x1
    27f8:	31a03803 	movcc	r3, r3, lsl #16
    27fc:	31a02823 	movcc	r2, r3, lsr #16
    2800:	e5960000 	ldr	r0, [r6]
    2804:	e1a01004 	mov	r1, r4
    2808:	ebfffd55 	bl	1d64 <fat16_append_clusters>
    280c:	e3500000 	cmp	r0, #0	; 0x0
    2810:	0a000035 	beq	28ec <fat16_resize_file+0x184>
    2814:	e3550000 	cmp	r5, #0	; 0x0
    2818:	11c602b6 	strneh	r0, [r6, #38]
    281c:	11a04000 	movne	r4, r0
    2820:	e3590000 	cmp	r9, #0	; 0x0
    2824:	13a03000 	movne	r3, #0	; 0x0
    2828:	11c632b6 	strneh	r3, [r6, #38]
    282c:	e586a028 	str	sl, [r6, #40]
    2830:	e5960000 	ldr	r0, [r6]
    2834:	e2861004 	add	r1, r6, #4	; 0x4
    2838:	ebffff27 	bl	24dc <fat16_write_dir_entry>
    283c:	e3500000 	cmp	r0, #0	; 0x0
    2840:	0a000029 	beq	28ec <fat16_resize_file+0x184>
    2844:	e3590000 	cmp	r9, #0	; 0x0
    2848:	11a01004 	movne	r1, r4
    284c:	15960000 	ldrne	r0, [r6]
    2850:	1a00001c 	bne	28c8 <fat16_resize_file+0x160>
    2854:	e1570008 	cmp	r7, r8
    2858:	8a00001b 	bhi	28cc <fat16_resize_file+0x164>
    285c:	e1a03804 	mov	r3, r4, lsl #16
    2860:	e5965000 	ldr	r5, [r6]
    2864:	e1a04823 	mov	r4, r3, lsr #16
    2868:	e3550000 	cmp	r5, #0	; 0x0
    286c:	13540001 	cmpne	r4, #1	; 0x1
    2870:	9a000015 	bls	28cc <fat16_resize_file+0x164>
    2874:	e1a01004 	mov	r1, r4
    2878:	e1a00005 	mov	r0, r5
    287c:	ebfffcd8 	bl	1be4 <fat16_get_next_cluster>
    2880:	e3e03000 	mvn	r3, #0	; 0x0
    2884:	e5cd3003 	strb	r3, [sp, #3]
    2888:	e5cd3002 	strb	r3, [sp, #2]
    288c:	e1a07000 	mov	r7, r0
    2890:	e5950008 	ldr	r0, [r5, #8]
    2894:	e5953000 	ldr	r3, [r5]
    2898:	e0800084 	add	r0, r0, r4, lsl #1
    289c:	e28d1002 	add	r1, sp, #2	; 0x2
    28a0:	e3a02002 	mov	r2, #2	; 0x2
    28a4:	e593c008 	ldr	ip, [r3, #8]
    28a8:	e1a0e00f 	mov	lr, pc
    28ac:	e12fff1c 	bx	ip
    28b0:	e3500000 	cmp	r0, #0	; 0x0
    28b4:	0a000004 	beq	28cc <fat16_resize_file+0x164>
    28b8:	e3570000 	cmp	r7, #0	; 0x0
    28bc:	0a000002 	beq	28cc <fat16_resize_file+0x164>
    28c0:	e1a00005 	mov	r0, r5
    28c4:	e1a01007 	mov	r1, r7
    28c8:	ebfffcef 	bl	1c8c <fat16_free_clusters>
    28cc:	e5963030 	ldr	r3, [r6, #48]
    28d0:	e15a0003 	cmp	sl, r3
    28d4:	33a03000 	movcc	r3, #0	; 0x0
    28d8:	23a00001 	movcs	r0, #1	; 0x1
    28dc:	33a00001 	movcc	r0, #1	; 0x1
    28e0:	3586a030 	strcc	sl, [r6, #48]
    28e4:	31c633b4 	strcch	r3, [r6, #52]
    28e8:	ea000004 	b	2900 <fat16_resize_file+0x198>
    28ec:	e3a00000 	mov	r0, #0	; 0x0
    28f0:	ea000002 	b	2900 <fat16_resize_file+0x198>
    28f4:	e2745001 	rsbs	r5, r4, #1	; 0x1
    28f8:	33a05000 	movcc	r5, #0	; 0x0
    28fc:	eaffffb5 	b	27d8 <fat16_resize_file+0x70>
    2900:	e28dd004 	add	sp, sp, #4	; 0x4
    2904:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2908:	e12fff1e 	bx	lr

0000290c <fat16_seek_file>:
    290c:	e3510000 	cmp	r1, #0	; 0x0
    2910:	13500000 	cmpne	r0, #0	; 0x0
    2914:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    2918:	e20220ff 	and	r2, r2, #255	; 0xff
    291c:	e1a05000 	mov	r5, r0
    2920:	e1a06001 	mov	r6, r1
    2924:	0a00001b 	beq	2998 <fat16_seek_file+0x8c>
    2928:	e3520001 	cmp	r2, #1	; 0x1
    292c:	e5901030 	ldr	r1, [r0, #48]
    2930:	0a000004 	beq	2948 <fat16_seek_file+0x3c>
    2934:	35964000 	ldrcc	r4, [r6]
    2938:	3a000008 	bcc	2960 <fat16_seek_file+0x54>
    293c:	e3520002 	cmp	r2, #2	; 0x2
    2940:	1a000014 	bne	2998 <fat16_seek_file+0x8c>
    2944:	ea000002 	b	2954 <fat16_seek_file+0x48>
    2948:	e5963000 	ldr	r3, [r6]
    294c:	e0814003 	add	r4, r1, r3
    2950:	ea000002 	b	2960 <fat16_seek_file+0x54>
    2954:	e5902028 	ldr	r2, [r0, #40]
    2958:	e5963000 	ldr	r3, [r6]
    295c:	e0824003 	add	r4, r2, r3
    2960:	e5953028 	ldr	r3, [r5, #40]
    2964:	e1540003 	cmp	r4, r3
    2968:	9a000004 	bls	2980 <fat16_seek_file+0x74>
    296c:	e1a00005 	mov	r0, r5
    2970:	e1a01004 	mov	r1, r4
    2974:	ebffff7b 	bl	2768 <fat16_resize_file>
    2978:	e3500000 	cmp	r0, #0	; 0x0
    297c:	0a000005 	beq	2998 <fat16_seek_file+0x8c>
    2980:	e3a03000 	mov	r3, #0	; 0x0
    2984:	e3a00001 	mov	r0, #1	; 0x1
    2988:	e5854030 	str	r4, [r5, #48]
    298c:	e1c533b4 	strh	r3, [r5, #52]
    2990:	e5864000 	str	r4, [r6]
    2994:	ea000000 	b	299c <fat16_seek_file+0x90>
    2998:	e3a00000 	mov	r0, #0	; 0x0
    299c:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    29a0:	e12fff1e 	bx	lr

000029a4 <fat16_write_file>:
    29a4:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    29a8:	e1a02802 	mov	r2, r2, lsl #16
    29ac:	e24dd004 	sub	sp, sp, #4	; 0x4
    29b0:	e1a02822 	mov	r2, r2, lsr #16
    29b4:	e3510000 	cmp	r1, #0	; 0x0
    29b8:	13500000 	cmpne	r0, #0	; 0x0
    29bc:	e1a04000 	mov	r4, r0
    29c0:	e1a0b001 	mov	fp, r1
    29c4:	e58d2000 	str	r2, [sp]
    29c8:	0a000077 	beq	2bac <fat16_write_file+0x208>
    29cc:	e3520000 	cmp	r2, #0	; 0x0
    29d0:	0a000075 	beq	2bac <fat16_write_file+0x208>
    29d4:	e590a030 	ldr	sl, [r0, #48]
    29d8:	e5903028 	ldr	r3, [r0, #40]
    29dc:	e15a0003 	cmp	sl, r3
    29e0:	8a000071 	bhi	2bac <fat16_write_file+0x208>
    29e4:	e1d053b4 	ldrh	r5, [r0, #52]
    29e8:	e5900000 	ldr	r0, [r0]
    29ec:	e3550000 	cmp	r5, #0	; 0x0
    29f0:	e1d081b2 	ldrh	r8, [r0, #18]
    29f4:	1a000020 	bne	2a7c <fat16_write_file+0xd8>
    29f8:	e1d452b6 	ldrh	r5, [r4, #38]
    29fc:	e3550000 	cmp	r5, #0	; 0x0
    2a00:	1a000008 	bne	2a28 <fat16_write_file+0x84>
    2a04:	e35a0000 	cmp	sl, #0	; 0x0
    2a08:	1a000067 	bne	2bac <fat16_write_file+0x208>
    2a0c:	e1a01005 	mov	r1, r5
    2a10:	e3a02001 	mov	r2, #1	; 0x1
    2a14:	ebfffcd2 	bl	1d64 <fat16_append_clusters>
    2a18:	e3500000 	cmp	r0, #0	; 0x0
    2a1c:	e1a05000 	mov	r5, r0
    2a20:	e1c402b6 	strh	r0, [r4, #38]
    2a24:	0a000060 	beq	2bac <fat16_write_file+0x208>
    2a28:	e5946030 	ldr	r6, [r4, #48]
    2a2c:	e3560000 	cmp	r6, #0	; 0x0
    2a30:	12689000 	rsbne	r9, r8, #0	; 0x0
    2a34:	10687006 	rsbne	r7, r8, r6
    2a38:	1a00000c 	bne	2a70 <fat16_write_file+0xcc>
    2a3c:	ea00000e 	b	2a7c <fat16_write_file+0xd8>
    2a40:	e5940000 	ldr	r0, [r4]
    2a44:	ebfffc66 	bl	1be4 <fat16_get_next_cluster>
    2a48:	e3500000 	cmp	r0, #0	; 0x0
    2a4c:	03570000 	cmpeq	r7, #0	; 0x0
    2a50:	e0866009 	add	r6, r6, r9
    2a54:	e0877009 	add	r7, r7, r9
    2a58:	e1a01005 	mov	r1, r5
    2a5c:	e3a02001 	mov	r2, #1	; 0x1
    2a60:	05940000 	ldreq	r0, [r4]
    2a64:	0bfffcbe 	bleq	1d64 <fat16_append_clusters>
    2a68:	e2505000 	subs	r5, r0, #0	; 0x0
    2a6c:	0a00004e 	beq	2bac <fat16_write_file+0x208>
    2a70:	e1560008 	cmp	r6, r8
    2a74:	e1a01005 	mov	r1, r5
    2a78:	2afffff0 	bcs	2a40 <fat16_write_file+0x9c>
    2a7c:	e1a0000a 	mov	r0, sl
    2a80:	e1a01008 	mov	r1, r8
    2a84:	eb000c58 	bl	5bec <__umodsi3>
    2a88:	e59d7000 	ldr	r7, [sp]
    2a8c:	e1a00800 	mov	r0, r0, lsl #16
    2a90:	e1a0a820 	mov	sl, r0, lsr #16
    2a94:	e594c000 	ldr	ip, [r4]
    2a98:	e06a3008 	rsb	r3, sl, r8
    2a9c:	e59c2018 	ldr	r2, [ip, #24]
    2aa0:	e1a03803 	mov	r3, r3, lsl #16
    2aa4:	e1a03823 	mov	r3, r3, lsr #16
    2aa8:	e1570003 	cmp	r7, r3
    2aac:	31a06007 	movcc	r6, r7
    2ab0:	21a06003 	movcs	r6, r3
    2ab4:	e08a2002 	add	r2, sl, r2
    2ab8:	e2453002 	sub	r3, r5, #2	; 0x2
    2abc:	e0202398 	mla	r0, r8, r3, r2
    2ac0:	e1a0100b 	mov	r1, fp
    2ac4:	e1a02006 	mov	r2, r6
    2ac8:	e59c3000 	ldr	r3, [ip]
    2acc:	e593c008 	ldr	ip, [r3, #8]
    2ad0:	e1a0e00f 	mov	lr, pc
    2ad4:	e12fff1c 	bx	ip
    2ad8:	e0663007 	rsb	r3, r6, r7
    2adc:	e3500000 	cmp	r0, #0	; 0x0
    2ae0:	e1a01005 	mov	r1, r5
    2ae4:	e08bb006 	add	fp, fp, r6
    2ae8:	e08a2006 	add	r2, sl, r6
    2aec:	e1a00803 	mov	r0, r3, lsl #16
    2af0:	0a000018 	beq	2b58 <fat16_write_file+0x1b4>
    2af4:	e5943030 	ldr	r3, [r4, #48]
    2af8:	e1520008 	cmp	r2, r8
    2afc:	e0833006 	add	r3, r3, r6
    2b00:	e5843030 	str	r3, [r4, #48]
    2b04:	e1a07820 	mov	r7, r0, lsr #16
    2b08:	ba00000f 	blt	2b4c <fat16_write_file+0x1a8>
    2b0c:	e5940000 	ldr	r0, [r4]
    2b10:	ebfffc33 	bl	1be4 <fat16_get_next_cluster>
    2b14:	e3a0a000 	mov	sl, #0	; 0x0
    2b18:	e150000a 	cmp	r0, sl
    2b1c:	13a03000 	movne	r3, #0	; 0x0
    2b20:	03a03001 	moveq	r3, #1	; 0x1
    2b24:	e157000a 	cmp	r7, sl
    2b28:	03a03000 	moveq	r3, #0	; 0x0
    2b2c:	e153000a 	cmp	r3, sl
    2b30:	e1a01005 	mov	r1, r5
    2b34:	e3a02001 	mov	r2, #1	; 0x1
    2b38:	15940000 	ldrne	r0, [r4]
    2b3c:	1bfffc88 	blne	1d64 <fat16_append_clusters>
    2b40:	e3500000 	cmp	r0, #0	; 0x0
    2b44:	e1a05000 	mov	r5, r0
    2b48:	0a000015 	beq	2ba4 <fat16_write_file+0x200>
    2b4c:	e3570000 	cmp	r7, #0	; 0x0
    2b50:	e1c453b4 	strh	r5, [r4, #52]
    2b54:	1affffce 	bne	2a94 <fat16_write_file+0xf0>
    2b58:	e5943030 	ldr	r3, [r4, #48]
    2b5c:	e5945028 	ldr	r5, [r4, #40]
    2b60:	e1530005 	cmp	r3, r5
    2b64:	9a000009 	bls	2b90 <fat16_write_file+0x1ec>
    2b68:	e5843028 	str	r3, [r4, #40]
    2b6c:	e5940000 	ldr	r0, [r4]
    2b70:	e2841004 	add	r1, r4, #4	; 0x4
    2b74:	ebfffe58 	bl	24dc <fat16_write_dir_entry>
    2b78:	e3500000 	cmp	r0, #0	; 0x0
    2b7c:	05943030 	ldreq	r3, [r4, #48]
    2b80:	00653003 	rsbeq	r3, r5, r3
    2b84:	01a03803 	moveq	r3, r3, lsl #16
    2b88:	05845030 	streq	r5, [r4, #48]
    2b8c:	01a07823 	moveq	r7, r3, lsr #16
    2b90:	e59d2000 	ldr	r2, [sp]
    2b94:	e0673002 	rsb	r3, r7, r2
    2b98:	e1a03803 	mov	r3, r3, lsl #16
    2b9c:	e1a00843 	mov	r0, r3, asr #16
    2ba0:	ea000002 	b	2bb0 <fat16_write_file+0x20c>
    2ba4:	e1c403b4 	strh	r0, [r4, #52]
    2ba8:	eaffffea 	b	2b58 <fat16_write_file+0x1b4>
    2bac:	e3e00000 	mvn	r0, #0	; 0x0
    2bb0:	e28dd004 	add	sp, sp, #4	; 0x4
    2bb4:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2bb8:	e12fff1e 	bx	lr

00002bbc <fat16_close_dir>:
    2bbc:	e3500000 	cmp	r0, #0	; 0x0
    2bc0:	e52de004 	str	lr, [sp, #-4]!
    2bc4:	1b00087e 	blne	4dc4 <free>
    2bc8:	e49de004 	ldr	lr, [sp], #4
    2bcc:	e12fff1e 	bx	lr

00002bd0 <fat16_close_file>:
    2bd0:	e3500000 	cmp	r0, #0	; 0x0
    2bd4:	e52de004 	str	lr, [sp, #-4]!
    2bd8:	1b000879 	blne	4dc4 <free>
    2bdc:	e49de004 	ldr	lr, [sp], #4
    2be0:	e12fff1e 	bx	lr

00002be4 <fat16_close>:
    2be4:	e3500000 	cmp	r0, #0	; 0x0
    2be8:	e52de004 	str	lr, [sp, #-4]!
    2bec:	1b000874 	blne	4dc4 <free>
    2bf0:	e49de004 	ldr	lr, [sp], #4
    2bf4:	e12fff1e 	bx	lr

00002bf8 <fat16_open_dir>:
    2bf8:	e3510000 	cmp	r1, #0	; 0x0
    2bfc:	13500000 	cmpne	r0, #0	; 0x0
    2c00:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2c04:	e1a07000 	mov	r7, r0
    2c08:	e1a05001 	mov	r5, r1
    2c0c:	13a08000 	movne	r8, #0	; 0x0
    2c10:	03a08001 	moveq	r8, #1	; 0x1
    2c14:	0a000013 	beq	2c68 <fat16_open_dir+0x70>
    2c18:	e5d13020 	ldrb	r3, [r1, #32]
    2c1c:	e3130010 	tst	r3, #16	; 0x10
    2c20:	e3a00034 	mov	r0, #52	; 0x34
    2c24:	0a00000f 	beq	2c68 <fat16_open_dir+0x70>
    2c28:	eb00086d 	bl	4de4 <malloc>
    2c2c:	e3500000 	cmp	r0, #0	; 0x0
    2c30:	e1a06000 	mov	r6, r0
    2c34:	e2804004 	add	r4, r0, #4	; 0x4
    2c38:	0a00000a 	beq	2c68 <fat16_open_dir+0x70>
    2c3c:	e1a0c005 	mov	ip, r5
    2c40:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
    2c44:	e1a0e004 	mov	lr, r4
    2c48:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    2c4c:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
    2c50:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    2c54:	e89c0007 	ldmia	ip, {r0, r1, r2}
    2c58:	e5867000 	str	r7, [r6]
    2c5c:	e88e0007 	stmia	lr, {r0, r1, r2}
    2c60:	e1c683b0 	strh	r8, [r6, #48]
    2c64:	ea000000 	b	2c6c <fat16_open_dir+0x74>
    2c68:	e3a06000 	mov	r6, #0	; 0x0
    2c6c:	e1a00006 	mov	r0, r6
    2c70:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    2c74:	e12fff1e 	bx	lr

00002c78 <fat16_open_file>:
    2c78:	e3510000 	cmp	r1, #0	; 0x0
    2c7c:	13500000 	cmpne	r0, #0	; 0x0
    2c80:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2c84:	e1a05001 	mov	r5, r1
    2c88:	e1a07000 	mov	r7, r0
    2c8c:	0a000015 	beq	2ce8 <fat16_open_file+0x70>
    2c90:	e5d13020 	ldrb	r3, [r1, #32]
    2c94:	e2138010 	ands	r8, r3, #16	; 0x10
    2c98:	e3a00038 	mov	r0, #56	; 0x38
    2c9c:	1a000011 	bne	2ce8 <fat16_open_file+0x70>
    2ca0:	eb00084f 	bl	4de4 <malloc>
    2ca4:	e3500000 	cmp	r0, #0	; 0x0
    2ca8:	e1a06000 	mov	r6, r0
    2cac:	e2804004 	add	r4, r0, #4	; 0x4
    2cb0:	0a00000c 	beq	2ce8 <fat16_open_file+0x70>
    2cb4:	e1a0c005 	mov	ip, r5
    2cb8:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
    2cbc:	e1a0e004 	mov	lr, r4
    2cc0:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    2cc4:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
    2cc8:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    2ccc:	e89c0007 	ldmia	ip, {r0, r1, r2}
    2cd0:	e88e0007 	stmia	lr, {r0, r1, r2}
    2cd4:	e1d552b2 	ldrh	r5, [r5, #34]
    2cd8:	e5867000 	str	r7, [r6]
    2cdc:	e5868030 	str	r8, [r6, #48]
    2ce0:	e1c653b4 	strh	r5, [r6, #52]
    2ce4:	ea000000 	b	2cec <fat16_open_file+0x74>
    2ce8:	e3a06000 	mov	r6, #0	; 0x0
    2cec:	e1a00006 	mov	r0, r6
    2cf0:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    2cf4:	e12fff1e 	bx	lr

00002cf8 <open_file_in_dir>:
    2cf8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    2cfc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
    2d00:	e1a0300d 	mov	r3, sp
    2d04:	e1a04000 	mov	r4, r0
    2d08:	ebfffddc 	bl	2480 <find_file_in_dir>
    2d0c:	e3500000 	cmp	r0, #0	; 0x0
    2d10:	e1a03000 	mov	r3, r0
    2d14:	e1a0500d 	mov	r5, sp
    2d18:	e1a00004 	mov	r0, r4
    2d1c:	e1a0100d 	mov	r1, sp
    2d20:	0a000001 	beq	2d2c <open_file_in_dir+0x34>
    2d24:	ebffffd3 	bl	2c78 <fat16_open_file>
    2d28:	e1a03000 	mov	r3, r0
    2d2c:	e1a00003 	mov	r0, r3
    2d30:	e28dd02c 	add	sp, sp, #44	; 0x2c
    2d34:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    2d38:	e12fff1e 	bx	lr

00002d3c <fat16_get_dir_entry_of_path>:
    2d3c:	e3510000 	cmp	r1, #0	; 0x0
    2d40:	13500000 	cmpne	r0, #0	; 0x0
    2d44:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2d48:	e1a09000 	mov	r9, r0
    2d4c:	e1a04001 	mov	r4, r1
    2d50:	e1a05002 	mov	r5, r2
    2d54:	0a00003c 	beq	2e4c <fat16_get_dir_entry_of_path+0x110>
    2d58:	e5d13000 	ldrb	r3, [r1]
    2d5c:	e3520000 	cmp	r2, #0	; 0x0
    2d60:	13530000 	cmpne	r3, #0	; 0x0
    2d64:	13a01000 	movne	r1, #0	; 0x0
    2d68:	03a01001 	moveq	r1, #1	; 0x1
    2d6c:	0a000036 	beq	2e4c <fat16_get_dir_entry_of_path+0x110>
    2d70:	e353002f 	cmp	r3, #47	; 0x2f
    2d74:	e1a00002 	mov	r0, r2
    2d78:	e3a0202c 	mov	r2, #44	; 0x2c
    2d7c:	02844001 	addeq	r4, r4, #1	; 0x1
    2d80:	eb0009c9 	bl	54ac <memset>
    2d84:	e3a03010 	mov	r3, #16	; 0x10
    2d88:	e5c53020 	strb	r3, [r5, #32]
    2d8c:	e5d43000 	ldrb	r3, [r4]
    2d90:	e3530000 	cmp	r3, #0	; 0x0
    2d94:	0a00002e 	beq	2e54 <fat16_get_dir_entry_of_path+0x118>
    2d98:	e1a00009 	mov	r0, r9
    2d9c:	e1a01005 	mov	r1, r5
    2da0:	ebffff94 	bl	2bf8 <fat16_open_dir>
    2da4:	e2507000 	subs	r7, r0, #0	; 0x0
    2da8:	0a000027 	beq	2e4c <fat16_get_dir_entry_of_path+0x110>
    2dac:	e1a00004 	mov	r0, r4
    2db0:	e3a0102f 	mov	r1, #47	; 0x2f
    2db4:	eb0009c5 	bl	54d0 <strchr>
    2db8:	e2508000 	subs	r8, r0, #0	; 0x0
    2dbc:	1a000002 	bne	2dcc <fat16_get_dir_entry_of_path+0x90>
    2dc0:	e1a00004 	mov	r0, r4
    2dc4:	eb0009d9 	bl	5530 <strlen>
    2dc8:	e0848000 	add	r8, r4, r0
    2dcc:	e0643008 	rsb	r3, r4, r8
    2dd0:	e20360ff 	and	r6, r3, #255	; 0xff
    2dd4:	ea000013 	b	2e28 <fat16_get_dir_entry_of_path+0xec>
    2dd8:	eb0009d4 	bl	5530 <strlen>
    2ddc:	e1500006 	cmp	r0, r6
    2de0:	e1a01005 	mov	r1, r5
    2de4:	e1a02006 	mov	r2, r6
    2de8:	e1a00004 	mov	r0, r4
    2dec:	1a00000d 	bne	2e28 <fat16_get_dir_entry_of_path+0xec>
    2df0:	eb0009d6 	bl	5550 <strncmp>
    2df4:	e250a000 	subs	sl, r0, #0	; 0x0
    2df8:	1a00000a 	bne	2e28 <fat16_get_dir_entry_of_path+0xec>
    2dfc:	e1a00007 	mov	r0, r7
    2e00:	ebffff6d 	bl	2bbc <fat16_close_dir>
    2e04:	e7d43006 	ldrb	r3, [r4, r6]
    2e08:	e3530000 	cmp	r3, #0	; 0x0
    2e0c:	0a000010 	beq	2e54 <fat16_get_dir_entry_of_path+0x118>
    2e10:	e5d53020 	ldrb	r3, [r5, #32]
    2e14:	e3130010 	tst	r3, #16	; 0x10
    2e18:	0a00000b 	beq	2e4c <fat16_get_dir_entry_of_path+0x110>
    2e1c:	e2884001 	add	r4, r8, #1	; 0x1
    2e20:	e1a0700a 	mov	r7, sl
    2e24:	ea000005 	b	2e40 <fat16_get_dir_entry_of_path+0x104>
    2e28:	e1a01005 	mov	r1, r5
    2e2c:	e1a00007 	mov	r0, r7
    2e30:	ebfffd0c 	bl	2268 <fat16_read_dir>
    2e34:	e3500000 	cmp	r0, #0	; 0x0
    2e38:	e1a00005 	mov	r0, r5
    2e3c:	1affffe5 	bne	2dd8 <fat16_get_dir_entry_of_path+0x9c>
    2e40:	e1a00007 	mov	r0, r7
    2e44:	ebffff5c 	bl	2bbc <fat16_close_dir>
    2e48:	eaffffd2 	b	2d98 <fat16_get_dir_entry_of_path+0x5c>
    2e4c:	e3a00000 	mov	r0, #0	; 0x0
    2e50:	ea000000 	b	2e58 <fat16_get_dir_entry_of_path+0x11c>
    2e54:	e3a00001 	mov	r0, #1	; 0x1
    2e58:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2e5c:	e12fff1e 	bx	lr

00002e60 <fat16_open>:
    2e60:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2e64:	e2508000 	subs	r8, r0, #0	; 0x0
    2e68:	e24dd03c 	sub	sp, sp, #60	; 0x3c
    2e6c:	0a000071 	beq	3038 <fat16_open+0x1d8>
    2e70:	e5983008 	ldr	r3, [r8, #8]
    2e74:	e3530000 	cmp	r3, #0	; 0x0
    2e78:	0a00006e 	beq	3038 <fat16_open+0x1d8>
    2e7c:	e3a0001c 	mov	r0, #28	; 0x1c
    2e80:	eb0007d7 	bl	4de4 <malloc>
    2e84:	e250b000 	subs	fp, r0, #0	; 0x0
    2e88:	1a000003 	bne	2e9c <fat16_open+0x3c>
    2e8c:	e59f01b8 	ldr	r0, [pc, #440]	; 304c <.text+0x304c>
    2e90:	ebfff550 	bl	3d8 <rprintf>
    2e94:	e1a0a00b 	mov	sl, fp
    2e98:	ea000067 	b	303c <fat16_open+0x1dc>
    2e9c:	e3a01000 	mov	r1, #0	; 0x0
    2ea0:	e3a0201c 	mov	r2, #28	; 0x1c
    2ea4:	eb000980 	bl	54ac <memset>
    2ea8:	e5983010 	ldr	r3, [r8, #16]
    2eac:	e1a03483 	mov	r3, r3, lsl #9
    2eb0:	e58d3008 	str	r3, [sp, #8]
    2eb4:	e58b8000 	str	r8, [fp]
    2eb8:	e283000b 	add	r0, r3, #11	; 0xb
    2ebc:	e28d1023 	add	r1, sp, #35	; 0x23
    2ec0:	e3a02019 	mov	r2, #25	; 0x19
    2ec4:	e598c000 	ldr	ip, [r8]
    2ec8:	e1a0e00f 	mov	lr, pc
    2ecc:	e12fff1c 	bx	ip
    2ed0:	e3500000 	cmp	r0, #0	; 0x0
    2ed4:	e1a0a00b 	mov	sl, fp
    2ed8:	0a000052 	beq	3028 <fat16_open+0x1c8>
    2edc:	e5dd202e 	ldrb	r2, [sp, #46]
    2ee0:	e5dd302f 	ldrb	r3, [sp, #47]
    2ee4:	e1923403 	orrs	r3, r2, r3, lsl #8
    2ee8:	e5dd0023 	ldrb	r0, [sp, #35]
    2eec:	e5dd2024 	ldrb	r2, [sp, #36]
    2ef0:	e58d3010 	str	r3, [sp, #16]
    2ef4:	e5dd6026 	ldrb	r6, [sp, #38]
    2ef8:	e5dd3025 	ldrb	r3, [sp, #37]
    2efc:	e58d001c 	str	r0, [sp, #28]
    2f00:	e58d2018 	str	r2, [sp, #24]
    2f04:	e58d3004 	str	r3, [sp, #4]
    2f08:	e58d6014 	str	r6, [sp, #20]
    2f0c:	e5dd1027 	ldrb	r1, [sp, #39]
    2f10:	e5dd9028 	ldrb	r9, [sp, #40]
    2f14:	e5dd7029 	ldrb	r7, [sp, #41]
    2f18:	e5dd502a 	ldrb	r5, [sp, #42]
    2f1c:	e5dd402b 	ldrb	r4, [sp, #43]
    2f20:	e5dde02c 	ldrb	lr, [sp, #44]
    2f24:	e5ddc038 	ldrb	ip, [sp, #56]
    2f28:	e5dd2039 	ldrb	r2, [sp, #57]
    2f2c:	e5dd303a 	ldrb	r3, [sp, #58]
    2f30:	e5dd003b 	ldrb	r0, [sp, #59]
    2f34:	0a00003b 	beq	3028 <fat16_open+0x1c8>
    2f38:	e1a03803 	mov	r3, r3, lsl #16
    2f3c:	e18c2402 	orr	r2, ip, r2, lsl #8
    2f40:	e1833c00 	orr	r3, r3, r0, lsl #24
    2f44:	e1926003 	orrs	r6, r2, r3
    2f48:	1a000002 	bne	2f58 <fat16_open+0xf8>
    2f4c:	e194240e 	orrs	r2, r4, lr, lsl #8
    2f50:	0a000034 	beq	3028 <fat16_open+0x1c8>
    2f54:	e1a06002 	mov	r6, r2
    2f58:	e59d0010 	ldr	r0, [sp, #16]
    2f5c:	e0000099 	mul	r0, r9, r0
    2f60:	e59d201c 	ldr	r2, [sp, #28]
    2f64:	e58d000c 	str	r0, [sp, #12]
    2f68:	e59d0018 	ldr	r0, [sp, #24]
    2f6c:	e1873405 	orr	r3, r7, r5, lsl #8
    2f70:	e1825400 	orr	r5, r2, r0, lsl #8
    2f74:	e59d2014 	ldr	r2, [sp, #20]
    2f78:	e1a03283 	mov	r3, r3, lsl #5
    2f7c:	e1829401 	orr	r9, r2, r1, lsl #8
    2f80:	e58d3000 	str	r3, [sp]
    2f84:	e0830005 	add	r0, r3, r5
    2f88:	e59d300c 	ldr	r3, [sp, #12]
    2f8c:	e1a01005 	mov	r1, r5
    2f90:	e2400001 	sub	r0, r0, #1	; 0x1
    2f94:	e0694006 	rsb	r4, r9, r6
    2f98:	e0634004 	rsb	r4, r3, r4
    2f9c:	eb000ac1 	bl	5aa8 <__aeabi_idiv>
    2fa0:	e59d1004 	ldr	r1, [sp, #4]
    2fa4:	e0600004 	rsb	r0, r0, r4
    2fa8:	eb000a79 	bl	5994 <__aeabi_uidiv>
    2fac:	e2403eff 	sub	r3, r0, #4080	; 0xff0
    2fb0:	e2433005 	sub	r3, r3, #5	; 0x5
    2fb4:	e3530a0f 	cmp	r3, #61440	; 0xf000
    2fb8:	e1a07000 	mov	r7, r0
    2fbc:	2a000019 	bcs	3028 <fat16_open+0x1c8>
    2fc0:	e28a4004 	add	r4, sl, #4	; 0x4
    2fc4:	e3a03006 	mov	r3, #6	; 0x6
    2fc8:	e5c8300c 	strb	r3, [r8, #12]
    2fcc:	e3a01000 	mov	r1, #0	; 0x0
    2fd0:	e3a02018 	mov	r2, #24	; 0x18
    2fd4:	e1a00004 	mov	r0, r4
    2fd8:	eb000933 	bl	54ac <memset>
    2fdc:	e59dc008 	ldr	ip, [sp, #8]
    2fe0:	e02cc995 	mla	ip, r5, r9, ip
    2fe4:	e59de00c 	ldr	lr, [sp, #12]
    2fe8:	e59d0004 	ldr	r0, [sp, #4]
    2fec:	e02ece95 	mla	lr, r5, lr, ip
    2ff0:	e0010695 	mul	r1, r5, r6
    2ff4:	e0000095 	mul	r0, r5, r0
    2ff8:	e59d6000 	ldr	r6, [sp]
    2ffc:	e1a03087 	mov	r3, r7, lsl #1
    3000:	e08e2006 	add	r2, lr, r6
    3004:	e2833004 	add	r3, r3, #4	; 0x4
    3008:	e5842014 	str	r2, [r4, #20]
    300c:	e58a1004 	str	r1, [sl, #4]
    3010:	e5843008 	str	r3, [r4, #8]
    3014:	e1c400be 	strh	r0, [r4, #14]
    3018:	e584c004 	str	ip, [r4, #4]
    301c:	e1c450bc 	strh	r5, [r4, #12]
    3020:	e584e010 	str	lr, [r4, #16]
    3024:	ea000004 	b	303c <fat16_open+0x1dc>
    3028:	e59f0020 	ldr	r0, [pc, #32]	; 3050 <.text+0x3050>
    302c:	ebfff4e9 	bl	3d8 <rprintf>
    3030:	e1a0000b 	mov	r0, fp
    3034:	eb000762 	bl	4dc4 <free>
    3038:	e3a0a000 	mov	sl, #0	; 0x0
    303c:	e1a0000a 	mov	r0, sl
    3040:	e28dd03c 	add	sp, sp, #60	; 0x3c
    3044:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3048:	e12fff1e 	bx	lr
    304c:	00005f38 	andeq	r5, r0, r8, lsr pc
    3050:	00005f48 	andeq	r5, r0, r8, asr #30

00003054 <fat16_create_file>:
    3054:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3058:	e2706001 	rsbs	r6, r0, #1	; 0x1
    305c:	33a06000 	movcc	r6, #0	; 0x0
    3060:	e3500000 	cmp	r0, #0	; 0x0
    3064:	13510000 	cmpne	r1, #0	; 0x0
    3068:	e24dd004 	sub	sp, sp, #4	; 0x4
    306c:	e1a05000 	mov	r5, r0
    3070:	e1a04001 	mov	r4, r1
    3074:	e1a08002 	mov	r8, r2
    3078:	0a000065 	beq	3214 <fat16_create_file+0x1c0>
    307c:	e5d13000 	ldrb	r3, [r1]
    3080:	e3530000 	cmp	r3, #0	; 0x0
    3084:	0a000062 	beq	3214 <fat16_create_file+0x1c0>
    3088:	e1a01008 	mov	r1, r8
    308c:	e1a00005 	mov	r0, r5
    3090:	ebfffc74 	bl	2268 <fat16_read_dir>
    3094:	e250a000 	subs	sl, r0, #0	; 0x0
    3098:	e1a01008 	mov	r1, r8
    309c:	e1a00004 	mov	r0, r4
    30a0:	0a000007 	beq	30c4 <fat16_create_file+0x70>
    30a4:	eb000915 	bl	5500 <strcmp>
    30a8:	e3500000 	cmp	r0, #0	; 0x0
    30ac:	1afffff5 	bne	3088 <fat16_create_file+0x34>
    30b0:	e3560000 	cmp	r6, #0	; 0x0
    30b4:	12800001 	addne	r0, r0, #1	; 0x1
    30b8:	03a00001 	moveq	r0, #1	; 0x1
    30bc:	01c563b0 	streqh	r6, [r5, #48]
    30c0:	ea000054 	b	3218 <fat16_create_file+0x1c4>
    30c4:	e1a0100a 	mov	r1, sl
    30c8:	e3a0202c 	mov	r2, #44	; 0x2c
    30cc:	e1a00008 	mov	r0, r8
    30d0:	eb0008f5 	bl	54ac <memset>
    30d4:	e1a01004 	mov	r1, r4
    30d8:	e3a0201f 	mov	r2, #31	; 0x1f
    30dc:	e1a00008 	mov	r0, r8
    30e0:	eb00092e 	bl	55a0 <strncpy>
    30e4:	e1a00004 	mov	r0, r4
    30e8:	eb000910 	bl	5530 <strlen>
    30ec:	e3a0100d 	mov	r1, #13	; 0xd
    30f0:	eb000a27 	bl	5994 <__aeabi_uidiv>
    30f4:	e1d572b6 	ldrh	r7, [r5, #38]
    30f8:	e5955000 	ldr	r5, [r5]
    30fc:	e3570000 	cmp	r7, #0	; 0x0
    3100:	05954014 	ldreq	r4, [r5, #20]
    3104:	11a0600a 	movne	r6, sl
    3108:	e2800002 	add	r0, r0, #2	; 0x2
    310c:	0595a018 	ldreq	sl, [r5, #24]
    3110:	e200b0ff 	and	fp, r0, #255	; 0xff
    3114:	11a04006 	movne	r4, r6
    3118:	11a0a006 	movne	sl, r6
    311c:	01a06004 	moveq	r6, r4
    3120:	e3a09000 	mov	r9, #0	; 0x0
    3124:	e154000a 	cmp	r4, sl
    3128:	1a00001b 	bne	319c <fat16_create_file+0x148>
    312c:	e3570000 	cmp	r7, #0	; 0x0
    3130:	0a000037 	beq	3214 <fat16_create_file+0x1c0>
    3134:	e3540000 	cmp	r4, #0	; 0x0
    3138:	0a000010 	beq	3180 <fat16_create_file+0x12c>
    313c:	e1a00005 	mov	r0, r5
    3140:	e1a01007 	mov	r1, r7
    3144:	ebfffaa6 	bl	1be4 <fat16_get_next_cluster>
    3148:	e3500000 	cmp	r0, #0	; 0x0
    314c:	1a00000a 	bne	317c <fat16_create_file+0x128>
    3150:	e1a01007 	mov	r1, r7
    3154:	e1a00005 	mov	r0, r5
    3158:	e3a02001 	mov	r2, #1	; 0x1
    315c:	ebfffb00 	bl	1d64 <fat16_append_clusters>
    3160:	e3500000 	cmp	r0, #0	; 0x0
    3164:	0a00002a 	beq	3214 <fat16_create_file+0x1c0>
    3168:	e1d511b2 	ldrh	r1, [r5, #18]
    316c:	e5952018 	ldr	r2, [r5, #24]
    3170:	e2403002 	sub	r3, r0, #2	; 0x2
    3174:	e0262391 	mla	r6, r1, r3, r2
    3178:	ea00001e 	b	31f8 <fat16_create_file+0x1a4>
    317c:	e1a07000 	mov	r7, r0
    3180:	e1d511b2 	ldrh	r1, [r5, #18]
    3184:	e5952018 	ldr	r2, [r5, #24]
    3188:	e2473002 	sub	r3, r7, #2	; 0x2
    318c:	e0242391 	mla	r4, r1, r3, r2
    3190:	e3a09000 	mov	r9, #0	; 0x0
    3194:	e084a001 	add	sl, r4, r1
    3198:	e1a06004 	mov	r6, r4
    319c:	e5953000 	ldr	r3, [r5]
    31a0:	e1a00004 	mov	r0, r4
    31a4:	e28d1003 	add	r1, sp, #3	; 0x3
    31a8:	e3a02001 	mov	r2, #1	; 0x1
    31ac:	e593c000 	ldr	ip, [r3]
    31b0:	e1a0e00f 	mov	lr, pc
    31b4:	e12fff1c 	bx	ip
    31b8:	e3500000 	cmp	r0, #0	; 0x0
    31bc:	0a000014 	beq	3214 <fat16_create_file+0x1c0>
    31c0:	e5dd3003 	ldrb	r3, [sp, #3]
    31c4:	e3530000 	cmp	r3, #0	; 0x0
    31c8:	135300e5 	cmpne	r3, #229	; 0xe5
    31cc:	13a03000 	movne	r3, #0	; 0x0
    31d0:	03a03001 	moveq	r3, #1	; 0x1
    31d4:	12846020 	addne	r6, r4, #32	; 0x20
    31d8:	11a09003 	movne	r9, r3
    31dc:	11a04006 	movne	r4, r6
    31e0:	1affffcf 	bne	3124 <fat16_create_file+0xd0>
    31e4:	e2893001 	add	r3, r9, #1	; 0x1
    31e8:	e20390ff 	and	r9, r3, #255	; 0xff
    31ec:	e159000b 	cmp	r9, fp
    31f0:	32844020 	addcc	r4, r4, #32	; 0x20
    31f4:	3affffca 	bcc	3124 <fat16_create_file+0xd0>
    31f8:	e5886028 	str	r6, [r8, #40]
    31fc:	e1a00005 	mov	r0, r5
    3200:	e1a01008 	mov	r1, r8
    3204:	ebfffcb4 	bl	24dc <fat16_write_dir_entry>
    3208:	e2500000 	subs	r0, r0, #0	; 0x0
    320c:	13a00001 	movne	r0, #1	; 0x1
    3210:	ea000000 	b	3218 <fat16_create_file+0x1c4>
    3214:	e3a00000 	mov	r0, #0	; 0x0
    3218:	e28dd004 	add	sp, sp, #4	; 0x4
    321c:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3220:	e12fff1e 	bx	lr

00003224 <partition_close>:
 * \see partition_open
 */
uint8_t partition_close(struct partition_struct* partition)
{
    if(!partition)
    3224:	e2503000 	subs	r3, r0, #0	; 0x0
    3228:	e52de004 	str	lr, [sp, #-4]!
    322c:	0a000001 	beq	3238 <partition_close+0x14>
        return 0;

    /* destroy partition descriptor */
    free(partition);
    3230:	eb0006e3 	bl	4dc4 <free>
    3234:	e3a03001 	mov	r3, #1	; 0x1

    return 1;
}
    3238:	e1a00003 	mov	r0, r3
    323c:	e49de004 	ldr	lr, [sp], #4
    3240:	e12fff1e 	bx	lr

00003244 <partition_open>:
    3244:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3248:	e3510000 	cmp	r1, #0	; 0x0
    324c:	13500000 	cmpne	r0, #0	; 0x0
    3250:	e24dd010 	sub	sp, sp, #16	; 0x10
    3254:	e1a06000 	mov	r6, r0
    3258:	e1a07001 	mov	r7, r1
    325c:	13a04000 	movne	r4, #0	; 0x0
    3260:	03a04001 	moveq	r4, #1	; 0x1
    3264:	e1a08002 	mov	r8, r2
    3268:	e20330ff 	and	r3, r3, #255	; 0xff
    326c:	0a000033 	beq	3340 <partition_open+0xfc>
    3270:	e1a03c03 	mov	r3, r3, lsl #24
    3274:	e1a05c43 	mov	r5, r3, asr #24
    3278:	e3550003 	cmp	r5, #3	; 0x3
    327c:	ca00002f 	bgt	3340 <partition_open+0xfc>
    3280:	e3550000 	cmp	r5, #0	; 0x0
    3284:	ba00000b 	blt	32b8 <partition_open+0x74>
    3288:	e1a00205 	mov	r0, r5, lsl #4
    328c:	e2800f6f 	add	r0, r0, #444	; 0x1bc
    3290:	e2800002 	add	r0, r0, #2	; 0x2
    3294:	e1a0100d 	mov	r1, sp
    3298:	e3a02010 	mov	r2, #16	; 0x10
    329c:	e1a0e00f 	mov	lr, pc
    32a0:	e12fff16 	bx	r6
    32a4:	e3500000 	cmp	r0, #0	; 0x0
    32a8:	0a000024 	beq	3340 <partition_open+0xfc>
    32ac:	e5dd3004 	ldrb	r3, [sp, #4]
    32b0:	e3530000 	cmp	r3, #0	; 0x0
    32b4:	0a000021 	beq	3340 <partition_open+0xfc>
    32b8:	e3a00018 	mov	r0, #24	; 0x18
    32bc:	eb0006c8 	bl	4de4 <malloc>
    32c0:	e2503000 	subs	r3, r0, #0	; 0x0
    32c4:	0a00001d 	beq	3340 <partition_open+0xfc>
    32c8:	e1a01004 	mov	r1, r4
    32cc:	e3a02018 	mov	r2, #24	; 0x18
    32d0:	e1a04003 	mov	r4, r3
    32d4:	eb000874 	bl	54ac <memset>
    32d8:	e3550000 	cmp	r5, #0	; 0x0
    32dc:	b3e03000 	mvnlt	r3, #0	; 0x0
    32e0:	e88401c0 	stmia	r4, {r6, r7, r8}
    32e4:	b5c4300c 	strltb	r3, [r4, #12]
    32e8:	ba000015 	blt	3344 <partition_open+0x100>
    32ec:	e5dd3004 	ldrb	r3, [sp, #4]
    32f0:	e5c4300c 	strb	r3, [r4, #12]
    32f4:	e5dd300a 	ldrb	r3, [sp, #10]
    32f8:	e5dd1009 	ldrb	r1, [sp, #9]
    32fc:	e5dd000b 	ldrb	r0, [sp, #11]
    3300:	e5dd2008 	ldrb	r2, [sp, #8]
    3304:	e1a03803 	mov	r3, r3, lsl #16
    3308:	e1833c00 	orr	r3, r3, r0, lsl #24
    330c:	e1822401 	orr	r2, r2, r1, lsl #8
    3310:	e1822003 	orr	r2, r2, r3
    3314:	e5842010 	str	r2, [r4, #16]
    3318:	e5dd300e 	ldrb	r3, [sp, #14]
    331c:	e5dd200c 	ldrb	r2, [sp, #12]
    3320:	e5dd100d 	ldrb	r1, [sp, #13]
    3324:	e5dd000f 	ldrb	r0, [sp, #15]
    3328:	e1a03803 	mov	r3, r3, lsl #16
    332c:	e1822401 	orr	r2, r2, r1, lsl #8
    3330:	e1833c00 	orr	r3, r3, r0, lsl #24
    3334:	e1822003 	orr	r2, r2, r3
    3338:	e5842014 	str	r2, [r4, #20]
    333c:	ea000000 	b	3344 <partition_open+0x100>
    3340:	e3a04000 	mov	r4, #0	; 0x0
    3344:	e1a00004 	mov	r0, r4
    3348:	e28dd010 	add	sp, sp, #16	; 0x10
    334c:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    3350:	e12fff1e 	bx	lr

00003354 <main_msc>:
    msc_main
    ====
**************************************************************************/
int main_msc(void)
{
    3354:	e52de004 	str	lr, [sp, #-4]!
    // initialise the SD card
    BlockDevInit();
    3358:	eb0002e9 	bl	3f04 <BlockDevInit>

    rprintf("Initialising USB stack\n");
    335c:	e59f006c 	ldr	r0, [pc, #108]	; 33d0 <.text+0x33d0>
    3360:	ebfff41c 	bl	3d8 <rprintf>

    // initialise stack
    USBInit();
    3364:	eb0003d9 	bl	42d0 <USBInit>

    // enable bulk-in interrupts on NAKs
    // these are required to get the BOT protocol going again after a STALL
    USBHwNakIntEnable(INACK_BI);
    3368:	e3a00020 	mov	r0, #32	; 0x20
    336c:	eb00046b 	bl	4520 <USBHwNakIntEnable>

    // register descriptors
    USBRegisterDescriptors(abDescriptors);
    3370:	e59f005c 	ldr	r0, [pc, #92]	; 33d4 <.text+0x33d4>
    3374:	eb0005cb 	bl	4aa8 <USBRegisterDescriptors>

    // register class request handler
    USBRegisterRequestHandler(REQTYPE_TYPE_CLASS, HandleClassRequest, abClassReqData);
    3378:	e59f2058 	ldr	r2, [pc, #88]	; 33d8 <.text+0x33d8>
    337c:	e3a00001 	mov	r0, #1	; 0x1
    3380:	e59f1054 	ldr	r1, [pc, #84]	; 33dc <.text+0x33dc>
    3384:	eb000553 	bl	48d8 <USBRegisterRequestHandler>

    // register endpoint handlers
    USBHwRegisterEPIntHandler(MSC_BULK_IN_EP, MSCBotBulkIn);
    3388:	e3a00085 	mov	r0, #133	; 0x85
    338c:	e59f104c 	ldr	r1, [pc, #76]	; 33e0 <.text+0x33e0>
    3390:	eb000435 	bl	446c <USBHwRegisterEPIntHandler>
    USBHwRegisterEPIntHandler(MSC_BULK_OUT_EP, MSCBotBulkOut);
    3394:	e59f1048 	ldr	r1, [pc, #72]	; 33e4 <.text+0x33e4>
    3398:	e3a00002 	mov	r0, #2	; 0x2
    339c:	eb000432 	bl	446c <USBHwRegisterEPIntHandler>

    rprintf("Starting USB communication\n");
    33a0:	e59f0040 	ldr	r0, [pc, #64]	; 33e8 <.text+0x33e8>
    33a4:	ebfff40b 	bl	3d8 <rprintf>
	
    // connect to bus
    USBHwConnect(TRUE);
    33a8:	e3a00001 	mov	r0, #1	; 0x1
    33ac:	eb000457 	bl	4510 <USBHwConnect>
    33b0:	ea000000 	b	33b8 <main_msc+0x64>

    // call USB interrupt handler continuously
    while (IOPIN0 & (1<<23))
	{
		USBHwISR();
    33b4:	eb0004bc 	bl	46ac <USBHwISR>
    33b8:	e59f302c 	ldr	r3, [pc, #44]	; 33ec <.text+0x33ec>
    33bc:	e5933000 	ldr	r3, [r3]
    33c0:	e2130502 	ands	r0, r3, #8388608	; 0x800000
    33c4:	1afffffa 	bne	33b4 <main_msc+0x60>
    }

    return 0;
}
    33c8:	e49de004 	ldr	lr, [sp], #4
    33cc:	e12fff1e 	bx	lr
    33d0:	00005f60 	andeq	r5, r0, r0, ror #30
    33d4:	40000240 	andmi	r0, r0, r0, asr #4
    33d8:	40000ce0 	andmi	r0, r0, r0, ror #25
    33dc:	000033f0 	streqd	r3, [r0], -r0
    33e0:	000035b0 	streqh	r3, [r0], -r0
    33e4:	00003614 	andeq	r3, r0, r4, lsl r6
    33e8:	00005f78 	andeq	r5, r0, r8, ror pc
    33ec:	e0028000 	and	r8, r2, r0

000033f0 <HandleClassRequest>:
    33f0:	e1d030b4 	ldrh	r3, [r0, #4]
    33f4:	e3530000 	cmp	r3, #0	; 0x0
    33f8:	e92d4010 	stmdb	sp!, {r4, lr}
    33fc:	e1a03002 	mov	r3, r2
    3400:	e1a04001 	mov	r4, r1
    3404:	1a000012 	bne	3454 <HandleClassRequest+0x64>
    3408:	e1d0e0b2 	ldrh	lr, [r0, #2]
    340c:	e35e0000 	cmp	lr, #0	; 0x0
    3410:	1a00000f 	bne	3454 <HandleClassRequest+0x64>
    3414:	e5d0c001 	ldrb	ip, [r0, #1]
    3418:	e35c00fe 	cmp	ip, #254	; 0xfe
    341c:	05933000 	ldreq	r3, [r3]
    3420:	e3a02001 	mov	r2, #1	; 0x1
    3424:	05c3e000 	streqb	lr, [r3]
    3428:	e1a01002 	mov	r1, r2
    342c:	05842000 	streq	r2, [r4]
    3430:	0a000008 	beq	3458 <HandleClassRequest+0x68>
    3434:	e35c00ff 	cmp	ip, #255	; 0xff
    3438:	1a000005 	bne	3454 <HandleClassRequest+0x64>
    343c:	e1d030b6 	ldrh	r3, [r0, #6]
    3440:	e3530000 	cmp	r3, #0	; 0x0
    3444:	1a000002 	bne	3454 <HandleClassRequest+0x64>
    3448:	eb000103 	bl	385c <MSCBotReset>
    344c:	e3a01001 	mov	r1, #1	; 0x1
    3450:	ea000000 	b	3458 <HandleClassRequest+0x68>
    3454:	e3a01000 	mov	r1, #0	; 0x0
    3458:	e1a00001 	mov	r0, r1
    345c:	e8bd4010 	ldmia	sp!, {r4, lr}
    3460:	e12fff1e 	bx	lr

00003464 <SendCSW>:
static void SendCSW(U8 bStatus)
{
    int iResidue;

    iResidue = CBW.dwCBWDataTransferLength - dwTransferSize;
    3464:	e59f203c 	ldr	r2, [pc, #60]	; 34a8 <.text+0x34a8>
    3468:	e59f303c 	ldr	r3, [pc, #60]	; 34ac <.text+0x34ac>
    346c:	e5921008 	ldr	r1, [r2, #8]
    3470:	e5933000 	ldr	r3, [r3]

    // construct CSW
    CSW.dwCSWSignature      = CSW_SIGNATURE;
    CSW.dwCSWTag            = CBW.dwCBWTag;
    3474:	e592c004 	ldr	ip, [r2, #4]
    3478:	e59f2030 	ldr	r2, [pc, #48]	; 34b0 <.text+0x34b0>
    347c:	e0631001 	rsb	r1, r3, r1
    CSW.dwCSWDataResidue    = MAX(iResidue, 0);
    CSW.bmCSWStatus         = bStatus;

    DBG("CSW: status=%x, residue=%d\n", bStatus, CSW.dwCSWDataResidue);

    // next state
    eState = eCSW;
    3480:	e59f302c 	ldr	r3, [pc, #44]	; 34b4 <.text+0x34b4>
    3484:	e5c2000c 	strb	r0, [r2, #12]
    3488:	e3a00003 	mov	r0, #3	; 0x3
    348c:	e5830000 	str	r0, [r3]
    3490:	e59f3020 	ldr	r3, [pc, #32]	; 34b8 <.text+0x34b8>
    3494:	e3510000 	cmp	r1, #0	; 0x0
    3498:	b3a01000 	movlt	r1, #0	; 0x0
    349c:	e8821008 	stmia	r2, {r3, ip}
    34a0:	e5821008 	str	r1, [r2, #8]
}
    34a4:	e12fff1e 	bx	lr
    34a8:	40000cec 	andmi	r0, r0, ip, ror #25
    34ac:	40000ce4 	andmi	r0, r0, r4, ror #25
    34b0:	40000d0c 	andmi	r0, r0, ip, lsl #26
    34b4:	40000d1c 	andmi	r0, r0, ip, lsl sp
    34b8:	53425355 	movtpl	r5, #9045	; 0x2355

000034bc <BOTStall>:


/*************************************************************************
    CheckCBW
    ========
        Checks if CBW is valid and meaningful

    IN      pCBW    Command block wrapper
            iLen    Length of CBW

    Returns TRUE if valid and meaningful
**************************************************************************/
static BOOL CheckCBW(TCBW *pCBW, int iLen)
{
    // CBW valid?
    if (iLen != 31)
    {
        DBG("Invalid length (%d)\n", iLen);
        return FALSE;
    }
    if (pCBW->dwCBWSignature != CBW_SIGNATURE)
    {
        DBG("Invalid signature %x\n", pCBW->dwCBWSignature);
        return FALSE;
    }

    // CBW meaningful?
    if (pCBW->bCBWLun != 0)
    {
        DBG("Invalid LUN %d\n", pCBW->bCBWLun);
        return FALSE;
    }
    if ((pCBW->bCBWCBLength < 1) || (pCBW->bCBWCBLength > 16))
    {
        DBG("Invalid CB len %d\n", pCBW->bCBWCBLength);
        return FALSE;
    }
    return TRUE;
}


/*************************************************************************
    BOTStall
    ========
        Local function to stall ongoing transfer

    Which endpoint to stall is determined by looking at the transfer
    direction intended by the host.

**************************************************************************/
static void BOTStall(void)
{
    34bc:	e52de004 	str	lr, [sp, #-4]!
    if ((CBW.bmCBWFlags & 0x80) || (CBW.dwCBWDataTransferLength == 0))
    34c0:	e59f202c 	ldr	r2, [pc, #44]	; 34f4 <.text+0x34f4>
    34c4:	e1d230dc 	ldrsb	r3, [r2, #12]
    34c8:	e3530000 	cmp	r3, #0	; 0x0
    {
        // stall data-in or CSW
        USBHwEPStall(MSC_BULK_IN_EP, TRUE);
    34cc:	e3a00085 	mov	r0, #133	; 0x85
    34d0:	e3a01001 	mov	r1, #1	; 0x1
    34d4:	ba000003 	blt	34e8 <BOTStall+0x2c>
    34d8:	e5923008 	ldr	r3, [r2, #8]
    34dc:	e3530000 	cmp	r3, #0	; 0x0
    }
    else
    {
        // stall data-out
        USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
    34e0:	13a00002 	movne	r0, #2	; 0x2
    34e4:	13a01001 	movne	r1, #1	; 0x1
    34e8:	eb000418 	bl	4550 <USBHwEPStall>
    }
}
    34ec:	e49de004 	ldr	lr, [sp], #4
    34f0:	e12fff1e 	bx	lr
    34f4:	40000cec 	andmi	r0, r0, ip, ror #25

000034f8 <HandleDataIn>:


/*************************************************************************
    HandleDataIn
    ============
        Handles data from device-to-host

**************************************************************************/
static void HandleDataIn(void)
{
    34f8:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    int iChunk;

    // process data for host in SCSI layer
    pbData = SCSIHandleData(CBW.CBWCB, CBW.bCBWCBLength, pbData, dwOffset);
    34fc:	e59f609c 	ldr	r6, [pc, #156]	; 35a0 <.text+0x35a0>
    3500:	e59f409c 	ldr	r4, [pc, #156]	; 35a4 <.text+0x35a4>
    3504:	e59f509c 	ldr	r5, [pc, #156]	; 35a8 <.text+0x35a8>
    3508:	e5d6100e 	ldrb	r1, [r6, #14]
    350c:	e5942000 	ldr	r2, [r4]
    3510:	e5953000 	ldr	r3, [r5]
    3514:	e286000f 	add	r0, r6, #15	; 0xf
    3518:	eb000129 	bl	39c4 <SCSIHandleData>
    if (pbData == NULL)
    351c:	e3500000 	cmp	r0, #0	; 0x0
    {
        BOTStall();
        SendCSW(STATUS_FAILED);
        return;
    }

    // send data to host?
    if (dwOffset < dwTransferSize)
    3520:	e59f7084 	ldr	r7, [pc, #132]	; 35ac <.text+0x35ac>
    3524:	e5840000 	str	r0, [r4]
    3528:	1a000002 	bne	3538 <HandleDataIn+0x40>
    352c:	ebffffe2 	bl	34bc <BOTStall>
    3530:	e3a00001 	mov	r0, #1	; 0x1
    3534:	ea000015 	b	3590 <HandleDataIn+0x98>
    3538:	e5952000 	ldr	r2, [r5]
    353c:	e5973000 	ldr	r3, [r7]
    3540:	e1520003 	cmp	r2, r3
    {
        iChunk = MIN(64, dwTransferSize - dwOffset);
        USBHwEPWrite(MSC_BULK_IN_EP, pbData, iChunk);
    3544:	e1a01000 	mov	r1, r0
    3548:	e0624003 	rsb	r4, r2, r3
    354c:	e3a00085 	mov	r0, #133	; 0x85
    3550:	2a000006 	bcs	3570 <HandleDataIn+0x78>
    3554:	e3540040 	cmp	r4, #64	; 0x40
    3558:	23a04040 	movcs	r4, #64	; 0x40
    355c:	e1a02004 	mov	r2, r4
    3560:	eb000402 	bl	4570 <USBHwEPWrite>
        dwOffset += iChunk;
    3564:	e5953000 	ldr	r3, [r5]
    3568:	e0833004 	add	r3, r3, r4
    356c:	e5853000 	str	r3, [r5]
    }

    // are we done now?
    if (dwOffset == dwTransferSize)
    3570:	e5952000 	ldr	r2, [r5]
    3574:	e5973000 	ldr	r3, [r7]
    3578:	e1520003 	cmp	r2, r3
    357c:	1a000005 	bne	3598 <HandleDataIn+0xa0>
    {
        if (dwOffset != CBW.dwCBWDataTransferLength)
    3580:	e5963008 	ldr	r3, [r6, #8]
    3584:	e1520003 	cmp	r2, r3
        {
            // stall pipe
            DBG("stalling DIN");
            BOTStall();
    3588:	1bffffcb 	blne	34bc <BOTStall>
        }
        // done
        SendCSW(STATUS_PASSED);
    358c:	e3a00000 	mov	r0, #0	; 0x0
    }
}
    3590:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    3594:	eaffffb2 	b	3464 <SendCSW>
    3598:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    359c:	e12fff1e 	bx	lr
    35a0:	40000cec 	andmi	r0, r0, ip, ror #25
    35a4:	40000d20 	andmi	r0, r0, r0, lsr #26
    35a8:	40000ce8 	andmi	r0, r0, r8, ror #25
    35ac:	40000ce4 	andmi	r0, r0, r4, ror #25

000035b0 <MSCBotBulkIn>:


/*************************************************************************
    HandleDataOut
    =============
        Handles data from host-to-device

**************************************************************************/
static void HandleDataOut(void)
{
    int iChunk;

    if (dwOffset < dwTransferSize)
    {
        // get data from host
        iChunk = USBHwEPRead(MSC_BULK_OUT_EP, pbData, dwTransferSize - dwOffset);
        // process data in SCSI layer
        pbData = SCSIHandleData(CBW.CBWCB, CBW.bCBWCBLength, pbData, dwOffset);
        if (pbData == NULL)
        {
            BOTStall();
            SendCSW(STATUS_FAILED);
            return;
        }
        dwOffset += iChunk;
    }

    // are we done now?
    if (dwOffset == dwTransferSize)
    {
        if (dwOffset != CBW.dwCBWDataTransferLength)
        {
            // stall pipe
            DBG("stalling DOUT");
            BOTStall();
        }
        SendCSW(STATUS_PASSED);
    }
}


/*************************************************************************
    MSCBotBulkOut
    ===============
        Handles the BOT bulk OUT endpoint

    IN      bEP         Endpoint number
            bEPStatus   Endpoint status (indicates NAK, STALL, etc)

**************************************************************************/
void MSCBotBulkOut(U8 bEP, U8 bEPStatus)
{
    int     iLen, iChunk;
    BOOL    fHostIn, fDevIn;

    // ignore events on stalled EP
    if (bEPStatus & EP_STATUS_STALLED)
    {
        return;
    }

    switch (eState)
    {

        case eCBW:
            iLen = USBHwEPRead(bEP, (U8 *)&CBW, sizeof(CBW));

            // check if we got a good CBW
            if (!CheckCBW(&CBW, iLen))
            {
                // see 6.6.1
                USBHwEPStall(MSC_BULK_IN_EP, TRUE);
                USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
                eState = eStalled;
                break;
            }

            DBG("CBW: len=%d, flags=%x, cmd=%x, cmdlen=%d\n",
                    CBW.dwCBWDataTransferLength, CBW.bmCBWFlags, CBW.CBWCB[0], CBW.bCBWCBLength);

            dwOffset = 0;
            dwTransferSize = 0;
            fHostIn = ((CBW.bmCBWFlags & 0x80) != 0);

            // verify request
            pbData = SCSIHandleCmd(CBW.CBWCB, CBW.bCBWCBLength, &iLen, &fDevIn);
            if (pbData == NULL)
            {
                // unknown command
                BOTStall();
                SendCSW(STATUS_FAILED);
                break;
            }

            // rule: if device and host disagree on direction, send CSW with status 2
            if ((iLen > 0) &&
                ((fHostIn && !fDevIn) ||
                (!fHostIn && fDevIn)))
            {
                DBG("Host and device disagree on direction\n");
                BOTStall();
                SendCSW(STATUS_PHASE_ERR);
                break;
            }

            // rule: if D > H, send CSW with status 2
            if (iLen > CBW.dwCBWDataTransferLength)
            {
                DBG("Negative residue\n");
                BOTStall();
                SendCSW(STATUS_PHASE_ERR);
                break;
            }

            dwTransferSize = iLen;
            if ((dwTransferSize == 0) || fDevIn)
            {
                // data from device-to-host
                eState = eDataIn;
                HandleDataIn();
            }
            else
            {
                // data from host-to-device
                eState = eDataOut;
            }
            break;

        case eDataOut:
            HandleDataOut();
            break;

        case eDataIn:
        case eCSW:
            iChunk = USBHwEPRead(bEP, NULL, 0);
            DBG("Phase error in state %d, %d bytes\n", eState, iChunk);
            eState = eCBW;
            break;

        case eStalled:
        // keep stalling
            USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
            break;

        default:
            DBG("Invalid state %d\n", eState);
//            ASSERT(FALSE);
            break;
    }
}


/*************************************************************************
    MSCBotBulkIn
    ============
        Handles the BOT bulk IN endpoint

    IN      bEP         Endpoint number
            bEPStatus   Endpoint status (indicates NAK, STALL, etc)

**************************************************************************/
void MSCBotBulkIn(U8 bEP, U8 bEPStatus)
{
    35b0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    // ignore events on stalled EP
    if (bEPStatus & EP_STATUS_STALLED)
    35b4:	e2114002 	ands	r4, r1, #2	; 0x2
    {
        return;
    }

    switch (eState)
    35b8:	e59f504c 	ldr	r5, [pc, #76]	; 360c <.text+0x360c>
    35bc:	1a000010 	bne	3604 <MSCBotBulkIn+0x54>
    35c0:	e5953000 	ldr	r3, [r5]
    35c4:	e3530003 	cmp	r3, #3	; 0x3
    {

        case eCBW:
        case eDataOut:
        // ignore possibly old ACKs
            break;

        case eDataIn:
            HandleDataIn();
            break;

        case eCSW:
        // wait for an IN token, then send the CSW
            USBHwEPWrite(MSC_BULK_IN_EP, (U8 *)&CSW, 13);
    35c8:	e3a00085 	mov	r0, #133	; 0x85
    35cc:	e59f103c 	ldr	r1, [pc, #60]	; 3610 <.text+0x3610>
    35d0:	e3a0200d 	mov	r2, #13	; 0xd
    35d4:	0a000006 	beq	35f4 <MSCBotBulkIn+0x44>
    35d8:	e3530004 	cmp	r3, #4	; 0x4
            eState = eCBW;
            break;

        case eStalled:
        // keep stalling
            USBHwEPStall(MSC_BULK_IN_EP, TRUE);
    35dc:	e3a01001 	mov	r1, #1	; 0x1
    35e0:	0a000006 	beq	3600 <MSCBotBulkIn+0x50>
    35e4:	e3530002 	cmp	r3, #2	; 0x2
    35e8:	1a000005 	bne	3604 <MSCBotBulkIn+0x54>
            break;

        default:
            DBG("Invalid state %d\n", eState);
//            ASSERT(FALSE);
            break;
    }
}
    35ec:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    35f0:	eaffffc0 	b	34f8 <HandleDataIn>
    35f4:	eb0003dd 	bl	4570 <USBHwEPWrite>
    35f8:	e5854000 	str	r4, [r5]
    35fc:	ea000000 	b	3604 <MSCBotBulkIn+0x54>
    3600:	eb0003d2 	bl	4550 <USBHwEPStall>
    3604:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    3608:	e12fff1e 	bx	lr
    360c:	40000d1c 	andmi	r0, r0, ip, lsl sp
    3610:	40000d0c 	andmi	r0, r0, ip, lsl #26

00003614 <MSCBotBulkOut>:
    3614:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    3618:	e3110002 	tst	r1, #2	; 0x2
    361c:	e24dd008 	sub	sp, sp, #8	; 0x8
    3620:	e20000ff 	and	r0, r0, #255	; 0xff
    3624:	1a000083 	bne	3838 <.text+0x3838>
    3628:	e59f3214 	ldr	r3, [pc, #532]	; 3844 <.text+0x3844>
    362c:	e5933000 	ldr	r3, [r3]
    3630:	e3530004 	cmp	r3, #4	; 0x4
    3634:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    3638:	ea00007e 	b	3838 <.text+0x3838>
    363c:	00003650 	andeq	r3, r0, r0, asr r6
    3640:	00003738 	andeq	r3, r0, r8, lsr r7
    3644:	000037d4 	ldreqd	r3, [r0], -r4
    3648:	000037d4 	ldreqd	r3, [r0], -r4
    364c:	000037f0 	streqd	r3, [r0], -r0
    3650:	e59f41f0 	ldr	r4, [pc, #496]	; 3848 <.text+0x3848>
    3654:	e3a02020 	mov	r2, #32	; 0x20
    3658:	e1a01004 	mov	r1, r4
    365c:	eb0003e5 	bl	45f8 <USBHwEPRead>
    3660:	e350001f 	cmp	r0, #31	; 0x1f
    3664:	e58d0000 	str	r0, [sp]
    3668:	1a00000a 	bne	3698 <.text+0x3698>
    366c:	e5942000 	ldr	r2, [r4]
    3670:	e59f31d4 	ldr	r3, [pc, #468]	; 384c <.text+0x384c>
    3674:	e1520003 	cmp	r2, r3
    3678:	1a000006 	bne	3698 <.text+0x3698>
    367c:	e5d4e00d 	ldrb	lr, [r4, #13]
    3680:	e35e0000 	cmp	lr, #0	; 0x0
    3684:	1a000003 	bne	3698 <.text+0x3698>
    3688:	e5d4100e 	ldrb	r1, [r4, #14]
    368c:	e2413001 	sub	r3, r1, #1	; 0x1
    3690:	e353000f 	cmp	r3, #15	; 0xf
    3694:	9a000059 	bls	3800 <.text+0x3800>
    3698:	e3a00085 	mov	r0, #133	; 0x85
    369c:	e3a01001 	mov	r1, #1	; 0x1
    36a0:	eb0003aa 	bl	4550 <USBHwEPStall>
    36a4:	e3a00002 	mov	r0, #2	; 0x2
    36a8:	e3a01001 	mov	r1, #1	; 0x1
    36ac:	eb0003a7 	bl	4550 <USBHwEPStall>
    36b0:	e3a02004 	mov	r2, #4	; 0x4
    36b4:	ea00004a 	b	37e4 <.text+0x37e4>
    36b8:	e59d2000 	ldr	r2, [sp]
    36bc:	e3520000 	cmp	r2, #0	; 0x0
    36c0:	da00000b 	ble	36f4 <.text+0x36f4>
    36c4:	e3140080 	tst	r4, #128	; 0x80
    36c8:	e59d3004 	ldr	r3, [sp, #4]
    36cc:	0a000002 	beq	36dc <.text+0x36dc>
    36d0:	e3530000 	cmp	r3, #0	; 0x0
    36d4:	0a000002 	beq	36e4 <.text+0x36e4>
    36d8:	ea000005 	b	36f4 <.text+0x36f4>
    36dc:	e3530000 	cmp	r3, #0	; 0x0
    36e0:	0a000003 	beq	36f4 <.text+0x36f4>
    36e4:	ebffff74 	bl	34bc <BOTStall>
    36e8:	e3a00002 	mov	r0, #2	; 0x2
    36ec:	ebffff5c 	bl	3464 <SendCSW>
    36f0:	ea000050 	b	3838 <.text+0x3838>
    36f4:	e59f314c 	ldr	r3, [pc, #332]	; 3848 <.text+0x3848>
    36f8:	e5933008 	ldr	r3, [r3, #8]
    36fc:	e1520003 	cmp	r2, r3
    3700:	8afffff7 	bhi	36e4 <.text+0x36e4>
    3704:	e59f3144 	ldr	r3, [pc, #324]	; 3850 <.text+0x3850>
    3708:	e3520000 	cmp	r2, #0	; 0x0
    370c:	e5832000 	str	r2, [r3]
    3710:	0a000003 	beq	3724 <.text+0x3724>
    3714:	e59d3004 	ldr	r3, [sp, #4]
    3718:	e3530000 	cmp	r3, #0	; 0x0
    371c:	03a02001 	moveq	r2, #1	; 0x1
    3720:	0a00002f 	beq	37e4 <.text+0x37e4>
    3724:	e59f3118 	ldr	r3, [pc, #280]	; 3844 <.text+0x3844>
    3728:	e3a02002 	mov	r2, #2	; 0x2
    372c:	e5832000 	str	r2, [r3]
    3730:	ebffff70 	bl	34f8 <HandleDataIn>
    3734:	ea00003f 	b	3838 <.text+0x3838>
    3738:	e59f5114 	ldr	r5, [pc, #276]	; 3854 <.text+0x3854>
    373c:	e59f310c 	ldr	r3, [pc, #268]	; 3850 <.text+0x3850>
    3740:	e5951000 	ldr	r1, [r5]
    3744:	e5932000 	ldr	r2, [r3]
    3748:	e1510002 	cmp	r1, r2
    374c:	2a000014 	bcs	37a4 <.text+0x37a4>
    3750:	e59f4100 	ldr	r4, [pc, #256]	; 3858 <.text+0x3858>
    3754:	e0612002 	rsb	r2, r1, r2
    3758:	e3a00002 	mov	r0, #2	; 0x2
    375c:	e5941000 	ldr	r1, [r4]
    3760:	eb0003a4 	bl	45f8 <USBHwEPRead>
    3764:	e1a06000 	mov	r6, r0
    3768:	e59f00d8 	ldr	r0, [pc, #216]	; 3848 <.text+0x3848>
    376c:	e5953000 	ldr	r3, [r5]
    3770:	e5d0100e 	ldrb	r1, [r0, #14]
    3774:	e5942000 	ldr	r2, [r4]
    3778:	e280000f 	add	r0, r0, #15	; 0xf
    377c:	eb000090 	bl	39c4 <SCSIHandleData>
    3780:	e3500000 	cmp	r0, #0	; 0x0
    3784:	15953000 	ldrne	r3, [r5]
    3788:	10833006 	addne	r3, r3, r6
    378c:	e5840000 	str	r0, [r4]
    3790:	15853000 	strne	r3, [r5]
    3794:	1a000002 	bne	37a4 <.text+0x37a4>
    3798:	ebffff47 	bl	34bc <BOTStall>
    379c:	e3a00001 	mov	r0, #1	; 0x1
    37a0:	eaffffd1 	b	36ec <.text+0x36ec>
    37a4:	e59f30a8 	ldr	r3, [pc, #168]	; 3854 <.text+0x3854>
    37a8:	e5932000 	ldr	r2, [r3]
    37ac:	e59f309c 	ldr	r3, [pc, #156]	; 3850 <.text+0x3850>
    37b0:	e5933000 	ldr	r3, [r3]
    37b4:	e1520003 	cmp	r2, r3
    37b8:	1a00001e 	bne	3838 <.text+0x3838>
    37bc:	e59f3084 	ldr	r3, [pc, #132]	; 3848 <.text+0x3848>
    37c0:	e5933008 	ldr	r3, [r3, #8]
    37c4:	e1520003 	cmp	r2, r3
    37c8:	1bffff3b 	blne	34bc <BOTStall>
    37cc:	e3a00000 	mov	r0, #0	; 0x0
    37d0:	eaffffc5 	b	36ec <.text+0x36ec>
    37d4:	e3a01000 	mov	r1, #0	; 0x0
    37d8:	e1a02001 	mov	r2, r1
    37dc:	eb000385 	bl	45f8 <USBHwEPRead>
    37e0:	e3a02000 	mov	r2, #0	; 0x0
    37e4:	e59f3058 	ldr	r3, [pc, #88]	; 3844 <.text+0x3844>
    37e8:	e5832000 	str	r2, [r3]
    37ec:	ea000011 	b	3838 <.text+0x3838>
    37f0:	e3a00002 	mov	r0, #2	; 0x2
    37f4:	e3a01001 	mov	r1, #1	; 0x1
    37f8:	eb000354 	bl	4550 <USBHwEPStall>
    37fc:	ea00000d 	b	3838 <.text+0x3838>
    3800:	e59fc048 	ldr	ip, [pc, #72]	; 3850 <.text+0x3850>
    3804:	e58ce000 	str	lr, [ip]
    3808:	e59fc044 	ldr	ip, [pc, #68]	; 3854 <.text+0x3854>
    380c:	e284000f 	add	r0, r4, #15	; 0xf
    3810:	e28d3004 	add	r3, sp, #4	; 0x4
    3814:	e1a0200d 	mov	r2, sp
    3818:	e58ce000 	str	lr, [ip]
    381c:	e5d4400c 	ldrb	r4, [r4, #12]
    3820:	eb00001a 	bl	3890 <SCSIHandleCmd>
    3824:	e59f302c 	ldr	r3, [pc, #44]	; 3858 <.text+0x3858>
    3828:	e3500000 	cmp	r0, #0	; 0x0
    382c:	e5830000 	str	r0, [r3]
    3830:	1affffa0 	bne	36b8 <.text+0x36b8>
    3834:	eaffffd7 	b	3798 <.text+0x3798>
    3838:	e28dd008 	add	sp, sp, #8	; 0x8
    383c:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    3840:	e12fff1e 	bx	lr
    3844:	40000d1c 	andmi	r0, r0, ip, lsl sp
    3848:	40000cec 	andmi	r0, r0, ip, ror #25
    384c:	43425355 	movtmi	r5, #9045	; 0x2355
    3850:	40000ce4 	andmi	r0, r0, r4, ror #25
    3854:	40000ce8 	andmi	r0, r0, r8, ror #25
    3858:	40000d20 	andmi	r0, r0, r0, lsr #26

0000385c <MSCBotReset>:
    385c:	e59f3014 	ldr	r3, [pc, #20]	; 3878 <.text+0x3878>
    3860:	e3a02000 	mov	r2, #0	; 0x0
    3864:	e52de004 	str	lr, [sp, #-4]!
    3868:	e5832000 	str	r2, [r3]
    386c:	eb000002 	bl	387c <SCSIReset>
    3870:	e49de004 	ldr	lr, [sp], #4
    3874:	e12fff1e 	bx	lr
    3878:	40000d1c 	andmi	r0, r0, ip, lsl sp

0000387c <SCSIReset>:

**************************************************************************/
void SCSIReset(void)
{
    dwSense = 0;
    387c:	e59f3008 	ldr	r3, [pc, #8]	; 388c <.text+0x388c>
    3880:	e3a02000 	mov	r2, #0	; 0x0
    3884:	e5832000 	str	r2, [r3]
}
    3888:	e12fff1e 	bx	lr
    388c:	40000d24 	andmi	r0, r0, r4, lsr #26

00003890 <SCSIHandleCmd>:


/*************************************************************************
    SCSIHandleCmd
    =============
        Verifies a SCSI CDB and indicates the direction and amount of data
        that the device wants to transfer.

    If this call fails, a sense code is set in dwSense.

    IN      pbCDB       Command data block
            iCDBLen     Command data block len
    OUT     *piRspLen   Length of intended response data:
            *pfDevIn    TRUE if data is transferred from device-to-host

    Returns a pointer to the data exchange buffer if successful,
    return NULL otherwise.
**************************************************************************/
U8 * SCSIHandleCmd(U8 *pbCDB, int iCDBLen, int *piRspLen, BOOL *pfDevIn)
{
    3890:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3894:	e1a04000 	mov	r4, r0
    3898:	e24dd008 	sub	sp, sp, #8	; 0x8
    int     i;
    TCDB6   *pCDB;
    U32     dwLen, dwLBA;

	//pCDB = (TCDB6 *)pbCDB;
	//Compiler warning fix
    TCDB6 cdb;
	pCDB = &cdb;
	memcpy(pCDB, pbCDB, sizeof(TCDB6));
    389c:	e3a08008 	mov	r8, #8	; 0x8
    38a0:	e1a06001 	mov	r6, r1
    38a4:	e1a05002 	mov	r5, r2
    38a8:	e1a0000d 	mov	r0, sp
    38ac:	e1a02008 	mov	r2, r8
    38b0:	e1a01004 	mov	r1, r4
    38b4:	e1a07003 	mov	r7, r3
    38b8:	eb0006f3 	bl	548c <memcpy>
	
    // default direction is from device to host
    *pfDevIn = TRUE;

    switch (pCDB->bOperationCode)
    38bc:	e5dd2000 	ldrb	r2, [sp]
    38c0:	e3a03001 	mov	r3, #1	; 0x1
    38c4:	e3520012 	cmp	r2, #18	; 0x12
    38c8:	e5873000 	str	r3, [r7]
    38cc:	0a000013 	beq	3920 <SCSIHandleCmd+0x90>
    38d0:	8a000006 	bhi	38f0 <SCSIHandleCmd+0x60>
    38d4:	e3520000 	cmp	r2, #0	; 0x0
    {

        // test unit ready (6)
        case SCSI_CMD_TEST_UNIT_READY:
            DBG("TEST UNIT READY\n");
            *piRspLen = 0;
    38d8:	059f00dc 	ldreq	r0, [pc, #220]	; 39bc <.text+0x39bc>
    38dc:	05852000 	streq	r2, [r5]
    38e0:	0a000032 	beq	39b0 <SCSIHandleCmd+0x120>
    38e4:	e3520003 	cmp	r2, #3	; 0x3
    38e8:	1a000028 	bne	3990 <SCSIHandleCmd+0x100>
    38ec:	ea000006 	b	390c <SCSIHandleCmd+0x7c>
    38f0:	e3520028 	cmp	r2, #40	; 0x28
    38f4:	0a000012 	beq	3944 <SCSIHandleCmd+0xb4>
    38f8:	e352002a 	cmp	r2, #42	; 0x2a
    38fc:	0a000018 	beq	3964 <SCSIHandleCmd+0xd4>
    3900:	e3520025 	cmp	r2, #37	; 0x25
    3904:	1a000021 	bne	3990 <SCSIHandleCmd+0x100>
    3908:	ea00000a 	b	3938 <SCSIHandleCmd+0xa8>
            break;

        // request sense (6)
        case SCSI_CMD_REQUEST_SENSE:
            DBG("REQUEST SENSE (%06X)\n", dwSense);
            // check params
            *piRspLen = MIN(18, pCDB->bLength);
    390c:	e5dd3004 	ldrb	r3, [sp, #4]
    3910:	e59f00a4 	ldr	r0, [pc, #164]	; 39bc <.text+0x39bc>
    3914:	e3530012 	cmp	r3, #18	; 0x12
    3918:	23a03012 	movcs	r3, #18	; 0x12
    391c:	ea000003 	b	3930 <SCSIHandleCmd+0xa0>
            break;

        // inquiry (6)
        case SCSI_CMD_INQUIRY:
            DBG("INQUIRY\n");
            // see SPC20r20, 4.3.4.6
            *piRspLen = MIN(36, pCDB->bLength);
    3920:	e5dd3004 	ldrb	r3, [sp, #4]
    3924:	e59f0090 	ldr	r0, [pc, #144]	; 39bc <.text+0x39bc>
    3928:	e3530024 	cmp	r3, #36	; 0x24
    392c:	23a03024 	movcs	r3, #36	; 0x24
    3930:	e5853000 	str	r3, [r5]
    3934:	ea00001d 	b	39b0 <SCSIHandleCmd+0x120>
            break;

        // read capacity (10)
        case SCSI_CMD_READ_CAPACITY:
            DBG("READ CAPACITY\n");
            *piRspLen = 8;
    3938:	e59f007c 	ldr	r0, [pc, #124]	; 39bc <.text+0x39bc>
    393c:	e5858000 	str	r8, [r5]
    3940:	ea00001a 	b	39b0 <SCSIHandleCmd+0x120>
            break;

        // read (10)
        case SCSI_CMD_READ_10:
            if (iCDBLen != 10)
    3944:	e356000a 	cmp	r6, #10	; 0xa
    3948:	1a000017 	bne	39ac <SCSIHandleCmd+0x11c>
            {
                return NULL;
            }
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);
            dwLen = (pbCDB[7] << 8) | pbCDB[8];
            DBG("READ10, LBA=%d, len=%d\n", dwLBA, dwLen);
            *piRspLen = dwLen * BLOCKSIZE;
    394c:	e5d43008 	ldrb	r3, [r4, #8]
    3950:	e5d42007 	ldrb	r2, [r4, #7]
    3954:	e59f0060 	ldr	r0, [pc, #96]	; 39bc <.text+0x39bc>
    3958:	e1833402 	orr	r3, r3, r2, lsl #8
    395c:	e1a03483 	mov	r3, r3, lsl #9
    3960:	eafffff2 	b	3930 <SCSIHandleCmd+0xa0>
            break;

        // write (10)
        case SCSI_CMD_WRITE_10:
            if (iCDBLen != 10)
    3964:	e356000a 	cmp	r6, #10	; 0xa
    3968:	1a00000f 	bne	39ac <SCSIHandleCmd+0x11c>
            {
                return NULL;
            }
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);
            dwLen = (pbCDB[7] << 8) | pbCDB[8];
            DBG("WRITE10, LBA=%d, len=%d\n", dwLBA, dwLen);
            *piRspLen = dwLen * BLOCKSIZE;
    396c:	e5d43008 	ldrb	r3, [r4, #8]
    3970:	e5d42007 	ldrb	r2, [r4, #7]
    3974:	e1833402 	orr	r3, r3, r2, lsl #8
    3978:	e1a03483 	mov	r3, r3, lsl #9
            *pfDevIn = FALSE;
    397c:	e59f0038 	ldr	r0, [pc, #56]	; 39bc <.text+0x39bc>
    3980:	e5853000 	str	r3, [r5]
    3984:	e3a03000 	mov	r3, #0	; 0x0
    3988:	e5873000 	str	r3, [r7]
    398c:	ea000007 	b	39b0 <SCSIHandleCmd+0x120>
            break;

        default:
            DBG("Unhandled SCSI: ");
            for (i = 0; i < iCDBLen; i++)
            {
                DBG(" %02X", pbCDB[i]);
            }
            DBG("\n");
            // unsupported command
            dwSense = INVALID_CMD_OPCODE;
            *piRspLen = 0;
    3990:	e3a01000 	mov	r1, #0	; 0x0
    3994:	e59f3024 	ldr	r3, [pc, #36]	; 39c0 <.text+0x39c0>
    3998:	e3a02a52 	mov	r2, #335872	; 0x52000
    399c:	e1a00001 	mov	r0, r1
    39a0:	e5832000 	str	r2, [r3]
    39a4:	e5851000 	str	r1, [r5]
    39a8:	ea000000 	b	39b0 <SCSIHandleCmd+0x120>
            return NULL;
    39ac:	e3a00000 	mov	r0, #0	; 0x0
        }


    return abBlockBuf;
}
    39b0:	e28dd008 	add	sp, sp, #8	; 0x8
    39b4:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    39b8:	e12fff1e 	bx	lr
    39bc:	40000d28 	andmi	r0, r0, r8, lsr #26
    39c0:	40000d24 	andmi	r0, r0, r4, lsr #26

000039c4 <SCSIHandleData>:


/*************************************************************************
    SCSIHandleData
    ==============
        Handles a block of SCSI data.

    IN      pbCDB       Command data block
            iCDBLen     Command data block len
    IN/OUT  pbData      Data buffer
    IN      dwOffset    Offset in data

    Returns a pointer to the next data to be exchanged if successful,
    returns NULL otherwise.
**************************************************************************/
U8 * SCSIHandleData(U8 *pbCDB, int iCDBLen, U8 *pbData, U32 dwOffset)
{
    39c4:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    39c8:	e1a04000 	mov	r4, r0
    39cc:	e24dd00c 	sub	sp, sp, #12	; 0xc
    39d0:	e1a05002 	mov	r5, r2
    TCDB6   *pCDB;
    U32     dwLBA;
    U32     dwBufPos, dwBlockNr;
    U32     dwNumBlocks, dwMaxBlock;

	//pCDB = (TCDB6 *)pbCDB;
	//Compiler warning fix
    TCDB6 cdb;
	pCDB = &cdb;
	memcpy(pCDB, pbCDB, sizeof(TCDB6));
    39d4:	e1a0000d 	mov	r0, sp
    39d8:	e1a01004 	mov	r1, r4
    39dc:	e3a02008 	mov	r2, #8	; 0x8
    39e0:	e1a06003 	mov	r6, r3
    39e4:	eb0006a8 	bl	548c <memcpy>
	
    switch (pCDB->bOperationCode)
    39e8:	e5dd3000 	ldrb	r3, [sp]
    39ec:	e3530012 	cmp	r3, #18	; 0x12
    39f0:	0a000022 	beq	3a80 <SCSIHandleData+0xbc>
    39f4:	8a000004 	bhi	3a0c <SCSIHandleData+0x48>
    39f8:	e3530000 	cmp	r3, #0	; 0x0
    39fc:	0a000009 	beq	3a28 <SCSIHandleData+0x64>
    3a00:	e3530003 	cmp	r3, #3	; 0x3
    3a04:	1a000065 	bne	3ba0 <SCSIHandleData+0x1dc>
    3a08:	ea00000d 	b	3a44 <SCSIHandleData+0x80>
    3a0c:	e3530028 	cmp	r3, #40	; 0x28
    3a10:	0a000034 	beq	3ae8 <SCSIHandleData+0x124>
    3a14:	e353002a 	cmp	r3, #42	; 0x2a
    3a18:	0a000046 	beq	3b38 <SCSIHandleData+0x174>
    3a1c:	e3530025 	cmp	r3, #37	; 0x25
    3a20:	1a00005e 	bne	3ba0 <SCSIHandleData+0x1dc>
    3a24:	ea00001b 	b	3a98 <SCSIHandleData+0xd4>
    {

        // test unit ready
        case 0x00:
            if (dwSense != 0)
    3a28:	e59f3190 	ldr	r3, [pc, #400]	; 3bc0 <.text+0x3bc0>
    3a2c:	e5932000 	ldr	r2, [r3]
    3a30:	e59f318c 	ldr	r3, [pc, #396]	; 3bc4 <.text+0x3bc4>
    3a34:	e3520000 	cmp	r2, #0	; 0x0
    3a38:	01a0e003 	moveq	lr, r3
    3a3c:	13a0e000 	movne	lr, #0	; 0x0
    3a40:	ea00005a 	b	3bb0 <SCSIHandleData+0x1ec>
            {
                return NULL;
            }
            break;

        // request sense
        case SCSI_CMD_REQUEST_SENSE:
            memcpy(pbData, abSense, 18);
    3a44:	e59f117c 	ldr	r1, [pc, #380]	; 3bc8 <.text+0x3bc8>
    3a48:	e3a02012 	mov	r2, #18	; 0x12
    3a4c:	e1a00005 	mov	r0, r5
    3a50:	eb00068d 	bl	548c <memcpy>
            // fill in KEY/ASC/ASCQ
            pbData[2] = (dwSense >> 16) & 0xFF;
    3a54:	e59f0164 	ldr	r0, [pc, #356]	; 3bc0 <.text+0x3bc0>
    3a58:	e5903000 	ldr	r3, [r0]
            pbData[12] = (dwSense >> 8) & 0xFF;
            pbData[13] = (dwSense >> 0) & 0xFF;
            // reset sense data
            dwSense = 0;
    3a5c:	e59fe160 	ldr	lr, [pc, #352]	; 3bc4 <.text+0x3bc4>
    3a60:	e1a02823 	mov	r2, r3, lsr #16
    3a64:	e1a01423 	mov	r1, r3, lsr #8
    3a68:	e5c5300d 	strb	r3, [r5, #13]
    3a6c:	e3a03000 	mov	r3, #0	; 0x0
    3a70:	e5c52002 	strb	r2, [r5, #2]
    3a74:	e5c5100c 	strb	r1, [r5, #12]
    3a78:	e5803000 	str	r3, [r0]
    3a7c:	ea00004b 	b	3bb0 <SCSIHandleData+0x1ec>
            break;

        // inquiry
        case SCSI_CMD_INQUIRY:
            memcpy(pbData, abInquiry, sizeof(abInquiry));
    3a80:	e1a00005 	mov	r0, r5
    3a84:	e59f1140 	ldr	r1, [pc, #320]	; 3bcc <.text+0x3bcc>
    3a88:	e3a02024 	mov	r2, #36	; 0x24
    3a8c:	eb00067e 	bl	548c <memcpy>
    3a90:	e59fe12c 	ldr	lr, [pc, #300]	; 3bc4 <.text+0x3bc4>
    3a94:	ea000045 	b	3bb0 <SCSIHandleData+0x1ec>
            break;

        // read capacity
        case SCSI_CMD_READ_CAPACITY:
        // get size of drive (bytes)
            BlockDevGetSize(&dwNumBlocks);
    3a98:	e28d0008 	add	r0, sp, #8	; 0x8
    3a9c:	eb000088 	bl	3cc4 <BlockDevGetSize>
            // calculate highest LBA
            dwMaxBlock = (dwNumBlocks - 1) / 512;
    3aa0:	e59d3008 	ldr	r3, [sp, #8]
    3aa4:	e2433001 	sub	r3, r3, #1	; 0x1
    3aa8:	e1a004a3 	mov	r0, r3, lsr #9

            pbData[0] = (dwMaxBlock >> 24) & 0xFF;
            pbData[1] = (dwMaxBlock >> 16) & 0xFF;
            pbData[2] = (dwMaxBlock >> 8) & 0xFF;
    3aac:	e1a0c8a3 	mov	ip, r3, lsr #17
            pbData[3] = (dwMaxBlock >> 0) & 0xFF;
            pbData[4] = (BLOCKSIZE >> 24) & 0xFF;
            pbData[5] = (BLOCKSIZE >> 16) & 0xFF;
            pbData[6] = (BLOCKSIZE >> 8) & 0xFF;
            pbData[7] = (BLOCKSIZE >> 0) & 0xFF;
    3ab0:	e59fe10c 	ldr	lr, [pc, #268]	; 3bc4 <.text+0x3bc4>
    3ab4:	e1a03ca3 	mov	r3, r3, lsr #25
    3ab8:	e3a02000 	mov	r2, #0	; 0x0
    3abc:	e1a01c20 	mov	r1, r0, lsr #24
    3ac0:	e5c53001 	strb	r3, [r5, #1]
    3ac4:	e3a03002 	mov	r3, #2	; 0x2
    3ac8:	e5c52007 	strb	r2, [r5, #7]
    3acc:	e5c51000 	strb	r1, [r5]
    3ad0:	e5c5c002 	strb	ip, [r5, #2]
    3ad4:	e5c50003 	strb	r0, [r5, #3]
    3ad8:	e5c53006 	strb	r3, [r5, #6]
    3adc:	e5c52004 	strb	r2, [r5, #4]
    3ae0:	e5c52005 	strb	r2, [r5, #5]
    3ae4:	ea000031 	b	3bb0 <SCSIHandleData+0x1ec>
            break;

        // read10
        case SCSI_CMD_READ_10:
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);

            // copy data from block buffer
            dwBufPos = (dwOffset & (BLOCKSIZE - 1));
    3ae8:	e1a05b86 	mov	r5, r6, lsl #23
    3aec:	e1a05ba5 	mov	r5, r5, lsr #23
            if (dwBufPos == 0)
    3af0:	e3550000 	cmp	r5, #0	; 0x0
    3af4:	e5d42005 	ldrb	r2, [r4, #5]
    3af8:	e5d43002 	ldrb	r3, [r4, #2]
    3afc:	e5d40003 	ldrb	r0, [r4, #3]
    3b00:	e5d41004 	ldrb	r1, [r4, #4]
    3b04:	1a000022 	bne	3b94 <SCSIHandleData+0x1d0>
            {
                // read new block
                dwBlockNr = dwLBA + (dwOffset / BLOCKSIZE);
                DBG("R");
                if (BlockDevRead(dwBlockNr, abBlockBuf) < 0)
    3b08:	e1a00800 	mov	r0, r0, lsl #16
    3b0c:	e1800c03 	orr	r0, r0, r3, lsl #24
    3b10:	e1800002 	orr	r0, r0, r2
    3b14:	e1800401 	orr	r0, r0, r1, lsl #8
    3b18:	e08004a6 	add	r0, r0, r6, lsr #9
    3b1c:	e59f10a0 	ldr	r1, [pc, #160]	; 3bc4 <.text+0x3bc4>
    3b20:	eb0000d2 	bl	3e70 <BlockDevRead>
    3b24:	e3500000 	cmp	r0, #0	; 0x0
                {
                    dwSense = READ_ERROR;
    3b28:	b1a0e005 	movlt	lr, r5
    3b2c:	b59f209c 	ldrlt	r2, [pc, #156]	; 3bd0 <.text+0x3bd0>
    3b30:	ba000014 	blt	3b88 <SCSIHandleData+0x1c4>
    3b34:	ea000016 	b	3b94 <SCSIHandleData+0x1d0>
                    DBG("BlockDevRead failed\n");
                    return NULL;
                }
            }
            // return pointer to data
            return abBlockBuf + dwBufPos;

            // write10
            case SCSI_CMD_WRITE_10:
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);

            // copy data to block buffer
            dwBufPos = ((dwOffset + 64) & (BLOCKSIZE - 1));
    3b38:	e2863040 	add	r3, r6, #64	; 0x40
    3b3c:	e1a05b83 	mov	r5, r3, lsl #23
    3b40:	e1a05ba5 	mov	r5, r5, lsr #23
            if (dwBufPos == 0)
    3b44:	e3550000 	cmp	r5, #0	; 0x0
    3b48:	e5d42005 	ldrb	r2, [r4, #5]
    3b4c:	e5d43002 	ldrb	r3, [r4, #2]
    3b50:	e5d40003 	ldrb	r0, [r4, #3]
    3b54:	e5d41004 	ldrb	r1, [r4, #4]
    3b58:	1a00000d 	bne	3b94 <SCSIHandleData+0x1d0>
            {
                // write new block
                dwBlockNr = dwLBA + (dwOffset / BLOCKSIZE);
                DBG("W");
                if (BlockDevWrite(dwBlockNr, abBlockBuf) < 0)
    3b5c:	e1a00800 	mov	r0, r0, lsl #16
    3b60:	e1800c03 	orr	r0, r0, r3, lsl #24
    3b64:	e1800002 	orr	r0, r0, r2
    3b68:	e1800401 	orr	r0, r0, r1, lsl #8
    3b6c:	e08004a6 	add	r0, r0, r6, lsr #9
    3b70:	e59f104c 	ldr	r1, [pc, #76]	; 3bc4 <.text+0x3bc4>
    3b74:	eb000039 	bl	3c60 <BlockDevWrite>
    3b78:	e3500000 	cmp	r0, #0	; 0x0
    3b7c:	aa000004 	bge	3b94 <SCSIHandleData+0x1d0>
                {
                    dwSense = WRITE_ERROR;
    3b80:	e1a0e005 	mov	lr, r5
    3b84:	e3a02bc3 	mov	r2, #199680	; 0x30c00
    3b88:	e59f3030 	ldr	r3, [pc, #48]	; 3bc0 <.text+0x3bc0>
    3b8c:	e5832000 	str	r2, [r3]
    3b90:	ea000006 	b	3bb0 <SCSIHandleData+0x1ec>
                    DBG("BlockDevWrite failed\n");
                    return NULL;
                }
            }
            // return pointer to next data
            return abBlockBuf + dwBufPos;
    3b94:	e59f3028 	ldr	r3, [pc, #40]	; 3bc4 <.text+0x3bc4>
    3b98:	e085e003 	add	lr, r5, r3
    3b9c:	ea000003 	b	3bb0 <SCSIHandleData+0x1ec>

            default:
            // unsupported command
            dwSense = INVALID_CMD_OPCODE;
    3ba0:	e59f3018 	ldr	r3, [pc, #24]	; 3bc0 <.text+0x3bc0>
    3ba4:	e3a02a52 	mov	r2, #335872	; 0x52000
    3ba8:	e5832000 	str	r2, [r3]
    3bac:	e3a0e000 	mov	lr, #0	; 0x0
            return NULL;
        }

    // default: return pointer to start of block buffer
    return abBlockBuf;
}
    3bb0:	e1a0000e 	mov	r0, lr
    3bb4:	e28dd00c 	add	sp, sp, #12	; 0xc
    3bb8:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    3bbc:	e12fff1e 	bx	lr
    3bc0:	40000d24 	andmi	r0, r0, r4, lsr #26
    3bc4:	40000d28 	andmi	r0, r0, r8, lsr #26
    3bc8:	00005cc0 	andeq	r5, r0, r0, asr #25
    3bcc:	00005cd2 	ldreqd	r5, [r0], -r2
    3bd0:	00031100 	andeq	r1, r3, r0, lsl #2

00003bd4 <Resp8b>:

/*****************************************************************************/

static U8 Resp8b(void)
{
    3bd4:	e92d4010 	stmdb	sp!, {r4, lr}
    3bd8:	e3a04000 	mov	r4, #0	; 0x0
    U8 i;
    U8 resp;

    /* Respone will come after 1 - 8 pings */
    for (i = 0; i < 8; i++)
    {
        resp = SPISend(0xff);
    3bdc:	e3a000ff 	mov	r0, #255	; 0xff
    3be0:	eb000146 	bl	4100 <SPISend>
    3be4:	e2843001 	add	r3, r4, #1	; 0x1
        if (resp != 0xff)
    3be8:	e35000ff 	cmp	r0, #255	; 0xff
    3bec:	e20340ff 	and	r4, r3, #255	; 0xff
    3bf0:	1a000001 	bne	3bfc <Resp8b+0x28>
    3bf4:	e3540008 	cmp	r4, #8	; 0x8
    3bf8:	1afffff7 	bne	3bdc <Resp8b+0x8>
        {
            return resp;
        }
    }

    return resp;
}
    3bfc:	e8bd4010 	ldmia	sp!, {r4, lr}
    3c00:	e12fff1e 	bx	lr

00003c04 <Command>:
    3c04:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    3c08:	e1a03001 	mov	r3, r1
    3c0c:	e24dd008 	sub	sp, sp, #8	; 0x8
    3c10:	e3804040 	orr	r4, r0, #64	; 0x40
    3c14:	e3e05000 	mvn	r5, #0	; 0x0
    3c18:	e1a02c21 	mov	r2, r1, lsr #24
    3c1c:	e1a0c821 	mov	ip, r1, lsr #16
    3c20:	e1a0e421 	mov	lr, r1, lsr #8
    3c24:	e5cd3005 	strb	r3, [sp, #5]
    3c28:	e1a0000d 	mov	r0, sp
    3c2c:	e3e0306a 	mvn	r3, #106	; 0x6a
    3c30:	e3a01008 	mov	r1, #8	; 0x8
    3c34:	e5cd4001 	strb	r4, [sp, #1]
    3c38:	e5cd2002 	strb	r2, [sp, #2]
    3c3c:	e5cdc003 	strb	ip, [sp, #3]
    3c40:	e5cde004 	strb	lr, [sp, #4]
    3c44:	e5cd3006 	strb	r3, [sp, #6]
    3c48:	e5cd5007 	strb	r5, [sp, #7]
    3c4c:	e5cd5000 	strb	r5, [sp]
    3c50:	eb00013d 	bl	414c <SPISendN>
    3c54:	e28dd008 	add	sp, sp, #8	; 0x8
    3c58:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    3c5c:	e12fff1e 	bx	lr

00003c60 <BlockDevWrite>:

/*****************************************************************************/

static void Resp8bError(U8 value)
{
    switch (value)
    {
        case 0x40:  rprintf("Argument out of bounds.\n");               break;
        case 0x20:  rprintf("Address out of bounds.\n");                break;
        case 0x10:  rprintf("Error during erase sequence.\n");          break;
        case 0x08:  rprintf("CRC failed.\n");                           break;
        case 0x04:  rprintf("Illegal command.\n");                      break;
        case 0x02:  rprintf("Erase reset (see SanDisk docs p5-13).\n"); break;
//        case 0x01:  rprintf("Card is initialising.\n");                 break;
        case 0x01:  rprintf(".");                 break;
            default:
            rprintf("Unknown error 0x%x (see SanDisk docs p5-13).\n", value);
            break;
    }
}


/* ****************************************************************************
 calculates size of card from CSD
 (extension by Martin Thomas, inspired by code from Holger Klabunde)
 */
int BlockDevGetSize(U32 *pdwDriveSize)
{
    U8 cardresp, i, by;
    U8 iob[16];
    U16 c_size, c_size_mult, read_bl_len;

    Command(CMD_READCSD, 0);
    do
    {
        cardresp = Resp8b();
    }
    while (cardresp != 0xFE);

    rprintf("CSD:");
    for (i = 0; i < 16; i++)
    {
        iob[i] = SPISend(0xFF);
        rprintf(" %02x", iob[i]);
    }
    rprintf("\n");

    SPISend(0xff);
    SPISend(0xff);

    c_size = iob[6] & 0x03;     // bits 1..0
    c_size <<= 10;
    c_size += (U16) iob[7] << 2;
    c_size += iob[8] >> 6;

    by = iob[5] & 0x0F;
    read_bl_len = 1 << by;

    by = iob[9] & 0x03;
    by <<= 1;
    by += iob[10] >> 7;

    c_size_mult = 1 << (2 + by);

    *pdwDriveSize = (U32) (c_size + 1) * (U32) c_size_mult *(U32) read_bl_len;

    return 0;
}

/*****************************************************************************/

static U16 Resp16b(void)
{
    U16 resp;

    resp = (Resp8b() << 8) & 0xff00;
    resp |= SPISend(0xff);

    return resp;
}

/*****************************************************************************/

static int State(void)
{
    U16 value;

    Command(CMD_SENDSTATUS, 0);
    value = Resp16b();

    switch (value)
    {
        case 0x0000: return 1;
        case 0x0001: rprintf("Card is Locked.\n");                                                  break;
        case 0x0002: rprintf("WP Erase Skip, Lock/Unlock Cmd Failed.\n");                           break;
        case 0x0004: rprintf("General / Unknown error -- card broken?.\n");                         break;
        case 0x0008: rprintf("Internal card controller error.\n");                                  break;
        case 0x0010: rprintf("Card internal ECC was applied, but failed to correct the data.\n");   break;
        case 0x0020: rprintf("Write protect violation.\n");                                         break;
        case 0x0040: rprintf("An invalid selection, sectors for erase.\n");                         break;
        case 0x0080: rprintf("Out of Range, CSD_Overwrite.\n");                                     break;
            default:
            if (value > 0x00FF)
            {
                Resp8bError((U8) (value >> 8));
            }
            else
            {
                rprintf("Unknown error: 0x%x (see SanDisk docs p5-14).\n", value);
            }
            break;
    }
    return -1;
}

/*****************************************************************************/


int BlockDevInit(void)
{
    int i;
    U8 resp;

    SPIInit();              /* init at low speed */

    /* Try to send reset command up to 100 times */
    i = 100;
    do
    {
        Command(CMD_GOIDLESTATE, 0);
        resp = Resp8b();
    }
    while (resp != 1 && i--);

    if (resp != 1)
    {
        if (resp == 0xff)
        {
            rprintf("resp=0xff\n");
            return -1;
        }
        else
        {
            Resp8bError(resp);
            rprintf("resp!=0xff\n");
            return -2;
        }
    }

    /* Wait till card is ready initialising (returns 0 on CMD_1) */
    /* Try up to 32000 times. */
    i = 32000;
    do
    {
        Command(CMD_SENDOPCOND, 0);

        resp = Resp8b();
        if (resp != 0)
        {
            Resp8bError(resp);
        }
    }
    while (resp == 1 && i--);

    if (resp != 0)
    {
        Resp8bError(resp);
        return -3;
    }

    /* increase speed after init */
    SPISetSpeed(SPI_PRESCALE_MIN);

    if (State() < 0)
    {
        rprintf("Card didn't return the ready state, breaking up...\n");
        return -2;
    }

    rprintf("SD Init done...\n");

    return 0;
}

/*****************************************************************************/



/*****************************************************************************/


/*****************************************************************************/

/* ****************************************************************************
 * WAIT ?? -- FIXME
 * CMD_WRITE
 * WAIT
 * CARD RESP
 * WAIT
 * DATA BLOCK OUT
 *      START BLOCK
 *      DATA
 *      CHKS (2B)
 * BUSY...
 */

int BlockDevWrite(U32 dwAddress, U8 * pbBuf)
{
    U32 place;
    U16 t = 0;

    place = 512 * dwAddress;
    Command(CMD_WRITE, place);
    3c60:	e1a00480 	mov	r0, r0, lsl #9
    3c64:	e92d4010 	stmdb	sp!, {r4, lr}
    3c68:	e1a04001 	mov	r4, r1
    3c6c:	e1a01000 	mov	r1, r0
    3c70:	e3a00018 	mov	r0, #24	; 0x18
    3c74:	ebffffe2 	bl	3c04 <Command>

    Resp8b();               /* Card response */
    3c78:	ebffffd5 	bl	3bd4 <Resp8b>

    SPISend(0xfe);          /* Start block */
    3c7c:	e3a000fe 	mov	r0, #254	; 0xfe
    3c80:	eb00011e 	bl	4100 <SPISend>
    SPISendN(pbBuf, 512);
    3c84:	e3a01c02 	mov	r1, #512	; 0x200
    3c88:	e1a00004 	mov	r0, r4
    3c8c:	eb00012e 	bl	414c <SPISendN>
    SPISend(0xff);          /* Checksum part 1 */
    3c90:	e3a000ff 	mov	r0, #255	; 0xff
    3c94:	eb000119 	bl	4100 <SPISend>
    SPISend(0xff);          /* Checksum part 2 */
    3c98:	e3a000ff 	mov	r0, #255	; 0xff
    3c9c:	eb000117 	bl	4100 <SPISend>

    SPISend(0xff);
    3ca0:	e3a000ff 	mov	r0, #255	; 0xff
    3ca4:	eb000115 	bl	4100 <SPISend>

    while (SPISend(0xff) != 0xff)
    3ca8:	e3a000ff 	mov	r0, #255	; 0xff
    3cac:	eb000113 	bl	4100 <SPISend>
    3cb0:	e35000ff 	cmp	r0, #255	; 0xff
    3cb4:	1afffffb 	bne	3ca8 <BlockDevWrite+0x48>
    {
        t++;
    }

    return 0;
}
    3cb8:	e3a00000 	mov	r0, #0	; 0x0
    3cbc:	e8bd4010 	ldmia	sp!, {r4, lr}
    3cc0:	e12fff1e 	bx	lr

00003cc4 <BlockDevGetSize>:
    3cc4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    3cc8:	e3a01000 	mov	r1, #0	; 0x0
    3ccc:	e1a05000 	mov	r5, r0
    3cd0:	e24dd010 	sub	sp, sp, #16	; 0x10
    3cd4:	e3a00009 	mov	r0, #9	; 0x9
    3cd8:	ebffffc9 	bl	3c04 <Command>
    3cdc:	ebffffbc 	bl	3bd4 <Resp8b>
    3ce0:	e35000fe 	cmp	r0, #254	; 0xfe
    3ce4:	1afffffc 	bne	3cdc <BlockDevGetSize+0x18>
    3ce8:	e59f00bc 	ldr	r0, [pc, #188]	; 3dac <.text+0x3dac>
    3cec:	ebfff1b9 	bl	3d8 <rprintf>
    3cf0:	e3a04000 	mov	r4, #0	; 0x0
    3cf4:	e3a000ff 	mov	r0, #255	; 0xff
    3cf8:	eb000100 	bl	4100 <SPISend>
    3cfc:	e1a0300d 	mov	r3, sp
    3d00:	e7c40003 	strb	r0, [r4, r3]
    3d04:	e1a01000 	mov	r1, r0
    3d08:	e2844001 	add	r4, r4, #1	; 0x1
    3d0c:	e59f009c 	ldr	r0, [pc, #156]	; 3db0 <.text+0x3db0>
    3d10:	ebfff1b0 	bl	3d8 <rprintf>
    3d14:	e3540010 	cmp	r4, #16	; 0x10
    3d18:	1afffff5 	bne	3cf4 <BlockDevGetSize+0x30>
    3d1c:	e59f0090 	ldr	r0, [pc, #144]	; 3db4 <.text+0x3db4>
    3d20:	ebfff1ac 	bl	3d8 <rprintf>
    3d24:	e3a000ff 	mov	r0, #255	; 0xff
    3d28:	eb0000f4 	bl	4100 <SPISend>
    3d2c:	e3a000ff 	mov	r0, #255	; 0xff
    3d30:	eb0000f2 	bl	4100 <SPISend>
    3d34:	e5dd1005 	ldrb	r1, [sp, #5]
    3d38:	e3a00001 	mov	r0, #1	; 0x1
    3d3c:	e201100f 	and	r1, r1, #15	; 0xf
    3d40:	e1a01110 	mov	r1, r0, lsl r1
    3d44:	e5dd2009 	ldrb	r2, [sp, #9]
    3d48:	e5dd300a 	ldrb	r3, [sp, #10]
    3d4c:	e2022003 	and	r2, r2, #3	; 0x3
    3d50:	e1a033a3 	mov	r3, r3, lsr #7
    3d54:	e0833082 	add	r3, r3, r2, lsl #1
    3d58:	e2833002 	add	r3, r3, #2	; 0x2
    3d5c:	e1a00310 	mov	r0, r0, lsl r3
    3d60:	e5dd3007 	ldrb	r3, [sp, #7]
    3d64:	e5dd2006 	ldrb	r2, [sp, #6]
    3d68:	e5ddc008 	ldrb	ip, [sp, #8]
    3d6c:	e1a03103 	mov	r3, r3, lsl #2
    3d70:	e083332c 	add	r3, r3, ip, lsr #6
    3d74:	e2022003 	and	r2, r2, #3	; 0x3
    3d78:	e0833502 	add	r3, r3, r2, lsl #10
    3d7c:	e1a01801 	mov	r1, r1, lsl #16
    3d80:	e1a01821 	mov	r1, r1, lsr #16
    3d84:	e2833001 	add	r3, r3, #1	; 0x1
    3d88:	e0030391 	mul	r3, r1, r3
    3d8c:	e1a00800 	mov	r0, r0, lsl #16
    3d90:	e1a00820 	mov	r0, r0, lsr #16
    3d94:	e0030390 	mul	r3, r0, r3
    3d98:	e3a00000 	mov	r0, #0	; 0x0
    3d9c:	e5853000 	str	r3, [r5]
    3da0:	e28dd010 	add	sp, sp, #16	; 0x10
    3da4:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    3da8:	e12fff1e 	bx	lr
    3dac:	00005f94 	muleq	r0, r4, pc
    3db0:	00005f9c 	muleq	r0, ip, pc
    3db4:	00006074 	andeq	r6, r0, r4, ror r0

00003db8 <Resp8bError>:
    3db8:	e20010ff 	and	r1, r0, #255	; 0xff
    3dbc:	e3510008 	cmp	r1, #8	; 0x8
    3dc0:	e52de004 	str	lr, [sp, #-4]!
    3dc4:	0a000015 	beq	3e20 <Resp8bError+0x68>
    3dc8:	8a000006 	bhi	3de8 <Resp8bError+0x30>
    3dcc:	e3510002 	cmp	r1, #2	; 0x2
    3dd0:	0a000016 	beq	3e30 <Resp8bError+0x78>
    3dd4:	e3510004 	cmp	r1, #4	; 0x4
    3dd8:	0a000012 	beq	3e28 <Resp8bError+0x70>
    3ddc:	e3510001 	cmp	r1, #1	; 0x1
    3de0:	1a000016 	bne	3e40 <Resp8bError+0x88>
    3de4:	ea000013 	b	3e38 <Resp8bError+0x80>
    3de8:	e3510020 	cmp	r1, #32	; 0x20
    3dec:	0a000006 	beq	3e0c <Resp8bError+0x54>
    3df0:	e3510040 	cmp	r1, #64	; 0x40
    3df4:	0a000002 	beq	3e04 <Resp8bError+0x4c>
    3df8:	e3510010 	cmp	r1, #16	; 0x10
    3dfc:	1a00000f 	bne	3e40 <Resp8bError+0x88>
    3e00:	ea000004 	b	3e18 <Resp8bError+0x60>
    3e04:	e59f0044 	ldr	r0, [pc, #68]	; 3e50 <.text+0x3e50>
    3e08:	ea000000 	b	3e10 <Resp8bError+0x58>
    3e0c:	e59f0040 	ldr	r0, [pc, #64]	; 3e54 <.text+0x3e54>
    3e10:	ebfff170 	bl	3d8 <rprintf>
    3e14:	ea00000b 	b	3e48 <Resp8bError+0x90>
    3e18:	e59f0038 	ldr	r0, [pc, #56]	; 3e58 <.text+0x3e58>
    3e1c:	eafffffb 	b	3e10 <Resp8bError+0x58>
    3e20:	e59f0034 	ldr	r0, [pc, #52]	; 3e5c <.text+0x3e5c>
    3e24:	eafffff9 	b	3e10 <Resp8bError+0x58>
    3e28:	e59f0030 	ldr	r0, [pc, #48]	; 3e60 <.text+0x3e60>
    3e2c:	eafffff7 	b	3e10 <Resp8bError+0x58>
    3e30:	e59f002c 	ldr	r0, [pc, #44]	; 3e64 <.text+0x3e64>
    3e34:	eafffff5 	b	3e10 <Resp8bError+0x58>
    3e38:	e59f0028 	ldr	r0, [pc, #40]	; 3e68 <.text+0x3e68>
    3e3c:	eafffff3 	b	3e10 <Resp8bError+0x58>
    3e40:	e59f0024 	ldr	r0, [pc, #36]	; 3e6c <.text+0x3e6c>
    3e44:	ebfff163 	bl	3d8 <rprintf>
    3e48:	e49de004 	ldr	lr, [sp], #4
    3e4c:	e12fff1e 	bx	lr
    3e50:	00005fa4 	andeq	r5, r0, r4, lsr #31
    3e54:	00005fc0 	andeq	r5, r0, r0, asr #31
    3e58:	00005fd8 	ldreqd	r5, [r0], -r8
    3e5c:	00005ff8 	streqd	r5, [r0], -r8
    3e60:	00006008 	andeq	r6, r0, r8
    3e64:	0000601c 	andeq	r6, r0, ip, lsl r0
    3e68:	00006044 	andeq	r6, r0, r4, asr #32
    3e6c:	00006048 	andeq	r6, r0, r8, asr #32

00003e70 <BlockDevRead>:

/*****************************************************************************/

/* ****************************************************************************
 * WAIT ?? -- FIXME
 * CMD_CMD_
 * WAIT
 * CARD RESP
 * WAIT
 * DATA BLOCK IN
 *      START BLOCK
 *      DATA
 *      CHKS (2B)
 */

int BlockDevRead(U32 dwAddress, U8 * pbBuf)
{
    U8 cardresp;
    U8 firstblock;
    U16 fb_timeout = 0xffff;
    U32 place;

    place = 512 * dwAddress;
    Command(CMD_READSINGLEBLOCK, place);
    3e70:	e1a00480 	mov	r0, r0, lsl #9
    3e74:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    3e78:	e1a06001 	mov	r6, r1
    3e7c:	e1a01000 	mov	r1, r0
    3e80:	e3a00011 	mov	r0, #17	; 0x11
    3e84:	ebffff5e 	bl	3c04 <Command>

    cardresp = Resp8b();        /* Card response */
    3e88:	ebffff51 	bl	3bd4 <Resp8b>
    3e8c:	e59f506c 	ldr	r5, [pc, #108]	; 3f00 <.text+0x3f00>
    3e90:	e1a04000 	mov	r4, r0

    /* Wait for startblock */
    do
    {
        firstblock = Resp8b();
    3e94:	ebffff4e 	bl	3bd4 <Resp8b>
    }
    while (firstblock == 0xff && fb_timeout--);
    3e98:	e2453001 	sub	r3, r5, #1	; 0x1
    3e9c:	e35000ff 	cmp	r0, #255	; 0xff
    3ea0:	e1a03803 	mov	r3, r3, lsl #16
    3ea4:	1a000003 	bne	3eb8 <BlockDevRead+0x48>
    3ea8:	e3730801 	cmn	r3, #65536	; 0x10000
    3eac:	e1a05823 	mov	r5, r3, lsr #16
    3eb0:	0a000005 	beq	3ecc <BlockDevRead+0x5c>
    3eb4:	eafffff6 	b	3e94 <BlockDevRead+0x24>

    if (cardresp != 0x00 || firstblock != 0xfe)
    3eb8:	e35000fe 	cmp	r0, #254	; 0xfe
    3ebc:	03540000 	cmpeq	r4, #0	; 0x0
    3ec0:	03a04000 	moveq	r4, #0	; 0x0
    3ec4:	13a04001 	movne	r4, #1	; 0x1
    3ec8:	0a000002 	beq	3ed8 <BlockDevRead+0x68>
    {
        Resp8bError(firstblock);
    3ecc:	ebffffb9 	bl	3db8 <Resp8bError>
    3ed0:	e3e00000 	mvn	r0, #0	; 0x0
    3ed4:	ea000007 	b	3ef8 <BlockDevRead+0x88>
        return -1;
    }

    SPIRecvN(pbBuf, 512);
    3ed8:	e3a01c02 	mov	r1, #512	; 0x200
    3edc:	e1a00006 	mov	r0, r6
    3ee0:	eb0000b0 	bl	41a8 <SPIRecvN>

    /* Checksum (2 byte) - ignore for now */
    SPISend(0xff);
    3ee4:	e3a000ff 	mov	r0, #255	; 0xff
    3ee8:	eb000084 	bl	4100 <SPISend>
    SPISend(0xff);
    3eec:	e3a000ff 	mov	r0, #255	; 0xff
    3ef0:	eb000082 	bl	4100 <SPISend>
    3ef4:	e1a00004 	mov	r0, r4

    return 0;
}
    3ef8:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    3efc:	e12fff1e 	bx	lr
    3f00:	0000ffff 	streqd	pc, [r0], -pc

00003f04 <BlockDevInit>:
    3f04:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    3f08:	eb0000bf 	bl	420c <SPIInit>
    3f0c:	e3a04064 	mov	r4, #100	; 0x64
    3f10:	e3a00000 	mov	r0, #0	; 0x0
    3f14:	e1a01000 	mov	r1, r0
    3f18:	ebffff39 	bl	3c04 <Command>
    3f1c:	ebffff2c 	bl	3bd4 <Resp8b>
    3f20:	e3500001 	cmp	r0, #1	; 0x1
    3f24:	e2444001 	sub	r4, r4, #1	; 0x1
    3f28:	0a00000a 	beq	3f58 <BlockDevInit+0x54>
    3f2c:	e3740001 	cmn	r4, #1	; 0x1
    3f30:	1afffff6 	bne	3f10 <BlockDevInit+0xc>
    3f34:	e35000ff 	cmp	r0, #255	; 0xff
    3f38:	1a000003 	bne	3f4c <BlockDevInit+0x48>
    3f3c:	e59f016c 	ldr	r0, [pc, #364]	; 40b0 <.text+0x40b0>
    3f40:	ebfff124 	bl	3d8 <rprintf>
    3f44:	e1a00004 	mov	r0, r4
    3f48:	ea000056 	b	40a8 <BlockDevInit+0x1a4>
    3f4c:	ebffff99 	bl	3db8 <Resp8bError>
    3f50:	e59f015c 	ldr	r0, [pc, #348]	; 40b4 <.text+0x40b4>
    3f54:	ea000051 	b	40a0 <BlockDevInit+0x19c>
    3f58:	e3a04c7d 	mov	r4, #32000	; 0x7d00
    3f5c:	e3a01000 	mov	r1, #0	; 0x0
    3f60:	e3a00001 	mov	r0, #1	; 0x1
    3f64:	ebffff26 	bl	3c04 <Command>
    3f68:	ebffff19 	bl	3bd4 <Resp8b>
    3f6c:	e2505000 	subs	r5, r0, #0	; 0x0
    3f70:	e2444001 	sub	r4, r4, #1	; 0x1
    3f74:	0a000008 	beq	3f9c <BlockDevInit+0x98>
    3f78:	ebffff8e 	bl	3db8 <Resp8bError>
    3f7c:	e3550001 	cmp	r5, #1	; 0x1
    3f80:	1a000001 	bne	3f8c <BlockDevInit+0x88>
    3f84:	e3740001 	cmn	r4, #1	; 0x1
    3f88:	1afffff3 	bne	3f5c <BlockDevInit+0x58>
    3f8c:	e1a00005 	mov	r0, r5
    3f90:	ebffff88 	bl	3db8 <Resp8bError>
    3f94:	e3e00002 	mvn	r0, #2	; 0x2
    3f98:	ea000042 	b	40a8 <BlockDevInit+0x1a4>
    3f9c:	e3a00008 	mov	r0, #8	; 0x8
    3fa0:	eb00004f 	bl	40e4 <SPISetSpeed>
    3fa4:	e1a01005 	mov	r1, r5
    3fa8:	e3a0000d 	mov	r0, #13	; 0xd
    3fac:	ebffff14 	bl	3c04 <Command>
    3fb0:	ebffff07 	bl	3bd4 <Resp8b>
    3fb4:	e1a04c00 	mov	r4, r0, lsl #24
    3fb8:	e3a000ff 	mov	r0, #255	; 0xff
    3fbc:	eb00004f 	bl	4100 <SPISend>
    3fc0:	e1a04824 	mov	r4, r4, lsr #16
    3fc4:	e1844000 	orr	r4, r4, r0
    3fc8:	e1a04804 	mov	r4, r4, lsl #16
    3fcc:	e1a01824 	mov	r1, r4, lsr #16
    3fd0:	e3510008 	cmp	r1, #8	; 0x8
    3fd4:	0a00001a 	beq	4044 <BlockDevInit+0x140>
    3fd8:	8a000007 	bhi	3ffc <BlockDevInit+0xf8>
    3fdc:	e3510001 	cmp	r1, #1	; 0x1
    3fe0:	0a000010 	beq	4028 <BlockDevInit+0x124>
    3fe4:	3a000028 	bcc	408c <BlockDevInit+0x188>
    3fe8:	e3510002 	cmp	r1, #2	; 0x2
    3fec:	0a00000f 	beq	4030 <BlockDevInit+0x12c>
    3ff0:	e3510004 	cmp	r1, #4	; 0x4
    3ff4:	1a00001c 	bne	406c <BlockDevInit+0x168>
    3ff8:	ea00000f 	b	403c <BlockDevInit+0x138>
    3ffc:	e3510020 	cmp	r1, #32	; 0x20
    4000:	0a000013 	beq	4054 <BlockDevInit+0x150>
    4004:	8a000002 	bhi	4014 <BlockDevInit+0x110>
    4008:	e3510010 	cmp	r1, #16	; 0x10
    400c:	1a000016 	bne	406c <BlockDevInit+0x168>
    4010:	ea00000d 	b	404c <BlockDevInit+0x148>
    4014:	e3510040 	cmp	r1, #64	; 0x40
    4018:	0a00000f 	beq	405c <BlockDevInit+0x158>
    401c:	e3510080 	cmp	r1, #128	; 0x80
    4020:	1a000011 	bne	406c <BlockDevInit+0x168>
    4024:	ea00000e 	b	4064 <BlockDevInit+0x160>
    4028:	e59f0088 	ldr	r0, [pc, #136]	; 40b8 <.text+0x40b8>
    402c:	ea000000 	b	4034 <BlockDevInit+0x130>
    4030:	e59f0084 	ldr	r0, [pc, #132]	; 40bc <.text+0x40bc>
    4034:	ebfff0e7 	bl	3d8 <rprintf>
    4038:	ea000017 	b	409c <BlockDevInit+0x198>
    403c:	e59f007c 	ldr	r0, [pc, #124]	; 40c0 <.text+0x40c0>
    4040:	eafffffb 	b	4034 <BlockDevInit+0x130>
    4044:	e59f0078 	ldr	r0, [pc, #120]	; 40c4 <.text+0x40c4>
    4048:	eafffff9 	b	4034 <BlockDevInit+0x130>
    404c:	e59f0074 	ldr	r0, [pc, #116]	; 40c8 <.text+0x40c8>
    4050:	eafffff7 	b	4034 <BlockDevInit+0x130>
    4054:	e59f0070 	ldr	r0, [pc, #112]	; 40cc <.text+0x40cc>
    4058:	eafffff5 	b	4034 <BlockDevInit+0x130>
    405c:	e59f006c 	ldr	r0, [pc, #108]	; 40d0 <.text+0x40d0>
    4060:	eafffff3 	b	4034 <BlockDevInit+0x130>
    4064:	e59f0068 	ldr	r0, [pc, #104]	; 40d4 <.text+0x40d4>
    4068:	eafffff1 	b	4034 <BlockDevInit+0x130>
    406c:	e35100ff 	cmp	r1, #255	; 0xff
    4070:	9a000002 	bls	4080 <BlockDevInit+0x17c>
    4074:	e1a00421 	mov	r0, r1, lsr #8
    4078:	ebffff4e 	bl	3db8 <Resp8bError>
    407c:	ea000006 	b	409c <BlockDevInit+0x198>
    4080:	e59f0050 	ldr	r0, [pc, #80]	; 40d8 <.text+0x40d8>
    4084:	ebfff0d3 	bl	3d8 <rprintf>
    4088:	ea000003 	b	409c <BlockDevInit+0x198>
    408c:	e59f0048 	ldr	r0, [pc, #72]	; 40dc <.text+0x40dc>
    4090:	ebfff0d0 	bl	3d8 <rprintf>
    4094:	e1a00005 	mov	r0, r5
    4098:	ea000002 	b	40a8 <BlockDevInit+0x1a4>
    409c:	e59f003c 	ldr	r0, [pc, #60]	; 40e0 <.text+0x40e0>
    40a0:	ebfff0cc 	bl	3d8 <rprintf>
    40a4:	e3e00001 	mvn	r0, #1	; 0x1
    40a8:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    40ac:	e12fff1e 	bx	lr
    40b0:	00006078 	andeq	r6, r0, r8, ror r0
    40b4:	00006084 	andeq	r6, r0, r4, lsl #1
    40b8:	00006090 	muleq	r0, r0, r0
    40bc:	000060a4 	andeq	r6, r0, r4, lsr #1
    40c0:	000060cc 	andeq	r6, r0, ip, asr #1
    40c4:	000060f8 	streqd	r6, [r0], -r8
    40c8:	0000611c 	andeq	r6, r0, ip, lsl r1
    40cc:	0000615c 	andeq	r6, r0, ip, asr r1
    40d0:	00006178 	andeq	r6, r0, r8, ror r1
    40d4:	000061a4 	andeq	r6, r0, r4, lsr #3
    40d8:	000061c4 	andeq	r6, r0, r4, asr #3
    40dc:	000061f4 	streqd	r6, [r0], -r4
    40e0:	00006208 	andeq	r6, r0, r8, lsl #4

000040e4 <SPISetSpeed>:
/*****************************************************************************/

void SPISetSpeed(U8 speed)
{
    speed &= 0xFE;
    40e4:	e20000fe 	and	r0, r0, #254	; 0xfe
    if (speed < SPI_PRESCALE_MIN)
    40e8:	e3500007 	cmp	r0, #7	; 0x7
    {
        speed = SPI_PRESCALE_MIN;
    }
    SPI_PRESCALE_REG = speed;
    40ec:	e59f3008 	ldr	r3, [pc, #8]	; 40fc <.text+0x40fc>
    40f0:	93a00008 	movls	r0, #8	; 0x8
    40f4:	e5c3000c 	strb	r0, [r3, #12]
}
    40f8:	e12fff1e 	bx	lr
    40fc:	e0020000 	and	r0, r2, r0

00004100 <SPISend>:


void SPIInit(void)
{
    U8 i;
    //U32 j;

    rprintf("spiInit for SPI(0)\n");

    // setup GPIO
    PINSEL2 = 0;

	SPI_IODIR |= (1 << SPI_SCK_PIN) | (1 << SPI_MOSI_PIN);
    IODIR0 |= (1 << SPI_SS_PIN);			//Changed to Port0 for MP3 Player
    SPI_IODIR &= ~(1 << SPI_MISO_PIN);

    // reset Pin-Functions
    SPI_PINSEL &= ~((3 << SPI_SCK_FUNCBIT) | (3 << SPI_MISO_FUNCBIT) | (3 << SPI_MOSI_FUNCBIT));
    SPI_PINSEL |= ((1 << SPI_SCK_FUNCBIT) | (1 << SPI_MISO_FUNCBIT) | (1 << SPI_MOSI_FUNCBIT));

    /*        PINSEL0 &= ~(3 << (SPI_SS_FUNCBIT));*/
    /*        PINSEL0 |= (0 << (SPI_SS_FUNCBIT));*/

    // set Chip-Select high - unselect card
    UNSELECT_CARD();

    // enable SPI-Master
    S0SPCR = (1 << MSTR) | (0 << CPOL);   // TODO: check CPOL

    // low speed during init
    SPISetSpeed(254);

    /* Send 20 spi commands with card not selected */
    for (i = 0; i < 21; i++)
    {
        my_SPISend(0xff);
    }
}

/*****************************************************************************/

/*****************************************************************************/

U8 SPISend(U8 outgoing)
{
    U8 incoming;

    SELECT_CARD();
    4100:	e59f203c 	ldr	r2, [pc, #60]	; 4144 <.text+0x4144>
    4104:	e592300c 	ldr	r3, [r2, #12]
    4108:	e3833080 	orr	r3, r3, #128	; 0x80
    410c:	e582300c 	str	r3, [r2, #12]
    S0SPDR = outgoing;
    4110:	e59f3030 	ldr	r3, [pc, #48]	; 4148 <.text+0x4148>
    4114:	e20000ff 	and	r0, r0, #255	; 0xff
    4118:	e5c30008 	strb	r0, [r3, #8]
    while (!(S0SPSR & (1 << SPIF)));
    411c:	e59f2024 	ldr	r2, [pc, #36]	; 4148 <.text+0x4148>
    4120:	e5d23004 	ldrb	r3, [r2, #4]
    4124:	e3130080 	tst	r3, #128	; 0x80
    4128:	0afffffb 	beq	411c <SPISend+0x1c>
    incoming = S0SPDR;
    UNSELECT_CARD();
    412c:	e59f3010 	ldr	r3, [pc, #16]	; 4144 <.text+0x4144>
    4130:	e5d20008 	ldrb	r0, [r2, #8]
    4134:	e5932004 	ldr	r2, [r3, #4]
    4138:	e3822080 	orr	r2, r2, #128	; 0x80
    413c:	e5832004 	str	r2, [r3, #4]

    return incoming;
}
    4140:	e12fff1e 	bx	lr
    4144:	e0028000 	and	r8, r2, r0
    4148:	e0020000 	and	r0, r2, r0

0000414c <SPISendN>:

void SPISendN(U8 * pbBuf, int iLen)
{
    int i;

    SELECT_CARD();
    414c:	e59f204c 	ldr	r2, [pc, #76]	; 41a0 <.text+0x41a0>
    4150:	e592300c 	ldr	r3, [r2, #12]
    4154:	e3a0c000 	mov	ip, #0	; 0x0
    4158:	e3833080 	orr	r3, r3, #128	; 0x80
    415c:	e582300c 	str	r3, [r2, #12]
    4160:	ea000007 	b	4184 <SPISendN+0x38>
    for (i = 0; i < iLen; i++)
    {
        S0SPDR = pbBuf[i];
    4164:	e7d0200c 	ldrb	r2, [r0, ip]
    4168:	e59f3034 	ldr	r3, [pc, #52]	; 41a4 <.text+0x41a4>
    416c:	e5c32008 	strb	r2, [r3, #8]
        while (!(S0SPSR & (1 << SPIF)));
    4170:	e59f302c 	ldr	r3, [pc, #44]	; 41a4 <.text+0x41a4>
    4174:	e5d33004 	ldrb	r3, [r3, #4]
    4178:	e3130080 	tst	r3, #128	; 0x80
    417c:	0afffffb 	beq	4170 <SPISendN+0x24>
    4180:	e28cc001 	add	ip, ip, #1	; 0x1
    4184:	e15c0001 	cmp	ip, r1
    4188:	bafffff5 	blt	4164 <SPISendN+0x18>
    }
    UNSELECT_CARD();
    418c:	e59f200c 	ldr	r2, [pc, #12]	; 41a0 <.text+0x41a0>
    4190:	e5923004 	ldr	r3, [r2, #4]
    4194:	e3833080 	orr	r3, r3, #128	; 0x80
    4198:	e5823004 	str	r3, [r2, #4]
}
    419c:	e12fff1e 	bx	lr
    41a0:	e0028000 	and	r8, r2, r0
    41a4:	e0020000 	and	r0, r2, r0

000041a8 <SPIRecvN>:

void SPIRecvN(U8 * pbBuf, int iLen)
{
    int i;

    SELECT_CARD();
    41a8:	e59f2054 	ldr	r2, [pc, #84]	; 4204 <.text+0x4204>
    41ac:	e592300c 	ldr	r3, [r2, #12]
    41b0:	e3a0c000 	mov	ip, #0	; 0x0
    41b4:	e3833080 	orr	r3, r3, #128	; 0x80
    41b8:	e582300c 	str	r3, [r2, #12]
    41bc:	ea000009 	b	41e8 <SPIRecvN+0x40>
    for (i = 0; i < iLen; i++)
    {
        S0SPDR = 0xFF;
    41c0:	e59f3040 	ldr	r3, [pc, #64]	; 4208 <.text+0x4208>
    41c4:	e3e02000 	mvn	r2, #0	; 0x0
    41c8:	e5c32008 	strb	r2, [r3, #8]
        while (!(S0SPSR & (1 << SPIF)));
    41cc:	e59f2034 	ldr	r2, [pc, #52]	; 4208 <.text+0x4208>
    41d0:	e5d23004 	ldrb	r3, [r2, #4]
    41d4:	e3130080 	tst	r3, #128	; 0x80
    41d8:	0afffffb 	beq	41cc <SPIRecvN+0x24>
        pbBuf[i] = S0SPDR;
    41dc:	e5d23008 	ldrb	r3, [r2, #8]
    41e0:	e7c0300c 	strb	r3, [r0, ip]
    41e4:	e28cc001 	add	ip, ip, #1	; 0x1
    41e8:	e15c0001 	cmp	ip, r1
    41ec:	bafffff3 	blt	41c0 <SPIRecvN+0x18>
    }
    UNSELECT_CARD();
    41f0:	e59f200c 	ldr	r2, [pc, #12]	; 4204 <.text+0x4204>
    41f4:	e5923004 	ldr	r3, [r2, #4]
    41f8:	e3833080 	orr	r3, r3, #128	; 0x80
    41fc:	e5823004 	str	r3, [r2, #4]
}
    4200:	e12fff1e 	bx	lr
    4204:	e0028000 	and	r8, r2, r0
    4208:	e0020000 	and	r0, r2, r0

0000420c <SPIInit>:
    420c:	e59f00a8 	ldr	r0, [pc, #168]	; 42bc <.text+0x42bc>
    4210:	e52de004 	str	lr, [sp, #-4]!
    4214:	ebfff06f 	bl	3d8 <rprintf>
    4218:	e59f10a0 	ldr	r1, [pc, #160]	; 42c0 <.text+0x42c0>
    421c:	e3a00000 	mov	r0, #0	; 0x0
    4220:	e5810014 	str	r0, [r1, #20]
    4224:	e59f2098 	ldr	r2, [pc, #152]	; 42c4 <.text+0x42c4>
    4228:	e5923008 	ldr	r3, [r2, #8]
    422c:	e3833050 	orr	r3, r3, #80	; 0x50
    4230:	e5823008 	str	r3, [r2, #8]
    4234:	e5923008 	ldr	r3, [r2, #8]
    4238:	e3833080 	orr	r3, r3, #128	; 0x80
    423c:	e5823008 	str	r3, [r2, #8]
    4240:	e5923008 	ldr	r3, [r2, #8]
    4244:	e3c33020 	bic	r3, r3, #32	; 0x20
    4248:	e5823008 	str	r3, [r2, #8]
    424c:	e5913000 	ldr	r3, [r1]
    4250:	e3c33c3f 	bic	r3, r3, #16128	; 0x3f00
    4254:	e5813000 	str	r3, [r1]
    4258:	e5913000 	ldr	r3, [r1]
    425c:	e3833c15 	orr	r3, r3, #5376	; 0x1500
    4260:	e5813000 	str	r3, [r1]
    4264:	e5923004 	ldr	r3, [r2, #4]
    4268:	e3833080 	orr	r3, r3, #128	; 0x80
    426c:	e5823004 	str	r3, [r2, #4]
    4270:	e2411903 	sub	r1, r1, #49152	; 0xc000
    4274:	e3a03020 	mov	r3, #32	; 0x20
    4278:	e5c13000 	strb	r3, [r1]
    427c:	e3e03001 	mvn	r3, #1	; 0x1
    4280:	e5c1300c 	strb	r3, [r1, #12]
    4284:	e59f303c 	ldr	r3, [pc, #60]	; 42c8 <.text+0x42c8>
    4288:	e3e02000 	mvn	r2, #0	; 0x0
    428c:	e5c32008 	strb	r2, [r3, #8]
    4290:	e59f2030 	ldr	r2, [pc, #48]	; 42c8 <.text+0x42c8>
    4294:	e5d23004 	ldrb	r3, [r2, #4]
    4298:	e3130080 	tst	r3, #128	; 0x80
    429c:	0afffffb 	beq	4290 <SPIInit+0x84>
    42a0:	e2803001 	add	r3, r0, #1	; 0x1
    42a4:	e20300ff 	and	r0, r3, #255	; 0xff
    42a8:	e3500015 	cmp	r0, #21	; 0x15
    42ac:	e5d23008 	ldrb	r3, [r2, #8]
    42b0:	1afffff3 	bne	4284 <SPIInit+0x78>
    42b4:	e49de004 	ldr	lr, [sp], #4
    42b8:	e12fff1e 	bx	lr
    42bc:	0000623c 	andeq	r6, r0, ip, lsr r2
    42c0:	e002c000 	and	ip, r2, r0
    42c4:	e0028000 	and	r8, r2, r0
    42c8:	e0020000 	and	r0, r2, r0

000042cc <HandleUsbReset>:
{
	if (bDevStatus & DEV_STATUS_RESET) {
		DBG("\n!");
	}
}
    42cc:	e12fff1e 	bx	lr

000042d0 <USBInit>:


/**
	Initialises the USB hardware and sets up the USB stack by
	installing default callbacks.
	
	@return TRUE if initialisation was successful
 */
BOOL USBInit(void)
{
    42d0:	e92d4010 	stmdb	sp!, {r4, lr}
	// init hardware
	USBHwInit();
	
	// register bus reset handler
	USBHwRegisterDevIntHandler(HandleUsbReset);
	
	// register control transfer handler on EP0
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
    42d4:	e59f4054 	ldr	r4, [pc, #84]	; 4330 <.text+0x4330>
    42d8:	eb00013d 	bl	47d4 <USBHwInit>
    42dc:	e59f0050 	ldr	r0, [pc, #80]	; 4334 <.text+0x4334>
    42e0:	eb000074 	bl	44b8 <USBHwRegisterDevIntHandler>
    42e4:	e1a01004 	mov	r1, r4
    42e8:	e3a00000 	mov	r0, #0	; 0x0
    42ec:	eb00005e 	bl	446c <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(0x80, USBHandleControlTransfer);
    42f0:	e1a01004 	mov	r1, r4
    42f4:	e3a00080 	mov	r0, #128	; 0x80
    42f8:	eb00005b 	bl	446c <USBHwRegisterEPIntHandler>
	
	// setup control endpoints
	USBHwEPConfig(0x00, MAX_PACKET_SIZE0);
    42fc:	e3a00000 	mov	r0, #0	; 0x0
    4300:	e3a01040 	mov	r1, #64	; 0x40
    4304:	eb000041 	bl	4410 <USBHwEPConfig>
	USBHwEPConfig(0x80, MAX_PACKET_SIZE0);
    4308:	e3a00080 	mov	r0, #128	; 0x80
    430c:	e3a01040 	mov	r1, #64	; 0x40
    4310:	eb00003e 	bl	4410 <USBHwEPConfig>
	
	// register standard request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_STANDARD, USBHandleStandardRequest, abStdReqData);
    4314:	e3a00000 	mov	r0, #0	; 0x0
    4318:	e59f1018 	ldr	r1, [pc, #24]	; 4338 <.text+0x4338>
    431c:	e59f2018 	ldr	r2, [pc, #24]	; 433c <.text+0x433c>
    4320:	eb00016c 	bl	48d8 <USBRegisterRequestHandler>

	return TRUE;
}
    4324:	e3a00001 	mov	r0, #1	; 0x1
    4328:	e8bd4010 	ldmia	sp!, {r4, lr}
    432c:	e12fff1e 	bx	lr
    4330:	0000495c 	andeq	r4, r0, ip, asr r9
    4334:	000042cc 	andeq	r4, r0, ip, asr #5
    4338:	00004b4c 	andeq	r4, r0, ip, asr #22
    433c:	40000f28 	andmi	r0, r0, r8, lsr #30

00004340 <USBHwCmd>:
		
	@param [in]	bCmd		Command to send
 */
static void USBHwCmd(U8 bCmd)
{
    4340:	e1a00800 	mov	r0, r0, lsl #16
	// clear CDFULL/CCEMTY
	USBDevIntClr = CDFULL | CCEMTY;
    4344:	e59f202c 	ldr	r2, [pc, #44]	; 4378 <.text+0x4378>
	// write command code
	USBCmdCode = 0x00000500 | (bCmd << 16);
    4348:	e20008ff 	and	r0, r0, #16711680	; 0xff0000
    434c:	e3800c05 	orr	r0, r0, #1280	; 0x500
    4350:	e3a03030 	mov	r3, #48	; 0x30
    4354:	e5823008 	str	r3, [r2, #8]
    4358:	e5820010 	str	r0, [r2, #16]
    435c:	e59f2014 	ldr	r2, [pc, #20]	; 4378 <.text+0x4378>
    4360:	e5923000 	ldr	r3, [r2]
    4364:	e2033010 	and	r3, r3, #16	; 0x10
    4368:	e3530010 	cmp	r3, #16	; 0x10
    436c:	1afffffa 	bne	435c <USBHwCmd+0x1c>
    4370:	e5823008 	str	r3, [r2, #8]
	Wait4DevInt(CCEMTY);
}
    4374:	e12fff1e 	bx	lr
    4378:	e0090000 	and	r0, r9, r0

0000437c <USBHwCmdWrite>:


/**
	Local function to send a command + data to the USB protocol engine
		
	@param [in]	bCmd		Command to send
	@param [in]	bData		Data to send
 */
static void USBHwCmdWrite(U8 bCmd, U16 bData)
{
    437c:	e92d4010 	stmdb	sp!, {r4, lr}
    4380:	e1a04801 	mov	r4, r1, lsl #16
    4384:	e20000ff 	and	r0, r0, #255	; 0xff
    4388:	e1a04824 	mov	r4, r4, lsr #16
	// write command code
	USBHwCmd(bCmd);
    438c:	ebffffeb 	bl	4340 <USBHwCmd>

	// write command data
	USBCmdCode = 0x00000100 | (bData << 16);
    4390:	e1a04804 	mov	r4, r4, lsl #16
    4394:	e59f3024 	ldr	r3, [pc, #36]	; 43c0 <.text+0x43c0>
    4398:	e3844c01 	orr	r4, r4, #256	; 0x100
    439c:	e5834010 	str	r4, [r3, #16]
    43a0:	e59f2018 	ldr	r2, [pc, #24]	; 43c0 <.text+0x43c0>
    43a4:	e5923000 	ldr	r3, [r2]
    43a8:	e2033010 	and	r3, r3, #16	; 0x10
    43ac:	e3530010 	cmp	r3, #16	; 0x10
    43b0:	1afffffa 	bne	43a0 <USBHwCmdWrite+0x24>
    43b4:	e5823008 	str	r3, [r2, #8]
	Wait4DevInt(CCEMTY);
}
    43b8:	e8bd4010 	ldmia	sp!, {r4, lr}
    43bc:	e12fff1e 	bx	lr
    43c0:	e0090000 	and	r0, r9, r0

000043c4 <USBHwCmdRead>:


/**
	Local function to send a command to the USB protocol engine and read data
		
	@param [in]	bCmd		Command to send

	@return the data
 */
static U8 USBHwCmdRead(U8 bCmd)
{
    43c4:	e92d4010 	stmdb	sp!, {r4, lr}
    43c8:	e20040ff 	and	r4, r0, #255	; 0xff
	// write command code
	USBHwCmd(bCmd);
    43cc:	e1a00004 	mov	r0, r4
    43d0:	ebffffda 	bl	4340 <USBHwCmd>
	
	// get data
	USBCmdCode = 0x00000200 | (bCmd << 16);
    43d4:	e1a04804 	mov	r4, r4, lsl #16
    43d8:	e59f302c 	ldr	r3, [pc, #44]	; 440c <.text+0x440c>
    43dc:	e3844c02 	orr	r4, r4, #512	; 0x200
    43e0:	e5834010 	str	r4, [r3, #16]
    43e4:	e59f2020 	ldr	r2, [pc, #32]	; 440c <.text+0x440c>
    43e8:	e5923000 	ldr	r3, [r2]
    43ec:	e2033020 	and	r3, r3, #32	; 0x20
    43f0:	e3530020 	cmp	r3, #32	; 0x20
    43f4:	1afffffa 	bne	43e4 <USBHwCmdRead+0x20>
    43f8:	e5823008 	str	r3, [r2, #8]
	Wait4DevInt(CDFULL);
	return USBCmdData;
    43fc:	e5920014 	ldr	r0, [r2, #20]
    4400:	e20000ff 	and	r0, r0, #255	; 0xff
}
    4404:	e8bd4010 	ldmia	sp!, {r4, lr}
    4408:	e12fff1e 	bx	lr
    440c:	e0090000 	and	r0, r9, r0

00004410 <USBHwEPConfig>:


/**
	'Realizes' an endpoint, meaning that buffer space is reserved for
	it. An endpoint needs to be realised before it can be used.
		
	From experiments, it appears that a USB reset causes USBReEP to
	re-initialise to 3 (= just the control endpoints).
	However, a USB bus reset does not disturb the USBMaxPSize settings.
		
	@param [in]	idx			Endpoint index
	@param [in] wMaxPSize	Maximum packet size for this endpoint
 */
static void USBHwEPRealize(int idx, U16 wMaxPSize)
{
	USBReEP |= (1 << idx);
    4410:	e59fc050 	ldr	ip, [pc, #80]	; 4468 <.text+0x4468>
	USBEpInd = idx;
	USBMaxPSize = wMaxPSize;
	Wait4DevInt(EP_RLZED);
}


/**
	Enables or disables an endpoint
		
	@param [in]	idx		Endpoint index
	@param [in]	fEnable	TRUE to enable, FALSE to disable
 */
static void USBHwEPEnable(int idx, BOOL fEnable)
{
	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
}


/**
	Configures an endpoint and enables it
		
	@param [in]	bEP				Endpoint number
	@param [in]	wMaxPacketSize	Maximum packet size for this EP
 */
void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)
{
	int idx;
	
	idx = EP2IDX(bEP);
    4414:	e2003080 	and	r3, r0, #128	; 0x80
    4418:	e59c2044 	ldr	r2, [ip, #68]
    441c:	e1a033c3 	mov	r3, r3, asr #7
    4420:	e200000f 	and	r0, r0, #15	; 0xf
    4424:	e1830080 	orr	r0, r3, r0, lsl #1
    4428:	e3a03001 	mov	r3, #1	; 0x1
    442c:	e1822013 	orr	r2, r2, r3, lsl r0
    4430:	e1a01801 	mov	r1, r1, lsl #16
    4434:	e1a01821 	mov	r1, r1, lsr #16
    4438:	e58c2044 	str	r2, [ip, #68]
    443c:	e58c0048 	str	r0, [ip, #72]
    4440:	e58c104c 	str	r1, [ip, #76]
    4444:	e59f201c 	ldr	r2, [pc, #28]	; 4468 <.text+0x4468>
    4448:	e5923000 	ldr	r3, [r2]
    444c:	e2033c01 	and	r3, r3, #256	; 0x100
    4450:	e3530c01 	cmp	r3, #256	; 0x100
    4454:	1afffffa 	bne	4444 <USBHwEPConfig+0x34>
    4458:	e3800040 	orr	r0, r0, #64	; 0x40
    445c:	e3a01000 	mov	r1, #0	; 0x0
    4460:	e5823008 	str	r3, [r2, #8]
    4464:	eaffffc4 	b	437c <USBHwCmdWrite>
    4468:	e0090000 	and	r0, r9, r0

0000446c <USBHwRegisterEPIntHandler>:
	
	// realise EP
	USBHwEPRealize(idx, wMaxPacketSize);

	// enable EP
	USBHwEPEnable(idx, TRUE);
}


/**
	Registers an endpoint event callback
		
	@param [in]	bEP				Endpoint number
	@param [in]	pfnHandler		Callback function
 */
void USBHwRegisterEPIntHandler(U8 bEP, TFnEPIntHandler *pfnHandler)
{
    446c:	e52de004 	str	lr, [sp, #-4]!
	int idx;
	
	idx = EP2IDX(bEP);

	ASSERT(idx<32);

	/* add handler to list of EP handlers */
	_apfnEPIntHandlers[idx / 2] = pfnHandler;
	
	/* enable EP interrupt */
	USBEpIntEn |= (1 << idx);
    4470:	e59fe038 	ldr	lr, [pc, #56]	; 44b0 <.text+0x44b0>
    4474:	e2003080 	and	r3, r0, #128	; 0x80
    4478:	e59ec034 	ldr	ip, [lr, #52]
    447c:	e200000f 	and	r0, r0, #15	; 0xf
    4480:	e1a033c3 	mov	r3, r3, asr #7
    4484:	e1833080 	orr	r3, r3, r0, lsl #1
    4488:	e3a02001 	mov	r2, #1	; 0x1
    448c:	e18cc312 	orr	ip, ip, r2, lsl r3
    4490:	e58ec034 	str	ip, [lr, #52]
	USBDevIntEn |= EP_SLOW;
    4494:	e59e3004 	ldr	r3, [lr, #4]
    4498:	e59f2014 	ldr	r2, [pc, #20]	; 44b4 <.text+0x44b4>
    449c:	e3833004 	orr	r3, r3, #4	; 0x4
    44a0:	e7821100 	str	r1, [r2, r0, lsl #2]
    44a4:	e58e3004 	str	r3, [lr, #4]
	
	DBG("Registered handler for EP 0x%x\n", bEP);
}
    44a8:	e49de004 	ldr	lr, [sp], #4
    44ac:	e12fff1e 	bx	lr
    44b0:	e0090000 	and	r0, r9, r0
    44b4:	40000f38 	andmi	r0, r0, r8, lsr pc

000044b8 <USBHwRegisterDevIntHandler>:


/**
	Registers an device status callback
		
	@param [in]	pfnHandler	Callback function
 */
void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
{
	_pfnDevIntHandler = pfnHandler;
	
	// enable device interrupt
	USBDevIntEn |= DEV_STAT;
    44b8:	e59f3014 	ldr	r3, [pc, #20]	; 44d4 <.text+0x44d4>
    44bc:	e5932004 	ldr	r2, [r3, #4]
    44c0:	e59f1010 	ldr	r1, [pc, #16]	; 44d8 <.text+0x44d8>
    44c4:	e3822008 	orr	r2, r2, #8	; 0x8
    44c8:	e5810000 	str	r0, [r1]
    44cc:	e5832004 	str	r2, [r3, #4]

	DBG("Registered handler for device status\n");
}
    44d0:	e12fff1e 	bx	lr
    44d4:	e0090000 	and	r0, r9, r0
    44d8:	40000f34 	andmi	r0, r0, r4, lsr pc

000044dc <USBHwRegisterFrameHandler>:


/**
	Registers the frame callback
		
	@param [in]	pfnHandler	Callback function
 */
void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
{
	_pfnFrameHandler = pfnHandler;
	
	// enable device interrupt
	USBDevIntEn |= FRAME;
    44dc:	e59f3014 	ldr	r3, [pc, #20]	; 44f8 <.text+0x44f8>
    44e0:	e5932004 	ldr	r2, [r3, #4]
    44e4:	e59f1010 	ldr	r1, [pc, #16]	; 44fc <.text+0x44fc>
    44e8:	e3822001 	orr	r2, r2, #1	; 0x1
    44ec:	e5810000 	str	r0, [r1]
    44f0:	e5832004 	str	r2, [r3, #4]

	DBG("Registered handler for frame\n");
}
    44f4:	e12fff1e 	bx	lr
    44f8:	e0090000 	and	r0, r9, r0
    44fc:	40000f30 	andmi	r0, r0, r0, lsr pc

00004500 <USBHwSetAddress>:


/**
	Sets the USB address.
		
	@param [in]	bAddr		Device address to set
 */
void USBHwSetAddress(U8 bAddr)
{
    4500:	e20010ff 	and	r1, r0, #255	; 0xff
	USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
    4504:	e3811080 	orr	r1, r1, #128	; 0x80
    4508:	e3a000d0 	mov	r0, #208	; 0xd0
    450c:	eaffff9a 	b	437c <USBHwCmdWrite>

00004510 <USBHwConnect>:
}


/**
	Connects or disconnects from the USB bus
		
	@param [in]	fConnect	If TRUE, connect, otherwise disconnect
 */
void USBHwConnect(BOOL fConnect)
{
	USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
    4510:	e2501000 	subs	r1, r0, #0	; 0x0
    4514:	13a01001 	movne	r1, #1	; 0x1
    4518:	e3a000fe 	mov	r0, #254	; 0xfe
    451c:	eaffff96 	b	437c <USBHwCmdWrite>

00004520 <USBHwNakIntEnable>:

}


/**
	Enables interrupt on NAK condition
		
	For IN endpoints a NAK is generated when the host wants to read data
	from the device, but none is available in the endpoint buffer.
	For OUT endpoints a NAK is generated when the host wants to write data
	to the device, but the endpoint buffer is still full.
	
	The endpoint interrupt handlers can distinguish regular (ACK) interrupts
	from NAK interrupt by checking the bits in their bEPStatus argument.
	
	@param [in]	bIntBits	Bitmap indicating which NAK interrupts to enable
 */
void USBHwNakIntEnable(U8 bIntBits)
{
    4520:	e20010ff 	and	r1, r0, #255	; 0xff
	USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
    4524:	e3a000f3 	mov	r0, #243	; 0xf3
    4528:	eaffff93 	b	437c <USBHwCmdWrite>

0000452c <USBHwEPGetStatus>:
}


/**
	Gets the status from a specific endpoint.
		
	@param [in]	bEP		Endpoint number
	@return Endpoint status byte (containing EP_STATUS_xxx bits)
 */
U8	USBHwEPGetStatus(U8 bEP)
{
    452c:	e1a03000 	mov	r3, r0
	int idx = EP2IDX(bEP);

	return USBHwCmdRead(CMD_EP_SELECT | idx);
    4530:	e2000080 	and	r0, r0, #128	; 0x80
    4534:	e203300f 	and	r3, r3, #15	; 0xf
    4538:	e1a003c0 	mov	r0, r0, asr #7
    453c:	e52de004 	str	lr, [sp, #-4]!
    4540:	e1800083 	orr	r0, r0, r3, lsl #1
    4544:	ebffff9e 	bl	43c4 <USBHwCmdRead>
}
    4548:	e49de004 	ldr	lr, [sp], #4
    454c:	e12fff1e 	bx	lr

00004550 <USBHwEPStall>:


/**
	Sets the stalled property of an endpoint
		
	@param [in]	bEP		Endpoint number
	@param [in]	fStall	TRUE to stall, FALSE to unstall
 */
void USBHwEPStall(U8 bEP, BOOL fStall)
{
	int idx = EP2IDX(bEP);

	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
    4550:	e2003080 	and	r3, r0, #128	; 0x80
    4554:	e1a033c3 	mov	r3, r3, asr #7
    4558:	e200000f 	and	r0, r0, #15	; 0xf
    455c:	e1833080 	orr	r3, r3, r0, lsl #1
    4560:	e2511000 	subs	r1, r1, #0	; 0x0
    4564:	13a01001 	movne	r1, #1	; 0x1
    4568:	e3830040 	orr	r0, r3, #64	; 0x40
    456c:	eaffff82 	b	437c <USBHwCmdWrite>

00004570 <USBHwEPWrite>:
}


/**
	Writes data to an endpoint buffer
		
	@param [in]	bEP		Endpoint number
	@param [in]	pbBuf	Endpoint data
	@param [in]	iLen	Number of bytes to write
			
	@return TRUE if the data was successfully written or <0 in case of error.
*/
int USBHwEPWrite(U8 bEP, U8 *pbBuf, int iLen)
{
    4570:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	int idx;
	
	idx = EP2IDX(bEP);
    4574:	e200400f 	and	r4, r0, #15	; 0xf
	
	// set write enable for specific endpoint
	USBCtrl = WR_EN | ((bEP & 0xF) << 2);
    4578:	e59fc074 	ldr	ip, [pc, #116]	; 45f4 <.text+0x45f4>
    457c:	e1a03104 	mov	r3, r4, lsl #2
    4580:	e3833002 	orr	r3, r3, #2	; 0x2
    4584:	e1a05002 	mov	r5, r2
	
	// set packet length
	USBTxPLen = iLen;
    4588:	e1a0e001 	mov	lr, r1
    458c:	e20000ff 	and	r0, r0, #255	; 0xff
    4590:	e58c3028 	str	r3, [ip, #40]
    4594:	e58c2024 	str	r2, [ip, #36]
    4598:	ea000008 	b	45c0 <USBHwEPWrite+0x50>
	
	// write data
	while (USBCtrl & WR_EN) {
		USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
    459c:	e55e3002 	ldrb	r3, [lr, #-2]
    45a0:	e55e2001 	ldrb	r2, [lr, #-1]
    45a4:	e55e1004 	ldrb	r1, [lr, #-4]
    45a8:	e1a03803 	mov	r3, r3, lsl #16
    45ac:	e1833c02 	orr	r3, r3, r2, lsl #24
    45b0:	e55e2003 	ldrb	r2, [lr, #-3]
    45b4:	e1833001 	orr	r3, r3, r1
    45b8:	e1833402 	orr	r3, r3, r2, lsl #8
    45bc:	e58c301c 	str	r3, [ip, #28]
    45c0:	e59fc02c 	ldr	ip, [pc, #44]	; 45f4 <.text+0x45f4>
    45c4:	e59c3028 	ldr	r3, [ip, #40]
    45c8:	e3130002 	tst	r3, #2	; 0x2
    45cc:	e28ee004 	add	lr, lr, #4	; 0x4
    45d0:	1afffff1 	bne	459c <USBHwEPWrite+0x2c>
		pbBuf += 4;
	}

	// select endpoint and validate buffer
	USBHwCmd(CMD_EP_SELECT | idx);
    45d4:	e1a003a0 	mov	r0, r0, lsr #7
    45d8:	e1800084 	orr	r0, r0, r4, lsl #1
    45dc:	ebffff57 	bl	4340 <USBHwCmd>
	USBHwCmd(CMD_EP_VALIDATE_BUFFER);
    45e0:	e3a000fa 	mov	r0, #250	; 0xfa
    45e4:	ebffff55 	bl	4340 <USBHwCmd>
	
	return iLen;
}
    45e8:	e1a00005 	mov	r0, r5
    45ec:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    45f0:	e12fff1e 	bx	lr
    45f4:	e0090000 	and	r0, r9, r0

000045f8 <USBHwEPRead>:


/**
	Reads data from an endpoint buffer
		
	@param [in]	bEP		Endpoint number
	@param [in]	pbBuf	Endpoint data
	@param [in]	iMaxLen	Maximum number of bytes to read
			
	@return the number of bytes available in the EP (possibly more than iMaxLen),
	or <0 in case of error.
 */
int USBHwEPRead(U8 bEP, U8 *pbBuf, int iMaxLen)
{
    45f8:	e92d4010 	stmdb	sp!, {r4, lr}
	int i, idx;
	U32	dwData, dwLen;
	
	idx = EP2IDX(bEP);
    45fc:	e200e00f 	and	lr, r0, #15	; 0xf
	
	// set read enable bit for specific endpoint
	USBCtrl = RD_EN | ((bEP & 0xF) << 2);
    4600:	e1a0310e 	mov	r3, lr, lsl #2
    4604:	e59fc08c 	ldr	ip, [pc, #140]	; 4698 <.text+0x4698>
    4608:	e3833001 	orr	r3, r3, #1	; 0x1
    460c:	e58c3028 	str	r3, [ip, #40]
    4610:	e20000ff 	and	r0, r0, #255	; 0xff
	
	// wait for PKT_RDY
	do {
		dwLen = USBRxPLen;
    4614:	e59f307c 	ldr	r3, [pc, #124]	; 4698 <.text+0x4698>
    4618:	e5933020 	ldr	r3, [r3, #32]
	} while ((dwLen & PKT_RDY) == 0);
    461c:	e3130b02 	tst	r3, #2048	; 0x800
    4620:	0afffffb 	beq	4614 <USBHwEPRead+0x1c>
	
	// packet valid?
	if ((dwLen & DV) == 0) {
    4624:	e3130b01 	tst	r3, #1024	; 0x400
    4628:	03e04000 	mvneq	r4, #0	; 0x0
    462c:	0a000016 	beq	468c <USBHwEPRead+0x94>
		return -1;
	}
	
	// get length
	dwLen &= PKT_LNGTH_MASK;
    4630:	e1a0cb03 	mov	ip, r3, lsl #22
    4634:	e3a04000 	mov	r4, #0	; 0x0
    4638:	e1a0cb2c 	mov	ip, ip, lsr #22
    463c:	e1a03004 	mov	r3, r4
    4640:	ea000007 	b	4664 <USBHwEPRead+0x6c>
	
	// get data
	dwData = 0;
	for (i = 0; i < dwLen; i++) {
		if ((i % 4) == 0) {
    4644:	e3140003 	tst	r4, #3	; 0x3
			dwData = USBRxData;
    4648:	059f3048 	ldreq	r3, [pc, #72]	; 4698 <.text+0x4698>
    464c:	05933018 	ldreq	r3, [r3, #24]
		}
		if ((pbBuf != NULL) && (i < iMaxLen)) {
    4650:	e3510000 	cmp	r1, #0	; 0x0
    4654:	11540002 	cmpne	r4, r2
			pbBuf[i] = dwData & 0xFF;
    4658:	b7c43001 	strltb	r3, [r4, r1]
		}
		dwData >>= 8;
    465c:	e1a03423 	mov	r3, r3, lsr #8
    4660:	e2844001 	add	r4, r4, #1	; 0x1
    4664:	e154000c 	cmp	r4, ip
    4668:	1afffff5 	bne	4644 <USBHwEPRead+0x4c>
	}

	// make sure RD_EN is clear
	USBCtrl = 0;
    466c:	e59f3024 	ldr	r3, [pc, #36]	; 4698 <.text+0x4698>
    4670:	e3a02000 	mov	r2, #0	; 0x0

	// select endpoint and clear buffer
	USBHwCmd(CMD_EP_SELECT | idx);
    4674:	e1a003a0 	mov	r0, r0, lsr #7
    4678:	e180008e 	orr	r0, r0, lr, lsl #1
    467c:	e5832028 	str	r2, [r3, #40]
    4680:	ebffff2e 	bl	4340 <USBHwCmd>
	USBHwCmd(CMD_EP_CLEAR_BUFFER);
    4684:	e3a000f2 	mov	r0, #242	; 0xf2
    4688:	ebffff2c 	bl	4340 <USBHwCmd>
	
	return dwLen;
}
    468c:	e1a00004 	mov	r0, r4
    4690:	e8bd4010 	ldmia	sp!, {r4, lr}
    4694:	e12fff1e 	bx	lr
    4698:	e0090000 	and	r0, r9, r0

0000469c <USBHwConfigDevice>:


/**
	Sets the 'configured' state.
		
	All registered endpoints are 'realised' and enabled, and the
	'configured' bit is set in the device status register.
		
	@param [in]	fConfigured	If TRUE, configure device, else unconfigure
 */
void USBHwConfigDevice(BOOL fConfigured)
{
	// set configured bit
	USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
    469c:	e2501000 	subs	r1, r0, #0	; 0x0
    46a0:	13a01001 	movne	r1, #1	; 0x1
    46a4:	e3a000d8 	mov	r0, #216	; 0xd8
    46a8:	eaffff33 	b	437c <USBHwCmdWrite>

000046ac <USBHwISR>:
}


/**
	USB interrupt handler
		
	@todo Get all 11 bits of frame number instead of just 8

	Endpoint interrupts are mapped to the slow interrupt
 */
void USBHwISR(void)
{
	U32	dwStatus;
	U32 dwIntBit;
	U8	bEPStat, bDevStat, bStat;
	int i;
	U16	wFrame;

// LED9 monitors total time in interrupt routine
DEBUG_LED_ON(9);

	// handle device interrupts
	dwStatus = USBDevIntSt;
    46ac:	e59f2110 	ldr	r2, [pc, #272]	; 47c4 <.text+0x47c4>
    46b0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    46b4:	e5925000 	ldr	r5, [r2]
	
	// frame interrupt
	if (dwStatus & FRAME) {
    46b8:	e3150001 	tst	r5, #1	; 0x1
    46bc:	0a00000b 	beq	46f0 <USBHwISR+0x44>
		// clear int
		USBDevIntClr = FRAME;
		// call handler
		if (_pfnFrameHandler != NULL) {
    46c0:	e59f3100 	ldr	r3, [pc, #256]	; 47c8 <.text+0x47c8>
    46c4:	e5934000 	ldr	r4, [r3]
    46c8:	e3a03001 	mov	r3, #1	; 0x1
    46cc:	e3540000 	cmp	r4, #0	; 0x0
    46d0:	e5823008 	str	r3, [r2, #8]
    46d4:	0a000005 	beq	46f0 <USBHwISR+0x44>
			wFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);
    46d8:	e3a000f5 	mov	r0, #245	; 0xf5
    46dc:	ebffff38 	bl	43c4 <USBHwCmdRead>
			_pfnFrameHandler(wFrame);
    46e0:	e1a00800 	mov	r0, r0, lsl #16
    46e4:	e1a00820 	mov	r0, r0, lsr #16
    46e8:	e1a0e00f 	mov	lr, pc
    46ec:	e12fff14 	bx	r4
		}
	}
	
	// device status interrupt
	if (dwStatus & DEV_STAT) {
    46f0:	e3150008 	tst	r5, #8	; 0x8
    46f4:	0a00000c 	beq	472c <USBHwISR+0x80>
		/*	Clear DEV_STAT interrupt before reading DEV_STAT register.
			This prevents corrupted device status reads, see
			LPC2148 User manual revision 2, 25 july 2006.
		*/
		USBDevIntClr = DEV_STAT;
    46f8:	e59f30c4 	ldr	r3, [pc, #196]	; 47c4 <.text+0x47c4>
    46fc:	e3a02008 	mov	r2, #8	; 0x8
		bDevStat = USBHwCmdRead(CMD_DEV_STATUS);
    4700:	e3a000fe 	mov	r0, #254	; 0xfe
    4704:	e5832008 	str	r2, [r3, #8]
    4708:	ebffff2d 	bl	43c4 <USBHwCmdRead>
		if (bDevStat & (CON_CH | SUS_CH | RST)) {
    470c:	e310001a 	tst	r0, #26	; 0x1a
    4710:	0a000005 	beq	472c <USBHwISR+0x80>
			// convert device status into something HW independent
			bStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |
					((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |
					((bDevStat & RST) ? DEV_STATUS_RESET : 0);
			// call handler
			if (_pfnDevIntHandler != NULL) {
    4714:	e59f30b0 	ldr	r3, [pc, #176]	; 47cc <.text+0x47cc>
    4718:	e5933000 	ldr	r3, [r3]
    471c:	e3530000 	cmp	r3, #0	; 0x0
DEBUG_LED_ON(8);		
				_pfnDevIntHandler(bStat);
    4720:	12000015 	andne	r0, r0, #21	; 0x15
    4724:	11a0e00f 	movne	lr, pc
    4728:	112fff13 	bxne	r3
DEBUG_LED_OFF(8);		
			}
		}
	}
	
	// endpoint interrupt
	if (dwStatus & EP_SLOW) {
    472c:	e3150004 	tst	r5, #4	; 0x4
    4730:	0a000021 	beq	47bc <USBHwISR+0x110>
		// clear EP_SLOW
		USBDevIntClr = EP_SLOW;
    4734:	e59f3088 	ldr	r3, [pc, #136]	; 47c4 <.text+0x47c4>
    4738:	e3a02004 	mov	r2, #4	; 0x4
    473c:	e5832008 	str	r2, [r3, #8]
    4740:	e3a04000 	mov	r4, #0	; 0x0
		// check all endpoints
		for (i = 0; i < 32; i++) {
			dwIntBit = (1 << i);
    4744:	e3a03001 	mov	r3, #1	; 0x1
    4748:	e1a02413 	mov	r2, r3, lsl r4
			if (USBEpIntSt & dwIntBit) {
    474c:	e59f1070 	ldr	r1, [pc, #112]	; 47c4 <.text+0x47c4>
    4750:	e5913030 	ldr	r3, [r1, #48]
    4754:	e1130002 	tst	r3, r2
    4758:	0a000014 	beq	47b0 <USBHwISR+0x104>
				// clear int (and retrieve status)
				USBEpIntClr = dwIntBit;
    475c:	e5812038 	str	r2, [r1, #56]
    4760:	e59f105c 	ldr	r1, [pc, #92]	; 47c4 <.text+0x47c4>
    4764:	e5913000 	ldr	r3, [r1]
    4768:	e2030020 	and	r0, r3, #32	; 0x20
    476c:	e3500020 	cmp	r0, #32	; 0x20
    4770:	1afffffa 	bne	4760 <USBHwISR+0xb4>
				Wait4DevInt(CDFULL);
				bEPStat = USBCmdData;
				// convert EP pipe stat into something HW independent
				bStat = ((bEPStat & EPSTAT_FE) ? EP_STATUS_DATA : 0) |
						((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
						((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
						((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
						((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
				// call handler
				if (_apfnEPIntHandlers[i / 2] != NULL) {
    4774:	e0843fa4 	add	r3, r4, r4, lsr #31
    4778:	e59f2050 	ldr	r2, [pc, #80]	; 47d0 <.text+0x47d0>
    477c:	e1a030c3 	mov	r3, r3, asr #1
    4780:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    4784:	e5810008 	str	r0, [r1, #8]
    4788:	e3530000 	cmp	r3, #0	; 0x0
    478c:	e5911014 	ldr	r1, [r1, #20]
    4790:	0a000006 	beq	47b0 <USBHwISR+0x104>
DEBUG_LED_ON(10);		
					_apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);
    4794:	e1a000c4 	mov	r0, r4, asr #1
    4798:	e200000f 	and	r0, r0, #15	; 0xf
    479c:	e1800384 	orr	r0, r0, r4, lsl #7
    47a0:	e200008f 	and	r0, r0, #143	; 0x8f
    47a4:	e201101f 	and	r1, r1, #31	; 0x1f
    47a8:	e1a0e00f 	mov	lr, pc
    47ac:	e12fff13 	bx	r3
    47b0:	e2844001 	add	r4, r4, #1	; 0x1
    47b4:	e3540020 	cmp	r4, #32	; 0x20
    47b8:	1affffe1 	bne	4744 <USBHwISR+0x98>
DEBUG_LED_OFF(10);
				}
			}
		}
	}
	
DEBUG_LED_OFF(9);		
}
    47bc:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    47c0:	e12fff1e 	bx	lr
    47c4:	e0090000 	and	r0, r9, r0
    47c8:	40000f30 	andmi	r0, r0, r0, lsr pc
    47cc:	40000f34 	andmi	r0, r0, r4, lsr pc
    47d0:	40000f38 	andmi	r0, r0, r8, lsr pc

000047d4 <USBHwInit>:



/**
	Initialises the USB hardware
		
	This function assumes that the hardware is connected as shown in
	section 10.1 of the LPC2148 data sheet:
	* P0.31 controls a switch to connect a 1.5k pull-up to D+ if low.
	* P0.23 is connected to USB VCC.
	
	Embedded artists board: make sure to disconnect P0.23 LED as it
	acts as a pull-up and so prevents detection of USB disconnect.
		
	@return TRUE if the hardware was successfully initialised
 */
BOOL USBHwInit(void)
{
	// configure P0.23 for Vbus sense
	PINSEL1 = (PINSEL1 & ~(3 << 14)) | (1 << 14);	// P0.23
    47d4:	e59f20b0 	ldr	r2, [pc, #176]	; 488c <.text+0x488c>
    47d8:	e5923004 	ldr	r3, [r2, #4]
    47dc:	e3c33903 	bic	r3, r3, #49152	; 0xc000
    47e0:	e3833901 	orr	r3, r3, #16384	; 0x4000
    47e4:	e5823004 	str	r3, [r2, #4]
	// configure P0.31 for CONNECT
	PINSEL1 = (PINSEL1 & ~(3 << 30)) | (2 << 30);	// P0.31
    47e8:	e5923004 	ldr	r3, [r2, #4]
    47ec:	e3c33103 	bic	r3, r3, #-1073741824	; 0xc0000000
    47f0:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
    47f4:	e5823004 	str	r3, [r2, #4]

	// enable PUSB
	PCONP |= (1 << 31);		
    47f8:	e282281d 	add	r2, r2, #1900544	; 0x1d0000
    47fc:	e59230c4 	ldr	r3, [r2, #196]
    4800:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
    4804:	e58230c4 	str	r3, [r2, #196]
	
	// initialise PLL
	PLL1CON = 1;			// enable PLL
    4808:	e3a03001 	mov	r3, #1	; 0x1
    480c:	e58230a0 	str	r3, [r2, #160]
    4810:	e52de004 	str	lr, [sp, #-4]!
	PLL1CFG = (1 << 5) | 3; // P = 2, M = 4
    4814:	e2833022 	add	r3, r3, #34	; 0x22
    4818:	e58230a4 	str	r3, [r2, #164]
	PLL1FEED = 0xAA;
    481c:	e2833087 	add	r3, r3, #135	; 0x87
    4820:	e58230ac 	str	r3, [r2, #172]
	PLL1FEED = 0x55;
    4824:	e3a03055 	mov	r3, #85	; 0x55
    4828:	e58230ac 	str	r3, [r2, #172]
	while ((PLL1STAT & (1 << 10)) == 0);
    482c:	e59fe05c 	ldr	lr, [pc, #92]	; 4890 <.text+0x4890>
    4830:	e59e30a8 	ldr	r3, [lr, #168]
    4834:	e3130b01 	tst	r3, #1024	; 0x400
    4838:	0afffffb 	beq	482c <USBHwInit+0x58>

	PLL1CON = 3;			// enable and connect
    483c:	e3a03003 	mov	r3, #3	; 0x3
    4840:	e58e30a0 	str	r3, [lr, #160]
	PLL1FEED = 0xAA;
	PLL1FEED = 0x55;
	
	// disable/clear all interrupts for now
	USBDevIntEn = 0;
    4844:	e59f2048 	ldr	r2, [pc, #72]	; 4894 <.text+0x4894>
    4848:	e28330a7 	add	r3, r3, #167	; 0xa7
    484c:	e58e30ac 	str	r3, [lr, #172]
    4850:	e3a01000 	mov	r1, #0	; 0x0
	USBDevIntClr = 0xFFFFFFFF;
    4854:	e3e0c000 	mvn	ip, #0	; 0x0
    4858:	e3a03055 	mov	r3, #85	; 0x55
    485c:	e58e30ac 	str	r3, [lr, #172]
	USBDevIntPri = 0;

	USBEpIntEn = 0;
	USBEpIntClr = 0xFFFFFFFF;
	USBEpIntPri = 0;

	// by default, only ACKs generate interrupts
	USBHwNakIntEnable(0);
    4860:	e1a00001 	mov	r0, r1
    4864:	e5821004 	str	r1, [r2, #4]
    4868:	e582c008 	str	ip, [r2, #8]
    486c:	e582102c 	str	r1, [r2, #44]
    4870:	e5821034 	str	r1, [r2, #52]
    4874:	e582c038 	str	ip, [r2, #56]
    4878:	e5821040 	str	r1, [r2, #64]
    487c:	ebffff27 	bl	4520 <USBHwNakIntEnable>
	
	// init debug leds
	DEBUG_LED_INIT(8);
	DEBUG_LED_INIT(9);
	DEBUG_LED_INIT(10);

	return TRUE;
}
    4880:	e3a00001 	mov	r0, #1	; 0x1
    4884:	e49de004 	ldr	lr, [sp], #4
    4888:	e12fff1e 	bx	lr
    488c:	e002c000 	and	ip, r2, r0
    4890:	e01fc000 	ands	ip, pc, r0
    4894:	e0090000 	and	r0, r9, r0

00004898 <_HandleRequest>:

	@return TRUE if the request was handles successfully
 */
static BOOL _HandleRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
    4898:	e52de004 	str	lr, [sp, #-4]!
	TFnHandleRequest *pfnHandler;
	int iType;
	
	iType = REQTYPE_GET_TYPE(pSetup->bmRequestType);
	pfnHandler = apfnReqHandlers[iType];
    489c:	e5d03000 	ldrb	r3, [r0]
    48a0:	e59fc02c 	ldr	ip, [pc, #44]	; 48d4 <.text+0x48d4>
    48a4:	e1a032a3 	mov	r3, r3, lsr #5
    48a8:	e2033003 	and	r3, r3, #3	; 0x3
    48ac:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
	if (pfnHandler == NULL) {
    48b0:	e3530000 	cmp	r3, #0	; 0x0
    48b4:	e1a0c003 	mov	ip, r3
    48b8:	0a000002 	beq	48c8 <_HandleRequest+0x30>
		DBG("No handler for reqtype %d\n", iType);
		return FALSE;
	}

	return pfnHandler(pSetup, piLen, ppbData);
    48bc:	e1a0e00f 	mov	lr, pc
    48c0:	e12fff13 	bx	r3
    48c4:	e1a0c000 	mov	ip, r0
}
    48c8:	e1a0000c 	mov	r0, ip
    48cc:	e49de004 	ldr	lr, [sp], #4
    48d0:	e12fff1e 	bx	lr
    48d4:	40000f78 	andmi	r0, r0, r8, ror pc

000048d8 <USBRegisterRequestHandler>:


/**
	Local function to stall the control endpoint
	
	@param [in]	bEPStat	Endpoint status
 */
static void StallControlPipe(U8 bEPStat)
{
	U8	*pb;
	int	i;

	USBHwEPStall(0x80, TRUE);

// dump setup packet
	DBG("STALL on [");
	pb = (U8 *)&Setup;
	for (i = 0; i < 8; i++) {
		DBG(" %02x", *pb++);
	}
	DBG("] stat=%x\n", bEPStat);
}


/**
	Sends next chunk of data (possibly 0 bytes) to host
 */
static void DataIn(void)
{
	int iChunk;

	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
	USBHwEPWrite(0x80, pbData, iChunk);
	pbData += iChunk;
	iResidue -= iChunk;
}


/**
 *	Handles IN/OUT transfers on EP0
 *
 *	@param [in]	bEP		Endpoint address
 *	@param [in]	bEPStat	Endpoint status
 */
void USBHandleControlTransfer(U8 bEP, U8 bEPStat)
{
	int iChunk, iType;

	if (bEP == 0x00) {
		// OUT transfer
		if (bEPStat & EP_STATUS_SETUP) {
			// setup packet, reset request message state machine
			USBHwEPRead(0x00, (U8 *)&Setup, sizeof(Setup));
			DBG("S%x", Setup.bRequest);

			// defaults for data pointer and residue
			iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
			pbData = apbDataStore[iType];
			iResidue = Setup.wLength;
			iLen = Setup.wLength;

			if ((Setup.wLength == 0) ||
				(REQTYPE_GET_DIR(Setup.bmRequestType) == REQTYPE_DIR_TO_HOST)) {
				// ask installed handler to process request
				if (!_HandleRequest(&Setup, &iLen, &pbData)) {
					DBG("_HandleRequest1 failed\n");
					StallControlPipe(bEPStat);
					return;
				}
				// send smallest of requested and offered length
				iResidue = MIN(iLen, Setup.wLength);
				// send first part (possibly a zero-length status message)
				DataIn();
			}
		}
		else {		
			if (iResidue > 0) {
				// store data
				iChunk = USBHwEPRead(0x00, pbData, iResidue);
				if (iChunk < 0) {
					StallControlPipe(bEPStat);
					return;
				}
				pbData += iChunk;
				iResidue -= iChunk;
				if (iResidue == 0) {
					// received all, send data to handler
					iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
					pbData = apbDataStore[iType];
					if (!_HandleRequest(&Setup, &iLen, &pbData)) {
						DBG("_HandleRequest2 failed\n");
						StallControlPipe(bEPStat);
						return;
					}
					// send status to host
					DataIn();
				}
			}
			else {
				// absorb zero-length status message
				iChunk = USBHwEPRead(0x00, NULL, 0);
				DBG(iChunk > 0 ? "?" : "");
			}
		}
	}
	else if (bEP == 0x80) {
		// IN transfer
		// send more data if available (possibly a 0-length packet)
		DataIn();
	}
	else {
		ASSERT(FALSE);
	}
}


/**
	Registers a callback for handling requests
		
	@param [in]	iType			Type of request, e.g. REQTYPE_TYPE_STANDARD
	@param [in]	*pfnHandler		Callback function pointer
	@param [in]	*pbDataStore	Data storage area for this type of request
 */
void USBRegisterRequestHandler(int iType, TFnHandleRequest *pfnHandler, U8 *pbDataStore)
{
	ASSERT(iType >= 0);
	ASSERT(iType < 4);
	apfnReqHandlers[iType] = pfnHandler;
	apbDataStore[iType] = pbDataStore;
    48d8:	e59f300c 	ldr	r3, [pc, #12]	; 48ec <.text+0x48ec>
    48dc:	e7832100 	str	r2, [r3, r0, lsl #2]
    48e0:	e59f3008 	ldr	r3, [pc, #8]	; 48f0 <.text+0x48f0>
    48e4:	e7831100 	str	r1, [r3, r0, lsl #2]
}
    48e8:	e12fff1e 	bx	lr
    48ec:	40000f88 	andmi	r0, r0, r8, lsl #31
    48f0:	40000f78 	andmi	r0, r0, r8, ror pc

000048f4 <StallControlPipe>:
    48f4:	e52de004 	str	lr, [sp, #-4]!
    48f8:	e3a00080 	mov	r0, #128	; 0x80
    48fc:	e3a01001 	mov	r1, #1	; 0x1
    4900:	ebffff12 	bl	4550 <USBHwEPStall>
    4904:	e49de004 	ldr	lr, [sp], #4
    4908:	e12fff1e 	bx	lr

0000490c <DataIn>:
    490c:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    4910:	e59f603c 	ldr	r6, [pc, #60]	; 4954 <.text+0x4954>
    4914:	e5964000 	ldr	r4, [r6]
    4918:	e59f5038 	ldr	r5, [pc, #56]	; 4958 <.text+0x4958>
    491c:	e3540040 	cmp	r4, #64	; 0x40
    4920:	a3a04040 	movge	r4, #64	; 0x40
    4924:	e1a02004 	mov	r2, r4
    4928:	e3a00080 	mov	r0, #128	; 0x80
    492c:	e5951000 	ldr	r1, [r5]
    4930:	ebffff0e 	bl	4570 <USBHwEPWrite>
    4934:	e5953000 	ldr	r3, [r5]
    4938:	e5962000 	ldr	r2, [r6]
    493c:	e0833004 	add	r3, r3, r4
    4940:	e0642002 	rsb	r2, r4, r2
    4944:	e5853000 	str	r3, [r5]
    4948:	e5862000 	str	r2, [r6]
    494c:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    4950:	e12fff1e 	bx	lr
    4954:	40000fa4 	andmi	r0, r0, r4, lsr #31
    4958:	40000fa0 	andmi	r0, r0, r0, lsr #31

0000495c <USBHandleControlTransfer>:
    495c:	e21000ff 	ands	r0, r0, #255	; 0xff
    4960:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    4964:	e20170ff 	and	r7, r1, #255	; 0xff
    4968:	1a000043 	bne	4a7c <USBHandleControlTransfer+0x120>
    496c:	e3110004 	tst	r1, #4	; 0x4
    4970:	e59f611c 	ldr	r6, [pc, #284]	; 4a94 <.text+0x4a94>
    4974:	0a00001d 	beq	49f0 <USBHandleControlTransfer+0x94>
    4978:	e59f5118 	ldr	r5, [pc, #280]	; 4a98 <.text+0x4a98>
    497c:	e3a02008 	mov	r2, #8	; 0x8
    4980:	e1a01005 	mov	r1, r5
    4984:	ebffff1b 	bl	45f8 <USBHwEPRead>
    4988:	e5d50000 	ldrb	r0, [r5]
    498c:	e59f2108 	ldr	r2, [pc, #264]	; 4a9c <.text+0x4a9c>
    4990:	e1a032a0 	mov	r3, r0, lsr #5
    4994:	e1d510b6 	ldrh	r1, [r5, #6]
    4998:	e2033003 	and	r3, r3, #3	; 0x3
    499c:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    49a0:	e59f40f8 	ldr	r4, [pc, #248]	; 4aa0 <.text+0x4aa0>
    49a4:	e59f20f8 	ldr	r2, [pc, #248]	; 4aa4 <.text+0x4aa4>
    49a8:	e3510000 	cmp	r1, #0	; 0x0
    49ac:	e5823000 	str	r3, [r2]
    49b0:	e5861000 	str	r1, [r6]
    49b4:	e5841000 	str	r1, [r4]
    49b8:	0a000001 	beq	49c4 <USBHandleControlTransfer+0x68>
    49bc:	e1b003a0 	movs	r0, r0, lsr #7
    49c0:	0a000031 	beq	4a8c <USBHandleControlTransfer+0x130>
    49c4:	e1a00005 	mov	r0, r5
    49c8:	e1a01004 	mov	r1, r4
    49cc:	ebffffb1 	bl	4898 <_HandleRequest>
    49d0:	e3500000 	cmp	r0, #0	; 0x0
    49d4:	0a000021 	beq	4a60 <USBHandleControlTransfer+0x104>
    49d8:	e1d520b6 	ldrh	r2, [r5, #6]
    49dc:	e5943000 	ldr	r3, [r4]
    49e0:	e1520003 	cmp	r2, r3
    49e4:	d5862000 	strle	r2, [r6]
    49e8:	c5863000 	strgt	r3, [r6]
    49ec:	ea000024 	b	4a84 <USBHandleControlTransfer+0x128>
    49f0:	e5962000 	ldr	r2, [r6]
    49f4:	e3520000 	cmp	r2, #0	; 0x0
    49f8:	da00001b 	ble	4a6c <USBHandleControlTransfer+0x110>
    49fc:	e59f40a0 	ldr	r4, [pc, #160]	; 4aa4 <.text+0x4aa4>
    4a00:	e5941000 	ldr	r1, [r4]
    4a04:	ebfffefb 	bl	45f8 <USBHwEPRead>
    4a08:	e3500000 	cmp	r0, #0	; 0x0
    4a0c:	ba000013 	blt	4a60 <USBHandleControlTransfer+0x104>
    4a10:	e5962000 	ldr	r2, [r6]
    4a14:	e5943000 	ldr	r3, [r4]
    4a18:	e0602002 	rsb	r2, r0, r2
    4a1c:	e0833000 	add	r3, r3, r0
    4a20:	e3520000 	cmp	r2, #0	; 0x0
    4a24:	e5843000 	str	r3, [r4]
    4a28:	e5862000 	str	r2, [r6]
    4a2c:	1a000016 	bne	4a8c <USBHandleControlTransfer+0x130>
    4a30:	e59f0060 	ldr	r0, [pc, #96]	; 4a98 <.text+0x4a98>
    4a34:	e5d03000 	ldrb	r3, [r0]
    4a38:	e59f205c 	ldr	r2, [pc, #92]	; 4a9c <.text+0x4a9c>
    4a3c:	e1a032a3 	mov	r3, r3, lsr #5
    4a40:	e2033003 	and	r3, r3, #3	; 0x3
    4a44:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    4a48:	e59f1050 	ldr	r1, [pc, #80]	; 4aa0 <.text+0x4aa0>
    4a4c:	e1a02004 	mov	r2, r4
    4a50:	e5843000 	str	r3, [r4]
    4a54:	ebffff8f 	bl	4898 <_HandleRequest>
    4a58:	e3500000 	cmp	r0, #0	; 0x0
    4a5c:	1a000008 	bne	4a84 <USBHandleControlTransfer+0x128>
    4a60:	e1a00007 	mov	r0, r7
    4a64:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    4a68:	eaffffa1 	b	48f4 <StallControlPipe>
    4a6c:	e1a01000 	mov	r1, r0
    4a70:	e1a02000 	mov	r2, r0
    4a74:	ebfffedf 	bl	45f8 <USBHwEPRead>
    4a78:	ea000003 	b	4a8c <USBHandleControlTransfer+0x130>
    4a7c:	e3500080 	cmp	r0, #128	; 0x80
    4a80:	1a000001 	bne	4a8c <USBHandleControlTransfer+0x130>
    4a84:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    4a88:	eaffff9f 	b	490c <DataIn>
    4a8c:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    4a90:	e12fff1e 	bx	lr
    4a94:	40000fa4 	andmi	r0, r0, r4, lsr #31
    4a98:	40000f98 	mulmi	r0, r8, pc
    4a9c:	40000f88 	andmi	r0, r0, r8, lsl #31
    4aa0:	40000fa8 	andmi	r0, r0, r8, lsr #31
    4aa4:	40000fa0 	andmi	r0, r0, r0, lsr #31

00004aa8 <USBRegisterDescriptors>:
 */
//void USBRegisterDescriptors(const U8 *pabDescriptors)
void USBRegisterDescriptors(U8 *pabDescriptors)
{
	pabDescrip = pabDescriptors;
    4aa8:	e59f3004 	ldr	r3, [pc, #4]	; 4ab4 <.text+0x4ab4>
    4aac:	e5830000 	str	r0, [r3]
}
    4ab0:	e12fff1e 	bx	lr
    4ab4:	40000fb4 	strmih	r0, [r0], -r4

00004ab8 <USBGetDescriptor>:


/**
	Parses the list of installed USB descriptors and attempts to find
	the specified USB descriptor.
		
	@param [in]		wTypeIndex	Type and index of the descriptor
	@param [in]		wLangID		Language ID of the descriptor (currently unused)
	@param [out]	*piLen		Descriptor length
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetDescriptor(U16 wTypeIndex, U16 wLangID, int *piLen, U8 **ppbData)
{
    4ab8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	U8	bType, bIndex;
	U8	*pab;
	int iCurIndex;
	
	ASSERT(pabDescrip != NULL);

	bType = GET_DESC_TYPE(wTypeIndex);
	bIndex = GET_DESC_INDEX(wTypeIndex);
	
	pab = (U8 *)pabDescrip;
    4abc:	e59f1074 	ldr	r1, [pc, #116]	; 4b38 <.text+0x4b38>
    4ac0:	e1a00800 	mov	r0, r0, lsl #16
    4ac4:	e591c000 	ldr	ip, [r1]
    4ac8:	e1a01820 	mov	r1, r0, lsr #16
    4acc:	e1a05002 	mov	r5, r2
    4ad0:	e1a04003 	mov	r4, r3
    4ad4:	e1a0ec20 	mov	lr, r0, lsr #24
    4ad8:	e20110ff 	and	r1, r1, #255	; 0xff
    4adc:	e3a02000 	mov	r2, #0	; 0x0
    4ae0:	ea00000f 	b	4b24 <USBGetDescriptor+0x6c>
	iCurIndex = 0;
	
	while (pab[DESC_bLength] != 0) {
		if (pab[DESC_bDescriptorType] == bType) {
    4ae4:	e5dc3001 	ldrb	r3, [ip, #1]
    4ae8:	e153000e 	cmp	r3, lr
    4aec:	1a00000b 	bne	4b20 <USBGetDescriptor+0x68>
			if (iCurIndex == bIndex) {
    4af0:	e1520001 	cmp	r2, r1
				// set data pointer
				*ppbData = pab;
				// get length from structure
				if (bType == DESC_CONFIGURATION) {
					// configuration descriptor is an exception, length is at offset 2 and 3
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
								(pab[CONF_DESC_wTotalLength + 1] << 8);
				}
				else {
					// normally length is at offset 0
					*piLen = pab[DESC_bLength];
				}
				return TRUE;
			}
			iCurIndex++;
    4af4:	e2822001 	add	r2, r2, #1	; 0x1
    4af8:	1a000008 	bne	4b20 <USBGetDescriptor+0x68>
    4afc:	e584c000 	str	ip, [r4]
    4b00:	e35e0002 	cmp	lr, #2	; 0x2
    4b04:	05dc2003 	ldreqb	r2, [ip, #3]
    4b08:	05dc3002 	ldreqb	r3, [ip, #2]
    4b0c:	15dc3000 	ldrneb	r3, [ip]
    4b10:	01833402 	orreq	r3, r3, r2, lsl #8
    4b14:	e3a00001 	mov	r0, #1	; 0x1
    4b18:	e5853000 	str	r3, [r5]
    4b1c:	ea000003 	b	4b30 <USBGetDescriptor+0x78>
		}
		// skip to next descriptor
		pab += pab[DESC_bLength];
    4b20:	e08cc000 	add	ip, ip, r0
    4b24:	e5dc0000 	ldrb	r0, [ip]
    4b28:	e3500000 	cmp	r0, #0	; 0x0
    4b2c:	1affffec 	bne	4ae4 <USBGetDescriptor+0x2c>
	}
	// nothing found
	DBG("Desc %x not found!\n", wTypeIndex);
	return FALSE;
}
    4b30:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    4b34:	e12fff1e 	bx	lr
    4b38:	40000fb4 	strmih	r0, [r0], -r4

00004b3c <USBRegisterCustomReqHandler>:


/**
	Configures the device according to the specified configuration index and
	alternate setting by parsing the installed USB descriptor list.
	A configuration index of 0 unconfigures the device.
		
	@param [in]		bConfigIndex	Configuration index
	@param [in]		bAltSetting		Alternate setting number
	
	@todo function always returns TRUE, add stricter checking?
	
	@return TRUE if successfully configured, FALSE otherwise
 */
static BOOL USBSetConfiguration(U8 bConfigIndex, U8 bAltSetting)
{
	U8	*pab;
	U8	bCurConfig, bCurAltSetting;
	U8	bEP;
	U16	wMaxPktSize;
	
	ASSERT(pabDescrip != NULL);

	if (bConfigIndex == 0) {
		// unconfigure device
		USBHwConfigDevice(FALSE);
	}
	else {
		// configure endpoints for this configuration/altsetting
		pab = (U8 *)pabDescrip;
		bCurConfig = 0xFF;
		bCurAltSetting = 0xFF;

		while (pab[DESC_bLength] != 0) {

			switch (pab[DESC_bDescriptorType]) {

			case DESC_CONFIGURATION:
				// remember current configuration index
				bCurConfig = pab[CONF_DESC_bConfigurationValue];
				break;

			case DESC_INTERFACE:
				// remember current alternate setting
				bCurAltSetting = pab[INTF_DESC_bAlternateSetting];
				break;

			case DESC_ENDPOINT:
				if ((bCurConfig == bConfigIndex) &&
					(bCurAltSetting == bAltSetting)) {
					// endpoint found for desired config and alternate setting
					bEP = pab[ENDP_DESC_bEndpointAddress];
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
					// configure endpoint
					USBHwEPConfig(bEP, wMaxPktSize);
				}
				break;

			default:
				break;
			}
			// skip to next descriptor
			pab += pab[DESC_bLength];
		}
		
		// configure device
		USBHwConfigDevice(TRUE);
	}

	return TRUE;
}


/**
	Local function to handle a standard device request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in,out]	ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdDeviceReq(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
	
	case REQ_GET_STATUS:
		// bit 0: self-powered
		// bit 1: remote wakeup = not supported
		pbData[0] = 0;
		pbData[1] = 0;
		*piLen = 2;
		break;
		
	case REQ_SET_ADDRESS:
		USBHwSetAddress(pSetup->wValue);
		break;

	case REQ_GET_DESCRIPTOR:
		DBG("D%x", pSetup->wValue);
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);

	case REQ_GET_CONFIGURATION:
		// indicate if we are configured
		pbData[0] = bConfiguration;
		*piLen = 1;
		break;

	case REQ_SET_CONFIGURATION:
		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
			DBG("USBSetConfiguration failed!\n");
			return FALSE;
		}
		// configuration successful, update current configuration
		bConfiguration = pSetup->wValue & 0xFF;	
		break;

	case REQ_CLEAR_FEATURE:
	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_REMOTE_WAKEUP) {
			// put DEVICE_REMOTE_WAKEUP code here
		}
		if (pSetup->wValue == FEA_TEST_MODE) {
			// put TEST_MODE code here
		}
		return FALSE;

	case REQ_SET_DESCRIPTOR:
		DBG("Device req %d not implemented\n", pSetup->bRequest);
		return FALSE;

	default:
		DBG("Illegal device req %d\n", pSetup->bRequest);
		return FALSE;
	}
	
	return TRUE;
}


/**
	Local function to handle a standard interface request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdInterfaceReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {

	case REQ_GET_STATUS:
		// no bits specified
		pbData[0] = 0;
		pbData[1] = 0;
		*piLen = 2;
		break;

	case REQ_CLEAR_FEATURE:
	case REQ_SET_FEATURE:
		// not defined for interface
		return FALSE;
	
	case REQ_GET_INTERFACE:	// TODO use bNumInterfaces
        // there is only one interface, return n-1 (= 0)
		pbData[0] = 0;
		*piLen = 1;
		break;
	
	case REQ_SET_INTERFACE:	// TODO use bNumInterfaces
		// there is only one interface (= 0)
		if (pSetup->wValue != 0) {
			return FALSE;
		}
		*piLen = 0;
		break;

	default:
		DBG("Illegal interface req %d\n", pSetup->bRequest);
		return FALSE;
	}

	return TRUE;
}


/**
	Local function to handle a standard endpoint request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdEndPointReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
	case REQ_GET_STATUS:
		// bit 0 = endpointed halted or not
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
		pbData[1] = 0;
		*piLen = 2;
		break;
		
	case REQ_CLEAR_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
			// clear HALT by unstalling
			USBHwEPStall(pSetup->wIndex, FALSE);
			break;
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;
	
	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
			// set HALT by stalling
			USBHwEPStall(pSetup->wIndex, TRUE);
			break;
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;

	case REQ_SYNCH_FRAME:
		DBG("EP req %d not implemented\n", pSetup->bRequest);
		return FALSE;

	default:
		DBG("Illegal EP req %d\n", pSetup->bRequest);
		return FALSE;
	}
	
	return TRUE;
}


/**
	Default handler for standard ('chapter 9') requests
	
	If a custom request handler was installed, this handler is called first.
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
		return TRUE;
	}
	
	switch (REQTYPE_GET_RECIP(pSetup->bmRequestType)) {
	case REQTYPE_RECIP_DEVICE:		return HandleStdDeviceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
	default: 						return FALSE;
	}
}


/**
	Registers a callback for custom device requests
	
	In USBHandleStandardRequest, the custom request handler gets a first
	chance at handling the request before it is handed over to the 'chapter 9'
	request handler.
	
	This can be used for example in HID devices, where a REQ_GET_DESCRIPTOR
	request is sent to an interface, which is not covered by the 'chapter 9'
	specification.
		
	@param [in]	pfnHandler	Callback function pointer
 */
void USBRegisterCustomReqHandler(TFnHandleRequest *pfnHandler)
{
	pfnHandleCustomReq = pfnHandler;
    4b3c:	e59f3004 	ldr	r3, [pc, #4]	; 4b48 <.text+0x4b48>
    4b40:	e5830000 	str	r0, [r3]
}
    4b44:	e12fff1e 	bx	lr
    4b48:	40000fac 	andmi	r0, r0, ip, lsr #31

00004b4c <USBHandleStandardRequest>:
    4b4c:	e59f3264 	ldr	r3, [pc, #612]	; 4db8 <.text+0x4db8>
    4b50:	e5933000 	ldr	r3, [r3]
    4b54:	e3530000 	cmp	r3, #0	; 0x0
    4b58:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4b5c:	e1a05000 	mov	r5, r0
    4b60:	e1a08001 	mov	r8, r1
    4b64:	e1a07002 	mov	r7, r2
    4b68:	0a000003 	beq	4b7c <USBHandleStandardRequest+0x30>
    4b6c:	e1a0e00f 	mov	lr, pc
    4b70:	e12fff13 	bx	r3
    4b74:	e3500000 	cmp	r0, #0	; 0x0
    4b78:	1a00001e 	bne	4bf8 <.text+0x4bf8>
    4b7c:	e5d53000 	ldrb	r3, [r5]
    4b80:	e203401f 	and	r4, r3, #31	; 0x1f
    4b84:	e3540001 	cmp	r4, #1	; 0x1
    4b88:	0a00004e 	beq	4cc8 <.text+0x4cc8>
    4b8c:	e3540002 	cmp	r4, #2	; 0x2
    4b90:	0a000064 	beq	4d28 <.text+0x4d28>
    4b94:	e3540000 	cmp	r4, #0	; 0x0
    4b98:	1a000082 	bne	4da8 <.text+0x4da8>
    4b9c:	e5d53001 	ldrb	r3, [r5, #1]
    4ba0:	e5971000 	ldr	r1, [r7]
    4ba4:	e3530009 	cmp	r3, #9	; 0x9
    4ba8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    4bac:	ea00007d 	b	4da8 <.text+0x4da8>
    4bb0:	00004bd8 	ldreqd	r4, [r0], -r8
    4bb4:	00004da8 	andeq	r4, r0, r8, lsr #27
    4bb8:	00004da8 	andeq	r4, r0, r8, lsr #27
    4bbc:	00004da8 	andeq	r4, r0, r8, lsr #27
    4bc0:	00004da8 	andeq	r4, r0, r8, lsr #27
    4bc4:	00004bf0 	streqd	r4, [r0], -r0
    4bc8:	00004c00 	andeq	r4, r0, r0, lsl #24
    4bcc:	00004da8 	andeq	r4, r0, r8, lsr #27
    4bd0:	00004c18 	andeq	r4, r0, r8, lsl ip
    4bd4:	00004c34 	andeq	r4, r0, r4, lsr ip
    4bd8:	e3a03000 	mov	r3, #0	; 0x0
    4bdc:	e5c13001 	strb	r3, [r1, #1]
    4be0:	e5c13000 	strb	r3, [r1]
    4be4:	e3a0c001 	mov	ip, #1	; 0x1
    4be8:	e2833002 	add	r3, r3, #2	; 0x2
    4bec:	ea00000e 	b	4c2c <.text+0x4c2c>
    4bf0:	e5d50002 	ldrb	r0, [r5, #2]
    4bf4:	ebfffe41 	bl	4500 <USBHwSetAddress>
    4bf8:	e3a0c001 	mov	ip, #1	; 0x1
    4bfc:	ea00006a 	b	4dac <.text+0x4dac>
    4c00:	e1d510b4 	ldrh	r1, [r5, #4]
    4c04:	e1d500b2 	ldrh	r0, [r5, #2]
    4c08:	e1a02008 	mov	r2, r8
    4c0c:	e1a03007 	mov	r3, r7
    4c10:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    4c14:	eaffffa7 	b	4ab8 <USBGetDescriptor>
    4c18:	e59f319c 	ldr	r3, [pc, #412]	; 4dbc <.text+0x4dbc>
    4c1c:	e5d32000 	ldrb	r2, [r3]
    4c20:	e3a03001 	mov	r3, #1	; 0x1
    4c24:	e5c12000 	strb	r2, [r1]
    4c28:	e1a0c003 	mov	ip, r3
    4c2c:	e5883000 	str	r3, [r8]
    4c30:	ea00005d 	b	4dac <.text+0x4dac>
    4c34:	e5d56002 	ldrb	r6, [r5, #2]
    4c38:	e3560000 	cmp	r6, #0	; 0x0
    4c3c:	01a00006 	moveq	r0, r6
    4c40:	0a00001a 	beq	4cb0 <.text+0x4cb0>
    4c44:	e59f3174 	ldr	r3, [pc, #372]	; 4dc0 <.text+0x4dc0>
    4c48:	e3a070ff 	mov	r7, #255	; 0xff
    4c4c:	e5934000 	ldr	r4, [r3]
    4c50:	e1a08007 	mov	r8, r7
    4c54:	ea000011 	b	4ca0 <.text+0x4ca0>
    4c58:	e5d43001 	ldrb	r3, [r4, #1]
    4c5c:	e3530004 	cmp	r3, #4	; 0x4
    4c60:	05d47003 	ldreqb	r7, [r4, #3]
    4c64:	0a00000b 	beq	4c98 <.text+0x4c98>
    4c68:	e3530005 	cmp	r3, #5	; 0x5
    4c6c:	0a000002 	beq	4c7c <.text+0x4c7c>
    4c70:	e3530002 	cmp	r3, #2	; 0x2
    4c74:	05d48005 	ldreqb	r8, [r4, #5]
    4c78:	ea000006 	b	4c98 <.text+0x4c98>
    4c7c:	e1580006 	cmp	r8, r6
    4c80:	03570000 	cmpeq	r7, #0	; 0x0
    4c84:	05d43004 	ldreqb	r3, [r4, #4]
    4c88:	05d41005 	ldreqb	r1, [r4, #5]
    4c8c:	05d40002 	ldreqb	r0, [r4, #2]
    4c90:	01831401 	orreq	r1, r3, r1, lsl #8
    4c94:	0bfffddd 	bleq	4410 <USBHwEPConfig>
    4c98:	e5d43000 	ldrb	r3, [r4]
    4c9c:	e0844003 	add	r4, r4, r3
    4ca0:	e5d43000 	ldrb	r3, [r4]
    4ca4:	e3530000 	cmp	r3, #0	; 0x0
    4ca8:	1affffea 	bne	4c58 <.text+0x4c58>
    4cac:	e3a00001 	mov	r0, #1	; 0x1
    4cb0:	ebfffe79 	bl	469c <USBHwConfigDevice>
    4cb4:	e1d520b2 	ldrh	r2, [r5, #2]
    4cb8:	e59f30fc 	ldr	r3, [pc, #252]	; 4dbc <.text+0x4dbc>
    4cbc:	e3a0c001 	mov	ip, #1	; 0x1
    4cc0:	e5c32000 	strb	r2, [r3]
    4cc4:	ea000038 	b	4dac <.text+0x4dac>
    4cc8:	e5d53001 	ldrb	r3, [r5, #1]
    4ccc:	e3530000 	cmp	r3, #0	; 0x0
    4cd0:	e5972000 	ldr	r2, [r7]
    4cd4:	0a000004 	beq	4cec <.text+0x4cec>
    4cd8:	e353000a 	cmp	r3, #10	; 0xa
    4cdc:	0a000007 	beq	4d00 <.text+0x4d00>
    4ce0:	e353000b 	cmp	r3, #11	; 0xb
    4ce4:	1a00002f 	bne	4da8 <.text+0x4da8>
    4ce8:	ea000008 	b	4d10 <.text+0x4d10>
    4cec:	e5c23001 	strb	r3, [r2, #1]
    4cf0:	e5c23000 	strb	r3, [r2]
    4cf4:	e1a0c004 	mov	ip, r4
    4cf8:	e3a03002 	mov	r3, #2	; 0x2
    4cfc:	eaffffca 	b	4c2c <.text+0x4c2c>
    4d00:	e3a03000 	mov	r3, #0	; 0x0
    4d04:	e1a0c004 	mov	ip, r4
    4d08:	e5c23000 	strb	r3, [r2]
    4d0c:	ea000015 	b	4d68 <.text+0x4d68>
    4d10:	e1d500b2 	ldrh	r0, [r5, #2]
    4d14:	e3500000 	cmp	r0, #0	; 0x0
    4d18:	03a0c001 	moveq	ip, #1	; 0x1
    4d1c:	05880000 	streq	r0, [r8]
    4d20:	0a000021 	beq	4dac <.text+0x4dac>
    4d24:	ea00001f 	b	4da8 <.text+0x4da8>
    4d28:	e5d56001 	ldrb	r6, [r5, #1]
    4d2c:	e3560001 	cmp	r6, #1	; 0x1
    4d30:	e5977000 	ldr	r7, [r7]
    4d34:	0a00000d 	beq	4d70 <.text+0x4d70>
    4d38:	3a000002 	bcc	4d48 <.text+0x4d48>
    4d3c:	e3560003 	cmp	r6, #3	; 0x3
    4d40:	1a000018 	bne	4da8 <.text+0x4da8>
    4d44:	ea000010 	b	4d8c <.text+0x4d8c>
    4d48:	e5d50004 	ldrb	r0, [r5, #4]
    4d4c:	ebfffdf6 	bl	452c <USBHwEPGetStatus>
    4d50:	e1a000a0 	mov	r0, r0, lsr #1
    4d54:	e2000001 	and	r0, r0, #1	; 0x1
    4d58:	e3a03000 	mov	r3, #0	; 0x0
    4d5c:	e5c73001 	strb	r3, [r7, #1]
    4d60:	e5c70000 	strb	r0, [r7]
    4d64:	e3a0c001 	mov	ip, #1	; 0x1
    4d68:	e5884000 	str	r4, [r8]
    4d6c:	ea00000e 	b	4dac <.text+0x4dac>
    4d70:	e1d510b2 	ldrh	r1, [r5, #2]
    4d74:	e3510000 	cmp	r1, #0	; 0x0
    4d78:	1a00000a 	bne	4da8 <.text+0x4da8>
    4d7c:	e5d50004 	ldrb	r0, [r5, #4]
    4d80:	ebfffdf2 	bl	4550 <USBHwEPStall>
    4d84:	e1a0c006 	mov	ip, r6
    4d88:	ea000007 	b	4dac <.text+0x4dac>
    4d8c:	e1d530b2 	ldrh	r3, [r5, #2]
    4d90:	e3530000 	cmp	r3, #0	; 0x0
    4d94:	1a000003 	bne	4da8 <.text+0x4da8>
    4d98:	e5d50004 	ldrb	r0, [r5, #4]
    4d9c:	e3a01001 	mov	r1, #1	; 0x1
    4da0:	ebfffdea 	bl	4550 <USBHwEPStall>
    4da4:	eaffff93 	b	4bf8 <.text+0x4bf8>
    4da8:	e3a0c000 	mov	ip, #0	; 0x0
    4dac:	e1a0000c 	mov	r0, ip
    4db0:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    4db4:	e12fff1e 	bx	lr
    4db8:	40000fac 	andmi	r0, r0, ip, lsr #31
    4dbc:	40000fb0 	strmih	r0, [r0], -r0
    4dc0:	40000fb4 	strmih	r0, [r0], -r4

00004dc4 <free>:
    4dc4:	e59f3014 	ldr	r3, [pc, #20]	; 4de0 <.text+0x4de0>
    4dc8:	e1a01000 	mov	r1, r0
    4dcc:	e52de004 	str	lr, [sp, #-4]!
    4dd0:	e5930000 	ldr	r0, [r3]
    4dd4:	eb000256 	bl	5734 <_free_r>
    4dd8:	e49de004 	ldr	lr, [sp], #4
    4ddc:	e12fff1e 	bx	lr
    4de0:	400006c8 	andmi	r0, r0, r8, asr #13

00004de4 <malloc>:
    4de4:	e59f3014 	ldr	r3, [pc, #20]	; 4e00 <.text+0x4e00>
    4de8:	e1a01000 	mov	r1, r0
    4dec:	e52de004 	str	lr, [sp, #-4]!
    4df0:	e5930000 	ldr	r0, [r3]
    4df4:	eb000002 	bl	4e04 <_malloc_r>
    4df8:	e49de004 	ldr	lr, [sp], #4
    4dfc:	e12fff1e 	bx	lr
    4e00:	400006c8 	andmi	r0, r0, r8, asr #13

00004e04 <_malloc_r>:
    4e04:	e281300b 	add	r3, r1, #11	; 0xb
    4e08:	e3530016 	cmp	r3, #22	; 0x16
    4e0c:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4e10:	93a08010 	movls	r8, #16	; 0x10
    4e14:	83c38007 	bichi	r8, r3, #7	; 0x7
    4e18:	e1580001 	cmp	r8, r1
    4e1c:	23a03000 	movcs	r3, #0	; 0x0
    4e20:	33a03001 	movcc	r3, #1	; 0x1
    4e24:	e1933fa8 	orrs	r3, r3, r8, lsr #31
    4e28:	e1a0a000 	mov	sl, r0
    4e2c:	13a0300c 	movne	r3, #12	; 0xc
    4e30:	13a00000 	movne	r0, #0	; 0x0
    4e34:	158a3000 	strne	r3, [sl]
    4e38:	1a00018a 	bne	5468 <_malloc_r+0x664>
    4e3c:	e1a0000a 	mov	r0, sl
    4e40:	eb0001a0 	bl	54c8 <__malloc_lock>
    4e44:	e3580f7e 	cmp	r8, #504	; 0x1f8
    4e48:	2a000011 	bcs	4e94 <_malloc_r+0x90>
    4e4c:	e59f361c 	ldr	r3, [pc, #1564]	; 5470 <.text+0x5470>
    4e50:	e1a021a8 	mov	r2, r8, lsr #3
    4e54:	e0833182 	add	r3, r3, r2, lsl #3
    4e58:	e593400c 	ldr	r4, [r3, #12]
    4e5c:	e1540003 	cmp	r4, r3
    4e60:	1a000003 	bne	4e74 <_malloc_r+0x70>
    4e64:	e2843008 	add	r3, r4, #8	; 0x8
    4e68:	e593400c 	ldr	r4, [r3, #12]
    4e6c:	e1540003 	cmp	r4, r3
    4e70:	0a000005 	beq	4e8c <_malloc_r+0x88>
    4e74:	e5943004 	ldr	r3, [r4, #4]
    4e78:	e3c33003 	bic	r3, r3, #3	; 0x3
    4e7c:	e0843003 	add	r3, r4, r3
    4e80:	e5932004 	ldr	r2, [r3, #4]
    4e84:	e594000c 	ldr	r0, [r4, #12]
    4e88:	ea00016e 	b	5448 <_malloc_r+0x644>
    4e8c:	e2825002 	add	r5, r2, #2	; 0x2
    4e90:	ea00002a 	b	4f40 <_malloc_r+0x13c>
    4e94:	e1b024a8 	movs	r2, r8, lsr #9
    4e98:	01a021a8 	moveq	r2, r8, lsr #3
    4e9c:	0a000017 	beq	4f00 <_malloc_r+0xfc>
    4ea0:	e3520004 	cmp	r2, #4	; 0x4
    4ea4:	91a03328 	movls	r3, r8, lsr #6
    4ea8:	92832038 	addls	r2, r3, #56	; 0x38
    4eac:	9a000013 	bls	4f00 <_malloc_r+0xfc>
    4eb0:	e3520014 	cmp	r2, #20	; 0x14
    4eb4:	9282205b 	addls	r2, r2, #91	; 0x5b
    4eb8:	9a000010 	bls	4f00 <_malloc_r+0xfc>
    4ebc:	e3520054 	cmp	r2, #84	; 0x54
    4ec0:	91a03628 	movls	r3, r8, lsr #12
    4ec4:	9283206e 	addls	r2, r3, #110	; 0x6e
    4ec8:	9a00000c 	bls	4f00 <_malloc_r+0xfc>
    4ecc:	e3520f55 	cmp	r2, #340	; 0x154
    4ed0:	91a037a8 	movls	r3, r8, lsr #15
    4ed4:	92832077 	addls	r2, r3, #119	; 0x77
    4ed8:	9a000008 	bls	4f00 <_malloc_r+0xfc>
    4edc:	e59f3590 	ldr	r3, [pc, #1424]	; 5474 <.text+0x5474>
    4ee0:	e1520003 	cmp	r2, r3
    4ee4:	83a0207e 	movhi	r2, #126	; 0x7e
    4ee8:	8a000004 	bhi	4f00 <_malloc_r+0xfc>
    4eec:	ea000001 	b	4ef8 <_malloc_r+0xf4>
    4ef0:	e2422001 	sub	r2, r2, #1	; 0x1
    4ef4:	ea000010 	b	4f3c <_malloc_r+0x138>
    4ef8:	e1a03928 	mov	r3, r8, lsr #18
    4efc:	e283207c 	add	r2, r3, #124	; 0x7c
    4f00:	e59f3568 	ldr	r3, [pc, #1384]	; 5470 <.text+0x5470>
    4f04:	e083c182 	add	ip, r3, r2, lsl #3
    4f08:	e59c400c 	ldr	r4, [ip, #12]
    4f0c:	ea000008 	b	4f34 <_malloc_r+0x130>
    4f10:	e5943004 	ldr	r3, [r4, #4]
    4f14:	e3c33003 	bic	r3, r3, #3	; 0x3
    4f18:	e0681003 	rsb	r1, r8, r3
    4f1c:	e351000f 	cmp	r1, #15	; 0xf
    4f20:	cafffff2 	bgt	4ef0 <_malloc_r+0xec>
    4f24:	e3510000 	cmp	r1, #0	; 0x0
    4f28:	e594000c 	ldr	r0, [r4, #12]
    4f2c:	aa000143 	bge	5440 <_malloc_r+0x63c>
    4f30:	e1a04000 	mov	r4, r0
    4f34:	e154000c 	cmp	r4, ip
    4f38:	1afffff4 	bne	4f10 <_malloc_r+0x10c>
    4f3c:	e2825001 	add	r5, r2, #1	; 0x1
    4f40:	e59fb528 	ldr	fp, [pc, #1320]	; 5470 <.text+0x5470>
    4f44:	e28b7008 	add	r7, fp, #8	; 0x8
    4f48:	e5974008 	ldr	r4, [r7, #8]
    4f4c:	e1540007 	cmp	r4, r7
    4f50:	0a000054 	beq	50a8 <_malloc_r+0x2a4>
    4f54:	e5943004 	ldr	r3, [r4, #4]
    4f58:	e3c32003 	bic	r2, r3, #3	; 0x3
    4f5c:	e0680002 	rsb	r0, r8, r2
    4f60:	e350000f 	cmp	r0, #15	; 0xf
    4f64:	da000009 	ble	4f90 <_malloc_r+0x18c>
    4f68:	e0842008 	add	r2, r4, r8
    4f6c:	e3883001 	orr	r3, r8, #1	; 0x1
    4f70:	e3801001 	orr	r1, r0, #1	; 0x1
    4f74:	e5843004 	str	r3, [r4, #4]
    4f78:	e587200c 	str	r2, [r7, #12]
    4f7c:	e5872008 	str	r2, [r7, #8]
    4f80:	e7820000 	str	r0, [r2, r0]
    4f84:	e9820082 	stmib	r2, {r1, r7}
    4f88:	e582700c 	str	r7, [r2, #12]
    4f8c:	ea000132 	b	545c <_malloc_r+0x658>
    4f90:	e3500000 	cmp	r0, #0	; 0x0
    4f94:	e587700c 	str	r7, [r7, #12]
    4f98:	e5877008 	str	r7, [r7, #8]
    4f9c:	a0842002 	addge	r2, r4, r2
    4fa0:	a5923004 	ldrge	r3, [r2, #4]
    4fa4:	a3833001 	orrge	r3, r3, #1	; 0x1
    4fa8:	a5823004 	strge	r3, [r2, #4]
    4fac:	aa00012a 	bge	545c <_malloc_r+0x658>
    4fb0:	e3520c02 	cmp	r2, #512	; 0x200
    4fb4:	2a00000c 	bcs	4fec <_malloc_r+0x1e8>
    4fb8:	e1a011a2 	mov	r1, r2, lsr #3
    4fbc:	e59b2004 	ldr	r2, [fp, #4]
    4fc0:	e1a00121 	mov	r0, r1, lsr #2
    4fc4:	e3a03001 	mov	r3, #1	; 0x1
    4fc8:	e1822013 	orr	r2, r2, r3, lsl r0
    4fcc:	e08b1181 	add	r1, fp, r1, lsl #3
    4fd0:	e5913008 	ldr	r3, [r1, #8]
    4fd4:	e584100c 	str	r1, [r4, #12]
    4fd8:	e5843008 	str	r3, [r4, #8]
    4fdc:	e58b2004 	str	r2, [fp, #4]
    4fe0:	e583400c 	str	r4, [r3, #12]
    4fe4:	e5814008 	str	r4, [r1, #8]
    4fe8:	ea00002e 	b	50a8 <_malloc_r+0x2a4>
    4fec:	e1b014a2 	movs	r1, r2, lsr #9
    4ff0:	01a011a2 	moveq	r1, r2, lsr #3
    4ff4:	0a000013 	beq	5048 <_malloc_r+0x244>
    4ff8:	e3510004 	cmp	r1, #4	; 0x4
    4ffc:	91a03322 	movls	r3, r2, lsr #6
    5000:	92831038 	addls	r1, r3, #56	; 0x38
    5004:	9a00000f 	bls	5048 <_malloc_r+0x244>
    5008:	e3510014 	cmp	r1, #20	; 0x14
    500c:	9281105b 	addls	r1, r1, #91	; 0x5b
    5010:	9a00000c 	bls	5048 <_malloc_r+0x244>
    5014:	e3510054 	cmp	r1, #84	; 0x54
    5018:	91a03622 	movls	r3, r2, lsr #12
    501c:	9283106e 	addls	r1, r3, #110	; 0x6e
    5020:	9a000008 	bls	5048 <_malloc_r+0x244>
    5024:	e3510f55 	cmp	r1, #340	; 0x154
    5028:	91a037a2 	movls	r3, r2, lsr #15
    502c:	92831077 	addls	r1, r3, #119	; 0x77
    5030:	9a000004 	bls	5048 <_malloc_r+0x244>
    5034:	e59f3438 	ldr	r3, [pc, #1080]	; 5474 <.text+0x5474>
    5038:	e1510003 	cmp	r1, r3
    503c:	91a03922 	movls	r3, r2, lsr #18
    5040:	83a0107e 	movhi	r1, #126	; 0x7e
    5044:	9283107c 	addls	r1, r3, #124	; 0x7c
    5048:	e08b0181 	add	r0, fp, r1, lsl #3
    504c:	e590c008 	ldr	ip, [r0, #8]
    5050:	e15c0000 	cmp	ip, r0
    5054:	1a00000a 	bne	5084 <_malloc_r+0x280>
    5058:	e59f0410 	ldr	r0, [pc, #1040]	; 5470 <.text+0x5470>
    505c:	e5902004 	ldr	r2, [r0, #4]
    5060:	e1a01121 	mov	r1, r1, lsr #2
    5064:	e3a03001 	mov	r3, #1	; 0x1
    5068:	e1822113 	orr	r2, r2, r3, lsl r1
    506c:	e1a0e00c 	mov	lr, ip
    5070:	e5802004 	str	r2, [r0, #4]
    5074:	ea000007 	b	5098 <_malloc_r+0x294>
    5078:	e59cc008 	ldr	ip, [ip, #8]
    507c:	e15c0000 	cmp	ip, r0
    5080:	0a000003 	beq	5094 <_malloc_r+0x290>
    5084:	e59c3004 	ldr	r3, [ip, #4]
    5088:	e3c33003 	bic	r3, r3, #3	; 0x3
    508c:	e1520003 	cmp	r2, r3
    5090:	3afffff8 	bcc	5078 <_malloc_r+0x274>
    5094:	e59ce00c 	ldr	lr, [ip, #12]
    5098:	e584e00c 	str	lr, [r4, #12]
    509c:	e584c008 	str	ip, [r4, #8]
    50a0:	e58c400c 	str	r4, [ip, #12]
    50a4:	e58e4008 	str	r4, [lr, #8]
    50a8:	e3550000 	cmp	r5, #0	; 0x0
    50ac:	e2853003 	add	r3, r5, #3	; 0x3
    50b0:	a1a03005 	movge	r3, r5
    50b4:	e1a03143 	mov	r3, r3, asr #2
    50b8:	e3a02001 	mov	r2, #1	; 0x1
    50bc:	e1a02312 	mov	r2, r2, lsl r3
    50c0:	e59f93a8 	ldr	r9, [pc, #936]	; 5470 <.text+0x5470>
    50c4:	e5991004 	ldr	r1, [r9, #4]
    50c8:	e1520001 	cmp	r2, r1
    50cc:	8a000037 	bhi	51b0 <_malloc_r+0x3ac>
    50d0:	e1120001 	tst	r2, r1
    50d4:	01a02082 	moveq	r2, r2, lsl #1
    50d8:	03c53003 	biceq	r3, r5, #3	; 0x3
    50dc:	0a000001 	beq	50e8 <_malloc_r+0x2e4>
    50e0:	ea000004 	b	50f8 <_malloc_r+0x2f4>
    50e4:	e1a02082 	mov	r2, r2, lsl #1
    50e8:	e1120001 	tst	r2, r1
    50ec:	e2833004 	add	r3, r3, #4	; 0x4
    50f0:	0afffffb 	beq	50e4 <_malloc_r+0x2e0>
    50f4:	e1a05003 	mov	r5, r3
    50f8:	e08b6185 	add	r6, fp, r5, lsl #3
    50fc:	e1a0e005 	mov	lr, r5
    5100:	e1a01006 	mov	r1, r6
    5104:	e591400c 	ldr	r4, [r1, #12]
    5108:	ea000008 	b	5130 <_malloc_r+0x32c>
    510c:	e5943004 	ldr	r3, [r4, #4]
    5110:	e3c33003 	bic	r3, r3, #3	; 0x3
    5114:	e068c003 	rsb	ip, r8, r3
    5118:	e35c000f 	cmp	ip, #15	; 0xf
    511c:	ca0000ad 	bgt	53d8 <_malloc_r+0x5d4>
    5120:	e35c0000 	cmp	ip, #0	; 0x0
    5124:	e594000c 	ldr	r0, [r4, #12]
    5128:	aa0000b9 	bge	5414 <_malloc_r+0x610>
    512c:	e1a04000 	mov	r4, r0
    5130:	e1540001 	cmp	r4, r1
    5134:	1afffff4 	bne	510c <_malloc_r+0x308>
    5138:	e28ee001 	add	lr, lr, #1	; 0x1
    513c:	e31e0003 	tst	lr, #3	; 0x3
    5140:	12841008 	addne	r1, r4, #8	; 0x8
    5144:	1affffee 	bne	5104 <_malloc_r+0x300>
    5148:	e1a00005 	mov	r0, r5
    514c:	e1a01006 	mov	r1, r6
    5150:	e3100003 	tst	r0, #3	; 0x3
    5154:	e2411008 	sub	r1, r1, #8	; 0x8
    5158:	e2400001 	sub	r0, r0, #1	; 0x1
    515c:	0a00000f 	beq	51a0 <_malloc_r+0x39c>
    5160:	e5913008 	ldr	r3, [r1, #8]
    5164:	e1530001 	cmp	r3, r1
    5168:	0afffff8 	beq	5150 <_malloc_r+0x34c>
    516c:	e5993004 	ldr	r3, [r9, #4]
    5170:	e1a02082 	mov	r2, r2, lsl #1
    5174:	e1520003 	cmp	r2, r3
    5178:	8a00000c 	bhi	51b0 <_malloc_r+0x3ac>
    517c:	e3520000 	cmp	r2, #0	; 0x0
    5180:	0a00000a 	beq	51b0 <_malloc_r+0x3ac>
    5184:	e1a0500e 	mov	r5, lr
    5188:	ea000001 	b	5194 <_malloc_r+0x390>
    518c:	e2855004 	add	r5, r5, #4	; 0x4
    5190:	e1a02082 	mov	r2, r2, lsl #1
    5194:	e1120003 	tst	r2, r3
    5198:	0afffffb 	beq	518c <_malloc_r+0x388>
    519c:	eaffffd5 	b	50f8 <_malloc_r+0x2f4>
    51a0:	e5993004 	ldr	r3, [r9, #4]
    51a4:	e1c33002 	bic	r3, r3, r2
    51a8:	e5893004 	str	r3, [r9, #4]
    51ac:	eaffffee 	b	516c <_malloc_r+0x368>
    51b0:	e5996008 	ldr	r6, [r9, #8]
    51b4:	e5963004 	ldr	r3, [r6, #4]
    51b8:	e3c37003 	bic	r7, r3, #3	; 0x3
    51bc:	e0681007 	rsb	r1, r8, r7
    51c0:	e351000f 	cmp	r1, #15	; 0xf
    51c4:	c3a03000 	movgt	r3, #0	; 0x0
    51c8:	d3a03001 	movle	r3, #1	; 0x1
    51cc:	e1570008 	cmp	r7, r8
    51d0:	33833001 	orrcc	r3, r3, #1	; 0x1
    51d4:	e3530000 	cmp	r3, #0	; 0x0
    51d8:	0a000070 	beq	53a0 <_malloc_r+0x59c>
    51dc:	e59f3294 	ldr	r3, [pc, #660]	; 5478 <.text+0x5478>
    51e0:	e5932000 	ldr	r2, [r3]
    51e4:	e59f3290 	ldr	r3, [pc, #656]	; 547c <.text+0x547c>
    51e8:	e5933000 	ldr	r3, [r3]
    51ec:	e2822010 	add	r2, r2, #16	; 0x10
    51f0:	e3730001 	cmn	r3, #1	; 0x1
    51f4:	e0884002 	add	r4, r8, r2
    51f8:	12843eff 	addne	r3, r4, #4080	; 0xff0
    51fc:	1283300f 	addne	r3, r3, #15	; 0xf
    5200:	13c34eff 	bicne	r4, r3, #4080	; 0xff0
    5204:	13c4400f 	bicne	r4, r4, #15	; 0xf
    5208:	e1a0000a 	mov	r0, sl
    520c:	e1a01004 	mov	r1, r4
    5210:	ebffec51 	bl	35c <_sbrk_r>
    5214:	e3700001 	cmn	r0, #1	; 0x1
    5218:	0a000051 	beq	5364 <_malloc_r+0x560>
    521c:	e086c007 	add	ip, r6, r7
    5220:	e150000c 	cmp	r0, ip
    5224:	e1a05000 	mov	r5, r0
    5228:	2a000002 	bcs	5238 <_malloc_r+0x434>
    522c:	e1560009 	cmp	r6, r9
    5230:	1a00004b 	bne	5364 <_malloc_r+0x560>
    5234:	ea000062 	b	53c4 <_malloc_r+0x5c0>
    5238:	e59f2240 	ldr	r2, [pc, #576]	; 5480 <.text+0x5480>
    523c:	e5923000 	ldr	r3, [r2]
    5240:	e0841003 	add	r1, r4, r3
    5244:	e5821000 	str	r1, [r2]
    5248:	1a000007 	bne	526c <_malloc_r+0x468>
    524c:	e1a03a00 	mov	r3, r0, lsl #20
    5250:	e1a03a23 	mov	r3, r3, lsr #20
    5254:	e3530000 	cmp	r3, #0	; 0x0
    5258:	00843007 	addeq	r3, r4, r7
    525c:	05992008 	ldreq	r2, [r9, #8]
    5260:	03833001 	orreq	r3, r3, #1	; 0x1
    5264:	05823004 	streq	r3, [r2, #4]
    5268:	0a000033 	beq	533c <_malloc_r+0x538>
    526c:	e59f2208 	ldr	r2, [pc, #520]	; 547c <.text+0x547c>
    5270:	e5923000 	ldr	r3, [r2]
    5274:	e3730001 	cmn	r3, #1	; 0x1
    5278:	106c3000 	rsbne	r3, ip, r0
    527c:	159f21fc 	ldrne	r2, [pc, #508]	; 5480 <.text+0x5480>
    5280:	10813003 	addne	r3, r1, r3
    5284:	05820000 	streq	r0, [r2]
    5288:	15823000 	strne	r3, [r2]
    528c:	e2103007 	ands	r3, r0, #7	; 0x7
    5290:	12631008 	rsbne	r1, r3, #8	; 0x8
    5294:	10805001 	addne	r5, r0, r1
    5298:	01a01003 	moveq	r1, r3
    529c:	e0853004 	add	r3, r5, r4
    52a0:	e1a03a03 	mov	r3, r3, lsl #20
    52a4:	e1a03a23 	mov	r3, r3, lsr #20
    52a8:	e2633a01 	rsb	r3, r3, #4096	; 0x1000
    52ac:	e0814003 	add	r4, r1, r3
    52b0:	e1a01004 	mov	r1, r4
    52b4:	e1a0000a 	mov	r0, sl
    52b8:	ebffec27 	bl	35c <_sbrk_r>
    52bc:	e59f31bc 	ldr	r3, [pc, #444]	; 5480 <.text+0x5480>
    52c0:	e3700001 	cmn	r0, #1	; 0x1
    52c4:	01a00005 	moveq	r0, r5
    52c8:	03a04000 	moveq	r4, #0	; 0x0
    52cc:	e5931000 	ldr	r1, [r3]
    52d0:	e0652000 	rsb	r2, r5, r0
    52d4:	e0822004 	add	r2, r2, r4
    52d8:	e0811004 	add	r1, r1, r4
    52dc:	e3822001 	orr	r2, r2, #1	; 0x1
    52e0:	e1560009 	cmp	r6, r9
    52e4:	e5831000 	str	r1, [r3]
    52e8:	e5852004 	str	r2, [r5, #4]
    52ec:	e5895008 	str	r5, [r9, #8]
    52f0:	0a000011 	beq	533c <_malloc_r+0x538>
    52f4:	e357000f 	cmp	r7, #15	; 0xf
    52f8:	93a03001 	movls	r3, #1	; 0x1
    52fc:	95853004 	strls	r3, [r5, #4]
    5300:	9a000017 	bls	5364 <_malloc_r+0x560>
    5304:	e5963004 	ldr	r3, [r6, #4]
    5308:	e247200c 	sub	r2, r7, #12	; 0xc
    530c:	e3c22007 	bic	r2, r2, #7	; 0x7
    5310:	e2033001 	and	r3, r3, #1	; 0x1
    5314:	e1833002 	orr	r3, r3, r2
    5318:	e3a01005 	mov	r1, #5	; 0x5
    531c:	e352000f 	cmp	r2, #15	; 0xf
    5320:	e0862002 	add	r2, r6, r2
    5324:	e5863004 	str	r3, [r6, #4]
    5328:	e5821008 	str	r1, [r2, #8]
    532c:	e5821004 	str	r1, [r2, #4]
    5330:	82861008 	addhi	r1, r6, #8	; 0x8
    5334:	81a0000a 	movhi	r0, sl
    5338:	8b0000fd 	blhi	5734 <_free_r>
    533c:	e59f1140 	ldr	r1, [pc, #320]	; 5484 <.text+0x5484>
    5340:	e59f3138 	ldr	r3, [pc, #312]	; 5480 <.text+0x5480>
    5344:	e5932000 	ldr	r2, [r3]
    5348:	e5913000 	ldr	r3, [r1]
    534c:	e1520003 	cmp	r2, r3
    5350:	85812000 	strhi	r2, [r1]
    5354:	e59f112c 	ldr	r1, [pc, #300]	; 5488 <.text+0x5488>
    5358:	e5913000 	ldr	r3, [r1]
    535c:	e1520003 	cmp	r2, r3
    5360:	85812000 	strhi	r2, [r1]
    5364:	e5993008 	ldr	r3, [r9, #8]
    5368:	e5932004 	ldr	r2, [r3, #4]
    536c:	e3c22003 	bic	r2, r2, #3	; 0x3
    5370:	e0681002 	rsb	r1, r8, r2
    5374:	e351000f 	cmp	r1, #15	; 0xf
    5378:	c3a03000 	movgt	r3, #0	; 0x0
    537c:	d3a03001 	movle	r3, #1	; 0x1
    5380:	e1520008 	cmp	r2, r8
    5384:	33833001 	orrcc	r3, r3, #1	; 0x1
    5388:	e3530000 	cmp	r3, #0	; 0x0
    538c:	0a000003 	beq	53a0 <_malloc_r+0x59c>
    5390:	e1a0000a 	mov	r0, sl
    5394:	eb00004c 	bl	54cc <__malloc_unlock>
    5398:	e3a00000 	mov	r0, #0	; 0x0
    539c:	ea000031 	b	5468 <_malloc_r+0x664>
    53a0:	e5994008 	ldr	r4, [r9, #8]
    53a4:	e3811001 	orr	r1, r1, #1	; 0x1
    53a8:	e0842008 	add	r2, r4, r8
    53ac:	e3883001 	orr	r3, r8, #1	; 0x1
    53b0:	e1a0000a 	mov	r0, sl
    53b4:	e5843004 	str	r3, [r4, #4]
    53b8:	e5892008 	str	r2, [r9, #8]
    53bc:	e5821004 	str	r1, [r2, #4]
    53c0:	ea000026 	b	5460 <_malloc_r+0x65c>
    53c4:	e59f20b4 	ldr	r2, [pc, #180]	; 5480 <.text+0x5480>
    53c8:	e5923000 	ldr	r3, [r2]
    53cc:	e0841003 	add	r1, r4, r3
    53d0:	e5821000 	str	r1, [r2]
    53d4:	eaffffa4 	b	526c <_malloc_r+0x468>
    53d8:	e3883001 	orr	r3, r8, #1	; 0x1
    53dc:	e594000c 	ldr	r0, [r4, #12]
    53e0:	e5843004 	str	r3, [r4, #4]
    53e4:	e0843008 	add	r3, r4, r8
    53e8:	e5b41008 	ldr	r1, [r4, #8]!
    53ec:	e38c2001 	orr	r2, ip, #1	; 0x1
    53f0:	e5801008 	str	r1, [r0, #8]
    53f4:	e581000c 	str	r0, [r1, #12]
    53f8:	e1a0000a 	mov	r0, sl
    53fc:	e5873008 	str	r3, [r7, #8]
    5400:	e587300c 	str	r3, [r7, #12]
    5404:	e783c00c 	str	ip, [r3, ip]
    5408:	e9830084 	stmib	r3, {r2, r7}
    540c:	e583700c 	str	r7, [r3, #12]
    5410:	ea000007 	b	5434 <_malloc_r+0x630>
    5414:	e0843003 	add	r3, r4, r3
    5418:	e5932004 	ldr	r2, [r3, #4]
    541c:	e5b41008 	ldr	r1, [r4, #8]!
    5420:	e3822001 	orr	r2, r2, #1	; 0x1
    5424:	e5832004 	str	r2, [r3, #4]
    5428:	e5801008 	str	r1, [r0, #8]
    542c:	e581000c 	str	r0, [r1, #12]
    5430:	e1a0000a 	mov	r0, sl
    5434:	eb000024 	bl	54cc <__malloc_unlock>
    5438:	e1a00004 	mov	r0, r4
    543c:	ea000009 	b	5468 <_malloc_r+0x664>
    5440:	e0843003 	add	r3, r4, r3
    5444:	e5932004 	ldr	r2, [r3, #4]
    5448:	e5941008 	ldr	r1, [r4, #8]
    544c:	e3822001 	orr	r2, r2, #1	; 0x1
    5450:	e5801008 	str	r1, [r0, #8]
    5454:	e5832004 	str	r2, [r3, #4]
    5458:	e581000c 	str	r0, [r1, #12]
    545c:	e1a0000a 	mov	r0, sl
    5460:	eb000019 	bl	54cc <__malloc_unlock>
    5464:	e2840008 	add	r0, r4, #8	; 0x8
    5468:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    546c:	e12fff1e 	bx	lr
    5470:	400002b8 	strmih	r0, [r0], -r8
    5474:	00000554 	andeq	r0, r0, r4, asr r5
    5478:	40000fb8 	strmih	r0, [r0], -r8
    547c:	400006c4 	andmi	r0, r0, r4, asr #13
    5480:	40000fc4 	andmi	r0, r0, r4, asr #31
    5484:	40000fbc 	strmih	r0, [r0], -ip
    5488:	40000fc0 	andmi	r0, r0, r0, asr #31

0000548c <memcpy>:
    548c:	e3a0c000 	mov	ip, #0	; 0x0
    5490:	ea000002 	b	54a0 <memcpy+0x14>
    5494:	e7dc3001 	ldrb	r3, [ip, r1]
    5498:	e7cc3000 	strb	r3, [ip, r0]
    549c:	e28cc001 	add	ip, ip, #1	; 0x1
    54a0:	e2522001 	subs	r2, r2, #1	; 0x1
    54a4:	2afffffa 	bcs	5494 <memcpy+0x8>
    54a8:	e12fff1e 	bx	lr

000054ac <memset>:
    54ac:	e3a03000 	mov	r3, #0	; 0x0
    54b0:	ea000001 	b	54bc <memset+0x10>
    54b4:	e7c31000 	strb	r1, [r3, r0]
    54b8:	e2833001 	add	r3, r3, #1	; 0x1
    54bc:	e2522001 	subs	r2, r2, #1	; 0x1
    54c0:	2afffffb 	bcs	54b4 <memset+0x8>
    54c4:	e12fff1e 	bx	lr

000054c8 <__malloc_lock>:
    54c8:	e12fff1e 	bx	lr

000054cc <__malloc_unlock>:
    54cc:	e12fff1e 	bx	lr

000054d0 <strchr>:
    54d0:	e20110ff 	and	r1, r1, #255	; 0xff
    54d4:	ea000000 	b	54dc <strchr+0xc>
    54d8:	e2800001 	add	r0, r0, #1	; 0x1
    54dc:	e5d03000 	ldrb	r3, [r0]
    54e0:	e3530000 	cmp	r3, #0	; 0x0
    54e4:	0a000002 	beq	54f4 <strchr+0x24>
    54e8:	e1530001 	cmp	r3, r1
    54ec:	1afffff9 	bne	54d8 <strchr+0x8>
    54f0:	e12fff1e 	bx	lr
    54f4:	e3510000 	cmp	r1, #0	; 0x0
    54f8:	13a00000 	movne	r0, #0	; 0x0
    54fc:	e12fff1e 	bx	lr

00005500 <strcmp>:
    5500:	ea000000 	b	5508 <strcmp+0x8>
    5504:	e2811001 	add	r1, r1, #1	; 0x1
    5508:	e5d02000 	ldrb	r2, [r0]
    550c:	e3520000 	cmp	r2, #0	; 0x0
    5510:	e2800001 	add	r0, r0, #1	; 0x1
    5514:	0a000002 	beq	5524 <strcmp+0x24>
    5518:	e5d13000 	ldrb	r3, [r1]
    551c:	e1530002 	cmp	r3, r2
    5520:	0afffff7 	beq	5504 <strcmp+0x4>
    5524:	e5d10000 	ldrb	r0, [r1]
    5528:	e0600002 	rsb	r0, r0, r2
    552c:	e12fff1e 	bx	lr

00005530 <strlen>:
    5530:	e1a02000 	mov	r2, r0
    5534:	ea000000 	b	553c <strlen+0xc>
    5538:	e2800001 	add	r0, r0, #1	; 0x1
    553c:	e5d03000 	ldrb	r3, [r0]
    5540:	e3530000 	cmp	r3, #0	; 0x0
    5544:	1afffffb 	bne	5538 <strlen+0x8>
    5548:	e0620000 	rsb	r0, r2, r0
    554c:	e12fff1e 	bx	lr

00005550 <strncmp>:
    5550:	e3520000 	cmp	r2, #0	; 0x0
    5554:	01a00002 	moveq	r0, r2
    5558:	012fff1e 	bxeq	lr
    555c:	ea000005 	b	5578 <strncmp+0x28>
    5560:	e3520000 	cmp	r2, #0	; 0x0
    5564:	0a000009 	beq	5590 <strncmp+0x40>
    5568:	e35c0000 	cmp	ip, #0	; 0x0
    556c:	0a000007 	beq	5590 <strncmp+0x40>
    5570:	e2800001 	add	r0, r0, #1	; 0x1
    5574:	e2811001 	add	r1, r1, #1	; 0x1
    5578:	e2522001 	subs	r2, r2, #1	; 0x1
    557c:	3a000003 	bcc	5590 <strncmp+0x40>
    5580:	e5d1c000 	ldrb	ip, [r1]
    5584:	e5d03000 	ldrb	r3, [r0]
    5588:	e15c0003 	cmp	ip, r3
    558c:	0afffff3 	beq	5560 <strncmp+0x10>
    5590:	e5d02000 	ldrb	r2, [r0]
    5594:	e5d13000 	ldrb	r3, [r1]
    5598:	e0630002 	rsb	r0, r3, r2
    559c:	e12fff1e 	bx	lr

000055a0 <strncpy>:
    55a0:	e1a0c000 	mov	ip, r0
    55a4:	ea000005 	b	55c0 <strncpy+0x20>
    55a8:	e5d13000 	ldrb	r3, [r1]
    55ac:	e3530000 	cmp	r3, #0	; 0x0
    55b0:	e2422001 	sub	r2, r2, #1	; 0x1
    55b4:	e4cc3001 	strb	r3, [ip], #1
    55b8:	0a000002 	beq	55c8 <strncpy+0x28>
    55bc:	e2811001 	add	r1, r1, #1	; 0x1
    55c0:	e3520000 	cmp	r2, #0	; 0x0
    55c4:	1afffff7 	bne	55a8 <strncpy+0x8>
    55c8:	e1a0100c 	mov	r1, ip
    55cc:	ea000001 	b	55d8 <strncpy+0x38>
    55d0:	e3a03000 	mov	r3, #0	; 0x0
    55d4:	e5413001 	strb	r3, [r1, #-1]
    55d8:	e2422001 	sub	r2, r2, #1	; 0x1
    55dc:	e3720001 	cmn	r2, #1	; 0x1
    55e0:	e2811001 	add	r1, r1, #1	; 0x1
    55e4:	1afffff9 	bne	55d0 <strncpy+0x30>
    55e8:	e12fff1e 	bx	lr

000055ec <strrchr>:
    55ec:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    55f0:	e2515000 	subs	r5, r1, #0	; 0x0
    55f4:	e1a03000 	mov	r3, r0
    55f8:	13a04000 	movne	r4, #0	; 0x0
    55fc:	1a000002 	bne	560c <strrchr+0x20>
    5600:	ea000007 	b	5624 <strrchr+0x38>
    5604:	e1a04000 	mov	r4, r0
    5608:	e2803001 	add	r3, r0, #1	; 0x1
    560c:	e1a00003 	mov	r0, r3
    5610:	e1a01005 	mov	r1, r5
    5614:	ebffffad 	bl	54d0 <strchr>
    5618:	e3500000 	cmp	r0, #0	; 0x0
    561c:	1afffff8 	bne	5604 <strrchr+0x18>
    5620:	ea000001 	b	562c <strrchr+0x40>
    5624:	ebffffa9 	bl	54d0 <strchr>
    5628:	e1a04000 	mov	r4, r0
    562c:	e1a00004 	mov	r0, r4
    5630:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    5634:	e12fff1e 	bx	lr

00005638 <_malloc_trim_r>:
    5638:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    563c:	e59f70e4 	ldr	r7, [pc, #228]	; 5728 <.text+0x5728>
    5640:	e1a04001 	mov	r4, r1
    5644:	e1a05000 	mov	r5, r0
    5648:	ebffff9e 	bl	54c8 <__malloc_lock>
    564c:	e5973008 	ldr	r3, [r7, #8]
    5650:	e5933004 	ldr	r3, [r3, #4]
    5654:	e3c36003 	bic	r6, r3, #3	; 0x3
    5658:	e0644006 	rsb	r4, r4, r6
    565c:	e2844efe 	add	r4, r4, #4064	; 0xfe0
    5660:	e284400f 	add	r4, r4, #15	; 0xf
    5664:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
    5668:	e3c4400f 	bic	r4, r4, #15	; 0xf
    566c:	e2444a01 	sub	r4, r4, #4096	; 0x1000
    5670:	e3540a01 	cmp	r4, #4096	; 0x1000
    5674:	e3a01000 	mov	r1, #0	; 0x0
    5678:	e1a00005 	mov	r0, r5
    567c:	ba00001c 	blt	56f4 <_malloc_trim_r+0xbc>
    5680:	ebffeb35 	bl	35c <_sbrk_r>
    5684:	e5973008 	ldr	r3, [r7, #8]
    5688:	e0863003 	add	r3, r6, r3
    568c:	e1500003 	cmp	r0, r3
    5690:	e2641000 	rsb	r1, r4, #0	; 0x0
    5694:	e1a00005 	mov	r0, r5
    5698:	1a000015 	bne	56f4 <_malloc_trim_r+0xbc>
    569c:	ebffeb2e 	bl	35c <_sbrk_r>
    56a0:	e0643006 	rsb	r3, r4, r6
    56a4:	e3700001 	cmn	r0, #1	; 0x1
    56a8:	e3a01000 	mov	r1, #0	; 0x0
    56ac:	e59fe078 	ldr	lr, [pc, #120]	; 572c <.text+0x572c>
    56b0:	e383c001 	orr	ip, r3, #1	; 0x1
    56b4:	e1a00005 	mov	r0, r5
    56b8:	1a000010 	bne	5700 <_malloc_trim_r+0xc8>
    56bc:	ebffeb26 	bl	35c <_sbrk_r>
    56c0:	e597c008 	ldr	ip, [r7, #8]
    56c4:	e1a02000 	mov	r2, r0
    56c8:	e06c3002 	rsb	r3, ip, r2
    56cc:	e353000f 	cmp	r3, #15	; 0xf
    56d0:	e1a00005 	mov	r0, r5
    56d4:	e3831001 	orr	r1, r3, #1	; 0x1
    56d8:	da000005 	ble	56f4 <_malloc_trim_r+0xbc>
    56dc:	e59f304c 	ldr	r3, [pc, #76]	; 5730 <.text+0x5730>
    56e0:	e5933000 	ldr	r3, [r3]
    56e4:	e0633002 	rsb	r3, r3, r2
    56e8:	e59f203c 	ldr	r2, [pc, #60]	; 572c <.text+0x572c>
    56ec:	e58c1004 	str	r1, [ip, #4]
    56f0:	e5823000 	str	r3, [r2]
    56f4:	ebffff74 	bl	54cc <__malloc_unlock>
    56f8:	e3a00000 	mov	r0, #0	; 0x0
    56fc:	ea000007 	b	5720 <_malloc_trim_r+0xe8>
    5700:	e59e3000 	ldr	r3, [lr]
    5704:	e5972008 	ldr	r2, [r7, #8]
    5708:	e0643003 	rsb	r3, r4, r3
    570c:	e1a00005 	mov	r0, r5
    5710:	e582c004 	str	ip, [r2, #4]
    5714:	e58e3000 	str	r3, [lr]
    5718:	ebffff6b 	bl	54cc <__malloc_unlock>
    571c:	e3a00001 	mov	r0, #1	; 0x1
    5720:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    5724:	e12fff1e 	bx	lr
    5728:	400002b8 	strmih	r0, [r0], -r8
    572c:	40000fc4 	andmi	r0, r0, r4, asr #31
    5730:	400006c4 	andmi	r0, r0, r4, asr #13

00005734 <_free_r>:
    5734:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5738:	e2515000 	subs	r5, r1, #0	; 0x0
    573c:	e1a08000 	mov	r8, r0
    5740:	0a00008c 	beq	5978 <_free_r+0x244>
    5744:	ebffff5f 	bl	54c8 <__malloc_lock>
    5748:	e5153004 	ldr	r3, [r5, #-4]
    574c:	e59f722c 	ldr	r7, [pc, #556]	; 5980 <.text+0x5980>
    5750:	e245e008 	sub	lr, r5, #8	; 0x8
    5754:	e3c30001 	bic	r0, r3, #1	; 0x1
    5758:	e08e4000 	add	r4, lr, r0
    575c:	e5972008 	ldr	r2, [r7, #8]
    5760:	e5941004 	ldr	r1, [r4, #4]
    5764:	e1540002 	cmp	r4, r2
    5768:	e3c16003 	bic	r6, r1, #3	; 0x3
    576c:	e2031001 	and	r1, r3, #1	; 0x1
    5770:	1a000015 	bne	57cc <_free_r+0x98>
    5774:	e3510000 	cmp	r1, #0	; 0x0
    5778:	e0800006 	add	r0, r0, r6
    577c:	1a000006 	bne	579c <_free_r+0x68>
    5780:	e5151008 	ldr	r1, [r5, #-8]
    5784:	e061e00e 	rsb	lr, r1, lr
    5788:	e59e200c 	ldr	r2, [lr, #12]
    578c:	e59e3008 	ldr	r3, [lr, #8]
    5790:	e5823008 	str	r3, [r2, #8]
    5794:	e583200c 	str	r2, [r3, #12]
    5798:	e0800001 	add	r0, r0, r1
    579c:	e59f31e0 	ldr	r3, [pc, #480]	; 5984 <.text+0x5984>
    57a0:	e5933000 	ldr	r3, [r3]
    57a4:	e1500003 	cmp	r0, r3
    57a8:	e3803001 	orr	r3, r0, #1	; 0x1
    57ac:	e587e008 	str	lr, [r7, #8]
    57b0:	e58e3004 	str	r3, [lr, #4]
    57b4:	3a00006d 	bcc	5970 <_free_r+0x23c>
    57b8:	e59f31c8 	ldr	r3, [pc, #456]	; 5988 <.text+0x5988>
    57bc:	e1a00008 	mov	r0, r8
    57c0:	e5931000 	ldr	r1, [r3]
    57c4:	ebffff9b 	bl	5638 <_malloc_trim_r>
    57c8:	ea000068 	b	5970 <_free_r+0x23c>
    57cc:	e3510000 	cmp	r1, #0	; 0x0
    57d0:	e5846004 	str	r6, [r4, #4]
    57d4:	13a01000 	movne	r1, #0	; 0x0
    57d8:	1a000009 	bne	5804 <_free_r+0xd0>
    57dc:	e5152008 	ldr	r2, [r5, #-8]
    57e0:	e062e00e 	rsb	lr, r2, lr
    57e4:	e59ec008 	ldr	ip, [lr, #8]
    57e8:	e2873008 	add	r3, r7, #8	; 0x8
    57ec:	e15c0003 	cmp	ip, r3
    57f0:	159e300c 	ldrne	r3, [lr, #12]
    57f4:	1583c008 	strne	ip, [r3, #8]
    57f8:	158c300c 	strne	r3, [ip, #12]
    57fc:	e0800002 	add	r0, r0, r2
    5800:	03a01001 	moveq	r1, #1	; 0x1
    5804:	e0843006 	add	r3, r4, r6
    5808:	e5933004 	ldr	r3, [r3, #4]
    580c:	e3130001 	tst	r3, #1	; 0x1
    5810:	1a000012 	bne	5860 <_free_r+0x12c>
    5814:	e3510000 	cmp	r1, #0	; 0x0
    5818:	e0800006 	add	r0, r0, r6
    581c:	1a00000b 	bne	5850 <_free_r+0x11c>
    5820:	e5942008 	ldr	r2, [r4, #8]
    5824:	e59f3160 	ldr	r3, [pc, #352]	; 598c <.text+0x598c>
    5828:	e1520003 	cmp	r2, r3
    582c:	1a000007 	bne	5850 <_free_r+0x11c>
    5830:	e3803001 	orr	r3, r0, #1	; 0x1
    5834:	e582e00c 	str	lr, [r2, #12]
    5838:	e582e008 	str	lr, [r2, #8]
    583c:	e78e0000 	str	r0, [lr, r0]
    5840:	e58e3004 	str	r3, [lr, #4]
    5844:	e58e2008 	str	r2, [lr, #8]
    5848:	e58e200c 	str	r2, [lr, #12]
    584c:	ea000047 	b	5970 <_free_r+0x23c>
    5850:	e2842008 	add	r2, r4, #8	; 0x8
    5854:	e892000c 	ldmia	r2, {r2, r3}
    5858:	e5832008 	str	r2, [r3, #8]
    585c:	e582300c 	str	r3, [r2, #12]
    5860:	e3803001 	orr	r3, r0, #1	; 0x1
    5864:	e3510000 	cmp	r1, #0	; 0x0
    5868:	e58e3004 	str	r3, [lr, #4]
    586c:	e78e0000 	str	r0, [lr, r0]
    5870:	1a00003e 	bne	5970 <_free_r+0x23c>
    5874:	e3500c02 	cmp	r0, #512	; 0x200
    5878:	2a00000d 	bcs	58b4 <_free_r+0x180>
    587c:	e1a001a0 	mov	r0, r0, lsr #3
    5880:	e5972004 	ldr	r2, [r7, #4]
    5884:	e1a01120 	mov	r1, r0, lsr #2
    5888:	e3a03001 	mov	r3, #1	; 0x1
    588c:	e1822113 	orr	r2, r2, r3, lsl r1
    5890:	e59f30e8 	ldr	r3, [pc, #232]	; 5980 <.text+0x5980>
    5894:	e0833180 	add	r3, r3, r0, lsl #3
    5898:	e5931008 	ldr	r1, [r3, #8]
    589c:	e58e300c 	str	r3, [lr, #12]
    58a0:	e58e1008 	str	r1, [lr, #8]
    58a4:	e5872004 	str	r2, [r7, #4]
    58a8:	e581e00c 	str	lr, [r1, #12]
    58ac:	e583e008 	str	lr, [r3, #8]
    58b0:	ea00002e 	b	5970 <_free_r+0x23c>
    58b4:	e1b014a0 	movs	r1, r0, lsr #9
    58b8:	01a011a0 	moveq	r1, r0, lsr #3
    58bc:	0a000013 	beq	5910 <_free_r+0x1dc>
    58c0:	e3510004 	cmp	r1, #4	; 0x4
    58c4:	91a03320 	movls	r3, r0, lsr #6
    58c8:	92831038 	addls	r1, r3, #56	; 0x38
    58cc:	9a00000f 	bls	5910 <_free_r+0x1dc>
    58d0:	e3510014 	cmp	r1, #20	; 0x14
    58d4:	9281105b 	addls	r1, r1, #91	; 0x5b
    58d8:	9a00000c 	bls	5910 <_free_r+0x1dc>
    58dc:	e3510054 	cmp	r1, #84	; 0x54
    58e0:	91a03620 	movls	r3, r0, lsr #12
    58e4:	9283106e 	addls	r1, r3, #110	; 0x6e
    58e8:	9a000008 	bls	5910 <_free_r+0x1dc>
    58ec:	e3510f55 	cmp	r1, #340	; 0x154
    58f0:	91a037a0 	movls	r3, r0, lsr #15
    58f4:	92831077 	addls	r1, r3, #119	; 0x77
    58f8:	9a000004 	bls	5910 <_free_r+0x1dc>
    58fc:	e59f308c 	ldr	r3, [pc, #140]	; 5990 <.text+0x5990>
    5900:	e1510003 	cmp	r1, r3
    5904:	91a03920 	movls	r3, r0, lsr #18
    5908:	83a0107e 	movhi	r1, #126	; 0x7e
    590c:	9283107c 	addls	r1, r3, #124	; 0x7c
    5910:	e59f3068 	ldr	r3, [pc, #104]	; 5980 <.text+0x5980>
    5914:	e0832181 	add	r2, r3, r1, lsl #3
    5918:	e592c008 	ldr	ip, [r2, #8]
    591c:	e15c0002 	cmp	ip, r2
    5920:	1a000009 	bne	594c <_free_r+0x218>
    5924:	e5973004 	ldr	r3, [r7, #4]
    5928:	e3a02001 	mov	r2, #1	; 0x1
    592c:	e1a01121 	mov	r1, r1, lsr #2
    5930:	e1833112 	orr	r3, r3, r2, lsl r1
    5934:	e1a0200c 	mov	r2, ip
    5938:	e5873004 	str	r3, [r7, #4]
    593c:	ea000007 	b	5960 <_free_r+0x22c>
    5940:	e59cc008 	ldr	ip, [ip, #8]
    5944:	e15c0002 	cmp	ip, r2
    5948:	0a000003 	beq	595c <_free_r+0x228>
    594c:	e59c3004 	ldr	r3, [ip, #4]
    5950:	e3c33003 	bic	r3, r3, #3	; 0x3
    5954:	e1500003 	cmp	r0, r3
    5958:	3afffff8 	bcc	5940 <_free_r+0x20c>
    595c:	e59c200c 	ldr	r2, [ip, #12]
    5960:	e58e200c 	str	r2, [lr, #12]
    5964:	e58ec008 	str	ip, [lr, #8]
    5968:	e58ce00c 	str	lr, [ip, #12]
    596c:	e582e008 	str	lr, [r2, #8]
    5970:	e1a00008 	mov	r0, r8
    5974:	ebfffed4 	bl	54cc <__malloc_unlock>
    5978:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    597c:	e12fff1e 	bx	lr
    5980:	400002b8 	strmih	r0, [r0], -r8
    5984:	400006c0 	andmi	r0, r0, r0, asr #13
    5988:	40000fb8 	strmih	r0, [r0], -r8
    598c:	400002c0 	andmi	r0, r0, r0, asr #5
    5990:	00000554 	andeq	r0, r0, r4, asr r5

00005994 <__aeabi_uidiv>:
    5994:	e2512001 	subs	r2, r1, #1	; 0x1
    5998:	012fff1e 	bxeq	lr
    599c:	3a000036 	bcc	5a7c <__aeabi_uidiv+0xe8>
    59a0:	e1500001 	cmp	r0, r1
    59a4:	9a000022 	bls	5a34 <__aeabi_uidiv+0xa0>
    59a8:	e1110002 	tst	r1, r2
    59ac:	0a000023 	beq	5a40 <__aeabi_uidiv+0xac>
    59b0:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    59b4:	01a01181 	moveq	r1, r1, lsl #3
    59b8:	03a03008 	moveq	r3, #8	; 0x8
    59bc:	13a03001 	movne	r3, #1	; 0x1
    59c0:	e3510201 	cmp	r1, #268435456	; 0x10000000
    59c4:	31510000 	cmpcc	r1, r0
    59c8:	31a01201 	movcc	r1, r1, lsl #4
    59cc:	31a03203 	movcc	r3, r3, lsl #4
    59d0:	3afffffa 	bcc	59c0 <__aeabi_uidiv+0x2c>
    59d4:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    59d8:	31510000 	cmpcc	r1, r0
    59dc:	31a01081 	movcc	r1, r1, lsl #1
    59e0:	31a03083 	movcc	r3, r3, lsl #1
    59e4:	3afffffa 	bcc	59d4 <__aeabi_uidiv+0x40>
    59e8:	e3a02000 	mov	r2, #0	; 0x0
    59ec:	e1500001 	cmp	r0, r1
    59f0:	20400001 	subcs	r0, r0, r1
    59f4:	21822003 	orrcs	r2, r2, r3
    59f8:	e15000a1 	cmp	r0, r1, lsr #1
    59fc:	204000a1 	subcs	r0, r0, r1, lsr #1
    5a00:	218220a3 	orrcs	r2, r2, r3, lsr #1
    5a04:	e1500121 	cmp	r0, r1, lsr #2
    5a08:	20400121 	subcs	r0, r0, r1, lsr #2
    5a0c:	21822123 	orrcs	r2, r2, r3, lsr #2
    5a10:	e15001a1 	cmp	r0, r1, lsr #3
    5a14:	204001a1 	subcs	r0, r0, r1, lsr #3
    5a18:	218221a3 	orrcs	r2, r2, r3, lsr #3
    5a1c:	e3500000 	cmp	r0, #0	; 0x0
    5a20:	11b03223 	movnes	r3, r3, lsr #4
    5a24:	11a01221 	movne	r1, r1, lsr #4
    5a28:	1affffef 	bne	59ec <__aeabi_uidiv+0x58>
    5a2c:	e1a00002 	mov	r0, r2
    5a30:	e12fff1e 	bx	lr
    5a34:	03a00001 	moveq	r0, #1	; 0x1
    5a38:	13a00000 	movne	r0, #0	; 0x0
    5a3c:	e12fff1e 	bx	lr
    5a40:	e3510801 	cmp	r1, #65536	; 0x10000
    5a44:	21a01821 	movcs	r1, r1, lsr #16
    5a48:	23a02010 	movcs	r2, #16	; 0x10
    5a4c:	33a02000 	movcc	r2, #0	; 0x0
    5a50:	e3510c01 	cmp	r1, #256	; 0x100
    5a54:	21a01421 	movcs	r1, r1, lsr #8
    5a58:	22822008 	addcs	r2, r2, #8	; 0x8
    5a5c:	e3510010 	cmp	r1, #16	; 0x10
    5a60:	21a01221 	movcs	r1, r1, lsr #4
    5a64:	22822004 	addcs	r2, r2, #4	; 0x4
    5a68:	e3510004 	cmp	r1, #4	; 0x4
    5a6c:	82822003 	addhi	r2, r2, #3	; 0x3
    5a70:	908220a1 	addls	r2, r2, r1, lsr #1
    5a74:	e1a00230 	mov	r0, r0, lsr r2
    5a78:	e12fff1e 	bx	lr
    5a7c:	e52de008 	str	lr, [sp, #-8]!
    5a80:	eb00008d 	bl	5cbc <__aeabi_idiv0>
    5a84:	e3a00000 	mov	r0, #0	; 0x0
    5a88:	e49de008 	ldr	lr, [sp], #8
    5a8c:	e12fff1e 	bx	lr

00005a90 <__aeabi_uidivmod>:
    5a90:	e92d4003 	stmdb	sp!, {r0, r1, lr}
    5a94:	ebffffbe 	bl	5994 <__aeabi_uidiv>
    5a98:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
    5a9c:	e0030092 	mul	r3, r2, r0
    5aa0:	e0411003 	sub	r1, r1, r3
    5aa4:	e12fff1e 	bx	lr

00005aa8 <__aeabi_idiv>:
    5aa8:	e3510000 	cmp	r1, #0	; 0x0
    5aac:	e020c001 	eor	ip, r0, r1
    5ab0:	0a000042 	beq	5bc0 <__aeabi_idiv+0x118>
    5ab4:	42611000 	rsbmi	r1, r1, #0	; 0x0
    5ab8:	e2512001 	subs	r2, r1, #1	; 0x1
    5abc:	0a000027 	beq	5b60 <__aeabi_idiv+0xb8>
    5ac0:	e1b03000 	movs	r3, r0
    5ac4:	42603000 	rsbmi	r3, r0, #0	; 0x0
    5ac8:	e1530001 	cmp	r3, r1
    5acc:	9a000026 	bls	5b6c <__aeabi_idiv+0xc4>
    5ad0:	e1110002 	tst	r1, r2
    5ad4:	0a000028 	beq	5b7c <__aeabi_idiv+0xd4>
    5ad8:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    5adc:	01a01181 	moveq	r1, r1, lsl #3
    5ae0:	03a02008 	moveq	r2, #8	; 0x8
    5ae4:	13a02001 	movne	r2, #1	; 0x1
    5ae8:	e3510201 	cmp	r1, #268435456	; 0x10000000
    5aec:	31510003 	cmpcc	r1, r3
    5af0:	31a01201 	movcc	r1, r1, lsl #4
    5af4:	31a02202 	movcc	r2, r2, lsl #4
    5af8:	3afffffa 	bcc	5ae8 <__aeabi_idiv+0x40>
    5afc:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    5b00:	31510003 	cmpcc	r1, r3
    5b04:	31a01081 	movcc	r1, r1, lsl #1
    5b08:	31a02082 	movcc	r2, r2, lsl #1
    5b0c:	3afffffa 	bcc	5afc <__aeabi_idiv+0x54>
    5b10:	e3a00000 	mov	r0, #0	; 0x0
    5b14:	e1530001 	cmp	r3, r1
    5b18:	20433001 	subcs	r3, r3, r1
    5b1c:	21800002 	orrcs	r0, r0, r2
    5b20:	e15300a1 	cmp	r3, r1, lsr #1
    5b24:	204330a1 	subcs	r3, r3, r1, lsr #1
    5b28:	218000a2 	orrcs	r0, r0, r2, lsr #1
    5b2c:	e1530121 	cmp	r3, r1, lsr #2
    5b30:	20433121 	subcs	r3, r3, r1, lsr #2
    5b34:	21800122 	orrcs	r0, r0, r2, lsr #2
    5b38:	e15301a1 	cmp	r3, r1, lsr #3
    5b3c:	204331a1 	subcs	r3, r3, r1, lsr #3
    5b40:	218001a2 	orrcs	r0, r0, r2, lsr #3
    5b44:	e3530000 	cmp	r3, #0	; 0x0
    5b48:	11b02222 	movnes	r2, r2, lsr #4
    5b4c:	11a01221 	movne	r1, r1, lsr #4
    5b50:	1affffef 	bne	5b14 <__aeabi_idiv+0x6c>
    5b54:	e35c0000 	cmp	ip, #0	; 0x0
    5b58:	42600000 	rsbmi	r0, r0, #0	; 0x0
    5b5c:	e12fff1e 	bx	lr
    5b60:	e13c0000 	teq	ip, r0
    5b64:	42600000 	rsbmi	r0, r0, #0	; 0x0
    5b68:	e12fff1e 	bx	lr
    5b6c:	33a00000 	movcc	r0, #0	; 0x0
    5b70:	01a00fcc 	moveq	r0, ip, asr #31
    5b74:	03800001 	orreq	r0, r0, #1	; 0x1
    5b78:	e12fff1e 	bx	lr
    5b7c:	e3510801 	cmp	r1, #65536	; 0x10000
    5b80:	21a01821 	movcs	r1, r1, lsr #16
    5b84:	23a02010 	movcs	r2, #16	; 0x10
    5b88:	33a02000 	movcc	r2, #0	; 0x0
    5b8c:	e3510c01 	cmp	r1, #256	; 0x100
    5b90:	21a01421 	movcs	r1, r1, lsr #8
    5b94:	22822008 	addcs	r2, r2, #8	; 0x8
    5b98:	e3510010 	cmp	r1, #16	; 0x10
    5b9c:	21a01221 	movcs	r1, r1, lsr #4
    5ba0:	22822004 	addcs	r2, r2, #4	; 0x4
    5ba4:	e3510004 	cmp	r1, #4	; 0x4
    5ba8:	82822003 	addhi	r2, r2, #3	; 0x3
    5bac:	908220a1 	addls	r2, r2, r1, lsr #1
    5bb0:	e35c0000 	cmp	ip, #0	; 0x0
    5bb4:	e1a00233 	mov	r0, r3, lsr r2
    5bb8:	42600000 	rsbmi	r0, r0, #0	; 0x0
    5bbc:	e12fff1e 	bx	lr
    5bc0:	e52de008 	str	lr, [sp, #-8]!
    5bc4:	eb00003c 	bl	5cbc <__aeabi_idiv0>
    5bc8:	e3a00000 	mov	r0, #0	; 0x0
    5bcc:	e49de008 	ldr	lr, [sp], #8
    5bd0:	e12fff1e 	bx	lr

00005bd4 <__aeabi_idivmod>:
    5bd4:	e92d4003 	stmdb	sp!, {r0, r1, lr}
    5bd8:	ebffffb2 	bl	5aa8 <__aeabi_idiv>
    5bdc:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
    5be0:	e0030092 	mul	r3, r2, r0
    5be4:	e0411003 	sub	r1, r1, r3
    5be8:	e12fff1e 	bx	lr

00005bec <__umodsi3>:
    5bec:	e2512001 	subs	r2, r1, #1	; 0x1
    5bf0:	3a00002c 	bcc	5ca8 <__umodsi3+0xbc>
    5bf4:	11500001 	cmpne	r0, r1
    5bf8:	03a00000 	moveq	r0, #0	; 0x0
    5bfc:	81110002 	tsthi	r1, r2
    5c00:	00000002 	andeq	r0, r0, r2
    5c04:	912fff1e 	bxls	lr
    5c08:	e3a02000 	mov	r2, #0	; 0x0
    5c0c:	e3510201 	cmp	r1, #268435456	; 0x10000000
    5c10:	31510000 	cmpcc	r1, r0
    5c14:	31a01201 	movcc	r1, r1, lsl #4
    5c18:	32822004 	addcc	r2, r2, #4	; 0x4
    5c1c:	3afffffa 	bcc	5c0c <__umodsi3+0x20>
    5c20:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    5c24:	31510000 	cmpcc	r1, r0
    5c28:	31a01081 	movcc	r1, r1, lsl #1
    5c2c:	32822001 	addcc	r2, r2, #1	; 0x1
    5c30:	3afffffa 	bcc	5c20 <__umodsi3+0x34>
    5c34:	e2522003 	subs	r2, r2, #3	; 0x3
    5c38:	ba00000e 	blt	5c78 <__umodsi3+0x8c>
    5c3c:	e1500001 	cmp	r0, r1
    5c40:	20400001 	subcs	r0, r0, r1
    5c44:	e15000a1 	cmp	r0, r1, lsr #1
    5c48:	204000a1 	subcs	r0, r0, r1, lsr #1
    5c4c:	e1500121 	cmp	r0, r1, lsr #2
    5c50:	20400121 	subcs	r0, r0, r1, lsr #2
    5c54:	e15001a1 	cmp	r0, r1, lsr #3
    5c58:	204001a1 	subcs	r0, r0, r1, lsr #3
    5c5c:	e3500001 	cmp	r0, #1	; 0x1
    5c60:	e1a01221 	mov	r1, r1, lsr #4
    5c64:	a2522004 	subges	r2, r2, #4	; 0x4
    5c68:	aafffff3 	bge	5c3c <__umodsi3+0x50>
    5c6c:	e3120003 	tst	r2, #3	; 0x3
    5c70:	13300000 	teqne	r0, #0	; 0x0
    5c74:	0a00000a 	beq	5ca4 <__umodsi3+0xb8>
    5c78:	e3720002 	cmn	r2, #2	; 0x2
    5c7c:	ba000006 	blt	5c9c <__umodsi3+0xb0>
    5c80:	0a000002 	beq	5c90 <__umodsi3+0xa4>
    5c84:	e1500001 	cmp	r0, r1
    5c88:	20400001 	subcs	r0, r0, r1
    5c8c:	e1a010a1 	mov	r1, r1, lsr #1
    5c90:	e1500001 	cmp	r0, r1
    5c94:	20400001 	subcs	r0, r0, r1
    5c98:	e1a010a1 	mov	r1, r1, lsr #1
    5c9c:	e1500001 	cmp	r0, r1
    5ca0:	20400001 	subcs	r0, r0, r1
    5ca4:	e12fff1e 	bx	lr
    5ca8:	e52de008 	str	lr, [sp, #-8]!
    5cac:	eb000002 	bl	5cbc <__aeabi_idiv0>
    5cb0:	e3a00000 	mov	r0, #0	; 0x0
    5cb4:	e49de008 	ldr	lr, [sp], #8
    5cb8:	e12fff1e 	bx	lr

00005cbc <__aeabi_idiv0>:
    5cbc:	e12fff1e 	bx	lr

00005cc0 <abSense>:
    5cc0:	00ff0070 0a000000 00000000 0000ffff     p...............
	...

00005cd2 <abInquiry>:
    5cd2:	02048000 0000001f 5543504c 20204253     ........LPCUSB  
    5ce2:	7373614d 6f747320 65676172 20202020     Mass storage    
    5cf2:	20312e30 06cc0000                                0.1 ..

00005cf8 <_global_impure_ptr>:
    5cf8:	400006cc 746f6f42 20707520 706d6f63     ...@Boot up comp
    5d08:	6574656c 0000000a 55206f4e 44204253     lete....No USB D
    5d18:	63657465 0a646574 00000000 746f6f52     etected.....Root
    5d28:	65706f20 00000a6e 532e5746 00004546      open...FW.SFE..
    5d38:	2077654e 6d726966 65726177 756f6620     New firmware fou
    5d48:	000a646e 2077654e 6d726966 65726177     nd..New firmware
    5d58:	616f6c20 0a646564 00000000 53206f4e      loaded.....No S
    5d68:	61432044 44206472 63657465 0a646574     D Card Detected.
    5d78:	00000000 746f6f42 6e6f4420 43202e65     ....Boot Done. C
    5d88:	696c6c61 6620676e 776d7269 2e657261     alling firmware.
    5d98:	000a2e2e 550a0a0a 42204253 6c746f6f     .......USB Bootl
    5da8:	6564616f 31762072 000a312e 756e616d     oader v1.1..manu
    5db8:	20203a66 30257830 0d0a7832 00000000     f:  0x%02x......
    5dc8:	3a6d656f 20202020 0d0a7325 00000000     oem:    %s......
    5dd8:	646f7270 2020203a 0d0a7325 00000000     prod:   %s......
    5de8:	3a766572 20202020 78323025 00000d0a     rev:    %02x....
    5df8:	69726573 203a6c61 30257830 0a786c38     serial: 0x%08lx.
    5e08:	0000000d 65746164 2020203a 64323025     ....date:   %02d
    5e18:	3230252f 000d0a64 657a6973 2020203a     /%02d...size:   
    5e28:	0a646c25 0000000d 79706f63 2020203a     %ld.....copy:   
    5e38:	0d0a6425 00000000 702e7277 203a2e72     %d......wr.pr.: 
    5e48:	252f6425 000d0a64 6d726f66 203a7461     %d/%d...format: 
    5e58:	0d0a6425 00000000 65657266 2020203a     %d......free:   
    5e68:	2f646c25 0a646c25 0000000d 6e65706f     %ld/%ld.....open
    5e78:	20676e69 74726170 6f697469 6166206e     ing partition fa
    5e88:	64656c69 00000d0a 6e65706f 20676e69     iled....opening 
    5e98:	656c6966 74737973 66206d65 656c6961     filesystem faile
    5ea8:	000d0a64 0000002f 6e65706f 20676e69     d.../...opening 
    5eb8:	746f6f72 72696420 6f746365 66207972     root directory f
    5ec8:	656c6961 000d0a64 52204453 4e205741     ailed...SD RAW N
    5ed8:	4120544f 4c494156 454c4241 00000d0a     OT AVAILABLE....
    5ee8:	65720d0a 6e6f7073 203a6573 0d0a6425     ..response: %d..
    5ef8:	00000000 203d2069 66377830 0d0a6666     ....i = 0x7fff..
    5f08:	00000000 434f4c42 4953204b 5320455a     ....BLOCK SIZE S
    5f18:	45205445 0a205252 0000000d 725f6473     ET ERR .....sd_r
    5f28:	725f7761 20646165 6b726f62 000d0a73     aw_read borks...
    5f38:	4c4c414d 4620434f 534c4941 00000d0a     MALLOC FAILS....
    5f48:	6c696146 52206465 69646165 4820676e     Failed Reading H
    5f58:	65646165 000d0a72 74696e49 696c6169     eader...Initiali
    5f68:	676e6973 42535520 61747320 000a6b63     sing USB stack..
    5f78:	72617453 676e6974 42535520 6d6f6320     Starting USB com
    5f88:	696e756d 69746163 000a6e6f 3a445343     munication..CSD:
    5f98:	00000000 32302520 00000078 75677241     .... %02x...Argu
    5fa8:	746e656d 74756f20 20666f20 6e756f62     ment out of boun
    5fb8:	0a2e7364 00000000 72646441 20737365     ds......Address 
    5fc8:	2074756f 6220666f 646e756f 000a2e73     out of bounds...
    5fd8:	6f727245 75642072 676e6972 61726520     Error during era
    5fe8:	73206573 65757165 2e65636e 0000000a     se sequence.....
    5ff8:	20435243 6c696166 0a2e6465 00000000     CRC failed......
    6008:	656c6c49 206c6167 6d6d6f63 2e646e61     Illegal command.
    6018:	0000000a 73617245 65722065 20746573     ....Erase reset 
    6028:	65657328 6e615320 6b736944 636f6420     (see SanDisk doc
    6038:	35702073 2933312d 00000a2e 0000002e     s p5-13)........
    6048:	6e6b6e55 206e776f 6f727265 78302072     Unknown error 0x
    6058:	28207825 20656573 446e6153 206b7369     %x (see SanDisk 
    6068:	73636f64 2d357020 2e293331 0000000a     docs p5-13).....
    6078:	70736572 6678303d 00000a66 70736572     resp=0xff...resp
    6088:	78303d21 000a6666 64726143 20736920     !=0xff..Card is 
    6098:	6b636f4c 0a2e6465 00000000 45205057     Locked......WP E
    60a8:	65736172 696b5320 4c202c70 2f6b636f     rase Skip, Lock/
    60b8:	6f6c6e55 43206b63 4620646d 656c6961     Unlock Cmd Faile
    60c8:	000a2e64 656e6547 206c6172 6e55202f     d...General / Un
    60d8:	776f6e6b 7265206e 20726f72 63202d2d     known error -- c
    60e8:	20647261 6b6f7262 2e3f6e65 0000000a     ard broken?.....
    60f8:	65746e49 6c616e72 72616320 6f632064     Internal card co
    6108:	6f72746e 72656c6c 72726520 0a2e726f     ntroller error..
    6118:	00000000 64726143 746e6920 616e7265     ....Card interna
    6128:	4345206c 61772043 70612073 65696c70     l ECC was applie
    6138:	62202c64 66207475 656c6961 6f742064     d, but failed to
    6148:	726f6320 74636572 65687420 74616420      correct the dat
    6158:	000a2e61 74697257 72702065 6365746f     a...Write protec
    6168:	69762074 74616c6f 2e6e6f69 0000000a     t violation.....
    6178:	69206e41 6c61766e 73206469 63656c65     An invalid selec
    6188:	6e6f6974 6573202c 726f7463 6f662073     tion, sectors fo
    6198:	72652072 2e657361 0000000a 2074754f     r erase.....Out 
    61a8:	5220666f 65676e61 5343202c 764f5f44     of Range, CSD_Ov
    61b8:	72777265 2e657469 0000000a 6e6b6e55     erwrite.....Unkn
    61c8:	206e776f 6f727265 30203a72 20782578     own error: 0x%x 
    61d8:	65657328 6e615320 6b736944 636f6420     (see SanDisk doc
    61e8:	35702073 2934312d 00000a2e 49204453     s p5-14)....SD I
    61f8:	2074696e 656e6f64 0a2e2e2e 00000000     nit done........
    6208:	64726143 64696420 2074276e 75746572     Card didn't retu
    6218:	74206e72 72206568 79646165 61747320     rn the ready sta
    6228:	202c6574 61657262 676e696b 2e707520     te, breaking up.
    6238:	000a2e2e 49697073 2074696e 20726f66     ....spiInit for 
    6248:	28495053 000a2930 00000043              SPI(0)..C...
